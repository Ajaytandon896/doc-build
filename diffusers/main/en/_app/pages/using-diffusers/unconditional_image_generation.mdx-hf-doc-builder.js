import{S as Qe,i as Ve,s as We,e as s,k as c,w as L,t as a,M as Xe,c as l,d as t,m,a as r,x as M,h as i,b as d,G as o,g as f,y as N,L as Ze,q as B,o as z,B as H,v as et}from"../../chunks/vendor-hf-doc-builder.js";import{I as tt}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as re}from"../../chunks/CodeBlock-hf-doc-builder.js";function ot(Se){let h,J,g,y,C,P,fe,T,pe,R,w,ue,U,ce,me,F,p,de,G,he,ge,S,ye,we,E,_e,$e,A,ve,Pe,D,Ee,De,K,b,Q,_,be,O,ke,je,V,k,W,$,Ie,Y,qe,xe,X,j,Z,v,Ce,I,Te,Ue,ee,x,Ge,te,q,oe;return P=new tt({}),b=new re({props:{code:`from diffusers import DiffusionPipeline

generator = DiffusionPipeline.from_pretrained("google/ddpm-celebahq-256")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> diffusers <span class="hljs-keyword">import</span> DiffusionPipeline

<span class="hljs-meta">&gt;&gt;&gt; </span>generator = DiffusionPipeline.from_pretrained(<span class="hljs-string">&quot;google/ddpm-celebahq-256&quot;</span>)`}}),k=new re({props:{code:'generator.to("cuda")',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>generator.to(<span class="hljs-string">&quot;cuda&quot;</span>)'}}),j=new re({props:{code:"image = generator().images[0]",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>image = generator().images[<span class="hljs-number">0</span>]'}}),q=new re({props:{code:'image.save("generated_image.png")',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>image.save(<span class="hljs-string">&quot;generated_image.png&quot;</span>)'}}),{c(){h=s("meta"),J=c(),g=s("h1"),y=s("a"),C=s("span"),L(P.$$.fragment),fe=c(),T=s("span"),pe=a("Unonditional Image Generation"),R=c(),w=s("p"),ue=a("The "),U=s("code"),ce=a("DiffusionPipeline"),me=a(" is the easiest way to use a pre-trained diffusion system for inference"),F=c(),p=s("p"),de=a("Start by creating an instance of "),G=s("code"),he=a("DiffusionPipeline"),ge=a(` and specify which pipeline checkpoint you would like to download.
You can use the `),S=s("code"),ye=a("DiffusionPipeline"),we=a(" for any "),E=s("a"),_e=a("Diffusers\u2019 checkpoint"),$e=a(`.
In this guide though, you\u2019ll use `),A=s("code"),ve=a("DiffusionPipeline"),Pe=a(" for unconditional image generation with "),D=s("a"),Ee=a("DDPM"),De=a(":"),K=c(),L(b.$$.fragment),Q=c(),_=s("p"),be=a("The "),O=s("code"),ke=a("DiffusionPipeline"),je=a(` downloads and caches all modeling, tokenization, and scheduling components.
Because the model consists of roughly 1.4 billion parameters, we strongly recommend running it on GPU.
You can move the generator object to GPU, just like you would in PyTorch.`),V=c(),L(k.$$.fragment),W=c(),$=s("p"),Ie=a("Now you can use the "),Y=s("code"),qe=a("generator"),xe=a(" on your text prompt:"),X=c(),L(j.$$.fragment),Z=c(),v=s("p"),Ce=a("The output is by default wrapped into a "),I=s("a"),Te=a("PIL Image object"),Ue=a("."),ee=c(),x=s("p"),Ge=a("You can save the image by simply calling:"),te=c(),L(q.$$.fragment),this.h()},l(e){const n=Xe('[data-svelte="svelte-1phssyn"]',document.head);h=l(n,"META",{name:!0,content:!0}),n.forEach(t),J=m(e),g=l(e,"H1",{class:!0});var ne=r(g);y=l(ne,"A",{id:!0,class:!0,href:!0});var Ae=r(y);C=l(Ae,"SPAN",{});var Oe=r(C);M(P.$$.fragment,Oe),Oe.forEach(t),Ae.forEach(t),fe=m(ne),T=l(ne,"SPAN",{});var Ye=r(T);pe=i(Ye,"Unonditional Image Generation"),Ye.forEach(t),ne.forEach(t),R=m(e),w=l(e,"P",{});var ae=r(w);ue=i(ae,"The "),U=l(ae,"CODE",{});var Le=r(U);ce=i(Le,"DiffusionPipeline"),Le.forEach(t),me=i(ae," is the easiest way to use a pre-trained diffusion system for inference"),ae.forEach(t),F=m(e),p=l(e,"P",{});var u=r(p);de=i(u,"Start by creating an instance of "),G=l(u,"CODE",{});var Me=r(G);he=i(Me,"DiffusionPipeline"),Me.forEach(t),ge=i(u,` and specify which pipeline checkpoint you would like to download.
You can use the `),S=l(u,"CODE",{});var Ne=r(S);ye=i(Ne,"DiffusionPipeline"),Ne.forEach(t),we=i(u," for any "),E=l(u,"A",{href:!0,rel:!0});var Be=r(E);_e=i(Be,"Diffusers\u2019 checkpoint"),Be.forEach(t),$e=i(u,`.
In this guide though, you\u2019ll use `),A=l(u,"CODE",{});var ze=r(A);ve=i(ze,"DiffusionPipeline"),ze.forEach(t),Pe=i(u," for unconditional image generation with "),D=l(u,"A",{href:!0,rel:!0});var He=r(D);Ee=i(He,"DDPM"),He.forEach(t),De=i(u,":"),u.forEach(t),K=m(e),M(b.$$.fragment,e),Q=m(e),_=l(e,"P",{});var ie=r(_);be=i(ie,"The "),O=l(ie,"CODE",{});var Je=r(O);ke=i(Je,"DiffusionPipeline"),Je.forEach(t),je=i(ie,` downloads and caches all modeling, tokenization, and scheduling components.
Because the model consists of roughly 1.4 billion parameters, we strongly recommend running it on GPU.
You can move the generator object to GPU, just like you would in PyTorch.`),ie.forEach(t),V=m(e),M(k.$$.fragment,e),W=m(e),$=l(e,"P",{});var se=r($);Ie=i(se,"Now you can use the "),Y=l(se,"CODE",{});var Re=r(Y);qe=i(Re,"generator"),Re.forEach(t),xe=i(se," on your text prompt:"),se.forEach(t),X=m(e),M(j.$$.fragment,e),Z=m(e),v=l(e,"P",{});var le=r(v);Ce=i(le,"The output is by default wrapped into a "),I=l(le,"A",{href:!0,rel:!0});var Fe=r(I);Te=i(Fe,"PIL Image object"),Fe.forEach(t),Ue=i(le,"."),le.forEach(t),ee=m(e),x=l(e,"P",{});var Ke=r(x);Ge=i(Ke,"You can save the image by simply calling:"),Ke.forEach(t),te=m(e),M(q.$$.fragment,e),this.h()},h(){d(h,"name","hf:doc:metadata"),d(h,"content",JSON.stringify(nt)),d(y,"id","unonditional-image-generation"),d(y,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(y,"href","#unonditional-image-generation"),d(g,"class","relative group"),d(E,"href","https://huggingface.co/models?library=diffusers&sort=downloads"),d(E,"rel","nofollow"),d(D,"href","https://arxiv.org/abs/2006.11239"),d(D,"rel","nofollow"),d(I,"href","https://pillow.readthedocs.io/en/stable/reference/Image.html?highlight=image#the-image-class"),d(I,"rel","nofollow")},m(e,n){o(document.head,h),f(e,J,n),f(e,g,n),o(g,y),o(y,C),N(P,C,null),o(g,fe),o(g,T),o(T,pe),f(e,R,n),f(e,w,n),o(w,ue),o(w,U),o(U,ce),o(w,me),f(e,F,n),f(e,p,n),o(p,de),o(p,G),o(G,he),o(p,ge),o(p,S),o(S,ye),o(p,we),o(p,E),o(E,_e),o(p,$e),o(p,A),o(A,ve),o(p,Pe),o(p,D),o(D,Ee),o(p,De),f(e,K,n),N(b,e,n),f(e,Q,n),f(e,_,n),o(_,be),o(_,O),o(O,ke),o(_,je),f(e,V,n),N(k,e,n),f(e,W,n),f(e,$,n),o($,Ie),o($,Y),o(Y,qe),o($,xe),f(e,X,n),N(j,e,n),f(e,Z,n),f(e,v,n),o(v,Ce),o(v,I),o(I,Te),o(v,Ue),f(e,ee,n),f(e,x,n),o(x,Ge),f(e,te,n),N(q,e,n),oe=!0},p:Ze,i(e){oe||(B(P.$$.fragment,e),B(b.$$.fragment,e),B(k.$$.fragment,e),B(j.$$.fragment,e),B(q.$$.fragment,e),oe=!0)},o(e){z(P.$$.fragment,e),z(b.$$.fragment,e),z(k.$$.fragment,e),z(j.$$.fragment,e),z(q.$$.fragment,e),oe=!1},d(e){t(h),e&&t(J),e&&t(g),H(P),e&&t(R),e&&t(w),e&&t(F),e&&t(p),e&&t(K),H(b,e),e&&t(Q),e&&t(_),e&&t(V),H(k,e),e&&t(W),e&&t($),e&&t(X),H(j,e),e&&t(Z),e&&t(v),e&&t(ee),e&&t(x),e&&t(te),H(q,e)}}}const nt={local:"unonditional-image-generation",title:"Unonditional Image Generation"};function at(Se){return et(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class rt extends Qe{constructor(h){super();Ve(this,h,at,ot,We,{})}}export{rt as default,nt as metadata};
