import{S as Ss,i as Es,s as $s,e as i,k as d,w as g,t as r,M as ks,c as o,d as t,m as c,a,x as _,h as l,b as s,N as qn,G as e,g as p,y as b,L as Ts,q as v,o as D,B as w,v as Cs}from"../../../chunks/vendor-hf-doc-builder.js";import{D as E}from"../../../chunks/Docstring-hf-doc-builder.js";import{I as nn}from"../../../chunks/IconCopyLink-hf-doc-builder.js";function Ls(ia){let N,on,G,H,ht,re,Fn,mt,Un,an,q,R,gt,le,Vn,_t,Wn,sn,y,Hn,bt,Rn,Bn,de,Kn,jn,ce,Yn,Jn,fe,Qn,Xn,pe,Zn,ei,rn,L,ti,ue,ni,ii,je,oi,ai,ln,M,si,he,ri,li,me,di,ci,dn,F,B,vt,ge,fi,Dt,pi,cn,K,Ye,ui,_e,Je,oa,hi,wt,mi,fn,U,j,yt,be,gi,It,_i,pn,Y,xt,$,Pt,bi,vi,St,Di,wi,Qe,yi,Ii,Xe,xi,Pi,V,k,Et,ve,Si,Ei,$t,kt,$i,ki,Ze,De,et,aa,Ti,tt,we,Ci,Li,T,Tt,ye,Mi,Ai,Ct,Lt,Oi,zi,nt,Ie,it,sa,Ni,ot,xe,Gi,qi,C,Mt,Pe,Fi,Ui,Se,At,Vi,Wi,Ot,Hi,Ri,at,Ee,st,ra,Bi,rt,Ki,un,W,J,zt,$e,ji,Nt,Yi,hn,u,ke,Ji,Gt,Qi,Xi,Te,Zi,qt,eo,to,no,Q,Ce,io,Ft,oo,ao,A,Le,so,Ut,ro,lo,Vt,co,fo,X,Me,po,Ae,uo,Wt,ho,mo,mn,h,Oe,go,Ht,_o,bo,ze,vo,Rt,Do,wo,yo,Z,Ne,Io,Bt,xo,Po,O,Ge,So,Kt,Eo,$o,jt,ko,To,ee,qe,Co,Fe,Lo,Yt,Mo,Ao,gn,m,Ue,Oo,Ve,zo,Jt,No,Go,qo,We,Fo,Qt,Uo,Vo,Wo,te,He,Ho,Xt,Ro,Bo,z,Re,Ko,Zt,jo,Yo,en,Jo,Qo,ne,Be,Xo,Ke,Zo,tn,ea,ta,_n;return re=new nn({}),le=new nn({}),ge=new nn({}),be=new nn({}),$e=new nn({}),ke=new E({props:{name:"class diffusers.StableDiffusionPipeline",anchor:"diffusers.StableDiffusionPipeline",parameters:[{name:"vae",val:": AutoencoderKL"},{name:"text_encoder",val:": CLIPTextModel"},{name:"tokenizer",val:": CLIPTokenizer"},{name:"unet",val:": UNet2DConditionModel"},{name:"scheduler",val:": typing.Union[diffusers.schedulers.scheduling_ddim.DDIMScheduler, diffusers.schedulers.scheduling_pndm.PNDMScheduler, diffusers.schedulers.scheduling_lms_discrete.LMSDiscreteScheduler]"},{name:"safety_checker",val:": StableDiffusionSafetyChecker"},{name:"feature_extractor",val:": CLIPFeatureExtractor"}],parametersDescription:[{anchor:"diffusers.StableDiffusionPipeline.vae",description:`<strong>vae</strong> (<code>AutoencoderKL</code>) &#x2014;
Variational Auto-Encoder (VAE) Model to encode and decode images to and from latent representations.`,name:"vae"},{anchor:"diffusers.StableDiffusionPipeline.text_encoder",description:`<strong>text_encoder</strong> (<code>CLIPTextModel</code>) &#x2014;
Frozen text-encoder. Stable Diffusion uses the text portion of
<a href="https://huggingface.co/docs/transformers/model_doc/clip#transformers.CLIPTextModel" rel="nofollow">CLIP</a>, specifically
the <a href="https://huggingface.co/openai/clip-vit-large-patch14" rel="nofollow">clip-vit-large-patch14</a> variant.`,name:"text_encoder"},{anchor:"diffusers.StableDiffusionPipeline.tokenizer",description:`<strong>tokenizer</strong> (<code>CLIPTokenizer</code>) &#x2014;
Tokenizer of class
<a href="https://huggingface.co/docs/transformers/v4.21.0/en/model_doc/clip#transformers.CLIPTokenizer" rel="nofollow">CLIPTokenizer</a>.`,name:"tokenizer"},{anchor:"diffusers.StableDiffusionPipeline.unet",description:"<strong>unet</strong> (<code>UNet2DConditionModel</code>) &#x2014; Conditional U-Net architecture to denoise the encoded image latents.",name:"unet"},{anchor:"diffusers.StableDiffusionPipeline.scheduler",description:`<strong>scheduler</strong> (<a href="/docs/diffusers/main/en/api/schedulers#diffusers.SchedulerMixin">SchedulerMixin</a>) &#x2014;
A scheduler to be used in combination with <code>unet</code> to denoise the encoded image latens. Can be one of
<a href="/docs/diffusers/main/en/api/schedulers#diffusers.DDIMScheduler">DDIMScheduler</a>, <a href="/docs/diffusers/main/en/api/schedulers#diffusers.LMSDiscreteScheduler">LMSDiscreteScheduler</a>, or <a href="/docs/diffusers/main/en/api/schedulers#diffusers.PNDMScheduler">PNDMScheduler</a>.`,name:"scheduler"},{anchor:"diffusers.StableDiffusionPipeline.safety_checker",description:`<strong>safety_checker</strong> (<code>StableDiffusionSafetyChecker</code>) &#x2014;
Classification module that estimates whether generated images could be considered offsensive or harmful.
Please, refer to the <a href="https://huggingface.co/CompVis/stable-diffusion-v1-4" rel="nofollow">model card</a> for details.`,name:"safety_checker"},{anchor:"diffusers.StableDiffusionPipeline.feature_extractor",description:`<strong>feature_extractor</strong> (<code>CLIPFeatureExtractor</code>) &#x2014;
Model that extracts features from generated images to be used as inputs for the <code>safety_checker</code>.`,name:"feature_extractor"}],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion.py#L16"}}),Ce=new E({props:{name:"__call__",anchor:"diffusers.StableDiffusionPipeline.__call__",parameters:[{name:"prompt",val:": typing.Union[str, typing.List[str]]"},{name:"height",val:": typing.Optional[int] = 512"},{name:"width",val:": typing.Optional[int] = 512"},{name:"num_inference_steps",val:": typing.Optional[int] = 50"},{name:"guidance_scale",val:": typing.Optional[float] = 7.5"},{name:"eta",val:": typing.Optional[float] = 0.0"},{name:"generator",val:": typing.Optional[torch._C.Generator] = None"},{name:"latents",val:": typing.Optional[torch.FloatTensor] = None"},{name:"output_type",val:": typing.Optional[str] = 'pil'"},{name:"return_dict",val:": bool = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"diffusers.StableDiffusionPipeline.__call__.prompt",description:`<strong>prompt</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
The prompt or prompts to guide the image generation.`,name:"prompt"},{anchor:"diffusers.StableDiffusionPipeline.__call__.height",description:`<strong>height</strong> (<code>int</code>, <em>optional</em>, defaults to 512) &#x2014;
The height in pixels of the generated image.`,name:"height"},{anchor:"diffusers.StableDiffusionPipeline.__call__.width",description:`<strong>width</strong> (<code>int</code>, <em>optional</em>, defaults to 512) &#x2014;
The width in pixels of the generated image.`,name:"width"},{anchor:"diffusers.StableDiffusionPipeline.__call__.num_inference_steps",description:`<strong>num_inference_steps</strong> (<code>int</code>, <em>optional</em>, defaults to 50) &#x2014;
The number of denoising steps. More denoising steps usually lead to a higher quality image at the
expense of slower inference.`,name:"num_inference_steps"},{anchor:"diffusers.StableDiffusionPipeline.__call__.guidance_scale",description:`<strong>guidance_scale</strong> (<code>float</code>, <em>optional</em>, defaults to 7.5) &#x2014;
Guidance scale as defined in <a href="https://arxiv.org/abs/2207.12598" rel="nofollow">Classifier-Free Diffusion Guidance</a>.
<code>guidance_scale</code> is defined as <code>w</code> of equation 2. of <a href="https://arxiv.org/pdf/2205.11487.pdf" rel="nofollow">Imagen
Paper</a>. Guidance scale is enabled by setting <code>guidance_scale &gt; 1</code>. Higher guidance scale encourages to generate images that are closely linked to the text <code>prompt</code>,
usually at the expense of lower image quality.`,name:"guidance_scale"},{anchor:"diffusers.StableDiffusionPipeline.__call__.eta",description:`<strong>eta</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
Corresponds to parameter eta (&#x3B7;) in the DDIM paper: <a href="https://arxiv.org/abs/2010.02502" rel="nofollow">https://arxiv.org/abs/2010.02502</a>. Only applies to
<a href="/docs/diffusers/main/en/api/schedulers#diffusers.DDIMScheduler">schedulers.DDIMScheduler</a>, will be ignored for others.`,name:"eta"},{anchor:"diffusers.StableDiffusionPipeline.__call__.generator",description:`<strong>generator</strong> (<code>torch.Generator</code>, <em>optional</em>) &#x2014;
A <a href="https://pytorch.org/docs/stable/generated/torch.Generator.html" rel="nofollow">torch generator</a> to make generation
deterministic.`,name:"generator"},{anchor:"diffusers.StableDiffusionPipeline.__call__.latents",description:`<strong>latents</strong> (<code>torch.FloatTensor</code>, <em>optional</em>) &#x2014;
Pre-generated noisy latents, sampled from a Gaussian distribution, to be used as inputs for image
generation. Can be used to tweak the same generation with different prompts. If not provided, a latents
tensor will ge generated by sampling using the supplied random <code>generator</code>.`,name:"latents"},{anchor:"diffusers.StableDiffusionPipeline.__call__.output_type",description:`<strong>output_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;pil&quot;</code>) &#x2014;
The output format of the generate image. Choose between
<a href="https://pillow.readthedocs.io/en/stable/" rel="nofollow">PIL</a>: <code>PIL.Image.Image</code> or <code>nd.array</code>.`,name:"output_type"},{anchor:"diffusers.StableDiffusionPipeline.__call__.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to return a <code>StableDiffusionPipelineOutput</code> instead of a
plain tuple.`,name:"return_dict"}],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion.py#L93",returnDescription:`
<p><code>~pipelines.stable_diffusion.StableDiffusionPipelineOutput</code> if <code>return_dict</code> is True, otherwise a tuple.
When returning a tuple, the first element is a list with the generated images, and the second element is a
list of <code>bool</code>s denoting whether the corresponding generated image likely represents \u201Cnot-safe-for-work\u201D
(nsfw) content, according to the <code>safety_checker</code>.</p>
`}}),Le=new E({props:{name:"enable_attention_slicing",anchor:"diffusers.StableDiffusionPipeline.enable_attention_slicing",parameters:[{name:"slice_size",val:": typing.Union[str, int, NoneType] = 'auto'"}],parametersDescription:[{anchor:"diffusers.StableDiffusionPipeline.enable_attention_slicing.slice_size",description:`<strong>slice_size</strong> (<code>str</code> or <code>int</code>, <em>optional</em>, defaults to <code>&quot;auto&quot;</code>) &#x2014;
When <code>&quot;auto&quot;</code>, halves the input to the attention heads, so attention will be computed in two steps. If
a number is provided, uses as many slices as <code>attention_head_dim // slice_size</code>. In this case,
<code>attention_head_dim</code> must be a multiple of <code>slice_size</code>.`,name:"slice_size"}],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion.py#L66"}}),Me=new E({props:{name:"disable_attention_slicing",anchor:"diffusers.StableDiffusionPipeline.disable_attention_slicing",parameters:[],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion.py#L85"}}),Oe=new E({props:{name:"class diffusers.StableDiffusionImg2ImgPipeline",anchor:"diffusers.StableDiffusionImg2ImgPipeline",parameters:[{name:"vae",val:": AutoencoderKL"},{name:"text_encoder",val:": CLIPTextModel"},{name:"tokenizer",val:": CLIPTokenizer"},{name:"unet",val:": UNet2DConditionModel"},{name:"scheduler",val:": typing.Union[diffusers.schedulers.scheduling_ddim.DDIMScheduler, diffusers.schedulers.scheduling_pndm.PNDMScheduler, diffusers.schedulers.scheduling_lms_discrete.LMSDiscreteScheduler]"},{name:"safety_checker",val:": StableDiffusionSafetyChecker"},{name:"feature_extractor",val:": CLIPFeatureExtractor"}],parametersDescription:[{anchor:"diffusers.StableDiffusionImg2ImgPipeline.vae",description:`<strong>vae</strong> (<code>AutoencoderKL</code>) &#x2014;
Variational Auto-Encoder (VAE) Model to encode and decode images to and from latent representations.`,name:"vae"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.text_encoder",description:`<strong>text_encoder</strong> (<code>CLIPTextModel</code>) &#x2014;
Frozen text-encoder. Stable Diffusion uses the text portion of
<a href="https://huggingface.co/docs/transformers/model_doc/clip#transformers.CLIPTextModel" rel="nofollow">CLIP</a>, specifically
the <a href="https://huggingface.co/openai/clip-vit-large-patch14" rel="nofollow">clip-vit-large-patch14</a> variant.`,name:"text_encoder"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.tokenizer",description:`<strong>tokenizer</strong> (<code>CLIPTokenizer</code>) &#x2014;
Tokenizer of class
<a href="https://huggingface.co/docs/transformers/v4.21.0/en/model_doc/clip#transformers.CLIPTokenizer" rel="nofollow">CLIPTokenizer</a>.`,name:"tokenizer"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.unet",description:"<strong>unet</strong> (<code>UNet2DConditionModel</code>) &#x2014; Conditional U-Net architecture to denoise the encoded image latents.",name:"unet"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.scheduler",description:`<strong>scheduler</strong> (<a href="/docs/diffusers/main/en/api/schedulers#diffusers.SchedulerMixin">SchedulerMixin</a>) &#x2014;
A scheduler to be used in combination with <code>unet</code> to denoise the encoded image latens. Can be one of
<a href="/docs/diffusers/main/en/api/schedulers#diffusers.DDIMScheduler">DDIMScheduler</a>, <a href="/docs/diffusers/main/en/api/schedulers#diffusers.LMSDiscreteScheduler">LMSDiscreteScheduler</a>, or <a href="/docs/diffusers/main/en/api/schedulers#diffusers.PNDMScheduler">PNDMScheduler</a>.`,name:"scheduler"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.safety_checker",description:`<strong>safety_checker</strong> (<code>StableDiffusionSafetyChecker</code>) &#x2014;
Classification module that estimates whether generated images could be considered offsensive or harmful.
Please, refer to the <a href="https://huggingface.co/CompVis/stable-diffusion-v1-4" rel="nofollow">model card</a> for details.`,name:"safety_checker"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.feature_extractor",description:`<strong>feature_extractor</strong> (<code>CLIPFeatureExtractor</code>) &#x2014;
Model that extracts features from generated images to be used as inputs for the <code>safety_checker</code>.`,name:"feature_extractor"}],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion_img2img.py#L27"}}),Ne=new E({props:{name:"__call__",anchor:"diffusers.StableDiffusionImg2ImgPipeline.__call__",parameters:[{name:"prompt",val:": typing.Union[str, typing.List[str]]"},{name:"init_image",val:": typing.Union[torch.FloatTensor, PIL.Image.Image]"},{name:"strength",val:": float = 0.8"},{name:"num_inference_steps",val:": typing.Optional[int] = 50"},{name:"guidance_scale",val:": typing.Optional[float] = 7.5"},{name:"eta",val:": typing.Optional[float] = 0.0"},{name:"generator",val:": typing.Optional[torch._C.Generator] = None"},{name:"output_type",val:": typing.Optional[str] = 'pil'"},{name:"return_dict",val:": bool = True"}],parametersDescription:[{anchor:"diffusers.StableDiffusionImg2ImgPipeline.__call__.prompt",description:`<strong>prompt</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
The prompt or prompts to guide the image generation.`,name:"prompt"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.__call__.init_image",description:`<strong>init_image</strong> (<code>torch.FloatTensor</code> or <code>PIL.Image.Image</code>) &#x2014;
<code>Image</code>, or tensor representing an image batch, that will be used as the starting point for the
process.`,name:"init_image"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.__call__.strength",description:`<strong>strength</strong> (<code>float</code>, <em>optional</em>, defaults to 0.8) &#x2014;
Conceptually, indicates how much to transform the reference <code>init_image</code>. Must be between 0 and 1.
<code>init_image</code> will be used as a starting point, adding more noise to it the larger the <code>strength</code>. The
number of denoising steps depends on the amount of noise initially added. When <code>strength</code> is 1, added
noise will be maximum and the denoising process will run for the full number of iterations specified in
<code>num_inference_steps</code>. A value of 1, therefore, essentially ignores <code>init_image</code>.`,name:"strength"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.__call__.num_inference_steps",description:`<strong>num_inference_steps</strong> (<code>int</code>, <em>optional</em>, defaults to 50) &#x2014;
The number of denoising steps. More denoising steps usually lead to a higher quality image at the
expense of slower inference. This parameter will be modulated by <code>strength</code>.`,name:"num_inference_steps"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.__call__.guidance_scale",description:`<strong>guidance_scale</strong> (<code>float</code>, <em>optional</em>, defaults to 7.5) &#x2014;
Guidance scale as defined in <a href="https://arxiv.org/abs/2207.12598" rel="nofollow">Classifier-Free Diffusion Guidance</a>.
<code>guidance_scale</code> is defined as <code>w</code> of equation 2. of <a href="https://arxiv.org/pdf/2205.11487.pdf" rel="nofollow">Imagen
Paper</a>. Guidance scale is enabled by setting <code>guidance_scale &gt; 1</code>. Higher guidance scale encourages to generate images that are closely linked to the text <code>prompt</code>,
usually at the expense of lower image quality.`,name:"guidance_scale"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.__call__.eta",description:`<strong>eta</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
Corresponds to parameter eta (&#x3B7;) in the DDIM paper: <a href="https://arxiv.org/abs/2010.02502" rel="nofollow">https://arxiv.org/abs/2010.02502</a>. Only applies to
<a href="/docs/diffusers/main/en/api/schedulers#diffusers.DDIMScheduler">schedulers.DDIMScheduler</a>, will be ignored for others.`,name:"eta"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.__call__.generator",description:`<strong>generator</strong> (<code>torch.Generator</code>, <em>optional</em>) &#x2014;
A <a href="https://pytorch.org/docs/stable/generated/torch.Generator.html" rel="nofollow">torch generator</a> to make generation
deterministic.`,name:"generator"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.__call__.output_type",description:`<strong>output_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;pil&quot;</code>) &#x2014;
The output format of the generate image. Choose between
<a href="https://pillow.readthedocs.io/en/stable/" rel="nofollow">PIL</a>: <code>PIL.Image.Image</code> or <code>nd.array</code>.`,name:"output_type"},{anchor:"diffusers.StableDiffusionImg2ImgPipeline.__call__.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to return a <code>StableDiffusionPipelineOutput</code> instead of a
plain tuple.`,name:"return_dict"}],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion_img2img.py#L104",returnDescription:`
<p><code>~pipelines.stable_diffusion.StableDiffusionPipelineOutput</code> if <code>return_dict</code> is True, otherwise a tuple.
When returning a tuple, the first element is a list with the generated images, and the second element is a
list of <code>bool</code>s denoting whether the corresponding generated image likely represents \u201Cnot-safe-for-work\u201D
(nsfw) content, according to the <code>safety_checker</code>.</p>
`}}),Ge=new E({props:{name:"enable_attention_slicing",anchor:"diffusers.StableDiffusionImg2ImgPipeline.enable_attention_slicing",parameters:[{name:"slice_size",val:": typing.Union[str, int, NoneType] = 'auto'"}],parametersDescription:[{anchor:"diffusers.StableDiffusionImg2ImgPipeline.enable_attention_slicing.slice_size",description:`<strong>slice_size</strong> (<code>str</code> or <code>int</code>, <em>optional</em>, defaults to <code>&quot;auto&quot;</code>) &#x2014;
When <code>&quot;auto&quot;</code>, halves the input to the attention heads, so attention will be computed in two steps. If
a number is provided, uses as many slices as <code>attention_head_dim // slice_size</code>. In this case,
<code>attention_head_dim</code> must be a multiple of <code>slice_size</code>.`,name:"slice_size"}],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion_img2img.py#L77"}}),qe=new E({props:{name:"disable_attention_slicing",anchor:"diffusers.StableDiffusionImg2ImgPipeline.disable_attention_slicing",parameters:[],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion_img2img.py#L96"}}),Ue=new E({props:{name:"class diffusers.StableDiffusionInpaintPipeline",anchor:"diffusers.StableDiffusionInpaintPipeline",parameters:[{name:"vae",val:": AutoencoderKL"},{name:"text_encoder",val:": CLIPTextModel"},{name:"tokenizer",val:": CLIPTokenizer"},{name:"unet",val:": UNet2DConditionModel"},{name:"scheduler",val:": typing.Union[diffusers.schedulers.scheduling_ddim.DDIMScheduler, diffusers.schedulers.scheduling_pndm.PNDMScheduler]"},{name:"safety_checker",val:": StableDiffusionSafetyChecker"},{name:"feature_extractor",val:": CLIPFeatureExtractor"}],parametersDescription:[{anchor:"diffusers.StableDiffusionInpaintPipeline.vae",description:`<strong>vae</strong> (<code>AutoencoderKL</code>) &#x2014;
Variational Auto-Encoder (VAE) Model to encode and decode images to and from latent representations.`,name:"vae"},{anchor:"diffusers.StableDiffusionInpaintPipeline.text_encoder",description:`<strong>text_encoder</strong> (<code>CLIPTextModel</code>) &#x2014;
Frozen text-encoder. Stable Diffusion uses the text portion of
<a href="https://huggingface.co/docs/transformers/model_doc/clip#transformers.CLIPTextModel" rel="nofollow">CLIP</a>, specifically
the <a href="https://huggingface.co/openai/clip-vit-large-patch14" rel="nofollow">clip-vit-large-patch14</a> variant.`,name:"text_encoder"},{anchor:"diffusers.StableDiffusionInpaintPipeline.tokenizer",description:`<strong>tokenizer</strong> (<code>CLIPTokenizer</code>) &#x2014;
Tokenizer of class
<a href="https://huggingface.co/docs/transformers/v4.21.0/en/model_doc/clip#transformers.CLIPTokenizer" rel="nofollow">CLIPTokenizer</a>.`,name:"tokenizer"},{anchor:"diffusers.StableDiffusionInpaintPipeline.unet",description:"<strong>unet</strong> (<code>UNet2DConditionModel</code>) &#x2014; Conditional U-Net architecture to denoise the encoded image latents.",name:"unet"},{anchor:"diffusers.StableDiffusionInpaintPipeline.scheduler",description:`<strong>scheduler</strong> (<a href="/docs/diffusers/main/en/api/schedulers#diffusers.SchedulerMixin">SchedulerMixin</a>) &#x2014;
A scheduler to be used in combination with <code>unet</code> to denoise the encoded image latens. Can be one of
<a href="/docs/diffusers/main/en/api/schedulers#diffusers.DDIMScheduler">DDIMScheduler</a>, <a href="/docs/diffusers/main/en/api/schedulers#diffusers.LMSDiscreteScheduler">LMSDiscreteScheduler</a>, or <a href="/docs/diffusers/main/en/api/schedulers#diffusers.PNDMScheduler">PNDMScheduler</a>.`,name:"scheduler"},{anchor:"diffusers.StableDiffusionInpaintPipeline.safety_checker",description:`<strong>safety_checker</strong> (<code>StableDiffusionSafetyChecker</code>) &#x2014;
Classification module that estimates whether generated images could be considered offsensive or harmful.
Please, refer to the <a href="https://huggingface.co/CompVis/stable-diffusion-v1-4" rel="nofollow">model card</a> for details.`,name:"safety_checker"},{anchor:"diffusers.StableDiffusionInpaintPipeline.feature_extractor",description:`<strong>feature_extractor</strong> (<code>CLIPFeatureExtractor</code>) &#x2014;
Model that extracts features from generated images to be used as inputs for the <code>safety_checker</code>.`,name:"feature_extractor"}],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion_inpaint.py#L41"}}),He=new E({props:{name:"__call__",anchor:"diffusers.StableDiffusionInpaintPipeline.__call__",parameters:[{name:"prompt",val:": typing.Union[str, typing.List[str]]"},{name:"init_image",val:": typing.Union[torch.FloatTensor, PIL.Image.Image]"},{name:"mask_image",val:": typing.Union[torch.FloatTensor, PIL.Image.Image]"},{name:"strength",val:": float = 0.8"},{name:"num_inference_steps",val:": typing.Optional[int] = 50"},{name:"guidance_scale",val:": typing.Optional[float] = 7.5"},{name:"eta",val:": typing.Optional[float] = 0.0"},{name:"generator",val:": typing.Optional[torch._C.Generator] = None"},{name:"output_type",val:": typing.Optional[str] = 'pil'"},{name:"return_dict",val:": bool = True"}],parametersDescription:[{anchor:"diffusers.StableDiffusionInpaintPipeline.__call__.prompt",description:`<strong>prompt</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
The prompt or prompts to guide the image generation.`,name:"prompt"},{anchor:"diffusers.StableDiffusionInpaintPipeline.__call__.init_image",description:`<strong>init_image</strong> (<code>torch.FloatTensor</code> or <code>PIL.Image.Image</code>) &#x2014;
<code>Image</code>, or tensor representing an image batch, that will be used as the starting point for the
process. This is the image whose masked region will be inpainted.`,name:"init_image"},{anchor:"diffusers.StableDiffusionInpaintPipeline.__call__.mask_image",description:`<strong>mask_image</strong> (<code>torch.FloatTensor</code> or <code>PIL.Image.Image</code>) &#x2014;
<code>Image</code>, or tensor representing an image batch, to mask <code>init_image</code>. White pixels in the mask will be
replaced by noise and therefore repainted, while black pixels will be preserved. The mask image will be
converted to a single channel (luminance) before use.`,name:"mask_image"},{anchor:"diffusers.StableDiffusionInpaintPipeline.__call__.strength",description:`<strong>strength</strong> (<code>float</code>, <em>optional</em>, defaults to 0.8) &#x2014;
Conceptually, indicates how much to inpaint the masked area. Must be between 0 and 1. When <code>strength</code>
is 1, the denoising process will be run on the masked area for the full number of iterations specified
in <code>num_inference_steps</code>. <code>init_image</code> will be used as a reference for the masked area, adding more
noise to that region the larger the <code>strength</code>. If <code>strength</code> is 0, no inpainting will occur.`,name:"strength"},{anchor:"diffusers.StableDiffusionInpaintPipeline.__call__.num_inference_steps",description:`<strong>num_inference_steps</strong> (<code>int</code>, <em>optional</em>, defaults to 50) &#x2014;
The reference number of denoising steps. More denoising steps usually lead to a higher quality image at
the expense of slower inference. This parameter will be modulated by <code>strength</code>, as explained above.`,name:"num_inference_steps"},{anchor:"diffusers.StableDiffusionInpaintPipeline.__call__.guidance_scale",description:`<strong>guidance_scale</strong> (<code>float</code>, <em>optional</em>, defaults to 7.5) &#x2014;
Guidance scale as defined in <a href="https://arxiv.org/abs/2207.12598" rel="nofollow">Classifier-Free Diffusion Guidance</a>.
<code>guidance_scale</code> is defined as <code>w</code> of equation 2. of <a href="https://arxiv.org/pdf/2205.11487.pdf" rel="nofollow">Imagen
Paper</a>. Guidance scale is enabled by setting <code>guidance_scale &gt; 1</code>. Higher guidance scale encourages to generate images that are closely linked to the text <code>prompt</code>,
usually at the expense of lower image quality.`,name:"guidance_scale"},{anchor:"diffusers.StableDiffusionInpaintPipeline.__call__.eta",description:`<strong>eta</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
Corresponds to parameter eta (&#x3B7;) in the DDIM paper: <a href="https://arxiv.org/abs/2010.02502" rel="nofollow">https://arxiv.org/abs/2010.02502</a>. Only applies to
<a href="/docs/diffusers/main/en/api/schedulers#diffusers.DDIMScheduler">schedulers.DDIMScheduler</a>, will be ignored for others.`,name:"eta"},{anchor:"diffusers.StableDiffusionInpaintPipeline.__call__.generator",description:`<strong>generator</strong> (<code>torch.Generator</code>, <em>optional</em>) &#x2014;
A <a href="https://pytorch.org/docs/stable/generated/torch.Generator.html" rel="nofollow">torch generator</a> to make generation
deterministic.`,name:"generator"},{anchor:"diffusers.StableDiffusionInpaintPipeline.__call__.output_type",description:`<strong>output_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;pil&quot;</code>) &#x2014;
The output format of the generate image. Choose between
<a href="https://pillow.readthedocs.io/en/stable/" rel="nofollow">PIL</a>: <code>PIL.Image.Image</code> or <code>nd.array</code>.`,name:"output_type"},{anchor:"diffusers.StableDiffusionInpaintPipeline.__call__.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to return a <code>StableDiffusionPipelineOutput</code> instead of a
plain tuple.`,name:"return_dict"}],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion_inpaint.py#L118",returnDescription:`
<p><code>~pipelines.stable_diffusion.StableDiffusionPipelineOutput</code> if <code>return_dict</code> is True, otherwise a tuple.
When returning a tuple, the first element is a list with the generated images, and the second element is a
list of <code>bool</code>s denoting whether the corresponding generated image likely represents \u201Cnot-safe-for-work\u201D
(nsfw) content, according to the <code>safety_checker</code>.</p>
`}}),Re=new E({props:{name:"enable_attention_slicing",anchor:"diffusers.StableDiffusionInpaintPipeline.enable_attention_slicing",parameters:[{name:"slice_size",val:": typing.Union[str, int, NoneType] = 'auto'"}],parametersDescription:[{anchor:"diffusers.StableDiffusionInpaintPipeline.enable_attention_slicing.slice_size",description:`<strong>slice_size</strong> (<code>str</code> or <code>int</code>, <em>optional</em>, defaults to <code>&quot;auto&quot;</code>) &#x2014;
When <code>&quot;auto&quot;</code>, halves the input to the attention heads, so attention will be computed in two steps. If
a number is provided, uses as many slices as <code>attention_head_dim // slice_size</code>. In this case,
<code>attention_head_dim</code> must be a multiple of <code>slice_size</code>.`,name:"slice_size"}],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion_inpaint.py#L91"}}),Be=new E({props:{name:"disable_attention_slicing",anchor:"diffusers.StableDiffusionInpaintPipeline.disable_attention_slicing",parameters:[],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion_inpaint.py#L110"}}),{c(){N=i("meta"),on=d(),G=i("h1"),H=i("a"),ht=i("span"),g(re.$$.fragment),Fn=d(),mt=i("span"),Un=r("Stable diffusion pipelines"),an=d(),q=i("h2"),R=i("a"),gt=i("span"),g(le.$$.fragment),Vn=d(),_t=i("span"),Wn=r("Overview"),sn=d(),y=i("p"),Hn=r("Stable Diffusion is a text-to-image "),bt=i("em"),Rn=r("latent diffusion"),Bn=r(" model created by the researchers and engineers from "),de=i("a"),Kn=r("CompVis"),jn=r(", "),ce=i("a"),Yn=r("Stability AI"),Jn=r(" and "),fe=i("a"),Qn=r("LAION"),Xn=r(". It\u2019s trained on 512x512 images from a subset of the "),pe=i("a"),Zn=r("LAION-5B"),ei=r(" dataset. This model uses a frozen CLIP ViT-L/14 text encoder to condition the model on text prompts. With its 860M UNet and 123M text encoder, the model is relatively lightweight and can run on consumer GPUs."),rn=d(),L=i("p"),ti=r("Latent diffusion is the research on top of which Stable Diffusion was built. It was proposed in "),ue=i("a"),ni=r("High-Resolution Image Synthesis with Latent Diffusion Models"),ii=r(" by Robin Rombach, Andreas Blattmann, Dominik Lorenz, Patrick Esser, Bj\xF6rn Ommer. You can learn more details about it in the "),je=i("a"),oi=r("specific pipeline for latent diffusion"),ai=r(" that is part of \u{1F917} Diffusers."),ln=d(),M=i("p"),si=r("For more details about how Stable Diffusion works and how it differs from the base latent diffusion model, please refer to the official "),he=i("a"),ri=r("launch announcement post"),li=r(" and "),me=i("a"),di=r("this section of our own blog post"),ci=r("."),dn=d(),F=i("h2"),B=i("a"),vt=i("span"),g(ge.$$.fragment),fi=d(),Dt=i("span"),pi=r("Tips"),cn=d(),K=i("ul"),Ye=i("li"),ui=r("To tweak your prompts on a specific result you liked, you can generate your own latents, as demonstrated in the following notebook: "),_e=i("a"),Je=i("img"),hi=d(),wt=i("li"),mi=r("TODO: some interesting Tips"),fn=d(),U=i("h2"),j=i("a"),yt=i("span"),g(be.$$.fragment),gi=d(),It=i("span"),_i=r("Available pipelines"),pn=d(),Y=i("table"),xt=i("thead"),$=i("tr"),Pt=i("th"),bi=r("Pipeline"),vi=d(),St=i("th"),Di=r("Tasks"),wi=d(),Qe=i("th"),yi=r("Colab"),Ii=d(),Xe=i("th"),xi=r("Demo"),Pi=d(),V=i("tbody"),k=i("tr"),Et=i("td"),ve=i("a"),Si=r("pipeline_stable_diffusion.py"),Ei=d(),$t=i("td"),kt=i("em"),$i=r("Text-to-Image Generation"),ki=d(),Ze=i("td"),De=i("a"),et=i("img"),Ti=d(),tt=i("td"),we=i("a"),Ci=r("\u{1F917} Stable Diffusion"),Li=d(),T=i("tr"),Tt=i("td"),ye=i("a"),Mi=r("pipeline_stable_diffusion_img2img.py"),Ai=d(),Ct=i("td"),Lt=i("em"),Oi=r("Image-to-Image Text-Guided Generation"),zi=d(),nt=i("td"),Ie=i("a"),it=i("img"),Ni=d(),ot=i("td"),xe=i("a"),Gi=r("\u{1F917} Diffuse the Rest"),qi=d(),C=i("tr"),Mt=i("td"),Pe=i("a"),Fi=r("pipeline_stable_diffusion_inpaint.py"),Ui=d(),Se=i("td"),At=i("strong"),Vi=r("Experimental"),Wi=r(" \u2013 "),Ot=i("em"),Hi=r("Text-Guided Image Inpainting"),Ri=d(),at=i("td"),Ee=i("a"),st=i("img"),Bi=d(),rt=i("td"),Ki=r("Coming soon"),un=d(),W=i("h2"),J=i("a"),zt=i("span"),g($e.$$.fragment),ji=d(),Nt=i("span"),Yi=r("API"),hn=d(),u=i("div"),g(ke.$$.fragment),Ji=d(),Gt=i("p"),Qi=r("Pipeline for text-to-image generation using Stable Diffusion."),Xi=d(),Te=i("p"),Zi=r("This model inherits from "),qt=i("code"),eo=r("DiffusionPipeline"),to=r(`. Check the superclass documentation for the generic methods the
library implements for all the pipelines (such as downloading or saving, running on a particular device, etc.)`),no=d(),Q=i("div"),g(Ce.$$.fragment),io=d(),Ft=i("p"),oo=r("Function invoked when calling the pipeline for generation."),ao=d(),A=i("div"),g(Le.$$.fragment),so=d(),Ut=i("p"),ro=r("Enable sliced attention computation."),lo=d(),Vt=i("p"),co=r(`When this option is enabled, the attention module will split the input tensor in slices, to compute attention
in several steps. This is useful to save some memory in exchange for a small speed decrease.`),fo=d(),X=i("div"),g(Me.$$.fragment),po=d(),Ae=i("p"),uo=r("Disable sliced attention computation. If "),Wt=i("code"),ho=r("enable_attention_slicing"),mo=r(` was previously invoked, this method will go
back to computing attention in one step.`),mn=d(),h=i("div"),g(Oe.$$.fragment),go=d(),Ht=i("p"),_o=r("Pipeline for text-guided image to image generation using Stable Diffusion."),bo=d(),ze=i("p"),vo=r("This model inherits from "),Rt=i("code"),Do=r("DiffusionPipeline"),wo=r(`. Check the superclass documentation for the generic methods the
library implements for all the pipelines (such as downloading or saving, running on a particular device, etc.)`),yo=d(),Z=i("div"),g(Ne.$$.fragment),Io=d(),Bt=i("p"),xo=r("Function invoked when calling the pipeline for generation."),Po=d(),O=i("div"),g(Ge.$$.fragment),So=d(),Kt=i("p"),Eo=r("Enable sliced attention computation."),$o=d(),jt=i("p"),ko=r(`When this option is enabled, the attention module will split the input tensor in slices, to compute attention
in several steps. This is useful to save some memory in exchange for a small speed decrease.`),To=d(),ee=i("div"),g(qe.$$.fragment),Co=d(),Fe=i("p"),Lo=r("Disable sliced attention computation. If "),Yt=i("code"),Mo=r("enable_attention_slicing"),Ao=r(` was previously invoked, this method will go
back to computing attention in one step.`),gn=d(),m=i("div"),g(Ue.$$.fragment),Oo=d(),Ve=i("p"),zo=r("Pipeline for text-guided image inpainting using Stable Diffusion. "),Jt=i("em"),No=r("This is an experimental feature"),Go=r("."),qo=d(),We=i("p"),Fo=r("This model inherits from "),Qt=i("code"),Uo=r("DiffusionPipeline"),Vo=r(`. Check the superclass documentation for the generic methods the
library implements for all the pipelines (such as downloading or saving, running on a particular device, etc.)`),Wo=d(),te=i("div"),g(He.$$.fragment),Ho=d(),Xt=i("p"),Ro=r("Function invoked when calling the pipeline for generation."),Bo=d(),z=i("div"),g(Re.$$.fragment),Ko=d(),Zt=i("p"),jo=r("Enable sliced attention computation."),Yo=d(),en=i("p"),Jo=r(`When this option is enabled, the attention module will split the input tensor in slices, to compute attention
in several steps. This is useful to save some memory in exchange for a small speed decrease.`),Qo=d(),ne=i("div"),g(Be.$$.fragment),Xo=d(),Ke=i("p"),Zo=r("Disable sliced attention computation. If "),tn=i("code"),ea=r("enable_attention_slicing"),ta=r(` was previously invoked, this method will go
back to computing attention in one step.`),this.h()},l(n){const f=ks('[data-svelte="svelte-1phssyn"]',document.head);N=o(f,"META",{name:!0,content:!0}),f.forEach(t),on=c(n),G=o(n,"H1",{class:!0});var bn=a(G);H=o(bn,"A",{id:!0,class:!0,href:!0});var la=a(H);ht=o(la,"SPAN",{});var da=a(ht);_(re.$$.fragment,da),da.forEach(t),la.forEach(t),Fn=c(bn),mt=o(bn,"SPAN",{});var ca=a(mt);Un=l(ca,"Stable diffusion pipelines"),ca.forEach(t),bn.forEach(t),an=c(n),q=o(n,"H2",{class:!0});var vn=a(q);R=o(vn,"A",{id:!0,class:!0,href:!0});var fa=a(R);gt=o(fa,"SPAN",{});var pa=a(gt);_(le.$$.fragment,pa),pa.forEach(t),fa.forEach(t),Vn=c(vn),_t=o(vn,"SPAN",{});var ua=a(_t);Wn=l(ua,"Overview"),ua.forEach(t),vn.forEach(t),sn=c(n),y=o(n,"P",{});var I=a(y);Hn=l(I,"Stable Diffusion is a text-to-image "),bt=o(I,"EM",{});var ha=a(bt);Rn=l(ha,"latent diffusion"),ha.forEach(t),Bn=l(I," model created by the researchers and engineers from "),de=o(I,"A",{href:!0,rel:!0});var ma=a(de);Kn=l(ma,"CompVis"),ma.forEach(t),jn=l(I,", "),ce=o(I,"A",{href:!0,rel:!0});var ga=a(ce);Yn=l(ga,"Stability AI"),ga.forEach(t),Jn=l(I," and "),fe=o(I,"A",{href:!0,rel:!0});var _a=a(fe);Qn=l(_a,"LAION"),_a.forEach(t),Xn=l(I,". It\u2019s trained on 512x512 images from a subset of the "),pe=o(I,"A",{href:!0,rel:!0});var ba=a(pe);Zn=l(ba,"LAION-5B"),ba.forEach(t),ei=l(I," dataset. This model uses a frozen CLIP ViT-L/14 text encoder to condition the model on text prompts. With its 860M UNet and 123M text encoder, the model is relatively lightweight and can run on consumer GPUs."),I.forEach(t),rn=c(n),L=o(n,"P",{});var lt=a(L);ti=l(lt,"Latent diffusion is the research on top of which Stable Diffusion was built. It was proposed in "),ue=o(lt,"A",{href:!0,rel:!0});var va=a(ue);ni=l(va,"High-Resolution Image Synthesis with Latent Diffusion Models"),va.forEach(t),ii=l(lt," by Robin Rombach, Andreas Blattmann, Dominik Lorenz, Patrick Esser, Bj\xF6rn Ommer. You can learn more details about it in the "),je=o(lt,"A",{href:!0});var Da=a(je);oi=l(Da,"specific pipeline for latent diffusion"),Da.forEach(t),ai=l(lt," that is part of \u{1F917} Diffusers."),lt.forEach(t),ln=c(n),M=o(n,"P",{});var dt=a(M);si=l(dt,"For more details about how Stable Diffusion works and how it differs from the base latent diffusion model, please refer to the official "),he=o(dt,"A",{href:!0,rel:!0});var wa=a(he);ri=l(wa,"launch announcement post"),wa.forEach(t),li=l(dt," and "),me=o(dt,"A",{href:!0,rel:!0});var ya=a(me);di=l(ya,"this section of our own blog post"),ya.forEach(t),ci=l(dt,"."),dt.forEach(t),dn=c(n),F=o(n,"H2",{class:!0});var Dn=a(F);B=o(Dn,"A",{id:!0,class:!0,href:!0});var Ia=a(B);vt=o(Ia,"SPAN",{});var xa=a(vt);_(ge.$$.fragment,xa),xa.forEach(t),Ia.forEach(t),fi=c(Dn),Dt=o(Dn,"SPAN",{});var Pa=a(Dt);pi=l(Pa,"Tips"),Pa.forEach(t),Dn.forEach(t),cn=c(n),K=o(n,"UL",{});var wn=a(K);Ye=o(wn,"LI",{});var na=a(Ye);ui=l(na,"To tweak your prompts on a specific result you liked, you can generate your own latents, as demonstrated in the following notebook: "),_e=o(na,"A",{href:!0,rel:!0});var Sa=a(_e);Je=o(Sa,"IMG",{src:!0,alt:!0}),Sa.forEach(t),na.forEach(t),hi=c(wn),wt=o(wn,"LI",{});var Ea=a(wt);mi=l(Ea,"TODO: some interesting Tips"),Ea.forEach(t),wn.forEach(t),fn=c(n),U=o(n,"H2",{class:!0});var yn=a(U);j=o(yn,"A",{id:!0,class:!0,href:!0});var $a=a(j);yt=o($a,"SPAN",{});var ka=a(yt);_(be.$$.fragment,ka),ka.forEach(t),$a.forEach(t),gi=c(yn),It=o(yn,"SPAN",{});var Ta=a(It);_i=l(Ta,"Available pipelines"),Ta.forEach(t),yn.forEach(t),pn=c(n),Y=o(n,"TABLE",{});var In=a(Y);xt=o(In,"THEAD",{});var Ca=a(xt);$=o(Ca,"TR",{});var ie=a($);Pt=o(ie,"TH",{});var La=a(Pt);bi=l(La,"Pipeline"),La.forEach(t),vi=c(ie),St=o(ie,"TH",{});var Ma=a(St);Di=l(Ma,"Tasks"),Ma.forEach(t),wi=c(ie),Qe=o(ie,"TH",{align:!0});var Aa=a(Qe);yi=l(Aa,"Colab"),Aa.forEach(t),Ii=c(ie),Xe=o(ie,"TH",{align:!0});var Oa=a(Xe);xi=l(Oa,"Demo"),Oa.forEach(t),ie.forEach(t),Ca.forEach(t),Pi=c(In),V=o(In,"TBODY",{});var ct=a(V);k=o(ct,"TR",{});var oe=a(k);Et=o(oe,"TD",{});var za=a(Et);ve=o(za,"A",{href:!0,rel:!0});var Na=a(ve);Si=l(Na,"pipeline_stable_diffusion.py"),Na.forEach(t),za.forEach(t),Ei=c(oe),$t=o(oe,"TD",{});var Ga=a($t);kt=o(Ga,"EM",{});var qa=a(kt);$i=l(qa,"Text-to-Image Generation"),qa.forEach(t),Ga.forEach(t),ki=c(oe),Ze=o(oe,"TD",{align:!0});var Fa=a(Ze);De=o(Fa,"A",{href:!0,rel:!0});var Ua=a(De);et=o(Ua,"IMG",{src:!0,alt:!0}),Ua.forEach(t),Fa.forEach(t),Ti=c(oe),tt=o(oe,"TD",{align:!0});var Va=a(tt);we=o(Va,"A",{href:!0,rel:!0});var Wa=a(we);Ci=l(Wa,"\u{1F917} Stable Diffusion"),Wa.forEach(t),Va.forEach(t),oe.forEach(t),Li=c(ct),T=o(ct,"TR",{});var ae=a(T);Tt=o(ae,"TD",{});var Ha=a(Tt);ye=o(Ha,"A",{href:!0,rel:!0});var Ra=a(ye);Mi=l(Ra,"pipeline_stable_diffusion_img2img.py"),Ra.forEach(t),Ha.forEach(t),Ai=c(ae),Ct=o(ae,"TD",{});var Ba=a(Ct);Lt=o(Ba,"EM",{});var Ka=a(Lt);Oi=l(Ka,"Image-to-Image Text-Guided Generation"),Ka.forEach(t),Ba.forEach(t),zi=c(ae),nt=o(ae,"TD",{align:!0});var ja=a(nt);Ie=o(ja,"A",{href:!0,rel:!0});var Ya=a(Ie);it=o(Ya,"IMG",{src:!0,alt:!0}),Ya.forEach(t),ja.forEach(t),Ni=c(ae),ot=o(ae,"TD",{align:!0});var Ja=a(ot);xe=o(Ja,"A",{href:!0,rel:!0});var Qa=a(xe);Gi=l(Qa,"\u{1F917} Diffuse the Rest"),Qa.forEach(t),Ja.forEach(t),ae.forEach(t),qi=c(ct),C=o(ct,"TR",{});var se=a(C);Mt=o(se,"TD",{});var Xa=a(Mt);Pe=o(Xa,"A",{href:!0,rel:!0});var Za=a(Pe);Fi=l(Za,"pipeline_stable_diffusion_inpaint.py"),Za.forEach(t),Xa.forEach(t),Ui=c(se),Se=o(se,"TD",{});var xn=a(Se);At=o(xn,"STRONG",{});var es=a(At);Vi=l(es,"Experimental"),es.forEach(t),Wi=l(xn," \u2013 "),Ot=o(xn,"EM",{});var ts=a(Ot);Hi=l(ts,"Text-Guided Image Inpainting"),ts.forEach(t),xn.forEach(t),Ri=c(se),at=o(se,"TD",{align:!0});var ns=a(at);Ee=o(ns,"A",{href:!0,rel:!0});var is=a(Ee);st=o(is,"IMG",{src:!0,alt:!0}),is.forEach(t),ns.forEach(t),Bi=c(se),rt=o(se,"TD",{align:!0});var os=a(rt);Ki=l(os,"Coming soon"),os.forEach(t),se.forEach(t),ct.forEach(t),In.forEach(t),un=c(n),W=o(n,"H2",{class:!0});var Pn=a(W);J=o(Pn,"A",{id:!0,class:!0,href:!0});var as=a(J);zt=o(as,"SPAN",{});var ss=a(zt);_($e.$$.fragment,ss),ss.forEach(t),as.forEach(t),ji=c(Pn),Nt=o(Pn,"SPAN",{});var rs=a(Nt);Yi=l(rs,"API"),rs.forEach(t),Pn.forEach(t),hn=c(n),u=o(n,"DIV",{class:!0});var x=a(u);_(ke.$$.fragment,x),Ji=c(x),Gt=o(x,"P",{});var ls=a(Gt);Qi=l(ls,"Pipeline for text-to-image generation using Stable Diffusion."),ls.forEach(t),Xi=c(x),Te=o(x,"P",{});var Sn=a(Te);Zi=l(Sn,"This model inherits from "),qt=o(Sn,"CODE",{});var ds=a(qt);eo=l(ds,"DiffusionPipeline"),ds.forEach(t),to=l(Sn,`. Check the superclass documentation for the generic methods the
library implements for all the pipelines (such as downloading or saving, running on a particular device, etc.)`),Sn.forEach(t),no=c(x),Q=o(x,"DIV",{class:!0});var En=a(Q);_(Ce.$$.fragment,En),io=c(En),Ft=o(En,"P",{});var cs=a(Ft);oo=l(cs,"Function invoked when calling the pipeline for generation."),cs.forEach(t),En.forEach(t),ao=c(x),A=o(x,"DIV",{class:!0});var ft=a(A);_(Le.$$.fragment,ft),so=c(ft),Ut=o(ft,"P",{});var fs=a(Ut);ro=l(fs,"Enable sliced attention computation."),fs.forEach(t),lo=c(ft),Vt=o(ft,"P",{});var ps=a(Vt);co=l(ps,`When this option is enabled, the attention module will split the input tensor in slices, to compute attention
in several steps. This is useful to save some memory in exchange for a small speed decrease.`),ps.forEach(t),ft.forEach(t),fo=c(x),X=o(x,"DIV",{class:!0});var $n=a(X);_(Me.$$.fragment,$n),po=c($n),Ae=o($n,"P",{});var kn=a(Ae);uo=l(kn,"Disable sliced attention computation. If "),Wt=o(kn,"CODE",{});var us=a(Wt);ho=l(us,"enable_attention_slicing"),us.forEach(t),mo=l(kn,` was previously invoked, this method will go
back to computing attention in one step.`),kn.forEach(t),$n.forEach(t),x.forEach(t),mn=c(n),h=o(n,"DIV",{class:!0});var P=a(h);_(Oe.$$.fragment,P),go=c(P),Ht=o(P,"P",{});var hs=a(Ht);_o=l(hs,"Pipeline for text-guided image to image generation using Stable Diffusion."),hs.forEach(t),bo=c(P),ze=o(P,"P",{});var Tn=a(ze);vo=l(Tn,"This model inherits from "),Rt=o(Tn,"CODE",{});var ms=a(Rt);Do=l(ms,"DiffusionPipeline"),ms.forEach(t),wo=l(Tn,`. Check the superclass documentation for the generic methods the
library implements for all the pipelines (such as downloading or saving, running on a particular device, etc.)`),Tn.forEach(t),yo=c(P),Z=o(P,"DIV",{class:!0});var Cn=a(Z);_(Ne.$$.fragment,Cn),Io=c(Cn),Bt=o(Cn,"P",{});var gs=a(Bt);xo=l(gs,"Function invoked when calling the pipeline for generation."),gs.forEach(t),Cn.forEach(t),Po=c(P),O=o(P,"DIV",{class:!0});var pt=a(O);_(Ge.$$.fragment,pt),So=c(pt),Kt=o(pt,"P",{});var _s=a(Kt);Eo=l(_s,"Enable sliced attention computation."),_s.forEach(t),$o=c(pt),jt=o(pt,"P",{});var bs=a(jt);ko=l(bs,`When this option is enabled, the attention module will split the input tensor in slices, to compute attention
in several steps. This is useful to save some memory in exchange for a small speed decrease.`),bs.forEach(t),pt.forEach(t),To=c(P),ee=o(P,"DIV",{class:!0});var Ln=a(ee);_(qe.$$.fragment,Ln),Co=c(Ln),Fe=o(Ln,"P",{});var Mn=a(Fe);Lo=l(Mn,"Disable sliced attention computation. If "),Yt=o(Mn,"CODE",{});var vs=a(Yt);Mo=l(vs,"enable_attention_slicing"),vs.forEach(t),Ao=l(Mn,` was previously invoked, this method will go
back to computing attention in one step.`),Mn.forEach(t),Ln.forEach(t),P.forEach(t),gn=c(n),m=o(n,"DIV",{class:!0});var S=a(m);_(Ue.$$.fragment,S),Oo=c(S),Ve=o(S,"P",{});var An=a(Ve);zo=l(An,"Pipeline for text-guided image inpainting using Stable Diffusion. "),Jt=o(An,"EM",{});var Ds=a(Jt);No=l(Ds,"This is an experimental feature"),Ds.forEach(t),Go=l(An,"."),An.forEach(t),qo=c(S),We=o(S,"P",{});var On=a(We);Fo=l(On,"This model inherits from "),Qt=o(On,"CODE",{});var ws=a(Qt);Uo=l(ws,"DiffusionPipeline"),ws.forEach(t),Vo=l(On,`. Check the superclass documentation for the generic methods the
library implements for all the pipelines (such as downloading or saving, running on a particular device, etc.)`),On.forEach(t),Wo=c(S),te=o(S,"DIV",{class:!0});var zn=a(te);_(He.$$.fragment,zn),Ho=c(zn),Xt=o(zn,"P",{});var ys=a(Xt);Ro=l(ys,"Function invoked when calling the pipeline for generation."),ys.forEach(t),zn.forEach(t),Bo=c(S),z=o(S,"DIV",{class:!0});var ut=a(z);_(Re.$$.fragment,ut),Ko=c(ut),Zt=o(ut,"P",{});var Is=a(Zt);jo=l(Is,"Enable sliced attention computation."),Is.forEach(t),Yo=c(ut),en=o(ut,"P",{});var xs=a(en);Jo=l(xs,`When this option is enabled, the attention module will split the input tensor in slices, to compute attention
in several steps. This is useful to save some memory in exchange for a small speed decrease.`),xs.forEach(t),ut.forEach(t),Qo=c(S),ne=o(S,"DIV",{class:!0});var Nn=a(ne);_(Be.$$.fragment,Nn),Xo=c(Nn),Ke=o(Nn,"P",{});var Gn=a(Ke);Zo=l(Gn,"Disable sliced attention computation. If "),tn=o(Gn,"CODE",{});var Ps=a(tn);ea=l(Ps,"enable_attention_slicing"),Ps.forEach(t),ta=l(Gn,` was previously invoked, this method will go
back to computing attention in one step.`),Gn.forEach(t),Nn.forEach(t),S.forEach(t),this.h()},h(){s(N,"name","hf:doc:metadata"),s(N,"content",JSON.stringify(Ms)),s(H,"id","stable-diffusion-pipelines"),s(H,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),s(H,"href","#stable-diffusion-pipelines"),s(G,"class","relative group"),s(R,"id","overview"),s(R,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),s(R,"href","#overview"),s(q,"class","relative group"),s(de,"href","https://github.com/CompVis"),s(de,"rel","nofollow"),s(ce,"href","https://stability.ai/"),s(ce,"rel","nofollow"),s(fe,"href","https://laion.ai/"),s(fe,"rel","nofollow"),s(pe,"href","https://laion.ai/blog/laion-5b/"),s(pe,"rel","nofollow"),s(ue,"href","https://arxiv.org/abs/2112.10752"),s(ue,"rel","nofollow"),s(je,"href","pipelines/latent_diffusion"),s(he,"href","https://stability.ai/blog/stable-diffusion-announcement"),s(he,"rel","nofollow"),s(me,"href","https://huggingface.co/blog/stable_diffusion#how-does-stable-diffusion-work"),s(me,"rel","nofollow"),s(B,"id","tips"),s(B,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),s(B,"href","#tips"),s(F,"class","relative group"),qn(Je.src,oa="https://colab.research.google.com/assets/colab-badge.svg")||s(Je,"src",oa),s(Je,"alt","Open In Colab"),s(_e,"href","https://colab.research.google.com/github/pcuenca/diffusers-examples/blob/main/notebooks/stable-diffusion-seeds.ipynb"),s(_e,"rel","nofollow"),s(j,"id","available-pipelines"),s(j,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),s(j,"href","#available-pipelines"),s(U,"class","relative group"),s(Qe,"align","center"),s(Xe,"align","center"),s(ve,"href","https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion.py"),s(ve,"rel","nofollow"),qn(et.src,aa="https://colab.research.google.com/assets/colab-badge.svg")||s(et,"src",aa),s(et,"alt","Open In Colab"),s(De,"href","https://colab.research.google.com/github/huggingface/notebooks/blob/main/diffusers/stable_diffusion.ipynb"),s(De,"rel","nofollow"),s(Ze,"align","center"),s(we,"href","https://huggingface.co/spaces/stabilityai/stable-diffusion"),s(we,"rel","nofollow"),s(tt,"align","center"),s(ye,"href","https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion_img2img.py"),s(ye,"rel","nofollow"),qn(it.src,sa="https://colab.research.google.com/assets/colab-badge.svg")||s(it,"src",sa),s(it,"alt","Open In Colab"),s(Ie,"href","https://colab.research.google.com/github/patil-suraj/Notebooks/blob/master/image_2_image_using_diffusers.ipynb"),s(Ie,"rel","nofollow"),s(nt,"align","center"),s(xe,"href","https://huggingface.co/spaces/huggingface/diffuse-the-rest"),s(xe,"rel","nofollow"),s(ot,"align","center"),s(Pe,"href","https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/pipeline_stable_diffusion_inpaint.py"),s(Pe,"rel","nofollow"),qn(st.src,ra="https://colab.research.google.com/assets/colab-badge.svg")||s(st,"src",ra),s(st,"alt","Open In Colab"),s(Ee,"href","https://colab.research.google.com/github/patil-suraj/Notebooks/blob/master/in_painting_with_stable_diffusion_using_diffusers.ipynb"),s(Ee,"rel","nofollow"),s(at,"align","center"),s(rt,"align","center"),s(J,"id","diffusers.StableDiffusionPipeline"),s(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),s(J,"href","#diffusers.StableDiffusionPipeline"),s(W,"class","relative group"),s(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),s(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),s(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),s(u,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),s(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),s(O,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),s(ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),s(h,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),s(te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),s(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),s(ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),s(m,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(n,f){e(document.head,N),p(n,on,f),p(n,G,f),e(G,H),e(H,ht),b(re,ht,null),e(G,Fn),e(G,mt),e(mt,Un),p(n,an,f),p(n,q,f),e(q,R),e(R,gt),b(le,gt,null),e(q,Vn),e(q,_t),e(_t,Wn),p(n,sn,f),p(n,y,f),e(y,Hn),e(y,bt),e(bt,Rn),e(y,Bn),e(y,de),e(de,Kn),e(y,jn),e(y,ce),e(ce,Yn),e(y,Jn),e(y,fe),e(fe,Qn),e(y,Xn),e(y,pe),e(pe,Zn),e(y,ei),p(n,rn,f),p(n,L,f),e(L,ti),e(L,ue),e(ue,ni),e(L,ii),e(L,je),e(je,oi),e(L,ai),p(n,ln,f),p(n,M,f),e(M,si),e(M,he),e(he,ri),e(M,li),e(M,me),e(me,di),e(M,ci),p(n,dn,f),p(n,F,f),e(F,B),e(B,vt),b(ge,vt,null),e(F,fi),e(F,Dt),e(Dt,pi),p(n,cn,f),p(n,K,f),e(K,Ye),e(Ye,ui),e(Ye,_e),e(_e,Je),e(K,hi),e(K,wt),e(wt,mi),p(n,fn,f),p(n,U,f),e(U,j),e(j,yt),b(be,yt,null),e(U,gi),e(U,It),e(It,_i),p(n,pn,f),p(n,Y,f),e(Y,xt),e(xt,$),e($,Pt),e(Pt,bi),e($,vi),e($,St),e(St,Di),e($,wi),e($,Qe),e(Qe,yi),e($,Ii),e($,Xe),e(Xe,xi),e(Y,Pi),e(Y,V),e(V,k),e(k,Et),e(Et,ve),e(ve,Si),e(k,Ei),e(k,$t),e($t,kt),e(kt,$i),e(k,ki),e(k,Ze),e(Ze,De),e(De,et),e(k,Ti),e(k,tt),e(tt,we),e(we,Ci),e(V,Li),e(V,T),e(T,Tt),e(Tt,ye),e(ye,Mi),e(T,Ai),e(T,Ct),e(Ct,Lt),e(Lt,Oi),e(T,zi),e(T,nt),e(nt,Ie),e(Ie,it),e(T,Ni),e(T,ot),e(ot,xe),e(xe,Gi),e(V,qi),e(V,C),e(C,Mt),e(Mt,Pe),e(Pe,Fi),e(C,Ui),e(C,Se),e(Se,At),e(At,Vi),e(Se,Wi),e(Se,Ot),e(Ot,Hi),e(C,Ri),e(C,at),e(at,Ee),e(Ee,st),e(C,Bi),e(C,rt),e(rt,Ki),p(n,un,f),p(n,W,f),e(W,J),e(J,zt),b($e,zt,null),e(W,ji),e(W,Nt),e(Nt,Yi),p(n,hn,f),p(n,u,f),b(ke,u,null),e(u,Ji),e(u,Gt),e(Gt,Qi),e(u,Xi),e(u,Te),e(Te,Zi),e(Te,qt),e(qt,eo),e(Te,to),e(u,no),e(u,Q),b(Ce,Q,null),e(Q,io),e(Q,Ft),e(Ft,oo),e(u,ao),e(u,A),b(Le,A,null),e(A,so),e(A,Ut),e(Ut,ro),e(A,lo),e(A,Vt),e(Vt,co),e(u,fo),e(u,X),b(Me,X,null),e(X,po),e(X,Ae),e(Ae,uo),e(Ae,Wt),e(Wt,ho),e(Ae,mo),p(n,mn,f),p(n,h,f),b(Oe,h,null),e(h,go),e(h,Ht),e(Ht,_o),e(h,bo),e(h,ze),e(ze,vo),e(ze,Rt),e(Rt,Do),e(ze,wo),e(h,yo),e(h,Z),b(Ne,Z,null),e(Z,Io),e(Z,Bt),e(Bt,xo),e(h,Po),e(h,O),b(Ge,O,null),e(O,So),e(O,Kt),e(Kt,Eo),e(O,$o),e(O,jt),e(jt,ko),e(h,To),e(h,ee),b(qe,ee,null),e(ee,Co),e(ee,Fe),e(Fe,Lo),e(Fe,Yt),e(Yt,Mo),e(Fe,Ao),p(n,gn,f),p(n,m,f),b(Ue,m,null),e(m,Oo),e(m,Ve),e(Ve,zo),e(Ve,Jt),e(Jt,No),e(Ve,Go),e(m,qo),e(m,We),e(We,Fo),e(We,Qt),e(Qt,Uo),e(We,Vo),e(m,Wo),e(m,te),b(He,te,null),e(te,Ho),e(te,Xt),e(Xt,Ro),e(m,Bo),e(m,z),b(Re,z,null),e(z,Ko),e(z,Zt),e(Zt,jo),e(z,Yo),e(z,en),e(en,Jo),e(m,Qo),e(m,ne),b(Be,ne,null),e(ne,Xo),e(ne,Ke),e(Ke,Zo),e(Ke,tn),e(tn,ea),e(Ke,ta),_n=!0},p:Ts,i(n){_n||(v(re.$$.fragment,n),v(le.$$.fragment,n),v(ge.$$.fragment,n),v(be.$$.fragment,n),v($e.$$.fragment,n),v(ke.$$.fragment,n),v(Ce.$$.fragment,n),v(Le.$$.fragment,n),v(Me.$$.fragment,n),v(Oe.$$.fragment,n),v(Ne.$$.fragment,n),v(Ge.$$.fragment,n),v(qe.$$.fragment,n),v(Ue.$$.fragment,n),v(He.$$.fragment,n),v(Re.$$.fragment,n),v(Be.$$.fragment,n),_n=!0)},o(n){D(re.$$.fragment,n),D(le.$$.fragment,n),D(ge.$$.fragment,n),D(be.$$.fragment,n),D($e.$$.fragment,n),D(ke.$$.fragment,n),D(Ce.$$.fragment,n),D(Le.$$.fragment,n),D(Me.$$.fragment,n),D(Oe.$$.fragment,n),D(Ne.$$.fragment,n),D(Ge.$$.fragment,n),D(qe.$$.fragment,n),D(Ue.$$.fragment,n),D(He.$$.fragment,n),D(Re.$$.fragment,n),D(Be.$$.fragment,n),_n=!1},d(n){t(N),n&&t(on),n&&t(G),w(re),n&&t(an),n&&t(q),w(le),n&&t(sn),n&&t(y),n&&t(rn),n&&t(L),n&&t(ln),n&&t(M),n&&t(dn),n&&t(F),w(ge),n&&t(cn),n&&t(K),n&&t(fn),n&&t(U),w(be),n&&t(pn),n&&t(Y),n&&t(un),n&&t(W),w($e),n&&t(hn),n&&t(u),w(ke),w(Ce),w(Le),w(Me),n&&t(mn),n&&t(h),w(Oe),w(Ne),w(Ge),w(qe),n&&t(gn),n&&t(m),w(Ue),w(He),w(Re),w(Be)}}}const Ms={local:"stable-diffusion-pipelines",sections:[{local:"overview",title:"Overview"},{local:"tips",title:"Tips"},{local:"available-pipelines",title:"Available pipelines"},{local:"diffusers.StableDiffusionPipeline",title:"API"}],title:"Stable diffusion pipelines"};function As(ia){return Cs(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Gs extends Ss{constructor(N){super();Es(this,N,As,Ls,$s,{})}}export{Gs as default,Ms as metadata};
