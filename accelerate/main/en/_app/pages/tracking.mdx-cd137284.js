import{S as cs,i as is,s as ps,e as n,k as i,w as m,t as r,M as ds,c as s,d as a,m as p,a as l,x as h,h as o,b as u,F as e,g as d,y as f,L as us,q as g,o as _,B as v,v as ms}from"../chunks/vendor-19e06bd2.js";import{D as b}from"../chunks/Docstring-395e5a9c.js";import{C as Ne}from"../chunks/CodeBlock-9dd1fdfb.js";import{I as Ua}from"../chunks/IconCopyLink-3c713d38.js";function hs(pn){let x,Mt,I,W,tt,te,Ra,at,Ha,Gt,ae,Fa,We,Ja,Ut,P,V,rt,re,Ka,ot,Qa,Rt,M,Xa,nt,Ya,Za,Ht,y,oe,er,O,tr,st,ar,rr,lt,or,nr,sr,G,ne,lr,se,cr,ct,ir,pr,dr,U,le,ur,ce,mr,it,hr,fr,gr,R,ie,_r,pe,vr,pt,yr,kr,Ft,k,de,$r,q,br,dt,wr,Er,ut,Tr,Ar,jr,H,ue,Dr,me,Cr,mt,Lr,xr,Ir,F,he,Pr,fe,Or,ht,qr,Br,Sr,J,ge,zr,_e,Nr,ft,Wr,Vr,Jt,$,ve,Mr,B,Gr,gt,Ur,Rr,_t,Hr,Fr,Jr,vt,Kr,Qr,K,ye,Xr,ke,Yr,yt,Zr,eo,to,Q,$e,ao,be,ro,kt,oo,no,Kt,w,so,$t,lo,co,bt,io,po,Qt,we,Xt,X,uo,Ve,mo,ho,Yt,Ee,Zt,E,fo,Me,go,_o,wt,vo,yo,ea,Te,ta,Y,ko,Ge,$o,bo,aa,Ae,ra,Ue,wo,oa,je,na,S,Z,Et,De,Eo,Tt,To,sa,T,Ao,At,jo,Do,jt,Co,Lo,la,A,Ce,Dt,xo,Io,Le,xe,Po,Ct,Oo,qo,Bo,Ie,So,Lt,zo,No,Wo,Pe,xt,Vo,Mo,It,Oe,Go,Pt,Uo,Ro,Ho,qe,Ot,Fo,Jo,qt,z,Ko,Bt,Qo,Xo,St,Yo,Zo,ca,Re,en,ia,Be,pa,N,ee,zt,Se,tn,Nt,an,da,j,rn,Wt,on,nn,Vt,sn,ln,ua,ze,ma;return te=new Ua({}),re=new Ua({}),oe=new b({props:{name:"class accelerate.tracking.TensorBoardTracker",anchor:"accelerate.tracking.TensorBoardTracker",parameters:[{name:"run_name",val:": str"},{name:"logging_dir",val:": typing.Union[str, os.PathLike, NoneType] = ''"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/tracking.py#L92",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run`,name:"run_name"},{anchor:"accelerate.tracking.TensorBoardTracker.logging_dir",description:`<strong>logging_dir</strong> (<code>str</code>, <code>os.PathLike</code>) &#x2014;
Location for TensorBoard logs to be stored.`,name:"logging_dir"}]}}),ne=new b({props:{name:"finish",anchor:"accelerate.tracking.TensorBoardTracker.finish",parameters:[],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/tracking.py#L143"}}),le=new b({props:{name:"log",anchor:"accelerate.tracking.TensorBoardTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/tracking.py#L125",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.TensorBoardTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),ie=new b({props:{name:"store_init_configuration",anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/tracking.py#L112",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),de=new b({props:{name:"class accelerate.tracking.WandBTracker",anchor:"accelerate.tracking.WandBTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/tracking.py#L151",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),ue=new b({props:{name:"finish",anchor:"accelerate.tracking.WandBTracker.finish",parameters:[],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/tracking.py#L193"}}),he=new b({props:{name:"log",anchor:"accelerate.tracking.WandBTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/tracking.py#L180",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.WandBTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),ge=new b({props:{name:"store_init_configuration",anchor:"accelerate.tracking.WandBTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/tracking.py#L168",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),ve=new b({props:{name:"class accelerate.tracking.CometMLTracker",anchor:"accelerate.tracking.CometMLTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/tracking.py#L201",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),ye=new b({props:{name:"log",anchor:"accelerate.tracking.CometMLTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/tracking.py#L232",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.CometMLTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),$e=new b({props:{name:"store_init_configuration",anchor:"accelerate.tracking.CometMLTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/tracking.py#L220",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),we=new Ne({props:{code:`from accelerate import Accelerate
from accelerate.utils import LoggerType

accelerator = Accelerate(log_with="all")  # For all available trackers in the environment
accelerator = Accelerate(log_with="wandb")
accelerator = Accelerate(log_with=["wandb", LoggerType.TENSORBOARD])`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerate
<span class="hljs-keyword">from</span> accelerate.utils <span class="hljs-keyword">import</span> LoggerType

accelerator = Accelerate(log_with=<span class="hljs-string">&quot;all&quot;</span>)  <span class="hljs-comment"># For all available trackers in the environment</span>
accelerator = Accelerate(log_with=<span class="hljs-string">&quot;wandb&quot;</span>)
accelerator = Accelerate(log_with=[<span class="hljs-string">&quot;wandb&quot;</span>, LoggerType.TENSORBOARD])`}}),Ee=new Ne({props:{code:`hps = {"num_iterations": 5, "learning_rate": 1e-2}
accelerator.init_trackers("my_project", config=hps)`,highlighted:`hps = {<span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>}
accelerator.init_trackers(<span class="hljs-string">&quot;my_project&quot;</span>, config=hps)`}}),Te=new Ne({props:{code:'accelerator.log({"train_loss": 1.12, "valid_loss": 0.8}, step=1)',highlighted:'accelerator.log({<span class="hljs-string">&quot;train_loss&quot;</span>: <span class="hljs-number">1.12</span>, <span class="hljs-string">&quot;valid_loss&quot;</span>: <span class="hljs-number">0.8</span>}, step=<span class="hljs-number">1</span>)'}}),Ae=new Ne({props:{code:"accelerator.end_training()",highlighted:"accelerator.end_training()"}}),je=new Ne({props:{code:`from accelerate import Accelerator

accelerator = Accelerator(log_with="all")
config = {
    "num_iterations": 5,
    "learning_rate": 1e-2,
    "loss_function": str(my_loss_function),
}

accelerator.init_trackers("example_project", config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for step, batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({"training_loss": loss}, step=step)
accelerator.end_training()`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

accelerator = Accelerator(log_with=<span class="hljs-string">&quot;all&quot;</span>)
config = {
    <span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>,
    <span class="hljs-string">&quot;loss_function&quot;</span>: <span class="hljs-built_in">str</span>(my_loss_function),
}

accelerator.init_trackers(<span class="hljs-string">&quot;example_project&quot;</span>, config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

<span class="hljs-keyword">for</span> iteration <span class="hljs-keyword">in</span> config[<span class="hljs-string">&quot;num_iterations&quot;</span>]:
    <span class="hljs-keyword">for</span> step, batch <span class="hljs-keyword">in</span> my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({<span class="hljs-string">&quot;training_loss&quot;</span>: loss}, step=step)
accelerator.end_training()`}}),De=new Ua({}),Be=new Ne({props:{code:`from accelerate.tracking import GeneralTracker
from typing import Optional

import wandb


class WandBTracker(GeneralTracker):
    def __init__(self, run_name: str):
        self.run_name = run_name
        wandb.init(self.run_name)

    def store_init_configuration(self, values: dict):
        wandb.config(values)

    def log(self, values: dict, step: Optional[int] = None):
        wandb.log(values, step=step)`,highlighted:`<span class="hljs-keyword">from</span> accelerate.tracking <span class="hljs-keyword">import</span> GeneralTracker
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>

<span class="hljs-keyword">import</span> wandb


<span class="hljs-keyword">class</span> <span class="hljs-title class_">WandBTracker</span>(<span class="hljs-title class_ inherited__">GeneralTracker</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, run_name: <span class="hljs-built_in">str</span></span>):
        self.run_name = run_name
        wandb.init(self.run_name)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">store_init_configuration</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span></span>):
        wandb.config(values)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span>, step: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span></span>):
        wandb.log(values, step=step)`}}),Se=new Ua({}),ze=new Ne({props:{code:`from accelerate import Accelerator
+ import neptune.new as neptune

accelerator = Accelerator()
+ run = neptune.init(...)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
+       if accelerator.is_main_process:
+           run["logs/training/batch/loss"].log(loss)`,highlighted:`from accelerate import Accelerator
<span class="hljs-addition">+ import neptune.new as neptune</span>

accelerator = Accelerator()
<span class="hljs-addition">+ run = neptune.init(...)</span>

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config[&quot;num_iterations&quot;]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
<span class="hljs-addition">+       if accelerator.is_main_process:</span>
<span class="hljs-addition">+           run[&quot;logs/training/batch/loss&quot;].log(loss)</span>`}}),{c(){x=n("meta"),Mt=i(),I=n("h1"),W=n("a"),tt=n("span"),m(te.$$.fragment),Ra=i(),at=n("span"),Ha=r("Tracking"),Gt=i(),ae=n("p"),Fa=r(`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),We=n("a"),Ja=r("log()"),Ut=i(),P=n("h2"),V=n("a"),rt=n("span"),m(re.$$.fragment),Ka=i(),ot=n("span"),Qa=r("Integrated Trackers"),Rt=i(),M=n("p"),Xa=r("Currently "),nt=n("code"),Ya=r("Accelerate"),Za=r(" supports three trackers out-of-the-box:"),Ht=i(),y=n("div"),m(oe.$$.fragment),er=i(),O=n("p"),tr=r("A "),st=n("code"),ar=r("Tracker"),rr=r(" class that supports "),lt=n("code"),or=r("tensorboard"),nr=r(". Should be initialized at the start of your script."),sr=i(),G=n("div"),m(ne.$$.fragment),lr=i(),se=n("p"),cr=r("Closes "),ct=n("code"),ir=r("TensorBoard"),pr=r(" writer"),dr=i(),U=n("div"),m(le.$$.fragment),ur=i(),ce=n("p"),mr=r("Logs "),it=n("code"),hr=r("values"),fr=r(" to the current run."),gr=i(),R=n("div"),m(ie.$$.fragment),_r=i(),pe=n("p"),vr=r("Logs "),pt=n("code"),yr=r("values"),kr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Ft=i(),k=n("div"),m(de.$$.fragment),$r=i(),q=n("p"),br=r("A "),dt=n("code"),wr=r("Tracker"),Er=r(" class that supports "),ut=n("code"),Tr=r("wandb"),Ar=r(". Should be initialized at the start of your script."),jr=i(),H=n("div"),m(ue.$$.fragment),Dr=i(),me=n("p"),Cr=r("Closes "),mt=n("code"),Lr=r("wandb"),xr=r(" writer"),Ir=i(),F=n("div"),m(he.$$.fragment),Pr=i(),fe=n("p"),Or=r("Logs "),ht=n("code"),qr=r("values"),Br=r(" to the current run."),Sr=i(),J=n("div"),m(ge.$$.fragment),zr=i(),_e=n("p"),Nr=r("Logs "),ft=n("code"),Wr=r("values"),Vr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Jt=i(),$=n("div"),m(ve.$$.fragment),Mr=i(),B=n("p"),Gr=r("A "),gt=n("code"),Ur=r("Tracker"),Rr=r(" class that supports "),_t=n("code"),Hr=r("comet_ml"),Fr=r(". Should be initialized at the start of your script."),Jr=i(),vt=n("p"),Kr=r("API keys must be stored in a Comet config file."),Qr=i(),K=n("div"),m(ye.$$.fragment),Xr=i(),ke=n("p"),Yr=r("Logs "),yt=n("code"),Zr=r("values"),eo=r(" to the current run."),to=i(),Q=n("div"),m($e.$$.fragment),ao=i(),be=n("p"),ro=r("Logs "),kt=n("code"),oo=r("values"),no=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Kt=i(),w=n("p"),so=r("To use any of them, pass in the selected type(s) to the "),$t=n("code"),lo=r("log_with"),co=r(" parameter in "),bt=n("code"),io=r("Accelerate"),po=r(":"),Qt=i(),m(we.$$.fragment),Xt=i(),X=n("p"),uo=r("At the start of your experiment "),Ve=n("a"),mo=r("init_trackers()"),ho=r(" should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),Yt=i(),m(Ee.$$.fragment),Zt=i(),E=n("p"),fo=r("When you are ready to log any data, "),Me=n("a"),go=r("log()"),_o=r(` should be used.
A `),wt=n("code"),vo=r("step"),yo=r(" can also be passed in to correlate the data with a particular step in the training loop."),ea=i(),m(Te.$$.fragment),ta=i(),Y=n("p"),ko=r("Once you\u2019ve finished training, make sure to run "),Ge=n("a"),$o=r("end_training()"),bo=r(" so that all the trackers can run their finish functionalities if they have any."),aa=i(),m(Ae.$$.fragment),ra=i(),Ue=n("p"),wo=r("A full example is below:"),oa=i(),m(je.$$.fragment),na=i(),S=n("h2"),Z=n("a"),Et=n("span"),m(De.$$.fragment),Eo=i(),Tt=n("span"),To=r("Implementing Custom Trackers"),sa=i(),T=n("p"),Ao=r("To implement a new tracker to be used in "),At=n("code"),jo=r("Accelerator"),Do=r(", a new one can be made through implementing the "),jt=n("code"),Co=r("~GeneralTracker"),Lo=r(` class.
Every tracker must implement three functions:`),la=i(),A=n("ul"),Ce=n("li"),Dt=n("code"),xo=r("__init__"),Io=r(": "),Le=n("ul"),xe=n("li"),Po=r("Should store a "),Ct=n("code"),Oo=r("run_name"),qo=r(" and initialize the tracker API of the integrated library."),Bo=i(),Ie=n("li"),So=r("If a tracker stores their data locally (such as TensorBoard), a "),Lt=n("code"),zo=r("logging_dir"),No=r(" parameter can be added."),Wo=i(),Pe=n("li"),xt=n("code"),Vo=r("store_init_configuration"),Mo=r(": "),It=n("ul"),Oe=n("li"),Go=r("Should take in a "),Pt=n("code"),Uo=r("values"),Ro=r(" dictionary and store them as a one-time experiment configuration"),Ho=i(),qe=n("li"),Ot=n("code"),Fo=r("log"),Jo=r(": "),qt=n("ul"),z=n("li"),Ko=r("Should take in a "),Bt=n("code"),Qo=r("values"),Xo=r(" dictionary and a "),St=n("code"),Yo=r("step"),Zo=r(", and should log them to the run"),ca=i(),Re=n("p"),en=r("A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),ia=i(),m(Be.$$.fragment),pa=i(),N=n("h2"),ee=n("a"),zt=n("span"),m(Se.$$.fragment),tn=i(),Nt=n("span"),an=r("When a wrapper cannot work"),da=i(),j=n("p"),rn=r("If a library has an API that does not follow a strict "),Wt=n("code"),on=r(".log"),nn=r(" with an overall dictionary such as Neptune.AI, logging can be done manually under an "),Vt=n("code"),sn=r("if accelerator.is_main_process"),ln=r(" statement:"),ua=i(),m(ze.$$.fragment),this.h()},l(t){const c=ds('[data-svelte="svelte-1phssyn"]',document.head);x=s(c,"META",{name:!0,content:!0}),c.forEach(a),Mt=p(t),I=s(t,"H1",{class:!0});var ha=l(I);W=s(ha,"A",{id:!0,class:!0,href:!0});var dn=l(W);tt=s(dn,"SPAN",{});var un=l(tt);h(te.$$.fragment,un),un.forEach(a),dn.forEach(a),Ra=p(ha),at=s(ha,"SPAN",{});var mn=l(at);Ha=o(mn,"Tracking"),mn.forEach(a),ha.forEach(a),Gt=p(t),ae=s(t,"P",{});var cn=l(ae);Fa=o(cn,`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),We=s(cn,"A",{href:!0});var hn=l(We);Ja=o(hn,"log()"),hn.forEach(a),cn.forEach(a),Ut=p(t),P=s(t,"H2",{class:!0});var fa=l(P);V=s(fa,"A",{id:!0,class:!0,href:!0});var fn=l(V);rt=s(fn,"SPAN",{});var gn=l(rt);h(re.$$.fragment,gn),gn.forEach(a),fn.forEach(a),Ka=p(fa),ot=s(fa,"SPAN",{});var _n=l(ot);Qa=o(_n,"Integrated Trackers"),_n.forEach(a),fa.forEach(a),Rt=p(t),M=s(t,"P",{});var ga=l(M);Xa=o(ga,"Currently "),nt=s(ga,"CODE",{});var vn=l(nt);Ya=o(vn,"Accelerate"),vn.forEach(a),Za=o(ga," supports three trackers out-of-the-box:"),ga.forEach(a),Ht=p(t),y=s(t,"DIV",{class:!0});var D=l(y);h(oe.$$.fragment,D),er=p(D),O=s(D,"P",{});var He=l(O);tr=o(He,"A "),st=s(He,"CODE",{});var yn=l(st);ar=o(yn,"Tracker"),yn.forEach(a),rr=o(He," class that supports "),lt=s(He,"CODE",{});var kn=l(lt);or=o(kn,"tensorboard"),kn.forEach(a),nr=o(He,". Should be initialized at the start of your script."),He.forEach(a),sr=p(D),G=s(D,"DIV",{class:!0});var _a=l(G);h(ne.$$.fragment,_a),lr=p(_a),se=s(_a,"P",{});var va=l(se);cr=o(va,"Closes "),ct=s(va,"CODE",{});var $n=l(ct);ir=o($n,"TensorBoard"),$n.forEach(a),pr=o(va," writer"),va.forEach(a),_a.forEach(a),dr=p(D),U=s(D,"DIV",{class:!0});var ya=l(U);h(le.$$.fragment,ya),ur=p(ya),ce=s(ya,"P",{});var ka=l(ce);mr=o(ka,"Logs "),it=s(ka,"CODE",{});var bn=l(it);hr=o(bn,"values"),bn.forEach(a),fr=o(ka," to the current run."),ka.forEach(a),ya.forEach(a),gr=p(D),R=s(D,"DIV",{class:!0});var $a=l(R);h(ie.$$.fragment,$a),_r=p($a),pe=s($a,"P",{});var ba=l(pe);vr=o(ba,"Logs "),pt=s(ba,"CODE",{});var wn=l(pt);yr=o(wn,"values"),wn.forEach(a),kr=o(ba," as hyperparameters for the run. Should be run at the beginning of your experiment."),ba.forEach(a),$a.forEach(a),D.forEach(a),Ft=p(t),k=s(t,"DIV",{class:!0});var C=l(k);h(de.$$.fragment,C),$r=p(C),q=s(C,"P",{});var Fe=l(q);br=o(Fe,"A "),dt=s(Fe,"CODE",{});var En=l(dt);wr=o(En,"Tracker"),En.forEach(a),Er=o(Fe," class that supports "),ut=s(Fe,"CODE",{});var Tn=l(ut);Tr=o(Tn,"wandb"),Tn.forEach(a),Ar=o(Fe,". Should be initialized at the start of your script."),Fe.forEach(a),jr=p(C),H=s(C,"DIV",{class:!0});var wa=l(H);h(ue.$$.fragment,wa),Dr=p(wa),me=s(wa,"P",{});var Ea=l(me);Cr=o(Ea,"Closes "),mt=s(Ea,"CODE",{});var An=l(mt);Lr=o(An,"wandb"),An.forEach(a),xr=o(Ea," writer"),Ea.forEach(a),wa.forEach(a),Ir=p(C),F=s(C,"DIV",{class:!0});var Ta=l(F);h(he.$$.fragment,Ta),Pr=p(Ta),fe=s(Ta,"P",{});var Aa=l(fe);Or=o(Aa,"Logs "),ht=s(Aa,"CODE",{});var jn=l(ht);qr=o(jn,"values"),jn.forEach(a),Br=o(Aa," to the current run."),Aa.forEach(a),Ta.forEach(a),Sr=p(C),J=s(C,"DIV",{class:!0});var ja=l(J);h(ge.$$.fragment,ja),zr=p(ja),_e=s(ja,"P",{});var Da=l(_e);Nr=o(Da,"Logs "),ft=s(Da,"CODE",{});var Dn=l(ft);Wr=o(Dn,"values"),Dn.forEach(a),Vr=o(Da," as hyperparameters for the run. Should be run at the beginning of your experiment."),Da.forEach(a),ja.forEach(a),C.forEach(a),Jt=p(t),$=s(t,"DIV",{class:!0});var L=l($);h(ve.$$.fragment,L),Mr=p(L),B=s(L,"P",{});var Je=l(B);Gr=o(Je,"A "),gt=s(Je,"CODE",{});var Cn=l(gt);Ur=o(Cn,"Tracker"),Cn.forEach(a),Rr=o(Je," class that supports "),_t=s(Je,"CODE",{});var Ln=l(_t);Hr=o(Ln,"comet_ml"),Ln.forEach(a),Fr=o(Je,". Should be initialized at the start of your script."),Je.forEach(a),Jr=p(L),vt=s(L,"P",{});var xn=l(vt);Kr=o(xn,"API keys must be stored in a Comet config file."),xn.forEach(a),Qr=p(L),K=s(L,"DIV",{class:!0});var Ca=l(K);h(ye.$$.fragment,Ca),Xr=p(Ca),ke=s(Ca,"P",{});var La=l(ke);Yr=o(La,"Logs "),yt=s(La,"CODE",{});var In=l(yt);Zr=o(In,"values"),In.forEach(a),eo=o(La," to the current run."),La.forEach(a),Ca.forEach(a),to=p(L),Q=s(L,"DIV",{class:!0});var xa=l(Q);h($e.$$.fragment,xa),ao=p(xa),be=s(xa,"P",{});var Ia=l(be);ro=o(Ia,"Logs "),kt=s(Ia,"CODE",{});var Pn=l(kt);oo=o(Pn,"values"),Pn.forEach(a),no=o(Ia," as hyperparameters for the run. Should be run at the beginning of your experiment."),Ia.forEach(a),xa.forEach(a),L.forEach(a),Kt=p(t),w=s(t,"P",{});var Ke=l(w);so=o(Ke,"To use any of them, pass in the selected type(s) to the "),$t=s(Ke,"CODE",{});var On=l($t);lo=o(On,"log_with"),On.forEach(a),co=o(Ke," parameter in "),bt=s(Ke,"CODE",{});var qn=l(bt);io=o(qn,"Accelerate"),qn.forEach(a),po=o(Ke,":"),Ke.forEach(a),Qt=p(t),h(we.$$.fragment,t),Xt=p(t),X=s(t,"P",{});var Pa=l(X);uo=o(Pa,"At the start of your experiment "),Ve=s(Pa,"A",{href:!0});var Bn=l(Ve);mo=o(Bn,"init_trackers()"),Bn.forEach(a),ho=o(Pa," should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),Pa.forEach(a),Yt=p(t),h(Ee.$$.fragment,t),Zt=p(t),E=s(t,"P",{});var Qe=l(E);fo=o(Qe,"When you are ready to log any data, "),Me=s(Qe,"A",{href:!0});var Sn=l(Me);go=o(Sn,"log()"),Sn.forEach(a),_o=o(Qe,` should be used.
A `),wt=s(Qe,"CODE",{});var zn=l(wt);vo=o(zn,"step"),zn.forEach(a),yo=o(Qe," can also be passed in to correlate the data with a particular step in the training loop."),Qe.forEach(a),ea=p(t),h(Te.$$.fragment,t),ta=p(t),Y=s(t,"P",{});var Oa=l(Y);ko=o(Oa,"Once you\u2019ve finished training, make sure to run "),Ge=s(Oa,"A",{href:!0});var Nn=l(Ge);$o=o(Nn,"end_training()"),Nn.forEach(a),bo=o(Oa," so that all the trackers can run their finish functionalities if they have any."),Oa.forEach(a),aa=p(t),h(Ae.$$.fragment,t),ra=p(t),Ue=s(t,"P",{});var Wn=l(Ue);wo=o(Wn,"A full example is below:"),Wn.forEach(a),oa=p(t),h(je.$$.fragment,t),na=p(t),S=s(t,"H2",{class:!0});var qa=l(S);Z=s(qa,"A",{id:!0,class:!0,href:!0});var Vn=l(Z);Et=s(Vn,"SPAN",{});var Mn=l(Et);h(De.$$.fragment,Mn),Mn.forEach(a),Vn.forEach(a),Eo=p(qa),Tt=s(qa,"SPAN",{});var Gn=l(Tt);To=o(Gn,"Implementing Custom Trackers"),Gn.forEach(a),qa.forEach(a),sa=p(t),T=s(t,"P",{});var Xe=l(T);Ao=o(Xe,"To implement a new tracker to be used in "),At=s(Xe,"CODE",{});var Un=l(At);jo=o(Un,"Accelerator"),Un.forEach(a),Do=o(Xe,", a new one can be made through implementing the "),jt=s(Xe,"CODE",{});var Rn=l(jt);Co=o(Rn,"~GeneralTracker"),Rn.forEach(a),Lo=o(Xe,` class.
Every tracker must implement three functions:`),Xe.forEach(a),la=p(t),A=s(t,"UL",{});var Ye=l(A);Ce=s(Ye,"LI",{});var Ba=l(Ce);Dt=s(Ba,"CODE",{});var Hn=l(Dt);xo=o(Hn,"__init__"),Hn.forEach(a),Io=o(Ba,": "),Le=s(Ba,"UL",{});var Sa=l(Le);xe=s(Sa,"LI",{});var za=l(xe);Po=o(za,"Should store a "),Ct=s(za,"CODE",{});var Fn=l(Ct);Oo=o(Fn,"run_name"),Fn.forEach(a),qo=o(za," and initialize the tracker API of the integrated library."),za.forEach(a),Bo=p(Sa),Ie=s(Sa,"LI",{});var Na=l(Ie);So=o(Na,"If a tracker stores their data locally (such as TensorBoard), a "),Lt=s(Na,"CODE",{});var Jn=l(Lt);zo=o(Jn,"logging_dir"),Jn.forEach(a),No=o(Na," parameter can be added."),Na.forEach(a),Sa.forEach(a),Ba.forEach(a),Wo=p(Ye),Pe=s(Ye,"LI",{});var Wa=l(Pe);xt=s(Wa,"CODE",{});var Kn=l(xt);Vo=o(Kn,"store_init_configuration"),Kn.forEach(a),Mo=o(Wa,": "),It=s(Wa,"UL",{});var Qn=l(It);Oe=s(Qn,"LI",{});var Va=l(Oe);Go=o(Va,"Should take in a "),Pt=s(Va,"CODE",{});var Xn=l(Pt);Uo=o(Xn,"values"),Xn.forEach(a),Ro=o(Va," dictionary and store them as a one-time experiment configuration"),Va.forEach(a),Qn.forEach(a),Wa.forEach(a),Ho=p(Ye),qe=s(Ye,"LI",{});var Ma=l(qe);Ot=s(Ma,"CODE",{});var Yn=l(Ot);Fo=o(Yn,"log"),Yn.forEach(a),Jo=o(Ma,": "),qt=s(Ma,"UL",{});var Zn=l(qt);z=s(Zn,"LI",{});var Ze=l(z);Ko=o(Ze,"Should take in a "),Bt=s(Ze,"CODE",{});var es=l(Bt);Qo=o(es,"values"),es.forEach(a),Xo=o(Ze," dictionary and a "),St=s(Ze,"CODE",{});var ts=l(St);Yo=o(ts,"step"),ts.forEach(a),Zo=o(Ze,", and should log them to the run"),Ze.forEach(a),Zn.forEach(a),Ma.forEach(a),Ye.forEach(a),ca=p(t),Re=s(t,"P",{});var as=l(Re);en=o(as,"A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),as.forEach(a),ia=p(t),h(Be.$$.fragment,t),pa=p(t),N=s(t,"H2",{class:!0});var Ga=l(N);ee=s(Ga,"A",{id:!0,class:!0,href:!0});var rs=l(ee);zt=s(rs,"SPAN",{});var os=l(zt);h(Se.$$.fragment,os),os.forEach(a),rs.forEach(a),tn=p(Ga),Nt=s(Ga,"SPAN",{});var ns=l(Nt);an=o(ns,"When a wrapper cannot work"),ns.forEach(a),Ga.forEach(a),da=p(t),j=s(t,"P",{});var et=l(j);rn=o(et,"If a library has an API that does not follow a strict "),Wt=s(et,"CODE",{});var ss=l(Wt);on=o(ss,".log"),ss.forEach(a),nn=o(et," with an overall dictionary such as Neptune.AI, logging can be done manually under an "),Vt=s(et,"CODE",{});var ls=l(Vt);sn=o(ls,"if accelerator.is_main_process"),ls.forEach(a),ln=o(et," statement:"),et.forEach(a),ua=p(t),h(ze.$$.fragment,t),this.h()},h(){u(x,"name","hf:doc:metadata"),u(x,"content",JSON.stringify(fs)),u(W,"id","tracking"),u(W,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(W,"href","#tracking"),u(I,"class","relative group"),u(We,"href","/docs/accelerate/main/en/accelerator#accelerate.Accelerator.log"),u(V,"id","accelerate.tracking.TensorBoardTracker"),u(V,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(V,"href","#accelerate.tracking.TensorBoardTracker"),u(P,"class","relative group"),u(G,"class","docstring"),u(U,"class","docstring"),u(R,"class","docstring"),u(y,"class","docstring"),u(H,"class","docstring"),u(F,"class","docstring"),u(J,"class","docstring"),u(k,"class","docstring"),u(K,"class","docstring"),u(Q,"class","docstring"),u($,"class","docstring"),u(Ve,"href","/docs/accelerate/main/en/accelerator#accelerate.Accelerator.init_trackers"),u(Me,"href","/docs/accelerate/main/en/accelerator#accelerate.Accelerator.log"),u(Ge,"href","/docs/accelerate/main/en/accelerator#accelerate.Accelerator.end_training"),u(Z,"id","implementing-custom-trackers"),u(Z,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Z,"href","#implementing-custom-trackers"),u(S,"class","relative group"),u(ee,"id","when-a-wrapper-cannot-work"),u(ee,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(ee,"href","#when-a-wrapper-cannot-work"),u(N,"class","relative group")},m(t,c){e(document.head,x),d(t,Mt,c),d(t,I,c),e(I,W),e(W,tt),f(te,tt,null),e(I,Ra),e(I,at),e(at,Ha),d(t,Gt,c),d(t,ae,c),e(ae,Fa),e(ae,We),e(We,Ja),d(t,Ut,c),d(t,P,c),e(P,V),e(V,rt),f(re,rt,null),e(P,Ka),e(P,ot),e(ot,Qa),d(t,Rt,c),d(t,M,c),e(M,Xa),e(M,nt),e(nt,Ya),e(M,Za),d(t,Ht,c),d(t,y,c),f(oe,y,null),e(y,er),e(y,O),e(O,tr),e(O,st),e(st,ar),e(O,rr),e(O,lt),e(lt,or),e(O,nr),e(y,sr),e(y,G),f(ne,G,null),e(G,lr),e(G,se),e(se,cr),e(se,ct),e(ct,ir),e(se,pr),e(y,dr),e(y,U),f(le,U,null),e(U,ur),e(U,ce),e(ce,mr),e(ce,it),e(it,hr),e(ce,fr),e(y,gr),e(y,R),f(ie,R,null),e(R,_r),e(R,pe),e(pe,vr),e(pe,pt),e(pt,yr),e(pe,kr),d(t,Ft,c),d(t,k,c),f(de,k,null),e(k,$r),e(k,q),e(q,br),e(q,dt),e(dt,wr),e(q,Er),e(q,ut),e(ut,Tr),e(q,Ar),e(k,jr),e(k,H),f(ue,H,null),e(H,Dr),e(H,me),e(me,Cr),e(me,mt),e(mt,Lr),e(me,xr),e(k,Ir),e(k,F),f(he,F,null),e(F,Pr),e(F,fe),e(fe,Or),e(fe,ht),e(ht,qr),e(fe,Br),e(k,Sr),e(k,J),f(ge,J,null),e(J,zr),e(J,_e),e(_e,Nr),e(_e,ft),e(ft,Wr),e(_e,Vr),d(t,Jt,c),d(t,$,c),f(ve,$,null),e($,Mr),e($,B),e(B,Gr),e(B,gt),e(gt,Ur),e(B,Rr),e(B,_t),e(_t,Hr),e(B,Fr),e($,Jr),e($,vt),e(vt,Kr),e($,Qr),e($,K),f(ye,K,null),e(K,Xr),e(K,ke),e(ke,Yr),e(ke,yt),e(yt,Zr),e(ke,eo),e($,to),e($,Q),f($e,Q,null),e(Q,ao),e(Q,be),e(be,ro),e(be,kt),e(kt,oo),e(be,no),d(t,Kt,c),d(t,w,c),e(w,so),e(w,$t),e($t,lo),e(w,co),e(w,bt),e(bt,io),e(w,po),d(t,Qt,c),f(we,t,c),d(t,Xt,c),d(t,X,c),e(X,uo),e(X,Ve),e(Ve,mo),e(X,ho),d(t,Yt,c),f(Ee,t,c),d(t,Zt,c),d(t,E,c),e(E,fo),e(E,Me),e(Me,go),e(E,_o),e(E,wt),e(wt,vo),e(E,yo),d(t,ea,c),f(Te,t,c),d(t,ta,c),d(t,Y,c),e(Y,ko),e(Y,Ge),e(Ge,$o),e(Y,bo),d(t,aa,c),f(Ae,t,c),d(t,ra,c),d(t,Ue,c),e(Ue,wo),d(t,oa,c),f(je,t,c),d(t,na,c),d(t,S,c),e(S,Z),e(Z,Et),f(De,Et,null),e(S,Eo),e(S,Tt),e(Tt,To),d(t,sa,c),d(t,T,c),e(T,Ao),e(T,At),e(At,jo),e(T,Do),e(T,jt),e(jt,Co),e(T,Lo),d(t,la,c),d(t,A,c),e(A,Ce),e(Ce,Dt),e(Dt,xo),e(Ce,Io),e(Ce,Le),e(Le,xe),e(xe,Po),e(xe,Ct),e(Ct,Oo),e(xe,qo),e(Le,Bo),e(Le,Ie),e(Ie,So),e(Ie,Lt),e(Lt,zo),e(Ie,No),e(A,Wo),e(A,Pe),e(Pe,xt),e(xt,Vo),e(Pe,Mo),e(Pe,It),e(It,Oe),e(Oe,Go),e(Oe,Pt),e(Pt,Uo),e(Oe,Ro),e(A,Ho),e(A,qe),e(qe,Ot),e(Ot,Fo),e(qe,Jo),e(qe,qt),e(qt,z),e(z,Ko),e(z,Bt),e(Bt,Qo),e(z,Xo),e(z,St),e(St,Yo),e(z,Zo),d(t,ca,c),d(t,Re,c),e(Re,en),d(t,ia,c),f(Be,t,c),d(t,pa,c),d(t,N,c),e(N,ee),e(ee,zt),f(Se,zt,null),e(N,tn),e(N,Nt),e(Nt,an),d(t,da,c),d(t,j,c),e(j,rn),e(j,Wt),e(Wt,on),e(j,nn),e(j,Vt),e(Vt,sn),e(j,ln),d(t,ua,c),f(ze,t,c),ma=!0},p:us,i(t){ma||(g(te.$$.fragment,t),g(re.$$.fragment,t),g(oe.$$.fragment,t),g(ne.$$.fragment,t),g(le.$$.fragment,t),g(ie.$$.fragment,t),g(de.$$.fragment,t),g(ue.$$.fragment,t),g(he.$$.fragment,t),g(ge.$$.fragment,t),g(ve.$$.fragment,t),g(ye.$$.fragment,t),g($e.$$.fragment,t),g(we.$$.fragment,t),g(Ee.$$.fragment,t),g(Te.$$.fragment,t),g(Ae.$$.fragment,t),g(je.$$.fragment,t),g(De.$$.fragment,t),g(Be.$$.fragment,t),g(Se.$$.fragment,t),g(ze.$$.fragment,t),ma=!0)},o(t){_(te.$$.fragment,t),_(re.$$.fragment,t),_(oe.$$.fragment,t),_(ne.$$.fragment,t),_(le.$$.fragment,t),_(ie.$$.fragment,t),_(de.$$.fragment,t),_(ue.$$.fragment,t),_(he.$$.fragment,t),_(ge.$$.fragment,t),_(ve.$$.fragment,t),_(ye.$$.fragment,t),_($e.$$.fragment,t),_(we.$$.fragment,t),_(Ee.$$.fragment,t),_(Te.$$.fragment,t),_(Ae.$$.fragment,t),_(je.$$.fragment,t),_(De.$$.fragment,t),_(Be.$$.fragment,t),_(Se.$$.fragment,t),_(ze.$$.fragment,t),ma=!1},d(t){a(x),t&&a(Mt),t&&a(I),v(te),t&&a(Gt),t&&a(ae),t&&a(Ut),t&&a(P),v(re),t&&a(Rt),t&&a(M),t&&a(Ht),t&&a(y),v(oe),v(ne),v(le),v(ie),t&&a(Ft),t&&a(k),v(de),v(ue),v(he),v(ge),t&&a(Jt),t&&a($),v(ve),v(ye),v($e),t&&a(Kt),t&&a(w),t&&a(Qt),v(we,t),t&&a(Xt),t&&a(X),t&&a(Yt),v(Ee,t),t&&a(Zt),t&&a(E),t&&a(ea),v(Te,t),t&&a(ta),t&&a(Y),t&&a(aa),v(Ae,t),t&&a(ra),t&&a(Ue),t&&a(oa),v(je,t),t&&a(na),t&&a(S),v(De),t&&a(sa),t&&a(T),t&&a(la),t&&a(A),t&&a(ca),t&&a(Re),t&&a(ia),v(Be,t),t&&a(pa),t&&a(N),v(Se),t&&a(da),t&&a(j),t&&a(ua),v(ze,t)}}}const fs={local:"tracking",sections:[{local:"accelerate.tracking.TensorBoardTracker",title:"Integrated Trackers"},{local:"implementing-custom-trackers",title:"Implementing Custom Trackers"},{local:"when-a-wrapper-cannot-work",title:"When a wrapper cannot work"}],title:"Tracking"};function gs(pn){return ms(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class $s extends cs{constructor(x){super();is(this,x,gs,hs,ps,{})}}export{$s as default,fs as metadata};
