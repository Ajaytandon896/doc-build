import{S as De,i as Pe,s as Ce,e as a,k as d,w as M,t as s,M as Oe,c as n,d as r,m as u,a as o,x as S,h as l,b as c,G as t,g,y as j,L as Ae,q as U,o as W,B,v as ze}from"../chunks/vendor-hf-doc-builder.js";import{D as ve}from"../chunks/Docstring-hf-doc-builder.js";import{C as qe}from"../chunks/CodeBlock-hf-doc-builder.js";import{I as Le}from"../chunks/IconCopyLink-hf-doc-builder.js";function Me(ye){let h,V,f,_,P,b,ee,C,te,F,v,re,O,ae,ne,R,p,oe,A,ie,se,$,z,le,me,G,k,H,m,I,ce,y,w,pe,E,de,q,ue,he,fe,T,N,ge,L,_e,J;return b=new Le({}),k=new qe({props:{code:`-from transformers import Trainer
+from optimum.intel.neural_compressor import IncTrainer

-trainer = Trainer(
+trainer = IncTrainer(
    model=model,
    args=training_args,
    train_dataset=train_dataset,
    eval_dataset=eval_dataset,
    compute_metrics=compute_metrics,
    tokenizer=tokenizer,
    data_collator=data_collator,
)`,highlighted:`<span class="hljs-deletion">-from transformers import Trainer</span>
<span class="hljs-addition">+from optimum.intel.neural_compressor import IncTrainer</span>

<span class="hljs-deletion">-trainer = Trainer(</span>
<span class="hljs-addition">+trainer = IncTrainer(</span>
    model=model,
    args=training_args,
    train_dataset=train_dataset,
    eval_dataset=eval_dataset,
    compute_metrics=compute_metrics,
    tokenizer=tokenizer,
    data_collator=data_collator,
)`}}),I=new ve({props:{name:"class optimum.IncTrainer",anchor:"optimum.IncTrainer",parameters:[{name:"model",val:": Module = None"},{name:"args",val:": TrainingArguments = None"},{name:"data_collator",val:": typing.Optional[DataCollator] = None"},{name:"train_dataset",val:": typing.Optional[torch.utils.data.dataset.Dataset] = None"},{name:"eval_dataset",val:": typing.Optional[torch.utils.data.dataset.Dataset] = None"},{name:"tokenizer",val:": typing.Optional[transformers.tokenization_utils_base.PreTrainedTokenizerBase] = None"},{name:"model_init",val:": Callable = None"},{name:"compute_metrics",val:": typing.Union[typing.Callable[[transformers.trainer_utils.EvalPrediction], typing.Dict], NoneType] = None"},{name:"callbacks",val:": typing.Optional[typing.List[transformers.trainer_callback.TrainerCallback]] = None"},{name:"optimizers",val:": Tuple = (None, None)"},{name:"preprocess_logits_for_metrics",val:": Callable = None"}],source:"https://github.com/huggingface/optimum.intel/blob/main/src/optimum/intel/neural_compressor/trainer.py#L66"}}),w=new ve({props:{name:"save_model",anchor:"optimum.IncTrainer.save_model",parameters:[{name:"output_dir",val:": typing.Optional[str] = None"},{name:"_internal_call",val:": bool = False"}],source:"https://github.com/huggingface/optimum.intel/blob/main/src/optimum/intel/neural_compressor/trainer.py#L471"}}),N=new ve({props:{name:"train",anchor:"optimum.IncTrainer.train",parameters:[{name:"pruner",val:": typing.Optional[neural_compressor.experimental.pruning.Pruning] = None"},{name:"resume_from_checkpoint",val:": typing.Union[bool, str, NoneType] = None"},{name:"trial",val:": typing.Union[_ForwardRef('optuna.Trial'), typing.Dict[str, typing.Any]] = None"},{name:"ignore_keys_for_eval",val:": typing.Optional[typing.List[str]] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.IncTrainer.train.pruner",description:`<strong>pruner</strong> (<em>Pruning</em>, <em>optional</em>) &#x2014;
Pruning object handling the pruning process.`,name:"pruner"},{anchor:"optimum.IncTrainer.train.resume_from_checkpoint",description:`<strong>resume_from_checkpoint</strong> (<em>str</em> or <em>bool</em>, <em>optional</em>) &#x2014;
If a <em>str</em>, local path to a saved checkpoint as saved by a previous instance of
<code>Trainer</code>. If a <em>bool</em> and equals <em>True</em>, load the last checkpoint in
<em>args.output_dir</em> as saved by a previous instance of <code>Trainer</code>. If present,
training will resume from the model/optimizer/scheduler states loaded here.`,name:"resume_from_checkpoint"},{anchor:"optimum.IncTrainer.train.trial",description:`<strong>trial</strong> (<em>optuna.Trial</em> or <em>Dict[str, Any]</em>, <em>optional</em>) &#x2014;
The trial run or the hyperparameter dictionary for hyperparameter search.`,name:"trial"},{anchor:"optimum.IncTrainer.train.ignore_keys_for_eval",description:`<strong>ignore_keys_for_eval</strong> (<em>List[str]</em>, <em>optional</em>) &#x2014;
A list of keys in the output of your model (if it is a dictionary) that should be ignored when
gathering predictions for evaluation during the training.
kwargs &#x2014;
Additional keyword arguments used to hide deprecated arguments`,name:"ignore_keys_for_eval"}],source:"https://github.com/huggingface/optimum.intel/blob/main/src/optimum/intel/neural_compressor/trainer.py#L67"}}),{c(){h=a("meta"),V=d(),f=a("h1"),_=a("a"),P=a("span"),M(b.$$.fragment),ee=d(),C=a("span"),te=s("IncTrainer"),F=d(),v=a("p"),re=s("The "),O=a("code"),ae=s("IncTrainer"),ne=s(" class provides an API to apply compression techniques such as knowledge distillation, pruning and quantization while training the model."),R=d(),p=a("p"),oe=s("Those compression techniques can be combined easily with our "),A=a("code"),ie=s("IncTrainer"),se=s(" which possess a similar behavior than the "),$=a("a"),z=a("code"),le=s("Trainer"),me=s(" of Transformers:"),G=d(),M(k.$$.fragment),H=d(),m=a("div"),M(I.$$.fragment),ce=d(),y=a("div"),M(w.$$.fragment),pe=d(),E=a("p"),de=s("Will save the model, so you can reload it using "),q=a("code"),ue=s("from_pretrained()"),he=s(`.
Will only save from the main process.`),fe=d(),T=a("div"),M(N.$$.fragment),ge=d(),L=a("p"),_e=s("Main training entry point."),this.h()},l(e){const i=Oe('[data-svelte="svelte-1phssyn"]',document.head);h=n(i,"META",{name:!0,content:!0}),i.forEach(r),V=u(e),f=n(e,"H1",{class:!0});var K=o(f);_=n(K,"A",{id:!0,class:!0,href:!0});var Te=o(_);P=n(Te,"SPAN",{});var be=o(P);S(b.$$.fragment,be),be.forEach(r),Te.forEach(r),ee=u(K),C=n(K,"SPAN",{});var $e=o(C);te=l($e,"IncTrainer"),$e.forEach(r),K.forEach(r),F=u(e),v=n(e,"P",{});var Q=o(v);re=l(Q,"The "),O=n(Q,"CODE",{});var ke=o(O);ae=l(ke,"IncTrainer"),ke.forEach(r),ne=l(Q," class provides an API to apply compression techniques such as knowledge distillation, pruning and quantization while training the model."),Q.forEach(r),R=u(e),p=n(e,"P",{});var x=o(p);oe=l(x,"Those compression techniques can be combined easily with our "),A=n(x,"CODE",{});var Ie=o(A);ie=l(Ie,"IncTrainer"),Ie.forEach(r),se=l(x," which possess a similar behavior than the "),$=n(x,"A",{href:!0,rel:!0});var we=o($);z=n(we,"CODE",{});var Ee=o(z);le=l(Ee,"Trainer"),Ee.forEach(r),we.forEach(r),me=l(x," of Transformers:"),x.forEach(r),G=u(e),S(k.$$.fragment,e),H=u(e),m=n(e,"DIV",{class:!0});var D=o(m);S(I.$$.fragment,D),ce=u(D),y=n(D,"DIV",{class:!0});var X=o(y);S(w.$$.fragment,X),pe=u(X),E=n(X,"P",{});var Y=o(E);de=l(Y,"Will save the model, so you can reload it using "),q=n(Y,"CODE",{});var Ne=o(q);ue=l(Ne,"from_pretrained()"),Ne.forEach(r),he=l(Y,`.
Will only save from the main process.`),Y.forEach(r),X.forEach(r),fe=u(D),T=n(D,"DIV",{class:!0});var Z=o(T);S(N.$$.fragment,Z),ge=u(Z),L=n(Z,"P",{});var xe=o(L);_e=l(xe,"Main training entry point."),xe.forEach(r),Z.forEach(r),D.forEach(r),this.h()},h(){c(h,"name","hf:doc:metadata"),c(h,"content",JSON.stringify(Se)),c(_,"id","optimum.IncTrainer"),c(_,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(_,"href","#optimum.IncTrainer"),c(f,"class","relative group"),c($,"href","https://huggingface.co/docs/transformers/main/en/main_classes/trainer#trainer"),c($,"rel","nofollow"),c(y,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(T,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(m,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(e,i){t(document.head,h),g(e,V,i),g(e,f,i),t(f,_),t(_,P),j(b,P,null),t(f,ee),t(f,C),t(C,te),g(e,F,i),g(e,v,i),t(v,re),t(v,O),t(O,ae),t(v,ne),g(e,R,i),g(e,p,i),t(p,oe),t(p,A),t(A,ie),t(p,se),t(p,$),t($,z),t(z,le),t(p,me),g(e,G,i),j(k,e,i),g(e,H,i),g(e,m,i),j(I,m,null),t(m,ce),t(m,y),j(w,y,null),t(y,pe),t(y,E),t(E,de),t(E,q),t(q,ue),t(E,he),t(m,fe),t(m,T),j(N,T,null),t(T,ge),t(T,L),t(L,_e),J=!0},p:Ae,i(e){J||(U(b.$$.fragment,e),U(k.$$.fragment,e),U(I.$$.fragment,e),U(w.$$.fragment,e),U(N.$$.fragment,e),J=!0)},o(e){W(b.$$.fragment,e),W(k.$$.fragment,e),W(I.$$.fragment,e),W(w.$$.fragment,e),W(N.$$.fragment,e),J=!1},d(e){r(h),e&&r(V),e&&r(f),B(b),e&&r(F),e&&r(v),e&&r(R),e&&r(p),e&&r(G),B(k,e),e&&r(H),e&&r(m),B(I),B(w),B(N)}}}const Se={local:"optimum.IncTrainer",title:"IncTrainer"};function je(ye){return ze(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Fe extends De{constructor(h){super();Pe(this,h,je,Me,Ce,{})}}export{Fe as default,Se as metadata};
