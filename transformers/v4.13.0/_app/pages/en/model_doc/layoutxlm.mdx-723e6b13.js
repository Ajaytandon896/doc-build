import{S as Ws,i as Hs,s as Gs,e as r,k as c,w as v,t as n,L as Ys,c as s,d as o,m as d,a as i,x as L,h as a,b as l,J as e,g as u,y as k,K as Js,q as b,o as x,B as w}from"../../../chunks/vendor-e859c359.js";import{D as B}from"../../../chunks/Docstring-ade913b3.js";import{C as Bs}from"../../../chunks/CodeBlock-ce4317c2.js";import{I as Yt}from"../../../chunks/IconCopyLink-5fae3b20.js";import"../../../chunks/CopyButton-77addb3d.js";function Zs(qo){let F,Pe,E,$,dt,ne,Fo,mt,Po,Jt,R,W,ut,ae,No,pt,Ao,Zt,P,Do,re,Io,Oo,se,So,Co,Kt,Ne,Ro,Qt,Ae,ft,Uo,eo,De,jo,to,ie,oo,N,Vo,Ie,Bo,Wo,Oe,Ho,Go,no,le,ao,z,Yo,Se,Jo,Zo,Ce,Ko,Qo,Re,en,tn,Ue,on,nn,ro,H,an,je,rn,sn,so,A,ln,ce,cn,dn,de,mn,un,io,U,G,ht,me,pn,_t,fn,lo,h,ue,hn,q,_n,Ve,gn,yn,Be,vn,Ln,pe,kn,bn,xn,fe,wn,We,Tn,zn,Mn,he,Xn,_e,En,gt,$n,qn,Fn,Pn,Y,ge,Nn,yt,An,Dn,D,ye,In,vt,On,Sn,ve,He,Cn,Lt,Rn,Un,Ge,jn,kt,Vn,Bn,J,Le,Wn,ke,Hn,bt,Gn,Yn,Jn,Z,be,Zn,xt,Kn,Qn,wt,co,j,K,Tt,xe,ea,zt,ta,mo,M,we,oa,X,na,Mt,aa,ra,Ye,sa,ia,Je,la,ca,Te,da,ma,ua,ze,pa,Ze,fa,ha,_a,Q,Me,ga,Xt,ya,uo,V,ee,Et,Xe,va,$t,La,po,T,Ee,ka,qt,ba,xa,Ke,Qe,wa,Ta,za,_,Ma,et,Xa,Ea,tt,$a,qa,ot,Fa,Pa,Ft,Na,Aa,Pt,Da,Ia,Nt,Oa,Sa,At,Ca,Ra,Dt,Ua,ja,It,Va,Ba,Wa,I,$e,Ha,p,Ga,Ot,Ya,Ja,qe,St,Za,Ka,Qa,nt,er,tr,Ct,or,nr,Rt,ar,rr,Fe,Ut,sr,ir,lr,jt,cr,dr,at,mr,ur,Vt,pr,fr,Bt,hr,_r,Wt,gr,yr,Ht,vr,Lr,kr,Gt,br,fo;return ne=new Yt({}),ae=new Yt({}),ie=new Bs({props:{code:`from transformers import LayoutLMv2Model

model = LayoutLMv2Model.from_pretrained('microsoft/layoutxlm-base'),`,highlighted:`from transformers import LayoutLMv2Model

model = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LayoutLMv2Model</span>.</span></span>from<span class="hljs-constructor">_pretrained(&#x27;<span class="hljs-params">microsoft</span><span class="hljs-operator">/</span><span class="hljs-params">layoutxlm</span>-<span class="hljs-params">base</span>&#x27;)</span>`}}),le=new Bs({props:{code:`from transformers import LayoutXLMTokenizer

tokenizer = LayoutXLMTokenizer.from_pretrained('microsoft/layoutxlm-base'),`,highlighted:`from transformers import LayoutXLMTokenizer

tokenizer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LayoutXLMTokenizer</span>.</span></span>from<span class="hljs-constructor">_pretrained(&#x27;<span class="hljs-params">microsoft</span><span class="hljs-operator">/</span><span class="hljs-params">layoutxlm</span>-<span class="hljs-params">base</span>&#x27;)</span>`}}),me=new Yt({}),ue=new B({props:{name:"class transformers.LayoutXLMTokenizer",anchor:"transformers.LayoutXLMTokenizer",parameters:[{name:"vocab_file",val:""},{name:"bos_token",val:" = '<s>'"},{name:"eos_token",val:" = '</s>'"},{name:"sep_token",val:" = '</s>'"},{name:"cls_token",val:" = '<s>'"},{name:"unk_token",val:" = '<unk>'"},{name:"pad_token",val:" = '<pad>'"},{name:"mask_token",val:" = '<mask>'"},{name:"cls_token_box",val:" = [0, 0, 0, 0]"},{name:"sep_token_box",val:" = [1000, 1000, 1000, 1000]"},{name:"pad_token_box",val:" = [0, 0, 0, 0]"},{name:"pad_token_label",val:" = -100"},{name:"only_label_first_subword",val:" = True"},{name:"sp_model_kwargs",val:": typing.Union[typing.Dict[str, typing.Any], NoneType] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/master/src/transformers/models/layoutxlm/tokenization_layoutxlm.py#L48",parametersDescription:[{anchor:"transformers.LayoutXLMTokenizer.vocab_file",description:`<strong>vocab_file</strong> (<code>str</code>) &#x2014;
Path to the vocabulary file.`,name:"vocab_file"},{anchor:"transformers.LayoutXLMTokenizer.bos_token",description:`<strong>bos_token</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;&lt;s&gt;&quot;</code>) &#x2014;
The beginning of sequence token that was used during pretraining. Can be used a sequence classifier token.`,name:"bos_token"}]}}),ge=new B({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.LayoutXLMTokenizer.__call__",parameters:[{name:"text",val:": typing.Union[str, typing.List[str], typing.List[typing.List[str]]]"},{name:"text_pair",val:": typing.Union[typing.List[str], typing.List[typing.List[str]], NoneType] = None"},{name:"boxes",val:": typing.Union[typing.List[typing.List[int]], typing.List[typing.List[typing.List[int]]]] = None"},{name:"word_labels",val:": typing.Union[typing.List[int], typing.List[typing.List[int]], NoneType] = None"},{name:"add_special_tokens",val:": bool = True"},{name:"padding",val:": typing.Union[bool, str, transformers.file_utils.PaddingStrategy] = False"},{name:"truncation",val:": typing.Union[bool, str, transformers.tokenization_utils_base.TruncationStrategy] = False"},{name:"max_length",val:": typing.Optional[int] = None"},{name:"stride",val:": int = 0"},{name:"pad_to_multiple_of",val:": typing.Optional[int] = None"},{name:"return_tensors",val:": typing.Union[str, transformers.file_utils.TensorType, NoneType] = None"},{name:"return_token_type_ids",val:": typing.Optional[bool] = None"},{name:"return_attention_mask",val:": typing.Optional[bool] = None"},{name:"return_overflowing_tokens",val:": bool = False"},{name:"return_special_tokens_mask",val:": bool = False"},{name:"return_offsets_mapping",val:": bool = False"},{name:"return_length",val:": bool = False"},{name:"verbose",val:": bool = True"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/master/src/transformers/models/layoutxlm/tokenization_layoutxlm.py#L332",parametersDescription:[{anchor:"transformers.LayoutXLMTokenizer.__call__.text",description:`<strong>text</strong> (<code>str</code>, <code>List[str]</code>, <code>List[List[str]]</code>) &#x2014;
The sequence or batch of sequences to be encoded. Each sequence can be a string, a list of strings
(words of a single example or questions of a batch of examples) or a list of list of strings (batch of
words).`,name:"text"},{anchor:"transformers.LayoutXLMTokenizer.__call__.text_pair",description:`<strong>text_pair</strong> (<code>List[str]</code>, <code>List[List[str]]</code>) &#x2014;
The sequence or batch of sequences to be encoded. Each sequence should be a list of strings
(pretokenized string).`,name:"text_pair"},{anchor:"transformers.LayoutXLMTokenizer.__call__.boxes",description:`<strong>boxes</strong> (<code>List[List[int]]</code>, <code>List[List[List[int]]]</code>) &#x2014;
Word-level bounding boxes. Each bounding box should be normalized to be on a 0-1000 scale.`,name:"boxes"},{anchor:"transformers.LayoutXLMTokenizer.__call__.word_labels",description:`<strong>word_labels</strong> (<code>List[int]</code>, <code>List[List[int]]</code>, <em>optional</em>) &#x2014;
Word-level integer labels (for token classification tasks such as FUNSD, CORD).`,name:"word_labels"},{anchor:"transformers.LayoutXLMTokenizer.__call__.add_special_tokens",description:`<strong>add_special_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to encode the sequences with the special tokens relative to their model.`,name:"add_special_tokens"},{anchor:"transformers.LayoutXLMTokenizer.__call__.padding",description:`<strong>padding</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/master/en/internal/file_utils#transformers.file_utils.PaddingStrategy">PaddingStrategy</a>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls padding. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;longest&apos;</code>: Pad to the longest sequence in the batch (or no padding if only a
single sequence if provided).</li>
<li><code>&apos;max_length&apos;</code>: Pad to a maximum length specified with the argument <code>max_length</code> or to the
maximum acceptable input length for the model if that argument is not provided.</li>
<li><code>False</code> or <code>&apos;do_not_pad&apos;</code> (default): No padding (i.e., can output a batch with sequences of
different lengths).</li>
</ul>`,name:"padding"},{anchor:"transformers.LayoutXLMTokenizer.__call__.truncation",description:`<strong>truncation</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/master/en/internal/tokenization_utils#transformers.tokenization_utils_base.TruncationStrategy">TruncationStrategy</a>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls truncation. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;longest_first&apos;</code>: Truncate to a maximum length specified with the argument
<code>max_length</code> or to the maximum acceptable input length for the model if that argument is not
provided. This will truncate token by token, removing a token from the longest sequence in the pair
if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>&apos;only_first&apos;</code>: Truncate to a maximum length specified with the argument <code>max_length</code> or to
the maximum acceptable input length for the model if that argument is not provided. This will only
truncate the first sequence of a pair if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>&apos;only_second&apos;</code>: Truncate to a maximum length specified with the argument <code>max_length</code> or
to the maximum acceptable input length for the model if that argument is not provided. This will only
truncate the second sequence of a pair if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>False</code> or <code>&apos;do_not_truncate&apos;</code> (default): No truncation (i.e., can output batch with
sequence lengths greater than the model maximum admissible input size).</li>
</ul>`,name:"truncation"},{anchor:"transformers.LayoutXLMTokenizer.__call__.max_length",description:`<strong>max_length</strong> (<code>int</code>, <em>optional</em>) &#x2014;
Controls the maximum length to use by one of the truncation/padding parameters.</p>
<p>If left unset or set to <code>None</code>, this will use the predefined model maximum length if a maximum
length is required by one of the truncation/padding parameters. If the model has no specific maximum
input length (like XLNet) truncation/padding to a maximum length will be deactivated.`,name:"max_length"},{anchor:"transformers.LayoutXLMTokenizer.__call__.stride",description:`<strong>stride</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
If set to a number along with <code>max_length</code>, the overflowing tokens returned when
<code>return_overflowing_tokens=True</code> will contain some tokens from the end of the truncated sequence
returned to provide some overlap between truncated and overflowing sequences. The value of this
argument defines the number of overlapping tokens.`,name:"stride"},{anchor:"transformers.LayoutXLMTokenizer.__call__.is_split_into_words",description:`<strong>is_split_into_words</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the input is already pre-tokenized (e.g., split into words). If set to <code>True</code>, the
tokenizer assumes the input is already split into words (for instance, by splitting it on whitespace)
which it will tokenize. This is useful for NER or token classification.`,name:"is_split_into_words"},{anchor:"transformers.LayoutXLMTokenizer.__call__.pad_to_multiple_of",description:`<strong>pad_to_multiple_of</strong> (<code>int</code>, <em>optional</em>) &#x2014;
If set will pad the sequence to a multiple of the provided value. This is especially useful to enable
the use of Tensor Cores on NVIDIA hardware with compute capability &gt;= 7.5 (Volta).`,name:"pad_to_multiple_of"},{anchor:"transformers.LayoutXLMTokenizer.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>str</code> or <a href="/docs/transformers/master/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>) &#x2014;
If set, will return tensors instead of list of python integers. Acceptable values are:</p>
<ul>
<li><code>&apos;tf&apos;</code>: Return TensorFlow <code>tf.constant</code> objects.</li>
<li><code>&apos;pt&apos;</code>: Return PyTorch <code>torch.Tensor</code> objects.</li>
<li><code>&apos;np&apos;</code>: Return Numpy <code>np.ndarray</code> objects.</li>
</ul>`,name:"return_tensors"},{anchor:"transformers.LayoutXLMTokenizer.__call__.add_special_tokens",description:`<strong>add_special_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to encode the sequences with the special tokens relative to their model.`,name:"add_special_tokens"},{anchor:"transformers.LayoutXLMTokenizer.__call__.padding",description:`<strong>padding</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/master/en/internal/file_utils#transformers.file_utils.PaddingStrategy">PaddingStrategy</a>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls padding. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;longest&apos;</code>: Pad to the longest sequence in the batch (or no padding if only a
single sequence if provided).</li>
<li><code>&apos;max_length&apos;</code>: Pad to a maximum length specified with the argument <code>max_length</code> or to the
maximum acceptable input length for the model if that argument is not provided.</li>
<li><code>False</code> or <code>&apos;do_not_pad&apos;</code> (default): No padding (i.e., can output a batch with sequences of
different lengths).</li>
</ul>`,name:"padding"},{anchor:"transformers.LayoutXLMTokenizer.__call__.truncation",description:`<strong>truncation</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/master/en/internal/tokenization_utils#transformers.tokenization_utils_base.TruncationStrategy">TruncationStrategy</a>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls truncation. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;longest_first&apos;</code>: Truncate to a maximum length specified with the argument
<code>max_length</code> or to the maximum acceptable input length for the model if that argument is not
provided. This will truncate token by token, removing a token from the longest sequence in the pair
if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>&apos;only_first&apos;</code>: Truncate to a maximum length specified with the argument <code>max_length</code> or to
the maximum acceptable input length for the model if that argument is not provided. This will only
truncate the first sequence of a pair if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>&apos;only_second&apos;</code>: Truncate to a maximum length specified with the argument <code>max_length</code> or
to the maximum acceptable input length for the model if that argument is not provided. This will only
truncate the second sequence of a pair if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>False</code> or <code>&apos;do_not_truncate&apos;</code> (default): No truncation (i.e., can output batch with
sequence lengths greater than the model maximum admissible input size).</li>
</ul>`,name:"truncation"},{anchor:"transformers.LayoutXLMTokenizer.__call__.max_length",description:`<strong>max_length</strong> (<code>int</code>, <em>optional</em>) &#x2014;
Controls the maximum length to use by one of the truncation/padding parameters. If left unset or set to
<code>None</code>, this will use the predefined model maximum length if a maximum length is required by one
of the truncation/padding parameters. If the model has no specific maximum input length (like XLNet)
truncation/padding to a maximum length will be deactivated.`,name:"max_length"},{anchor:"transformers.LayoutXLMTokenizer.__call__.stride",description:`<strong>stride</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
If set to a number along with <code>max_length</code>, the overflowing tokens returned when
<code>return_overflowing_tokens=True</code> will contain some tokens from the end of the truncated sequence
returned to provide some overlap between truncated and overflowing sequences. The value of this
argument defines the number of overlapping tokens.`,name:"stride"},{anchor:"transformers.LayoutXLMTokenizer.__call__.pad_to_multiple_of",description:`<strong>pad_to_multiple_of</strong> (<code>int</code>, <em>optional</em>) &#x2014;
If set will pad the sequence to a multiple of the provided value. This is especially useful to enable
the use of Tensor Cores on NVIDIA hardware with compute capability &gt;= 7.5 (Volta).`,name:"pad_to_multiple_of"},{anchor:"transformers.LayoutXLMTokenizer.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>str</code> or <a href="/docs/transformers/master/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>) &#x2014;
If set, will return tensors instead of list of python integers. Acceptable values are:</p>
<ul>
<li><code>&apos;tf&apos;</code>: Return TensorFlow <code>tf.constant</code> objects.</li>
<li><code>&apos;pt&apos;</code>: Return PyTorch <code>torch.Tensor</code> objects.</li>
<li><code>&apos;np&apos;</code>: Return Numpy <code>np.ndarray</code> objects.</li>
</ul>`,name:"return_tensors"}]}}),ye=new B({props:{name:"build\\_inputs\\_with\\_special\\_tokens",anchor:"transformers.LayoutXLMTokenizer.build_inputs_with_special_tokens",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],source:"https://github.com/huggingface/transformers/blob/master/src/transformers/models/layoutxlm/tokenization_layoutxlm.py#L208",parametersDescription:[{anchor:"transformers.LayoutXLMTokenizer.build_inputs_with_special_tokens.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs to which the special tokens will be added.`,name:"token_ids_0"},{anchor:"transformers.LayoutXLMTokenizer.build_inputs_with_special_tokens.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],returnDescription:`
<p>List of <a href="../glossary#input-ids">input IDs</a> with the appropriate special tokens.</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Le=new B({props:{name:"get\\_special\\_tokens\\_mask",anchor:"transformers.LayoutXLMTokenizer.get_special_tokens_mask",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"},{name:"already_has_special_tokens",val:": bool = False"}],source:"https://github.com/huggingface/transformers/blob/master/src/transformers/models/layoutxlm/tokenization_layoutxlm.py#L234",parametersDescription:[{anchor:"transformers.LayoutXLMTokenizer.get_special_tokens_mask.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.LayoutXLMTokenizer.get_special_tokens_mask.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"},{anchor:"transformers.LayoutXLMTokenizer.get_special_tokens_mask.already_has_special_tokens",description:`<strong>already_has_special_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the token list is already formatted with special tokens for the model.`,name:"already_has_special_tokens"}],returnDescription:`
<p>A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),be=new B({props:{name:"create\\_token\\_type\\_ids\\_from\\_sequences",anchor:"transformers.LayoutXLMTokenizer.create_token_type_ids_from_sequences",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],source:"https://github.com/huggingface/transformers/blob/master/src/transformers/models/layoutxlm/tokenization_layoutxlm.py#L262",parametersDescription:[{anchor:"transformers.LayoutXLMTokenizer.create_token_type_ids_from_sequences.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.LayoutXLMTokenizer.create_token_type_ids_from_sequences.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],returnDescription:`
<p>List of zeros.</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),xe=new Yt({}),we=new B({props:{name:"class transformers.LayoutXLMTokenizerFast",anchor:"transformers.LayoutXLMTokenizerFast",parameters:[{name:"vocab_file",val:" = None"},{name:"tokenizer_file",val:" = None"},{name:"bos_token",val:" = '<s>'"},{name:"eos_token",val:" = '</s>'"},{name:"sep_token",val:" = '</s>'"},{name:"cls_token",val:" = '<s>'"},{name:"unk_token",val:" = '<unk>'"},{name:"pad_token",val:" = '<pad>'"},{name:"mask_token",val:" = '<mask>'"},{name:"cls_token_box",val:" = [0, 0, 0, 0]"},{name:"sep_token_box",val:" = [1000, 1000, 1000, 1000]"},{name:"pad_token_box",val:" = [0, 0, 0, 0]"},{name:"pad_token_label",val:" = -100"},{name:"only_label_first_subword",val:" = True"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/master/src/transformers/models/layoutxlm/tokenization_layoutxlm_fast.py#L53",parametersDescription:[{anchor:"transformers.LayoutXLMTokenizerFast.vocab_file",description:`<strong>vocab_file</strong> (<code>str</code>) &#x2014;
Path to the vocabulary file.`,name:"vocab_file"},{anchor:"transformers.LayoutXLMTokenizerFast.bos_token",description:`<strong>bos_token</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;&lt;s&gt;&quot;</code>) &#x2014;
The beginning of sequence token that was used during pretraining. Can be used a sequence classifier token.`,name:"bos_token"}]}}),Me=new B({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.LayoutXLMTokenizerFast.__call__",parameters:[{name:"text",val:": typing.Union[str, typing.List[str], typing.List[typing.List[str]]]"},{name:"text_pair",val:": typing.Union[typing.List[str], typing.List[typing.List[str]], NoneType] = None"},{name:"boxes",val:": typing.Union[typing.List[typing.List[int]], typing.List[typing.List[typing.List[int]]]] = None"},{name:"word_labels",val:": typing.Union[typing.List[int], typing.List[typing.List[int]], NoneType] = None"},{name:"add_special_tokens",val:": bool = True"},{name:"padding",val:": typing.Union[bool, str, transformers.file_utils.PaddingStrategy] = False"},{name:"truncation",val:": typing.Union[bool, str, transformers.tokenization_utils_base.TruncationStrategy] = False"},{name:"max_length",val:": typing.Optional[int] = None"},{name:"stride",val:": int = 0"},{name:"pad_to_multiple_of",val:": typing.Optional[int] = None"},{name:"return_tensors",val:": typing.Union[str, transformers.file_utils.TensorType, NoneType] = None"},{name:"return_token_type_ids",val:": typing.Optional[bool] = None"},{name:"return_attention_mask",val:": typing.Optional[bool] = None"},{name:"return_overflowing_tokens",val:": bool = False"},{name:"return_special_tokens_mask",val:": bool = False"},{name:"return_offsets_mapping",val:": bool = False"},{name:"return_length",val:": bool = False"},{name:"verbose",val:": bool = True"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/master/src/transformers/models/layoutxlm/tokenization_layoutxlm_fast.py#L164",parametersDescription:[{anchor:"transformers.LayoutXLMTokenizerFast.__call__.text",description:`<strong>text</strong> (<code>str</code>, <code>List[str]</code>, <code>List[List[str]]</code>) &#x2014;
The sequence or batch of sequences to be encoded. Each sequence can be a string, a list of strings
(words of a single example or questions of a batch of examples) or a list of list of strings (batch of
words).`,name:"text"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.text_pair",description:`<strong>text_pair</strong> (<code>List[str]</code>, <code>List[List[str]]</code>) &#x2014;
The sequence or batch of sequences to be encoded. Each sequence should be a list of strings
(pretokenized string).`,name:"text_pair"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.boxes",description:`<strong>boxes</strong> (<code>List[List[int]]</code>, <code>List[List[List[int]]]</code>) &#x2014;
Word-level bounding boxes. Each bounding box should be normalized to be on a 0-1000 scale.`,name:"boxes"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.word_labels",description:`<strong>word_labels</strong> (<code>List[int]</code>, <code>List[List[int]]</code>, <em>optional</em>) &#x2014;
Word-level integer labels (for token classification tasks such as FUNSD, CORD).`,name:"word_labels"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.add_special_tokens",description:`<strong>add_special_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to encode the sequences with the special tokens relative to their model.`,name:"add_special_tokens"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.padding",description:`<strong>padding</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/master/en/internal/file_utils#transformers.file_utils.PaddingStrategy">PaddingStrategy</a>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls padding. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;longest&apos;</code>: Pad to the longest sequence in the batch (or no padding if only a
single sequence if provided).</li>
<li><code>&apos;max_length&apos;</code>: Pad to a maximum length specified with the argument <code>max_length</code> or to the
maximum acceptable input length for the model if that argument is not provided.</li>
<li><code>False</code> or <code>&apos;do_not_pad&apos;</code> (default): No padding (i.e., can output a batch with sequences of
different lengths).</li>
</ul>`,name:"padding"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.truncation",description:`<strong>truncation</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/master/en/internal/tokenization_utils#transformers.tokenization_utils_base.TruncationStrategy">TruncationStrategy</a>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls truncation. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;longest_first&apos;</code>: Truncate to a maximum length specified with the argument
<code>max_length</code> or to the maximum acceptable input length for the model if that argument is not
provided. This will truncate token by token, removing a token from the longest sequence in the pair
if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>&apos;only_first&apos;</code>: Truncate to a maximum length specified with the argument <code>max_length</code> or to
the maximum acceptable input length for the model if that argument is not provided. This will only
truncate the first sequence of a pair if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>&apos;only_second&apos;</code>: Truncate to a maximum length specified with the argument <code>max_length</code> or
to the maximum acceptable input length for the model if that argument is not provided. This will only
truncate the second sequence of a pair if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>False</code> or <code>&apos;do_not_truncate&apos;</code> (default): No truncation (i.e., can output batch with
sequence lengths greater than the model maximum admissible input size).</li>
</ul>`,name:"truncation"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.max_length",description:`<strong>max_length</strong> (<code>int</code>, <em>optional</em>) &#x2014;
Controls the maximum length to use by one of the truncation/padding parameters.</p>
<p>If left unset or set to <code>None</code>, this will use the predefined model maximum length if a maximum
length is required by one of the truncation/padding parameters. If the model has no specific maximum
input length (like XLNet) truncation/padding to a maximum length will be deactivated.`,name:"max_length"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.stride",description:`<strong>stride</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
If set to a number along with <code>max_length</code>, the overflowing tokens returned when
<code>return_overflowing_tokens=True</code> will contain some tokens from the end of the truncated sequence
returned to provide some overlap between truncated and overflowing sequences. The value of this
argument defines the number of overlapping tokens.`,name:"stride"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.is_split_into_words",description:`<strong>is_split_into_words</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the input is already pre-tokenized (e.g., split into words). If set to <code>True</code>, the
tokenizer assumes the input is already split into words (for instance, by splitting it on whitespace)
which it will tokenize. This is useful for NER or token classification.`,name:"is_split_into_words"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.pad_to_multiple_of",description:`<strong>pad_to_multiple_of</strong> (<code>int</code>, <em>optional</em>) &#x2014;
If set will pad the sequence to a multiple of the provided value. This is especially useful to enable
the use of Tensor Cores on NVIDIA hardware with compute capability &gt;= 7.5 (Volta).`,name:"pad_to_multiple_of"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>str</code> or <a href="/docs/transformers/master/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>) &#x2014;
If set, will return tensors instead of list of python integers. Acceptable values are:</p>
<ul>
<li><code>&apos;tf&apos;</code>: Return TensorFlow <code>tf.constant</code> objects.</li>
<li><code>&apos;pt&apos;</code>: Return PyTorch <code>torch.Tensor</code> objects.</li>
<li><code>&apos;np&apos;</code>: Return Numpy <code>np.ndarray</code> objects.</li>
</ul>`,name:"return_tensors"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.add_special_tokens",description:`<strong>add_special_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to encode the sequences with the special tokens relative to their model.`,name:"add_special_tokens"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.padding",description:`<strong>padding</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/master/en/internal/file_utils#transformers.file_utils.PaddingStrategy">PaddingStrategy</a>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls padding. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;longest&apos;</code>: Pad to the longest sequence in the batch (or no padding if only a
single sequence if provided).</li>
<li><code>&apos;max_length&apos;</code>: Pad to a maximum length specified with the argument <code>max_length</code> or to the
maximum acceptable input length for the model if that argument is not provided.</li>
<li><code>False</code> or <code>&apos;do_not_pad&apos;</code> (default): No padding (i.e., can output a batch with sequences of
different lengths).</li>
</ul>`,name:"padding"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.truncation",description:`<strong>truncation</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/master/en/internal/tokenization_utils#transformers.tokenization_utils_base.TruncationStrategy">TruncationStrategy</a>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls truncation. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;longest_first&apos;</code>: Truncate to a maximum length specified with the argument
<code>max_length</code> or to the maximum acceptable input length for the model if that argument is not
provided. This will truncate token by token, removing a token from the longest sequence in the pair
if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>&apos;only_first&apos;</code>: Truncate to a maximum length specified with the argument <code>max_length</code> or to
the maximum acceptable input length for the model if that argument is not provided. This will only
truncate the first sequence of a pair if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>&apos;only_second&apos;</code>: Truncate to a maximum length specified with the argument <code>max_length</code> or
to the maximum acceptable input length for the model if that argument is not provided. This will only
truncate the second sequence of a pair if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>False</code> or <code>&apos;do_not_truncate&apos;</code> (default): No truncation (i.e., can output batch with
sequence lengths greater than the model maximum admissible input size).</li>
</ul>`,name:"truncation"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.max_length",description:`<strong>max_length</strong> (<code>int</code>, <em>optional</em>) &#x2014;
Controls the maximum length to use by one of the truncation/padding parameters. If left unset or set to
<code>None</code>, this will use the predefined model maximum length if a maximum length is required by one
of the truncation/padding parameters. If the model has no specific maximum input length (like XLNet)
truncation/padding to a maximum length will be deactivated.`,name:"max_length"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.stride",description:`<strong>stride</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
If set to a number along with <code>max_length</code>, the overflowing tokens returned when
<code>return_overflowing_tokens=True</code> will contain some tokens from the end of the truncated sequence
returned to provide some overlap between truncated and overflowing sequences. The value of this
argument defines the number of overlapping tokens.`,name:"stride"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.pad_to_multiple_of",description:`<strong>pad_to_multiple_of</strong> (<code>int</code>, <em>optional</em>) &#x2014;
If set will pad the sequence to a multiple of the provided value. This is especially useful to enable
the use of Tensor Cores on NVIDIA hardware with compute capability &gt;= 7.5 (Volta).`,name:"pad_to_multiple_of"},{anchor:"transformers.LayoutXLMTokenizerFast.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>str</code> or <a href="/docs/transformers/master/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>) &#x2014;
If set, will return tensors instead of list of python integers. Acceptable values are:</p>
<ul>
<li><code>&apos;tf&apos;</code>: Return TensorFlow <code>tf.constant</code> objects.</li>
<li><code>&apos;pt&apos;</code>: Return PyTorch <code>torch.Tensor</code> objects.</li>
<li><code>&apos;np&apos;</code>: Return Numpy <code>np.ndarray</code> objects.</li>
</ul>`,name:"return_tensors"}]}}),Xe=new Yt({}),Ee=new B({props:{name:"class transformers.LayoutXLMProcessor",anchor:"transformers.LayoutXLMProcessor",parameters:[{name:"feature_extractor",val:""},{name:"tokenizer",val:""}],source:"https://github.com/huggingface/transformers/blob/master/src/transformers/models/layoutxlm/processing_layoutxlm.py#L28",parametersDescription:[{anchor:"transformers.LayoutXLMProcessor.feature_extractor",description:`<strong>feature_extractor</strong> (<code>LayoutLMv2FeatureExtractor</code>) &#x2014;
An instance of <a href="/docs/transformers/master/en/model_doc/layoutlmv2#transformers.LayoutLMv2FeatureExtractor">LayoutLMv2FeatureExtractor</a>. The feature extractor is a required
input.`,name:"feature_extractor"},{anchor:"transformers.LayoutXLMProcessor.tokenizer",description:`<strong>tokenizer</strong> (<code>LayoutXLMTokenizer</code> or <code>LayoutXLMTokenizerFast</code>) &#x2014;
An instance of <a href="/docs/transformers/master/en/model_doc/layoutxlm#transformers.LayoutXLMTokenizer">LayoutXLMTokenizer</a> or <a href="/docs/transformers/master/en/model_doc/layoutxlm#transformers.LayoutXLMTokenizerFast">LayoutXLMTokenizerFast</a>.
The tokenizer is a required input.`,name:"tokenizer"}]}}),$e=new B({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.LayoutXLMProcessor.__call__",parameters:[{name:"images",val:""},{name:"text",val:": typing.Union[str, typing.List[str], typing.List[typing.List[str]]] = None"},{name:"text_pair",val:": typing.Union[typing.List[str], typing.List[typing.List[str]], NoneType] = None"},{name:"boxes",val:": typing.Union[typing.List[typing.List[int]], typing.List[typing.List[typing.List[int]]]] = None"},{name:"word_labels",val:": typing.Union[typing.List[int], typing.List[typing.List[int]], NoneType] = None"},{name:"add_special_tokens",val:": bool = True"},{name:"padding",val:": typing.Union[bool, str, transformers.file_utils.PaddingStrategy] = False"},{name:"truncation",val:": typing.Union[bool, str, transformers.tokenization_utils_base.TruncationStrategy] = False"},{name:"max_length",val:": typing.Optional[int] = None"},{name:"stride",val:": int = 0"},{name:"pad_to_multiple_of",val:": typing.Optional[int] = None"},{name:"return_token_type_ids",val:": typing.Optional[bool] = None"},{name:"return_attention_mask",val:": typing.Optional[bool] = None"},{name:"return_overflowing_tokens",val:": bool = False"},{name:"return_special_tokens_mask",val:": bool = False"},{name:"return_offsets_mapping",val:": bool = False"},{name:"return_length",val:": bool = False"},{name:"verbose",val:": bool = True"},{name:"return_tensors",val:": typing.Union[str, transformers.file_utils.TensorType, NoneType] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/master/src/transformers/models/layoutxlm/processing_layoutxlm.py#L125"}}),{c(){F=r("meta"),Pe=c(),E=r("h1"),$=r("a"),dt=r("span"),v(ne.$$.fragment),Fo=c(),mt=r("span"),Po=n("LayoutXLM"),Jt=c(),R=r("h2"),W=r("a"),ut=r("span"),v(ae.$$.fragment),No=c(),pt=r("span"),Ao=n("Overview"),Zt=c(),P=r("p"),Do=n("LayoutXLM was proposed in "),re=r("a"),Io=n("LayoutXLM: Multimodal Pre-training for Multilingual Visually-rich Document Understanding"),Oo=n(` by Yiheng Xu, Tengchao Lv, Lei Cui, Guoxin Wang, Yijuan Lu, Dinei Florencio, Cha
Zhang, Furu Wei. It\u2019s a multilingual extension of the `),se=r("a"),So=n("LayoutLMv2 model"),Co=n(` trained
on 53 languages.`),Kt=c(),Ne=r("p"),Ro=n("The abstract from the paper is the following:"),Qt=c(),Ae=r("p"),ft=r("em"),Uo=n(`Multimodal pre-training with text, layout, and image has achieved SOTA performance for visually-rich document
understanding tasks recently, which demonstrates the great potential for joint learning across different modalities. In
this paper, we present LayoutXLM, a multimodal pre-trained model for multilingual document understanding, which aims to
bridge the language barriers for visually-rich document understanding. To accurately evaluate LayoutXLM, we also
introduce a multilingual form understanding benchmark dataset named XFUN, which includes form understanding samples in
7 languages (Chinese, Japanese, Spanish, French, Italian, German, Portuguese), and key-value pairs are manually labeled
for each language. Experiment results show that the LayoutXLM model has significantly outperformed the existing SOTA
cross-lingual pre-trained models on the XFUN dataset.`),eo=c(),De=r("p"),jo=n("One can directly plug in the weights of LayoutXLM into a LayoutLMv2 model, like so:"),to=c(),v(ie.$$.fragment),oo=c(),N=r("p"),Vo=n(`Note that LayoutXLM has its own tokenizer, based on
`),Ie=r("a"),Bo=n("LayoutXLMTokenizer"),Wo=n("/"),Oe=r("a"),Ho=n("LayoutXLMTokenizerFast"),Go=n(`. You can initialize it as
follows:`),no=c(),v(le.$$.fragment),ao=c(),z=r("p"),Yo=n("Similar to LayoutLMv2, you can use "),Se=r("a"),Jo=n("LayoutXLMProcessor"),Zo=n(` (which internally applies
`),Ce=r("a"),Ko=n("LayoutLMv2FeatureExtractor"),Qo=n(` and
`),Re=r("a"),en=n("LayoutXLMTokenizer"),tn=n("/"),Ue=r("a"),on=n("LayoutXLMTokenizerFast"),nn=n(` in sequence) to prepare all
data for the model.`),ro=c(),H=r("p"),an=n("As LayoutXLM\u2019s architecture is equivalent to that of LayoutLMv2, one can refer to "),je=r("a"),rn=n("LayoutLMv2\u2019s documentation page"),sn=n(" for all tips, code examples and notebooks."),so=c(),A=r("p"),ln=n("This model was contributed by "),ce=r("a"),cn=n("nielsr"),dn=n(". The original code can be found "),de=r("a"),mn=n("here"),un=n("."),io=c(),U=r("h2"),G=r("a"),ht=r("span"),v(me.$$.fragment),pn=c(),_t=r("span"),fn=n("LayoutXLMTokenizer"),lo=c(),h=r("div"),v(ue.$$.fragment),hn=c(),q=r("p"),_n=n("Adapted from "),Ve=r("a"),gn=n("RobertaTokenizer"),yn=n(" and "),Be=r("a"),vn=n("XLNetTokenizer"),Ln=n(`. Based on
`),pe=r("a"),kn=n("SentencePiece"),bn=n("."),xn=c(),fe=r("p"),wn=n("This tokenizer inherits from "),We=r("a"),Tn=n("PreTrainedTokenizer"),zn=n(` which contains most of the main methods.
Users should refer to this superclass for more information regarding those methods.`),Mn=c(),he=r("p"),Xn=n(`Attributes:
sp`),_e=r("em"),En=n("model ("),gt=r("code"),$n=n("SentencePieceProcessor"),qn=n(`):
The _SentencePiece`),Fn=n(" processor that is used for every conversion (string, tokens and IDs)."),Pn=c(),Y=r("div"),v(ge.$$.fragment),Nn=c(),yt=r("p"),An=n(`Main method to tokenize and prepare for the model one or several sequence(s) or one or several pair(s) of
sequences with word-level normalized bounding boxes and optional labels.`),Dn=c(),D=r("div"),v(ye.$$.fragment),In=c(),vt=r("p"),On=n(`Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and
adding special tokens. An XLM-RoBERTa sequence has the following format:`),Sn=c(),ve=r("ul"),He=r("li"),Cn=n("single sequence: "),Lt=r("code"),Rn=n("<s> X </s>"),Un=c(),Ge=r("li"),jn=n("pair of sequences: "),kt=r("code"),Vn=n("<s> A </s></s> B </s>"),Bn=c(),J=r("div"),v(Le.$$.fragment),Wn=c(),ke=r("p"),Hn=n(`Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding
special tokens using the tokenizer `),bt=r("code"),Gn=n("prepare_for_model"),Yn=n(" method."),Jn=c(),Z=r("div"),v(be.$$.fragment),Zn=c(),xt=r("p"),Kn=n(`Create a mask from the two sequences passed to be used in a sequence-pair classification task. XLM-RoBERTa does
not make use of token type ids, therefore a list of zeros is returned.`),Qn=c(),wt=r("div"),co=c(),j=r("h2"),K=r("a"),Tt=r("span"),v(xe.$$.fragment),ea=c(),zt=r("span"),ta=n("LayoutXLMTokenizerFast"),mo=c(),M=r("div"),v(we.$$.fragment),oa=c(),X=r("p"),na=n("Construct a \u201Cfast\u201D LayoutXLM tokenizer (backed by HuggingFace\u2019s "),Mt=r("em"),aa=n("tokenizers"),ra=n(` library). Adapted from
`),Ye=r("a"),sa=n("RobertaTokenizer"),ia=n(" and "),Je=r("a"),la=n("XLNetTokenizer"),ca=n(". Based on "),Te=r("a"),da=n("BPE"),ma=n("."),ua=c(),ze=r("p"),pa=n("This tokenizer inherits from "),Ze=r("a"),fa=n("PreTrainedTokenizerFast"),ha=n(` which contains most of the main
methods. Users should refer to this superclass for more information regarding those methods.`),_a=c(),Q=r("div"),v(Me.$$.fragment),ga=c(),Xt=r("p"),ya=n(`Main method to tokenize and prepare for the model one or several sequence(s) or one or several pair(s) of
sequences with word-level normalized bounding boxes and optional labels.`),uo=c(),V=r("h2"),ee=r("a"),Et=r("span"),v(Xe.$$.fragment),va=c(),$t=r("span"),La=n("LayoutXLMProcessor"),po=c(),T=r("div"),v(Ee.$$.fragment),ka=c(),qt=r("p"),ba=n(`Constructs a LayoutXLM processor which combines a LayoutXLM feature extractor and a LayoutXLM tokenizer into a
single processor.`),xa=c(),Ke=r("p"),Qe=r("a"),wa=n("LayoutXLMProcessor"),Ta=n(" offers all the functionalities you need to prepare data for the model."),za=c(),_=r("p"),Ma=n("It first uses "),et=r("a"),Xa=n("LayoutLMv2FeatureExtractor"),Ea=n(` to resize document images to a fixed size, and
optionally applies OCR to get words and normalized bounding boxes. These are then provided to
`),tt=r("a"),$a=n("LayoutXLMTokenizer"),qa=n(" or "),ot=r("a"),Fa=n("LayoutXLMTokenizerFast"),Pa=n(`, which turns the words
and bounding boxes into token-level `),Ft=r("code"),Na=n("input_ids"),Aa=n(", "),Pt=r("code"),Da=n("attention_mask"),Ia=n(", "),Nt=r("code"),Oa=n("token_type_ids"),Sa=n(", "),At=r("code"),Ca=n("bbox"),Ra=n(`.
Optionally, one can provide integer `),Dt=r("code"),Ua=n("word_labels"),ja=n(", which are turned into token-level "),It=r("code"),Va=n("labels"),Ba=n(` for token
classification tasks (such as FUNSD, CORD).`),Wa=c(),I=r("div"),v($e.$$.fragment),Ha=c(),p=r("p"),Ga=n("This method first forwards the "),Ot=r("code"),Ya=n("images"),Ja=n(` argument to
`),qe=r("a"),St=r("strong"),Za=n("call"),Ka=n("()"),Qa=n(". In case "),nt=r("a"),er=n("~LayoutLMv2FeatureExtractor"),tr=n(` was
initialized with `),Ct=r("code"),or=n("apply_ocr"),nr=n(" set to "),Rt=r("code"),ar=n("True"),rr=n(`, it passes the obtained words and bounding boxes along with
the additional arguments to `),Fe=r("a"),Ut=r("strong"),sr=n("call"),ir=n("()"),lr=n(` and returns the output, together
with resized `),jt=r("code"),cr=n("images"),dr=n(". In case "),at=r("a"),mr=n("~LayoutLMv2FeatureExtractor"),ur=n(" was initialized with "),Vt=r("code"),pr=n("apply_ocr"),fr=n(`
set to `),Bt=r("code"),hr=n("False"),_r=n(", it passes the words ("),Wt=r("code"),gr=n("text"),yr=n("/"),Ht=r("code"),vr=n("text_pair`) and `boxes` specified by the user along with the additional arguments to [__call__()](/docs/transformers/master/en/model_doc/layoutxlm#transformers.LayoutXLMTokenizer.__call__) and returns the output, together with resized `images"),Lr=n("."),kr=c(),Gt=r("p"),br=n("Please refer to the docstring of the above two methods for more information."),this.h()},l(t){const m=Ys('[data-svelte="svelte-1phssyn"]',document.head);F=s(m,"META",{name:!0,content:!0}),m.forEach(o),Pe=d(t),E=s(t,"H1",{class:!0});var ho=i(E);$=s(ho,"A",{id:!0,class:!0,href:!0});var Xr=i($);dt=s(Xr,"SPAN",{});var Er=i(dt);L(ne.$$.fragment,Er),Er.forEach(o),Xr.forEach(o),Fo=d(ho),mt=s(ho,"SPAN",{});var $r=i(mt);Po=a($r,"LayoutXLM"),$r.forEach(o),ho.forEach(o),Jt=d(t),R=s(t,"H2",{class:!0});var _o=i(R);W=s(_o,"A",{id:!0,class:!0,href:!0});var qr=i(W);ut=s(qr,"SPAN",{});var Fr=i(ut);L(ae.$$.fragment,Fr),Fr.forEach(o),qr.forEach(o),No=d(_o),pt=s(_o,"SPAN",{});var Pr=i(pt);Ao=a(Pr,"Overview"),Pr.forEach(o),_o.forEach(o),Zt=d(t),P=s(t,"P",{});var rt=i(P);Do=a(rt,"LayoutXLM was proposed in "),re=s(rt,"A",{href:!0,rel:!0});var Nr=i(re);Io=a(Nr,"LayoutXLM: Multimodal Pre-training for Multilingual Visually-rich Document Understanding"),Nr.forEach(o),Oo=a(rt,` by Yiheng Xu, Tengchao Lv, Lei Cui, Guoxin Wang, Yijuan Lu, Dinei Florencio, Cha
Zhang, Furu Wei. It\u2019s a multilingual extension of the `),se=s(rt,"A",{href:!0,rel:!0});var Ar=i(se);So=a(Ar,"LayoutLMv2 model"),Ar.forEach(o),Co=a(rt,` trained
on 53 languages.`),rt.forEach(o),Kt=d(t),Ne=s(t,"P",{});var Dr=i(Ne);Ro=a(Dr,"The abstract from the paper is the following:"),Dr.forEach(o),Qt=d(t),Ae=s(t,"P",{});var Ir=i(Ae);ft=s(Ir,"EM",{});var Or=i(ft);Uo=a(Or,`Multimodal pre-training with text, layout, and image has achieved SOTA performance for visually-rich document
understanding tasks recently, which demonstrates the great potential for joint learning across different modalities. In
this paper, we present LayoutXLM, a multimodal pre-trained model for multilingual document understanding, which aims to
bridge the language barriers for visually-rich document understanding. To accurately evaluate LayoutXLM, we also
introduce a multilingual form understanding benchmark dataset named XFUN, which includes form understanding samples in
7 languages (Chinese, Japanese, Spanish, French, Italian, German, Portuguese), and key-value pairs are manually labeled
for each language. Experiment results show that the LayoutXLM model has significantly outperformed the existing SOTA
cross-lingual pre-trained models on the XFUN dataset.`),Or.forEach(o),Ir.forEach(o),eo=d(t),De=s(t,"P",{});var Sr=i(De);jo=a(Sr,"One can directly plug in the weights of LayoutXLM into a LayoutLMv2 model, like so:"),Sr.forEach(o),to=d(t),L(ie.$$.fragment,t),oo=d(t),N=s(t,"P",{});var st=i(N);Vo=a(st,`Note that LayoutXLM has its own tokenizer, based on
`),Ie=s(st,"A",{href:!0});var Cr=i(Ie);Bo=a(Cr,"LayoutXLMTokenizer"),Cr.forEach(o),Wo=a(st,"/"),Oe=s(st,"A",{href:!0});var Rr=i(Oe);Ho=a(Rr,"LayoutXLMTokenizerFast"),Rr.forEach(o),Go=a(st,`. You can initialize it as
follows:`),st.forEach(o),no=d(t),L(le.$$.fragment,t),ao=d(t),z=s(t,"P",{});var O=i(z);Yo=a(O,"Similar to LayoutLMv2, you can use "),Se=s(O,"A",{href:!0});var Ur=i(Se);Jo=a(Ur,"LayoutXLMProcessor"),Ur.forEach(o),Zo=a(O,` (which internally applies
`),Ce=s(O,"A",{href:!0});var jr=i(Ce);Ko=a(jr,"LayoutLMv2FeatureExtractor"),jr.forEach(o),Qo=a(O,` and
`),Re=s(O,"A",{href:!0});var Vr=i(Re);en=a(Vr,"LayoutXLMTokenizer"),Vr.forEach(o),tn=a(O,"/"),Ue=s(O,"A",{href:!0});var Br=i(Ue);on=a(Br,"LayoutXLMTokenizerFast"),Br.forEach(o),nn=a(O,` in sequence) to prepare all
data for the model.`),O.forEach(o),ro=d(t),H=s(t,"P",{});var go=i(H);an=a(go,"As LayoutXLM\u2019s architecture is equivalent to that of LayoutLMv2, one can refer to "),je=s(go,"A",{href:!0});var Wr=i(je);rn=a(Wr,"LayoutLMv2\u2019s documentation page"),Wr.forEach(o),sn=a(go," for all tips, code examples and notebooks."),go.forEach(o),so=d(t),A=s(t,"P",{});var it=i(A);ln=a(it,"This model was contributed by "),ce=s(it,"A",{href:!0,rel:!0});var Hr=i(ce);cn=a(Hr,"nielsr"),Hr.forEach(o),dn=a(it,". The original code can be found "),de=s(it,"A",{href:!0,rel:!0});var Gr=i(de);mn=a(Gr,"here"),Gr.forEach(o),un=a(it,"."),it.forEach(o),io=d(t),U=s(t,"H2",{class:!0});var yo=i(U);G=s(yo,"A",{id:!0,class:!0,href:!0});var Yr=i(G);ht=s(Yr,"SPAN",{});var Jr=i(ht);L(me.$$.fragment,Jr),Jr.forEach(o),Yr.forEach(o),pn=d(yo),_t=s(yo,"SPAN",{});var Zr=i(_t);fn=a(Zr,"LayoutXLMTokenizer"),Zr.forEach(o),yo.forEach(o),lo=d(t),h=s(t,"DIV",{class:!0});var y=i(h);L(ue.$$.fragment,y),hn=d(y),q=s(y,"P",{});var te=i(q);_n=a(te,"Adapted from "),Ve=s(te,"A",{href:!0});var Kr=i(Ve);gn=a(Kr,"RobertaTokenizer"),Kr.forEach(o),yn=a(te," and "),Be=s(te,"A",{href:!0});var Qr=i(Be);vn=a(Qr,"XLNetTokenizer"),Qr.forEach(o),Ln=a(te,`. Based on
`),pe=s(te,"A",{href:!0,rel:!0});var es=i(pe);kn=a(es,"SentencePiece"),es.forEach(o),bn=a(te,"."),te.forEach(o),xn=d(y),fe=s(y,"P",{});var vo=i(fe);wn=a(vo,"This tokenizer inherits from "),We=s(vo,"A",{href:!0});var ts=i(We);Tn=a(ts,"PreTrainedTokenizer"),ts.forEach(o),zn=a(vo,` which contains most of the main methods.
Users should refer to this superclass for more information regarding those methods.`),vo.forEach(o),Mn=d(y),he=s(y,"P",{});var Lo=i(he);Xn=a(Lo,`Attributes:
sp`),_e=s(Lo,"EM",{});var ko=i(_e);En=a(ko,"model ("),gt=s(ko,"CODE",{});var os=i(gt);$n=a(os,"SentencePieceProcessor"),os.forEach(o),qn=a(ko,`):
The _SentencePiece`),ko.forEach(o),Fn=a(Lo," processor that is used for every conversion (string, tokens and IDs)."),Lo.forEach(o),Pn=d(y),Y=s(y,"DIV",{class:!0});var bo=i(Y);L(ge.$$.fragment,bo),Nn=d(bo),yt=s(bo,"P",{});var ns=i(yt);An=a(ns,`Main method to tokenize and prepare for the model one or several sequence(s) or one or several pair(s) of
sequences with word-level normalized bounding boxes and optional labels.`),ns.forEach(o),bo.forEach(o),Dn=d(y),D=s(y,"DIV",{class:!0});var lt=i(D);L(ye.$$.fragment,lt),In=d(lt),vt=s(lt,"P",{});var as=i(vt);On=a(as,`Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and
adding special tokens. An XLM-RoBERTa sequence has the following format:`),as.forEach(o),Sn=d(lt),ve=s(lt,"UL",{});var xo=i(ve);He=s(xo,"LI",{});var xr=i(He);Cn=a(xr,"single sequence: "),Lt=s(xr,"CODE",{});var rs=i(Lt);Rn=a(rs,"<s> X </s>"),rs.forEach(o),xr.forEach(o),Un=d(xo),Ge=s(xo,"LI",{});var wr=i(Ge);jn=a(wr,"pair of sequences: "),kt=s(wr,"CODE",{});var ss=i(kt);Vn=a(ss,"<s> A </s></s> B </s>"),ss.forEach(o),wr.forEach(o),xo.forEach(o),lt.forEach(o),Bn=d(y),J=s(y,"DIV",{class:!0});var wo=i(J);L(Le.$$.fragment,wo),Wn=d(wo),ke=s(wo,"P",{});var To=i(ke);Hn=a(To,`Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding
special tokens using the tokenizer `),bt=s(To,"CODE",{});var is=i(bt);Gn=a(is,"prepare_for_model"),is.forEach(o),Yn=a(To," method."),To.forEach(o),wo.forEach(o),Jn=d(y),Z=s(y,"DIV",{class:!0});var zo=i(Z);L(be.$$.fragment,zo),Zn=d(zo),xt=s(zo,"P",{});var ls=i(xt);Kn=a(ls,`Create a mask from the two sequences passed to be used in a sequence-pair classification task. XLM-RoBERTa does
not make use of token type ids, therefore a list of zeros is returned.`),ls.forEach(o),zo.forEach(o),Qn=d(y),wt=s(y,"DIV",{class:!0}),i(wt).forEach(o),y.forEach(o),co=d(t),j=s(t,"H2",{class:!0});var Mo=i(j);K=s(Mo,"A",{id:!0,class:!0,href:!0});var cs=i(K);Tt=s(cs,"SPAN",{});var ds=i(Tt);L(xe.$$.fragment,ds),ds.forEach(o),cs.forEach(o),ea=d(Mo),zt=s(Mo,"SPAN",{});var ms=i(zt);ta=a(ms,"LayoutXLMTokenizerFast"),ms.forEach(o),Mo.forEach(o),mo=d(t),M=s(t,"DIV",{class:!0});var oe=i(M);L(we.$$.fragment,oe),oa=d(oe),X=s(oe,"P",{});var S=i(X);na=a(S,"Construct a \u201Cfast\u201D LayoutXLM tokenizer (backed by HuggingFace\u2019s "),Mt=s(S,"EM",{});var us=i(Mt);aa=a(us,"tokenizers"),us.forEach(o),ra=a(S,` library). Adapted from
`),Ye=s(S,"A",{href:!0});var ps=i(Ye);sa=a(ps,"RobertaTokenizer"),ps.forEach(o),ia=a(S," and "),Je=s(S,"A",{href:!0});var fs=i(Je);la=a(fs,"XLNetTokenizer"),fs.forEach(o),ca=a(S,". Based on "),Te=s(S,"A",{href:!0,rel:!0});var hs=i(Te);da=a(hs,"BPE"),hs.forEach(o),ma=a(S,"."),S.forEach(o),ua=d(oe),ze=s(oe,"P",{});var Xo=i(ze);pa=a(Xo,"This tokenizer inherits from "),Ze=s(Xo,"A",{href:!0});var _s=i(Ze);fa=a(_s,"PreTrainedTokenizerFast"),_s.forEach(o),ha=a(Xo,` which contains most of the main
methods. Users should refer to this superclass for more information regarding those methods.`),Xo.forEach(o),_a=d(oe),Q=s(oe,"DIV",{class:!0});var Eo=i(Q);L(Me.$$.fragment,Eo),ga=d(Eo),Xt=s(Eo,"P",{});var gs=i(Xt);ya=a(gs,`Main method to tokenize and prepare for the model one or several sequence(s) or one or several pair(s) of
sequences with word-level normalized bounding boxes and optional labels.`),gs.forEach(o),Eo.forEach(o),oe.forEach(o),uo=d(t),V=s(t,"H2",{class:!0});var $o=i(V);ee=s($o,"A",{id:!0,class:!0,href:!0});var ys=i(ee);Et=s(ys,"SPAN",{});var vs=i(Et);L(Xe.$$.fragment,vs),vs.forEach(o),ys.forEach(o),va=d($o),$t=s($o,"SPAN",{});var Ls=i($t);La=a(Ls,"LayoutXLMProcessor"),Ls.forEach(o),$o.forEach(o),po=d(t),T=s(t,"DIV",{class:!0});var C=i(T);L(Ee.$$.fragment,C),ka=d(C),qt=s(C,"P",{});var ks=i(qt);ba=a(ks,`Constructs a LayoutXLM processor which combines a LayoutXLM feature extractor and a LayoutXLM tokenizer into a
single processor.`),ks.forEach(o),xa=d(C),Ke=s(C,"P",{});var Tr=i(Ke);Qe=s(Tr,"A",{href:!0});var bs=i(Qe);wa=a(bs,"LayoutXLMProcessor"),bs.forEach(o),Ta=a(Tr," offers all the functionalities you need to prepare data for the model."),Tr.forEach(o),za=d(C),_=s(C,"P",{});var g=i(_);Ma=a(g,"It first uses "),et=s(g,"A",{href:!0});var xs=i(et);Xa=a(xs,"LayoutLMv2FeatureExtractor"),xs.forEach(o),Ea=a(g,` to resize document images to a fixed size, and
optionally applies OCR to get words and normalized bounding boxes. These are then provided to
`),tt=s(g,"A",{href:!0});var ws=i(tt);$a=a(ws,"LayoutXLMTokenizer"),ws.forEach(o),qa=a(g," or "),ot=s(g,"A",{href:!0});var Ts=i(ot);Fa=a(Ts,"LayoutXLMTokenizerFast"),Ts.forEach(o),Pa=a(g,`, which turns the words
and bounding boxes into token-level `),Ft=s(g,"CODE",{});var zs=i(Ft);Na=a(zs,"input_ids"),zs.forEach(o),Aa=a(g,", "),Pt=s(g,"CODE",{});var Ms=i(Pt);Da=a(Ms,"attention_mask"),Ms.forEach(o),Ia=a(g,", "),Nt=s(g,"CODE",{});var Xs=i(Nt);Oa=a(Xs,"token_type_ids"),Xs.forEach(o),Sa=a(g,", "),At=s(g,"CODE",{});var Es=i(At);Ca=a(Es,"bbox"),Es.forEach(o),Ra=a(g,`.
Optionally, one can provide integer `),Dt=s(g,"CODE",{});var $s=i(Dt);Ua=a($s,"word_labels"),$s.forEach(o),ja=a(g,", which are turned into token-level "),It=s(g,"CODE",{});var qs=i(It);Va=a(qs,"labels"),qs.forEach(o),Ba=a(g,` for token
classification tasks (such as FUNSD, CORD).`),g.forEach(o),Wa=d(C),I=s(C,"DIV",{class:!0});var ct=i(I);L($e.$$.fragment,ct),Ha=d(ct),p=s(ct,"P",{});var f=i(p);Ga=a(f,"This method first forwards the "),Ot=s(f,"CODE",{});var Fs=i(Ot);Ya=a(Fs,"images"),Fs.forEach(o),Ja=a(f,` argument to
`),qe=s(f,"A",{href:!0});var zr=i(qe);St=s(zr,"STRONG",{});var Ps=i(St);Za=a(Ps,"call"),Ps.forEach(o),Ka=a(zr,"()"),zr.forEach(o),Qa=a(f,". In case "),nt=s(f,"A",{href:!0});var Ns=i(nt);er=a(Ns,"~LayoutLMv2FeatureExtractor"),Ns.forEach(o),tr=a(f,` was
initialized with `),Ct=s(f,"CODE",{});var As=i(Ct);or=a(As,"apply_ocr"),As.forEach(o),nr=a(f," set to "),Rt=s(f,"CODE",{});var Ds=i(Rt);ar=a(Ds,"True"),Ds.forEach(o),rr=a(f,`, it passes the obtained words and bounding boxes along with
the additional arguments to `),Fe=s(f,"A",{href:!0});var Mr=i(Fe);Ut=s(Mr,"STRONG",{});var Is=i(Ut);sr=a(Is,"call"),Is.forEach(o),ir=a(Mr,"()"),Mr.forEach(o),lr=a(f,` and returns the output, together
with resized `),jt=s(f,"CODE",{});var Os=i(jt);cr=a(Os,"images"),Os.forEach(o),dr=a(f,". In case "),at=s(f,"A",{href:!0});var Ss=i(at);mr=a(Ss,"~LayoutLMv2FeatureExtractor"),Ss.forEach(o),ur=a(f," was initialized with "),Vt=s(f,"CODE",{});var Cs=i(Vt);pr=a(Cs,"apply_ocr"),Cs.forEach(o),fr=a(f,`
set to `),Bt=s(f,"CODE",{});var Rs=i(Bt);hr=a(Rs,"False"),Rs.forEach(o),_r=a(f,", it passes the words ("),Wt=s(f,"CODE",{});var Us=i(Wt);gr=a(Us,"text"),Us.forEach(o),yr=a(f,"/"),Ht=s(f,"CODE",{});var js=i(Ht);vr=a(js,"text_pair`) and `boxes` specified by the user along with the additional arguments to [__call__()](/docs/transformers/master/en/model_doc/layoutxlm#transformers.LayoutXLMTokenizer.__call__) and returns the output, together with resized `images"),js.forEach(o),Lr=a(f,"."),f.forEach(o),kr=d(ct),Gt=s(ct,"P",{});var Vs=i(Gt);br=a(Vs,"Please refer to the docstring of the above two methods for more information."),Vs.forEach(o),ct.forEach(o),C.forEach(o),this.h()},h(){l(F,"name","hf:doc:metadata"),l(F,"content",JSON.stringify(Ks)),l($,"id","layoutxlm"),l($,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l($,"href","#layoutxlm"),l(E,"class","relative group"),l(W,"id","overview"),l(W,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(W,"href","#overview"),l(R,"class","relative group"),l(re,"href","https://arxiv.org/abs/2104.08836"),l(re,"rel","nofollow"),l(se,"href","https://arxiv.org/abs/2012.14740"),l(se,"rel","nofollow"),l(Ie,"href","/docs/transformers/master/en/model_doc/layoutxlm#transformers.LayoutXLMTokenizer"),l(Oe,"href","/docs/transformers/master/en/model_doc/layoutxlm#transformers.LayoutXLMTokenizerFast"),l(Se,"href","/docs/transformers/master/en/model_doc/layoutxlm#transformers.LayoutXLMProcessor"),l(Ce,"href","/docs/transformers/master/en/model_doc/layoutlmv2#transformers.LayoutLMv2FeatureExtractor"),l(Re,"href","/docs/transformers/master/en/model_doc/layoutxlm#transformers.LayoutXLMTokenizer"),l(Ue,"href","/docs/transformers/master/en/model_doc/layoutxlm#transformers.LayoutXLMTokenizerFast"),l(je,"href","/docs/transformers/master/en/layoutlmv2"),l(ce,"href","https://huggingface.co/nielsr"),l(ce,"rel","nofollow"),l(de,"href","https://github.com/microsoft/unilm"),l(de,"rel","nofollow"),l(G,"id","transformers.LayoutXLMTokenizer"),l(G,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(G,"href","#transformers.LayoutXLMTokenizer"),l(U,"class","relative group"),l(Ve,"href","/docs/transformers/master/en/model_doc/roberta#transformers.RobertaTokenizer"),l(Be,"href","/docs/transformers/master/en/model_doc/xlnet#transformers.XLNetTokenizer"),l(pe,"href","https://github.com/google/sentencepiece"),l(pe,"rel","nofollow"),l(We,"href","/docs/transformers/master/en/main_classes/tokenizer#transformers.PreTrainedTokenizer"),l(Y,"class","docstring"),l(D,"class","docstring"),l(J,"class","docstring"),l(Z,"class","docstring"),l(wt,"class","docstring"),l(h,"class","docstring"),l(K,"id","transformers.LayoutXLMTokenizerFast"),l(K,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(K,"href","#transformers.LayoutXLMTokenizerFast"),l(j,"class","relative group"),l(Ye,"href","/docs/transformers/master/en/model_doc/roberta#transformers.RobertaTokenizer"),l(Je,"href","/docs/transformers/master/en/model_doc/xlnet#transformers.XLNetTokenizer"),l(Te,"href","https://huggingface.co/docs/tokenizers/python/latest/components.html?highlight=BPE#models"),l(Te,"rel","nofollow"),l(Ze,"href","/docs/transformers/master/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast"),l(Q,"class","docstring"),l(M,"class","docstring"),l(ee,"id","transformers.LayoutXLMProcessor"),l(ee,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(ee,"href","#transformers.LayoutXLMProcessor"),l(V,"class","relative group"),l(Qe,"href","/docs/transformers/master/en/model_doc/layoutxlm#transformers.LayoutXLMProcessor"),l(et,"href","/docs/transformers/master/en/model_doc/layoutlmv2#transformers.LayoutLMv2FeatureExtractor"),l(tt,"href","/docs/transformers/master/en/model_doc/layoutxlm#transformers.LayoutXLMTokenizer"),l(ot,"href","/docs/transformers/master/en/model_doc/layoutxlm#transformers.LayoutXLMTokenizerFast"),l(qe,"href","/docs/transformers/master/en/model_doc/layoutlmv2#transformers.LayoutLMv2FeatureExtractor.__call__"),l(nt,"href","/docs/transformers/master/en/model_doc/layoutlmv2#transformers.LayoutLMv2FeatureExtractor"),l(Fe,"href","/docs/transformers/master/en/model_doc/layoutxlm#transformers.LayoutXLMTokenizer.__call__"),l(at,"href","/docs/transformers/master/en/model_doc/layoutlmv2#transformers.LayoutLMv2FeatureExtractor"),l(I,"class","docstring"),l(T,"class","docstring")},m(t,m){e(document.head,F),u(t,Pe,m),u(t,E,m),e(E,$),e($,dt),k(ne,dt,null),e(E,Fo),e(E,mt),e(mt,Po),u(t,Jt,m),u(t,R,m),e(R,W),e(W,ut),k(ae,ut,null),e(R,No),e(R,pt),e(pt,Ao),u(t,Zt,m),u(t,P,m),e(P,Do),e(P,re),e(re,Io),e(P,Oo),e(P,se),e(se,So),e(P,Co),u(t,Kt,m),u(t,Ne,m),e(Ne,Ro),u(t,Qt,m),u(t,Ae,m),e(Ae,ft),e(ft,Uo),u(t,eo,m),u(t,De,m),e(De,jo),u(t,to,m),k(ie,t,m),u(t,oo,m),u(t,N,m),e(N,Vo),e(N,Ie),e(Ie,Bo),e(N,Wo),e(N,Oe),e(Oe,Ho),e(N,Go),u(t,no,m),k(le,t,m),u(t,ao,m),u(t,z,m),e(z,Yo),e(z,Se),e(Se,Jo),e(z,Zo),e(z,Ce),e(Ce,Ko),e(z,Qo),e(z,Re),e(Re,en),e(z,tn),e(z,Ue),e(Ue,on),e(z,nn),u(t,ro,m),u(t,H,m),e(H,an),e(H,je),e(je,rn),e(H,sn),u(t,so,m),u(t,A,m),e(A,ln),e(A,ce),e(ce,cn),e(A,dn),e(A,de),e(de,mn),e(A,un),u(t,io,m),u(t,U,m),e(U,G),e(G,ht),k(me,ht,null),e(U,pn),e(U,_t),e(_t,fn),u(t,lo,m),u(t,h,m),k(ue,h,null),e(h,hn),e(h,q),e(q,_n),e(q,Ve),e(Ve,gn),e(q,yn),e(q,Be),e(Be,vn),e(q,Ln),e(q,pe),e(pe,kn),e(q,bn),e(h,xn),e(h,fe),e(fe,wn),e(fe,We),e(We,Tn),e(fe,zn),e(h,Mn),e(h,he),e(he,Xn),e(he,_e),e(_e,En),e(_e,gt),e(gt,$n),e(_e,qn),e(he,Fn),e(h,Pn),e(h,Y),k(ge,Y,null),e(Y,Nn),e(Y,yt),e(yt,An),e(h,Dn),e(h,D),k(ye,D,null),e(D,In),e(D,vt),e(vt,On),e(D,Sn),e(D,ve),e(ve,He),e(He,Cn),e(He,Lt),e(Lt,Rn),e(ve,Un),e(ve,Ge),e(Ge,jn),e(Ge,kt),e(kt,Vn),e(h,Bn),e(h,J),k(Le,J,null),e(J,Wn),e(J,ke),e(ke,Hn),e(ke,bt),e(bt,Gn),e(ke,Yn),e(h,Jn),e(h,Z),k(be,Z,null),e(Z,Zn),e(Z,xt),e(xt,Kn),e(h,Qn),e(h,wt),u(t,co,m),u(t,j,m),e(j,K),e(K,Tt),k(xe,Tt,null),e(j,ea),e(j,zt),e(zt,ta),u(t,mo,m),u(t,M,m),k(we,M,null),e(M,oa),e(M,X),e(X,na),e(X,Mt),e(Mt,aa),e(X,ra),e(X,Ye),e(Ye,sa),e(X,ia),e(X,Je),e(Je,la),e(X,ca),e(X,Te),e(Te,da),e(X,ma),e(M,ua),e(M,ze),e(ze,pa),e(ze,Ze),e(Ze,fa),e(ze,ha),e(M,_a),e(M,Q),k(Me,Q,null),e(Q,ga),e(Q,Xt),e(Xt,ya),u(t,uo,m),u(t,V,m),e(V,ee),e(ee,Et),k(Xe,Et,null),e(V,va),e(V,$t),e($t,La),u(t,po,m),u(t,T,m),k(Ee,T,null),e(T,ka),e(T,qt),e(qt,ba),e(T,xa),e(T,Ke),e(Ke,Qe),e(Qe,wa),e(Ke,Ta),e(T,za),e(T,_),e(_,Ma),e(_,et),e(et,Xa),e(_,Ea),e(_,tt),e(tt,$a),e(_,qa),e(_,ot),e(ot,Fa),e(_,Pa),e(_,Ft),e(Ft,Na),e(_,Aa),e(_,Pt),e(Pt,Da),e(_,Ia),e(_,Nt),e(Nt,Oa),e(_,Sa),e(_,At),e(At,Ca),e(_,Ra),e(_,Dt),e(Dt,Ua),e(_,ja),e(_,It),e(It,Va),e(_,Ba),e(T,Wa),e(T,I),k($e,I,null),e(I,Ha),e(I,p),e(p,Ga),e(p,Ot),e(Ot,Ya),e(p,Ja),e(p,qe),e(qe,St),e(St,Za),e(qe,Ka),e(p,Qa),e(p,nt),e(nt,er),e(p,tr),e(p,Ct),e(Ct,or),e(p,nr),e(p,Rt),e(Rt,ar),e(p,rr),e(p,Fe),e(Fe,Ut),e(Ut,sr),e(Fe,ir),e(p,lr),e(p,jt),e(jt,cr),e(p,dr),e(p,at),e(at,mr),e(p,ur),e(p,Vt),e(Vt,pr),e(p,fr),e(p,Bt),e(Bt,hr),e(p,_r),e(p,Wt),e(Wt,gr),e(p,yr),e(p,Ht),e(Ht,vr),e(p,Lr),e(I,kr),e(I,Gt),e(Gt,br),fo=!0},p:Js,i(t){fo||(b(ne.$$.fragment,t),b(ae.$$.fragment,t),b(ie.$$.fragment,t),b(le.$$.fragment,t),b(me.$$.fragment,t),b(ue.$$.fragment,t),b(ge.$$.fragment,t),b(ye.$$.fragment,t),b(Le.$$.fragment,t),b(be.$$.fragment,t),b(xe.$$.fragment,t),b(we.$$.fragment,t),b(Me.$$.fragment,t),b(Xe.$$.fragment,t),b(Ee.$$.fragment,t),b($e.$$.fragment,t),fo=!0)},o(t){x(ne.$$.fragment,t),x(ae.$$.fragment,t),x(ie.$$.fragment,t),x(le.$$.fragment,t),x(me.$$.fragment,t),x(ue.$$.fragment,t),x(ge.$$.fragment,t),x(ye.$$.fragment,t),x(Le.$$.fragment,t),x(be.$$.fragment,t),x(xe.$$.fragment,t),x(we.$$.fragment,t),x(Me.$$.fragment,t),x(Xe.$$.fragment,t),x(Ee.$$.fragment,t),x($e.$$.fragment,t),fo=!1},d(t){o(F),t&&o(Pe),t&&o(E),w(ne),t&&o(Jt),t&&o(R),w(ae),t&&o(Zt),t&&o(P),t&&o(Kt),t&&o(Ne),t&&o(Qt),t&&o(Ae),t&&o(eo),t&&o(De),t&&o(to),w(ie,t),t&&o(oo),t&&o(N),t&&o(no),w(le,t),t&&o(ao),t&&o(z),t&&o(ro),t&&o(H),t&&o(so),t&&o(A),t&&o(io),t&&o(U),w(me),t&&o(lo),t&&o(h),w(ue),w(ge),w(ye),w(Le),w(be),t&&o(co),t&&o(j),w(xe),t&&o(mo),t&&o(M),w(we),w(Me),t&&o(uo),t&&o(V),w(Xe),t&&o(po),t&&o(T),w(Ee),w($e)}}}const Ks={local:"layoutxlm",sections:[{local:"overview",title:"Overview"},{local:"transformers.LayoutXLMTokenizer",title:"LayoutXLMTokenizer"},{local:"transformers.LayoutXLMTokenizerFast",title:"LayoutXLMTokenizerFast"},{local:"transformers.LayoutXLMProcessor",title:"LayoutXLMProcessor"}],title:"LayoutXLM"};function Qs(qo,F,Pe){let{fw:E}=F;return qo.$$set=$=>{"fw"in $&&Pe(0,E=$.fw)},[E]}class ri extends Ws{constructor(F){super();Hs(this,F,Qs,Zs,Gs,{fw:0})}}export{ri as default,Ks as metadata};
