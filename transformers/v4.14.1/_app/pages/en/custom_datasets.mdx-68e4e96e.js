import{S as dm,i as cm,s as mm,e as l,k as f,w as d,t as n,L as _m,c as i,d as t,m as h,a as p,x as c,h as o,b as u,J as s,g as r,y as m,q as _,o as w,B as g}from"../../chunks/vendor-b1433968.js";import{T as Su}from"../../chunks/Tip-c3840994.js";import{I as z}from"../../chunks/IconCopyLink-7029626d.js";import{C as $}from"../../chunks/CodeBlock-a320dbd7.js";import{C as wm}from"../../chunks/ColabDropdown-727dc22f.js";import"../../chunks/CopyButton-f65cb278.js";function gm(G){let b,E,k,y,q,v,P,T;return{c(){b=l("p"),E=n(`For a more in-depth example of how to fine-tune a model for text classification, take a look at the corresponding
`),k=l("a"),y=n("PyTorch notebook"),q=n(`
or `),v=l("a"),P=n("TensorFlow notebook"),T=n("."),this.h()},l(j){b=i(j,"P",{});var x=p(b);E=o(x,`For a more in-depth example of how to fine-tune a model for text classification, take a look at the corresponding
`),k=i(x,"A",{href:!0,rel:!0});var A=p(k);y=o(A,"PyTorch notebook"),A.forEach(t),q=o(x,`
or `),v=i(x,"A",{href:!0,rel:!0});var C=p(v);P=o(C,"TensorFlow notebook"),C.forEach(t),T=o(x,"."),x.forEach(t),this.h()},h(){u(k,"href","https://colab.research.google.com/github/huggingface/notebooks/blob/master/examples/text_classification.ipynb"),u(k,"rel","nofollow"),u(v,"href","https://colab.research.google.com/github/huggingface/notebooks/blob/master/examples/text_classification-tf.ipynb"),u(v,"rel","nofollow")},m(j,x){r(j,b,x),s(b,E),s(b,k),s(k,y),s(b,q),s(b,v),s(v,P),s(b,T)},d(j){j&&t(b)}}}function $m(G){let b,E,k,y,q,v,P,T;return{c(){b=l("p"),E=n(`For a more in-depth example of how to fine-tune a model for token classification, take a look at the corresponding
`),k=l("a"),y=n("PyTorch notebook"),q=n(`
or `),v=l("a"),P=n("TensorFlow notebook"),T=n("."),this.h()},l(j){b=i(j,"P",{});var x=p(b);E=o(x,`For a more in-depth example of how to fine-tune a model for token classification, take a look at the corresponding
`),k=i(x,"A",{href:!0,rel:!0});var A=p(k);y=o(A,"PyTorch notebook"),A.forEach(t),q=o(x,`
or `),v=i(x,"A",{href:!0,rel:!0});var C=p(v);P=o(C,"TensorFlow notebook"),C.forEach(t),T=o(x,"."),x.forEach(t),this.h()},h(){u(k,"href","https://colab.research.google.com/github/huggingface/notebooks/blob/master/examples/token_classification.ipynb"),u(k,"rel","nofollow"),u(v,"href","https://colab.research.google.com/github/huggingface/notebooks/blob/master/examples/token_classification-tf.ipynb"),u(v,"rel","nofollow")},m(j,x){r(j,b,x),s(b,E),s(b,k),s(k,y),s(b,q),s(b,v),s(v,P),s(b,T)},d(j){j&&t(b)}}}function bm(G){let b,E,k,y,q,v,P,T;return{c(){b=l("p"),E=n(`For a more in-depth example of how to fine-tune a model for question answering, take a look at the corresponding
`),k=l("a"),y=n("PyTorch notebook"),q=n(`
or `),v=l("a"),P=n("TensorFlow notebook"),T=n("."),this.h()},l(j){b=i(j,"P",{});var x=p(b);E=o(x,`For a more in-depth example of how to fine-tune a model for question answering, take a look at the corresponding
`),k=i(x,"A",{href:!0,rel:!0});var A=p(k);y=o(A,"PyTorch notebook"),A.forEach(t),q=o(x,`
or `),v=i(x,"A",{href:!0,rel:!0});var C=p(v);P=o(C,"TensorFlow notebook"),C.forEach(t),T=o(x,"."),x.forEach(t),this.h()},h(){u(k,"href","https://colab.research.google.com/github/huggingface/notebooks/blob/master/examples/question_answering.ipynb"),u(k,"rel","nofollow"),u(v,"href","https://colab.research.google.com/github/huggingface/notebooks/blob/master/examples/question_answering-tf.ipynb"),u(v,"rel","nofollow")},m(j,x){r(j,b,x),s(b,E),s(b,k),s(k,y),s(b,q),s(b,v),s(v,P),s(b,T)},d(j){j&&t(b)}}}function km(G){let b,E,k,y,q,v,P,T,j,x,A,C,Es,gi,to,ue,$i,st,bi,ki,so,at,ao,qs,vi,no,N,Da,Ts,xi,yi,Sa,As,ji,Ei,Ia,zs,qi,oo,Ps,ro,J,de,Na,nt,Ti,Ma,Ai,lo,ce,zi,ot,Pi,Fi,io,me,po,K,_e,La,rt,Ci,Ba,Di,fo,Fs,Si,ho,lt,uo,we,Ii,Oa,Ni,Mi,co,it,mo,X,ge,Ha,pt,Li,Wa,Bi,_o,M,Oi,Cs,Hi,Wi,ft,Qi,Ri,wo,ht,go,Ds,Ui,$o,ut,bo,L,Vi,Qa,Yi,Gi,Ra,Ji,Ki,ko,dt,vo,F,Xi,Ua,Zi,ep,Va,tp,sp,Ya,ap,np,Ga,op,rp,xo,ct,yo,Z,$e,Ja,mt,lp,Ka,ip,jo,be,pp,Ss,fp,hp,Eo,_t,qo,Is,up,To,B,wt,dp,Ns,cp,mp,_p,gt,wp,Ms,gp,$p,bp,$t,kp,Xa,vp,xp,Ao,bt,zo,ee,ke,Za,kt,yp,en,jp,Po,Ls,Ep,Fo,D,qp,Bs,Tp,Ap,tn,zp,Pp,sn,Fp,Cp,Co,vt,Do,S,Dp,an,Sp,Ip,nn,Np,Mp,on,Lp,Bp,So,xt,Io,Os,Op,No,yt,Mo,ve,Hp,Hs,Wp,Qp,Lo,jt,Bo,Ws,Rp,Oo,Et,Ho,xe,Up,rn,Vp,Yp,Wo,qt,Qo,Qs,Ro,te,ye,ln,Tt,Gp,pn,Jp,Uo,je,Kp,At,Xp,Zp,Vo,Ee,Yo,se,qe,fn,zt,ef,hn,tf,Go,Rs,sf,Jo,Pt,Ko,Us,af,Xo,Ft,Zo,Vs,nf,er,Ct,tr,Ys,of,sr,O,Gs,un,rf,lf,pf,H,dn,ff,hf,cn,uf,df,mn,cf,mf,_f,Js,_n,wf,gf,ar,ae,Te,wn,Dt,$f,gn,bf,nr,Ae,kf,Ks,vf,xf,or,St,rr,ze,yf,$n,jf,Ef,lr,It,ir,W,qf,bn,Tf,Af,kn,zf,Pf,pr,Q,Nt,Ff,vn,Cf,Df,Sf,ne,If,xn,Nf,Mf,yn,Lf,Bf,Of,Mt,Hf,jn,Wf,Qf,fr,Xs,Rf,hr,Lt,ur,Pe,Uf,En,Vf,Yf,dr,Bt,cr,Zs,Gf,mr,Ot,_r,oe,Fe,qn,Ht,Jf,Tn,Kf,wr,Ce,Xf,ea,Zf,eh,gr,Wt,$r,De,th,ta,sh,ah,br,Qt,kr,Se,nh,sa,oh,rh,vr,Rt,xr,aa,lh,yr,Ut,jr,re,Ie,An,Vt,ih,zn,ph,Er,na,fh,qr,Yt,Tr,R,hh,Pn,uh,dh,Fn,ch,mh,Ar,Gt,zr,Ne,_h,oa,wh,gh,Pr,Jt,Fr,ra,$h,Cr,Kt,Dr,la,bh,Sr,Xt,Ir,Me,kh,Cn,vh,xh,Nr,Zt,Mr,ia,Lr,le,Le,Dn,es,yh,Sn,jh,Br,Be,Eh,ts,qh,Th,Or,Oe,Hr,ie,He,In,ss,Ah,Nn,zh,Wr,pa,Ph,Qr,as,Rr,fa,Fh,Ur,ns,Vr,pe,We,Mn,os,Ch,Ln,Dh,Yr,Qe,Sh,ha,Ih,Nh,Gr,rs,Jr,ua,Mh,Kr,U,I,Lh,Bn,Bh,Oh,On,Hh,Wh,Hn,Qh,Rh,Uh,ls,Vh,Wn,Yh,Gh,Jh,is,Kh,Qn,Xh,Zh,Xr,da,eu,Zr,ps,el,Re,tu,Rn,su,au,tl,fs,sl,ca,nu,al,hs,nl,fe,Ue,Un,us,ou,Vn,ru,ol,Ve,lu,ma,iu,pu,rl,ds,ll,Ye,fu,_a,hu,uu,il,cs,pl,Ge,du,wa,cu,mu,fl,ms,hl,ga,_u,ul,_s,dl,he,Je,Yn,ws,wu,Gn,gu,cl,$a,$u,ml,gs,_l,V,bu,Jn,ku,vu,Kn,xu,yu,wl,$s,gl,ba,ju,$l,bs,bl,Ke,Eu,ka,qu,Tu,kl,ks,vl,va,Au,xl,vs,yl,Xe,zu,Xn,Pu,Fu,jl,xs,El;return v=new z({}),A=new wm({props:{"hydrate-props":{classNames:"absolute z-10 right-0 top-0",options:[{label:"Mixed",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/transformers_doc/custom_datasets.ipynb"},{label:"PyTorch",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/transformers_doc/pytorch/custom_datasets.ipynb"},{label:"TensorFlow",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/transformers_doc/tensorflow/custom_datasets.ipynb"}]}}}),at=new $({props:{code:"pip install datasets,",highlighted:"pip install datasets"}}),nt=new z({}),me=new Su({props:{$$slots:{default:[gm]},$$scope:{ctx:G}}}),rt=new z({}),lt=new $({props:{code:`from datasets import load_dataset
imdb = load_dataset("imdb"),`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
imdb = load_dataset(<span class="hljs-string">&quot;imdb&quot;</span>)`}}),it=new $({props:{code:`imdb["train"][0]
{'label': 1,
 'text': 'Bromwell High is a cartoon comedy. It ran at the same time as some other programs about school life, such as "Teachers". My 35 years in the teaching profession lead me to believe that Bromwell High\\'s satire is much closer to reality than is "Teachers". The scramble to survive financially, the insightful students who can see right through their pathetic teachers\\' pomp, the pettiness of the whole situation, all remind me of the schools I knew and their students. When I saw the episode in which a student repeatedly tried to burn down the school, I immediately recalled ......... at .......... High. A classic line: INSPECTOR: I\\'m here to sack one of your teachers. STUDENT: Welcome to Bromwell High. I expect that many adults of my age think that Bromwell High is far fetched. What a pity that it isn\\'t!'
},`,highlighted:`imdb[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>]
{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-number">1</span>,
 <span class="hljs-string">&#x27;text&#x27;</span>: <span class="hljs-string">&#x27;Bromwell High is a cartoon comedy. It ran at the same time as some other programs about school life, such as &quot;Teachers&quot;. My 35 years in the teaching profession lead me to believe that Bromwell High\\&#x27;s satire is much closer to reality than is &quot;Teachers&quot;. The scramble to survive financially, the insightful students who can see right through their pathetic teachers\\&#x27; pomp, the pettiness of the whole situation, all remind me of the schools I knew and their students. When I saw the episode in which a student repeatedly tried to burn down the school, I immediately recalled ......... at .......... High. A classic line: INSPECTOR: I\\&#x27;m here to sack one of your teachers. STUDENT: Welcome to Bromwell High. I expect that many adults of my age think that Bromwell High is far fetched. What a pity that it isn\\&#x27;t!&#x27;</span>
}`}}),pt=new z({}),ht=new $({props:{code:`from transformers import AutoTokenizer
tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased"),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)`}}),ut=new $({props:{code:`def preprocess_function(examples):
    return tokenizer(examples["text"], truncation=True),`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess_function</span>(<span class="hljs-params">examples</span>):
    <span class="hljs-keyword">return</span> tokenizer(examples[<span class="hljs-string">&quot;text&quot;</span>], truncation=<span class="hljs-literal">True</span>)`}}),dt=new $({props:{code:"tokenized_imdb = imdb.map(preprocess_function, batched=True),",highlighted:'tokenized_imdb = imdb.<span class="hljs-built_in">map</span>(preprocess_function, batched=<span class="hljs-literal">True</span>)'}}),ct=new $({props:{code:`from transformers import DataCollatorWithPadding
data_collator = DataCollatorWithPadding(tokenizer=tokenizer),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DataCollatorWithPadding
data_collator = DataCollatorWithPadding(tokenizer=tokenizer)`}}),mt=new z({}),_t=new $({props:{code:`from transformers import AutoModelForSequenceClassification
model = AutoModelForSequenceClassification.from_pretrained("distilbert-base-uncased", num_labels=2),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification
model = AutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>, num_labels=<span class="hljs-number">2</span>)`}}),bt=new $({props:{code:`from transformers import TrainingArguments, Trainer

training_args = TrainingArguments(
    output_dir='./results',
    learning_rate=2e-5,
    per_device_train_batch_size=16,
    per_device_eval_batch_size=16,
    num_train_epochs=5,
    weight_decay=0.01,
)

trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=tokenized_imdb["train"],
    eval_dataset=tokenized_imdb["test"],
    tokenizer=tokenizer,
    data_collator=data_collator,
)

trainer.train(),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments, Trainer

training_args = TrainingArguments(
    output_dir=<span class="hljs-string">&#x27;./results&#x27;</span>,
    learning_rate=<span class="hljs-number">2e-5</span>,
    per_device_train_batch_size=<span class="hljs-number">16</span>,
    per_device_eval_batch_size=<span class="hljs-number">16</span>,
    num_train_epochs=<span class="hljs-number">5</span>,
    weight_decay=<span class="hljs-number">0.01</span>,
)

trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=tokenized_imdb[<span class="hljs-string">&quot;train&quot;</span>],
    eval_dataset=tokenized_imdb[<span class="hljs-string">&quot;test&quot;</span>],
    tokenizer=tokenizer,
    data_collator=data_collator,
)

trainer.train()`}}),kt=new z({}),vt=new $({props:{code:`from transformers import DataCollatorWithPadding
data_collator = DataCollatorWithPadding(tokenizer, return_tensors="tf"),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DataCollatorWithPadding
data_collator = DataCollatorWithPadding(tokenizer, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)`}}),xt=new $({props:{code:`tf_train_dataset = tokenized_imdb["train"].to_tf_dataset(
    columns=['attention_mask', 'input_ids', 'label'],
    shuffle=True,
    batch_size=16,
    collate_fn=data_collator,
)

tf_validation_dataset = tokenized_imdb["train"].to_tf_dataset(
    columns=['attention_mask', 'input_ids', 'label'],
    shuffle=False,
    batch_size=16,
    collate_fn=data_collator,
),`,highlighted:`tf_train_dataset = tokenized_imdb[<span class="hljs-string">&quot;train&quot;</span>].to_tf_dataset(
    columns=[<span class="hljs-string">&#x27;attention_mask&#x27;</span>, <span class="hljs-string">&#x27;input_ids&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>],
    shuffle=<span class="hljs-literal">True</span>,
    batch_size=<span class="hljs-number">16</span>,
    collate_fn=data_collator,
)

tf_validation_dataset = tokenized_imdb[<span class="hljs-string">&quot;train&quot;</span>].to_tf_dataset(
    columns=[<span class="hljs-string">&#x27;attention_mask&#x27;</span>, <span class="hljs-string">&#x27;input_ids&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>],
    shuffle=<span class="hljs-literal">False</span>,
    batch_size=<span class="hljs-number">16</span>,
    collate_fn=data_collator,
)`}}),yt=new $({props:{code:`from transformers import create_optimizer
import tensorflow as tf

batch_size = 16
num_epochs = 5
batches_per_epoch = len(tokenized_imdb["train"]) // batch_size
total_train_steps = int(batches_per_epoch * num_epochs)
optimizer, schedule = create_optimizer(
    init_lr=2e-5, 
    num_warmup_steps=0, 
    num_train_steps=total_train_steps
),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> create_optimizer
<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

batch_size = <span class="hljs-number">16</span>
num_epochs = <span class="hljs-number">5</span>
batches_per_epoch = <span class="hljs-built_in">len</span>(tokenized_imdb[<span class="hljs-string">&quot;train&quot;</span>]) // batch_size
total_train_steps = <span class="hljs-built_in">int</span>(batches_per_epoch * num_epochs)
optimizer, schedule = create_optimizer(
    init_lr=<span class="hljs-number">2e-5</span>, 
    num_warmup_steps=<span class="hljs-number">0</span>, 
    num_train_steps=total_train_steps
)`}}),jt=new $({props:{code:`from transformers import TFAutoModelForSequenceClassification
model = TFAutoModelForSequenceClassification.from_pretrained("distilbert-base-uncased", num_labels=2),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForSequenceClassification
model = TFAutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>, num_labels=<span class="hljs-number">2</span>)`}}),Et=new $({props:{code:`import tensorflow as tf
model.compile(optimizer=optimizer),`,highlighted:`<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
model.<span class="hljs-built_in">compile</span>(optimizer=optimizer)`}}),qt=new $({props:{code:`model.fit(
    tf_train_set,
    validation_data=tf_validation_set,
    epochs=num_train_epochs,
),`,highlighted:`model.fit(
    tf_train_set,
    validation_data=tf_validation_set,
    epochs=num_train_epochs,
)`}}),Tt=new z({}),Ee=new Su({props:{$$slots:{default:[$m]},$$scope:{ctx:G}}}),zt=new z({}),Pt=new $({props:{code:`from datasets import load_dataset
wnut = load_dataset("wnut_17"),`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
wnut = load_dataset(<span class="hljs-string">&quot;wnut_17&quot;</span>)`}}),Ft=new $({props:{code:`wnut["train"][0]
{'id': '0',
 'ner_tags': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0],
 'tokens': ['@paulwalk', 'It', "'s", 'the', 'view', 'from', 'where', 'I', "'m", 'living', 'for', 'two', 'weeks', '.', 'Empire', 'State', 'Building', '=', 'ESB', '.', 'Pretty', 'bad', 'storm', 'here', 'last', 'evening', '.']
},`,highlighted:`wnut[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>]
{<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;0&#x27;</span>,
 <span class="hljs-string">&#x27;ner_tags&#x27;</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
 <span class="hljs-string">&#x27;tokens&#x27;</span>: [<span class="hljs-string">&#x27;@paulwalk&#x27;</span>, <span class="hljs-string">&#x27;It&#x27;</span>, <span class="hljs-string">&quot;&#x27;s&quot;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;view&#x27;</span>, <span class="hljs-string">&#x27;from&#x27;</span>, <span class="hljs-string">&#x27;where&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&quot;&#x27;m&quot;</span>, <span class="hljs-string">&#x27;living&#x27;</span>, <span class="hljs-string">&#x27;for&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;weeks&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;Empire&#x27;</span>, <span class="hljs-string">&#x27;State&#x27;</span>, <span class="hljs-string">&#x27;Building&#x27;</span>, <span class="hljs-string">&#x27;=&#x27;</span>, <span class="hljs-string">&#x27;ESB&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;Pretty&#x27;</span>, <span class="hljs-string">&#x27;bad&#x27;</span>, <span class="hljs-string">&#x27;storm&#x27;</span>, <span class="hljs-string">&#x27;here&#x27;</span>, <span class="hljs-string">&#x27;last&#x27;</span>, <span class="hljs-string">&#x27;evening&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>]
}`}}),Ct=new $({props:{code:`label_list = wnut["train"].features[f"ner_tags"].feature.names
label_list
['O',
 'B-corporation',
 'I-corporation',
 'B-creative-work',
 'I-creative-work',
 'B-group',
 'I-group',
 'B-location',
 'I-location',
 'B-person',
 'I-person',
 'B-product',
 'I-product'
],`,highlighted:`label_list = wnut[<span class="hljs-string">&quot;train&quot;</span>].features[<span class="hljs-string">f&quot;ner_tags&quot;</span>].feature.names
label_list
[<span class="hljs-string">&#x27;O&#x27;</span>,
 <span class="hljs-string">&#x27;B-corporation&#x27;</span>,
 <span class="hljs-string">&#x27;I-corporation&#x27;</span>,
 <span class="hljs-string">&#x27;B-creative-work&#x27;</span>,
 <span class="hljs-string">&#x27;I-creative-work&#x27;</span>,
 <span class="hljs-string">&#x27;B-group&#x27;</span>,
 <span class="hljs-string">&#x27;I-group&#x27;</span>,
 <span class="hljs-string">&#x27;B-location&#x27;</span>,
 <span class="hljs-string">&#x27;I-location&#x27;</span>,
 <span class="hljs-string">&#x27;B-person&#x27;</span>,
 <span class="hljs-string">&#x27;I-person&#x27;</span>,
 <span class="hljs-string">&#x27;B-product&#x27;</span>,
 <span class="hljs-string">&#x27;I-product&#x27;</span>
]`}}),Dt=new z({}),St=new $({props:{code:`from transformers import AutoTokenizer
tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased"),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)`}}),It=new $({props:{code:`tokenized_input = tokenizer(example["tokens"], is_split_into_words=True)
tokens = tokenizer.convert_ids_to_tokens(tokenized_input["input_ids"])
tokens
['[CLS]', '@', 'paul', '##walk', 'it', "'", 's', 'the', 'view', 'from', 'where', 'i', "'", 'm', 'living', 'for', 'two', 'weeks', '.', 'empire', 'state', 'building', '=', 'es', '##b', '.', 'pretty', 'bad', 'storm', 'here', 'last', 'evening', '.', '[SEP]'],`,highlighted:`tokenized_input = tokenizer(example[<span class="hljs-string">&quot;tokens&quot;</span>], is_split_into_words=<span class="hljs-literal">True</span>)
tokens = tokenizer.convert_ids_to_tokens(tokenized_input[<span class="hljs-string">&quot;input_ids&quot;</span>])
tokens
[<span class="hljs-string">&#x27;[CLS]&#x27;</span>, <span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;paul&#x27;</span>, <span class="hljs-string">&#x27;##walk&#x27;</span>, <span class="hljs-string">&#x27;it&#x27;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;view&#x27;</span>, <span class="hljs-string">&#x27;from&#x27;</span>, <span class="hljs-string">&#x27;where&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;living&#x27;</span>, <span class="hljs-string">&#x27;for&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;weeks&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;empire&#x27;</span>, <span class="hljs-string">&#x27;state&#x27;</span>, <span class="hljs-string">&#x27;building&#x27;</span>, <span class="hljs-string">&#x27;=&#x27;</span>, <span class="hljs-string">&#x27;es&#x27;</span>, <span class="hljs-string">&#x27;##b&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;pretty&#x27;</span>, <span class="hljs-string">&#x27;bad&#x27;</span>, <span class="hljs-string">&#x27;storm&#x27;</span>, <span class="hljs-string">&#x27;here&#x27;</span>, <span class="hljs-string">&#x27;last&#x27;</span>, <span class="hljs-string">&#x27;evening&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;[SEP]&#x27;</span>]`}}),Lt=new $({props:{code:`def tokenize_and_align_labels(examples):
    tokenized_inputs = tokenizer(examples["tokens"], truncation=True, is_split_into_words=True)

    labels = []
    for i, label in enumerate(examples[f"ner_tags"]):
        word_ids = tokenized_inputs.word_ids(batch_index=i)  # Map tokens to their respective word.
        previous_word_idx = None
        label_ids = []
        for word_idx in word_ids:                            # Set the special tokens to -100.
            if word_idx is None:
                label_ids.append(-100)
            elif word_idx != previous_word_idx:              # Only label the first token of a given word.
                label_ids.append(label[word_idx])

        labels.append(label_ids)

    tokenized_inputs["labels"] = labels
    return tokenized_inputs,`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_and_align_labels</span>(<span class="hljs-params">examples</span>):
    tokenized_inputs = tokenizer(examples[<span class="hljs-string">&quot;tokens&quot;</span>], truncation=<span class="hljs-literal">True</span>, is_split_into_words=<span class="hljs-literal">True</span>)

    labels = []
    <span class="hljs-keyword">for</span> i, label <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(examples[<span class="hljs-string">f&quot;ner_tags&quot;</span>]):
        word_ids = tokenized_inputs.word_ids(batch_index=i)  <span class="hljs-comment"># Map tokens to their respective word.</span>
        previous_word_idx = <span class="hljs-literal">None</span>
        label_ids = []
        <span class="hljs-keyword">for</span> word_idx <span class="hljs-keyword">in</span> word_ids:                            <span class="hljs-comment"># Set the special tokens to -100.</span>
            <span class="hljs-keyword">if</span> word_idx <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                label_ids.append(-<span class="hljs-number">100</span>)
            <span class="hljs-keyword">elif</span> word_idx != previous_word_idx:              <span class="hljs-comment"># Only label the first token of a given word.</span>
                label_ids.append(label[word_idx])

        labels.append(label_ids)

    tokenized_inputs[<span class="hljs-string">&quot;labels&quot;</span>] = labels
    <span class="hljs-keyword">return</span> tokenized_inputs`}}),Bt=new $({props:{code:"tokenized_wnut = wnut.map(tokenize_and_align_labels, batched=True),",highlighted:'tokenized_wnut = wnut.<span class="hljs-built_in">map</span>(tokenize_and_align_labels, batched=<span class="hljs-literal">True</span>)'}}),Ot=new $({props:{code:`from transformers import DataCollatorForTokenClassification
data_collator = DataCollatorForTokenClassification(tokenizer),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DataCollatorForTokenClassification
data_collator = DataCollatorForTokenClassification(tokenizer)`}}),Ht=new z({}),Wt=new $({props:{code:`from transformers import AutoModelForTokenClassification, TrainingArguments, Trainer
model = AutoModelForTokenClassification.from_pretrained("distilbert-base-uncased", num_labels=len(label_list)),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForTokenClassification, TrainingArguments, Trainer
model = AutoModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>, num_labels=<span class="hljs-built_in">len</span>(label_list))`}}),Qt=new $({props:{code:`training_args = TrainingArguments(
    output_dir='./results',
    evaluation_strategy="epoch",
    learning_rate=2e-5,
    per_device_train_batch_size=16,
    per_device_eval_batch_size=16,
    num_train_epochs=3,
    weight_decay=0.01,
),`,highlighted:`training_args = TrainingArguments(
    output_dir=<span class="hljs-string">&#x27;./results&#x27;</span>,
    evaluation_strategy=<span class="hljs-string">&quot;epoch&quot;</span>,
    learning_rate=<span class="hljs-number">2e-5</span>,
    per_device_train_batch_size=<span class="hljs-number">16</span>,
    per_device_eval_batch_size=<span class="hljs-number">16</span>,
    num_train_epochs=<span class="hljs-number">3</span>,
    weight_decay=<span class="hljs-number">0.01</span>,
)`}}),Rt=new $({props:{code:`trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=tokenized_wnut["train"],
    eval_dataset=tokenized_wnut["test"],
    data_collator=data_collator,
    tokenizer=tokenizer,
),`,highlighted:`trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=tokenized_wnut[<span class="hljs-string">&quot;train&quot;</span>],
    eval_dataset=tokenized_wnut[<span class="hljs-string">&quot;test&quot;</span>],
    data_collator=data_collator,
    tokenizer=tokenizer,
)`}}),Ut=new $({props:{code:"trainer.train(),",highlighted:"trainer.train()"}}),Vt=new z({}),Yt=new $({props:{code:`from transformers import DataCollatorForTokenClassification
data_collator = DataCollatorForTokenClassification(tokenizer, return_tensors="tf"),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DataCollatorForTokenClassification
data_collator = DataCollatorForTokenClassification(tokenizer, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)`}}),Gt=new $({props:{code:`tf_train_set = tokenized_wnut["train"].to_tf_dataset(
    columns=["attention_mask", "input_ids", "labels"],
    shuffle=True,
    batch_size=16,
    collate_fn=data_collator,
)

tf_validation_set = tokenized_wnut["validation"].to_tf_dataset(
    columns=["attention_mask", "input_ids", "labels"],
    shuffle=False,
    batch_size=16,
    collate_fn=data_collator,
),`,highlighted:`tf_train_set = tokenized_wnut[<span class="hljs-string">&quot;train&quot;</span>].to_tf_dataset(
    columns=[<span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;labels&quot;</span>],
    shuffle=<span class="hljs-literal">True</span>,
    batch_size=<span class="hljs-number">16</span>,
    collate_fn=data_collator,
)

tf_validation_set = tokenized_wnut[<span class="hljs-string">&quot;validation&quot;</span>].to_tf_dataset(
    columns=[<span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;labels&quot;</span>],
    shuffle=<span class="hljs-literal">False</span>,
    batch_size=<span class="hljs-number">16</span>,
    collate_fn=data_collator,
)`}}),Jt=new $({props:{code:`from transformers import TFAutoModelForTokenClassification
model = TFAutoModelForTokenClassification.from_pretrained("distilbert-base-uncased", num_labels=len(label_list)),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForTokenClassification
model = TFAutoModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>, num_labels=<span class="hljs-built_in">len</span>(label_list))`}}),Kt=new $({props:{code:`from transformers import create_optimizer

batch_size = 16
num_train_epochs = 3
num_train_steps = (len(tokenized_datasets["train"]) // batch_size) * num_train_epochs
optimizer, lr_schedule = create_optimizer(
    init_lr=2e-5,
    num_train_steps=num_train_steps,
    weight_decay_rate=0.01,
    num_warmup_steps=0,
),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> create_optimizer

batch_size = <span class="hljs-number">16</span>
num_train_epochs = <span class="hljs-number">3</span>
num_train_steps = (<span class="hljs-built_in">len</span>(tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>]) // batch_size) * num_train_epochs
optimizer, lr_schedule = create_optimizer(
    init_lr=<span class="hljs-number">2e-5</span>,
    num_train_steps=num_train_steps,
    weight_decay_rate=<span class="hljs-number">0.01</span>,
    num_warmup_steps=<span class="hljs-number">0</span>,
)`}}),Xt=new $({props:{code:`import tensorflow as tf
model.compile(optimizer=optimizer),`,highlighted:`<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
model.<span class="hljs-built_in">compile</span>(optimizer=optimizer)`}}),Zt=new $({props:{code:`model.fit(
    tf_train_set,
    validation_data=tf_validation_set,
    epochs=num_train_epochs,
),`,highlighted:`model.fit(
    tf_train_set,
    validation_data=tf_validation_set,
    epochs=num_train_epochs,
)`}}),es=new z({}),Oe=new Su({props:{$$slots:{default:[bm]},$$scope:{ctx:G}}}),ss=new z({}),as=new $({props:{code:`from datasets import load_dataset
squad = load_dataset("squad"),`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
squad = load_dataset(<span class="hljs-string">&quot;squad&quot;</span>)`}}),ns=new $({props:{code:`squad["train"][0]
{'answers': {'answer_start': [515], 'text': ['Saint Bernadette Soubirous']},
 'context': 'Architecturally, the school has a Catholic character. Atop the Main Building\\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend "Venite Ad Me Omnes". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive (and in a direct line that connects through 3 statues and the Gold Dome), is a simple, modern stone statue of Mary.',
 'id': '5733be284776f41900661182',
 'question': 'To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France?',
 'title': 'University_of_Notre_Dame'
},`,highlighted:`squad[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>]
{<span class="hljs-string">&#x27;answers&#x27;</span>: {<span class="hljs-string">&#x27;answer_start&#x27;</span>: [<span class="hljs-number">515</span>], <span class="hljs-string">&#x27;text&#x27;</span>: [<span class="hljs-string">&#x27;Saint Bernadette Soubirous&#x27;</span>]},
 <span class="hljs-string">&#x27;context&#x27;</span>: <span class="hljs-string">&#x27;Architecturally, the school has a Catholic character. Atop the Main Building\\&#x27;s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend &quot;Venite Ad Me Omnes&quot;. Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive (and in a direct line that connects through 3 statues and the Gold Dome), is a simple, modern stone statue of Mary.&#x27;</span>,
 <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;5733be284776f41900661182&#x27;</span>,
 <span class="hljs-string">&#x27;question&#x27;</span>: <span class="hljs-string">&#x27;To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France?&#x27;</span>,
 <span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;University_of_Notre_Dame&#x27;</span>
}`}}),os=new z({}),rs=new $({props:{code:`from transformers import AutoTokenizer
tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased"),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)`}}),ps=new $({props:{code:`def preprocess_function(examples):
    questions = [q.strip() for q in examples["question"]]
    inputs = tokenizer(
        questions,
        examples["context"],
        max_length=384,
        truncation="only_second",
        return_offsets_mapping=True,
        padding="max_length",
    )

    offset_mapping = inputs.pop("offset_mapping")
    answers = examples["answers"]
    start_positions = []
    end_positions = []

    for i, offset in enumerate(offset_mapping):
        answer = answers[i]
        start_char = answer["answer_start"][0]
        end_char = answer["answer_start"][0] + len(answer["text"][0])
        sequence_ids = inputs.sequence_ids(i)

        # Find the start and end of the context
        idx = 0
        while sequence_ids[idx] != 1:
            idx += 1
        context_start = idx
        while sequence_ids[idx] == 1:
            idx += 1
        context_end = idx - 1

        # If the answer is not fully inside the context, label it (0, 0)
        if offset[context_start][0] > end_char or offset[context_end][1] < start_char:
            start_positions.append(0)
            end_positions.append(0)
        else:
            # Otherwise it's the start and end token positions
            idx = context_start
            while idx <= context_end and offset[idx][0] <= start_char:
                idx += 1
            start_positions.append(idx - 1)

            idx = context_end
            while idx >= context_start and offset[idx][1] >= end_char:
                idx -= 1
            end_positions.append(idx + 1)

    inputs["start_positions"] = start_positions
    inputs["end_positions"] = end_positions
    return inputs,`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess_function</span>(<span class="hljs-params">examples</span>):
    questions = [q.strip() <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> examples[<span class="hljs-string">&quot;question&quot;</span>]]
    inputs = tokenizer(
        questions,
        examples[<span class="hljs-string">&quot;context&quot;</span>],
        max_length=<span class="hljs-number">384</span>,
        truncation=<span class="hljs-string">&quot;only_second&quot;</span>,
        return_offsets_mapping=<span class="hljs-literal">True</span>,
        padding=<span class="hljs-string">&quot;max_length&quot;</span>,
    )

    offset_mapping = inputs.pop(<span class="hljs-string">&quot;offset_mapping&quot;</span>)
    answers = examples[<span class="hljs-string">&quot;answers&quot;</span>]
    start_positions = []
    end_positions = []

    <span class="hljs-keyword">for</span> i, offset <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(offset_mapping):
        answer = answers[i]
        start_char = answer[<span class="hljs-string">&quot;answer_start&quot;</span>][<span class="hljs-number">0</span>]
        end_char = answer[<span class="hljs-string">&quot;answer_start&quot;</span>][<span class="hljs-number">0</span>] + <span class="hljs-built_in">len</span>(answer[<span class="hljs-string">&quot;text&quot;</span>][<span class="hljs-number">0</span>])
        sequence_ids = inputs.sequence_ids(i)

        <span class="hljs-comment"># Find the start and end of the context</span>
        idx = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> sequence_ids[idx] != <span class="hljs-number">1</span>:
            idx += <span class="hljs-number">1</span>
        context_start = idx
        <span class="hljs-keyword">while</span> sequence_ids[idx] == <span class="hljs-number">1</span>:
            idx += <span class="hljs-number">1</span>
        context_end = idx - <span class="hljs-number">1</span>

        <span class="hljs-comment"># If the answer is not fully inside the context, label it (0, 0)</span>
        <span class="hljs-keyword">if</span> offset[context_start][<span class="hljs-number">0</span>] &gt; end_char <span class="hljs-keyword">or</span> offset[context_end][<span class="hljs-number">1</span>] &lt; start_char:
            start_positions.append(<span class="hljs-number">0</span>)
            end_positions.append(<span class="hljs-number">0</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Otherwise it&#x27;s the start and end token positions</span>
            idx = context_start
            <span class="hljs-keyword">while</span> idx &lt;= context_end <span class="hljs-keyword">and</span> offset[idx][<span class="hljs-number">0</span>] &lt;= start_char:
                idx += <span class="hljs-number">1</span>
            start_positions.append(idx - <span class="hljs-number">1</span>)

            idx = context_end
            <span class="hljs-keyword">while</span> idx &gt;= context_start <span class="hljs-keyword">and</span> offset[idx][<span class="hljs-number">1</span>] &gt;= end_char:
                idx -= <span class="hljs-number">1</span>
            end_positions.append(idx + <span class="hljs-number">1</span>)

    inputs[<span class="hljs-string">&quot;start_positions&quot;</span>] = start_positions
    inputs[<span class="hljs-string">&quot;end_positions&quot;</span>] = end_positions
    <span class="hljs-keyword">return</span> inputs`}}),fs=new $({props:{code:'tokenized_squad = squad.map(preprocess_function, batched=True, remove_columns=squad["train"].column_names),',highlighted:'tokenized_squad = squad.<span class="hljs-built_in">map</span>(preprocess_function, batched=<span class="hljs-literal">True</span>, remove_columns=squad[<span class="hljs-string">&quot;train&quot;</span>].column_names)'}}),hs=new $({props:{code:`from transformers import default_data_collator
data_collator = default_data_collator,`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> default_data_collator
data_collator = default_data_collator`}}),us=new z({}),ds=new $({props:{code:`from transformers import AutoModelForQuestionAnswering, TrainingArguments, Trainer
model = AutoModelForQuestionAnswering.from_pretrained("distilbert-base-uncased"),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForQuestionAnswering, TrainingArguments, Trainer
model = AutoModelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)`}}),cs=new $({props:{code:`training_args = TrainingArguments(
    output_dir='./results',
    evaluation_strategy="epoch",
    learning_rate=2e-5,
    per_device_train_batch_size=16,
    per_device_eval_batch_size=16,
    num_train_epochs=3,
    weight_decay=0.01,
),`,highlighted:`training_args = TrainingArguments(
    output_dir=<span class="hljs-string">&#x27;./results&#x27;</span>,
    evaluation_strategy=<span class="hljs-string">&quot;epoch&quot;</span>,
    learning_rate=<span class="hljs-number">2e-5</span>,
    per_device_train_batch_size=<span class="hljs-number">16</span>,
    per_device_eval_batch_size=<span class="hljs-number">16</span>,
    num_train_epochs=<span class="hljs-number">3</span>,
    weight_decay=<span class="hljs-number">0.01</span>,
)`}}),ms=new $({props:{code:`trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=tokenized_squad["train"],
    eval_dataset=tokenized_squad["validation"],
    data_collator=data_collator,
    tokenizer=tokenizer,
),`,highlighted:`trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=tokenized_squad[<span class="hljs-string">&quot;train&quot;</span>],
    eval_dataset=tokenized_squad[<span class="hljs-string">&quot;validation&quot;</span>],
    data_collator=data_collator,
    tokenizer=tokenizer,
)`}}),_s=new $({props:{code:"trainer.train(),",highlighted:"trainer.train()"}}),ws=new z({}),gs=new $({props:{code:`from transformers.data.data_collator import tf_default_collator
data_collator = tf_default_collator,`,highlighted:`<span class="hljs-keyword">from</span> transformers.data.data_collator <span class="hljs-keyword">import</span> tf_default_collator
data_collator = tf_default_collator`}}),$s=new $({props:{code:`tf_train_set = tokenized_squad["train"].to_tf_dataset(
    columns=["attention_mask", "input_ids", "start_positions", "end_positions"],
    dummy_labels=True,
    shuffle=True,
    batch_size=16,
    collate_fn=data_collator,
)

tf_validation_set = tokenized_squad["validation"].to_tf_dataset(
    columns=["attention_mask", "input_ids", "start_positions", "end_positions"],
    dummy_labels=True,
    shuffle=False,
    batch_size=16,
    collate_fn=data_collator,
),`,highlighted:`tf_train_set = tokenized_squad[<span class="hljs-string">&quot;train&quot;</span>].to_tf_dataset(
    columns=[<span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;start_positions&quot;</span>, <span class="hljs-string">&quot;end_positions&quot;</span>],
    dummy_labels=<span class="hljs-literal">True</span>,
    shuffle=<span class="hljs-literal">True</span>,
    batch_size=<span class="hljs-number">16</span>,
    collate_fn=data_collator,
)

tf_validation_set = tokenized_squad[<span class="hljs-string">&quot;validation&quot;</span>].to_tf_dataset(
    columns=[<span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;start_positions&quot;</span>, <span class="hljs-string">&quot;end_positions&quot;</span>],
    dummy_labels=<span class="hljs-literal">True</span>,
    shuffle=<span class="hljs-literal">False</span>,
    batch_size=<span class="hljs-number">16</span>,
    collate_fn=data_collator,
)`}}),bs=new $({props:{code:`from transformers import create_optimizer

batch_size = 16
num_epochs = 2
total_train_steps = (len(tokenized_squad["train"]) // batch_size) * num_epochs
optimizer, schedule = create_optimizer(
    init_lr=2e-5, 
    num_warmup_steps=0, 
    num_train_steps=total_train_steps,
),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> create_optimizer

batch_size = <span class="hljs-number">16</span>
num_epochs = <span class="hljs-number">2</span>
total_train_steps = (<span class="hljs-built_in">len</span>(tokenized_squad[<span class="hljs-string">&quot;train&quot;</span>]) // batch_size) * num_epochs
optimizer, schedule = create_optimizer(
    init_lr=<span class="hljs-number">2e-5</span>, 
    num_warmup_steps=<span class="hljs-number">0</span>, 
    num_train_steps=total_train_steps,
)`}}),ks=new $({props:{code:`from transformers import TFAutoModelForQuestionAnswering
model = TFAutoModelForQuestionAnswering("distilbert-base-uncased"),`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForQuestionAnswering
model = TFAutoModelForQuestionAnswering(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)`}}),vs=new $({props:{code:`import tensorflow as tf
model.compile(optimizer=optimizer),`,highlighted:`<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
model.<span class="hljs-built_in">compile</span>(optimizer=optimizer)`}}),xs=new $({props:{code:`model.fit(
    tf_train_set,
    validation_data=tf_validation_set,
    epochs=num_train_epochs,
),`,highlighted:`model.fit(
    tf_train_set,
    validation_data=tf_validation_set,
    epochs=num_train_epochs,
)`}}),{c(){b=l("meta"),E=f(),k=l("h1"),y=l("a"),q=l("span"),d(v.$$.fragment),P=f(),T=l("span"),j=n("How to fine-tune a model for common downstream tasks"),x=f(),d(A.$$.fragment),C=f(),Es=l("p"),gi=n(`This guide will show you how to fine-tune \u{1F917} Transformers models for common downstream tasks. You will use the \u{1F917}
Datasets library to quickly load and preprocess the datasets, getting them ready for training with PyTorch and
TensorFlow.`),to=f(),ue=l("p"),$i=n(`Before you begin, make sure you have the \u{1F917} Datasets library installed. For more detailed installation instructions,
refer to the \u{1F917} Datasets `),st=l("a"),bi=n("installation page"),ki=n(`. All of the
examples in this guide will use \u{1F917} Datasets to load and preprocess a dataset.`),so=f(),d(at.$$.fragment),ao=f(),qs=l("p"),vi=n("Learn how to fine-tune a model for:"),no=f(),N=l("ul"),Da=l("li"),Ts=l("a"),xi=n("seq_imdb"),yi=f(),Sa=l("li"),As=l("a"),ji=n("tok_ner"),Ei=f(),Ia=l("li"),zs=l("a"),qi=n("qa_squad"),oo=f(),Ps=l("a"),ro=f(),J=l("h2"),de=l("a"),Na=l("span"),d(nt.$$.fragment),Ti=f(),Ma=l("span"),Ai=n("Sequence classification with IMDb reviews"),lo=f(),ce=l("p"),zi=n(`Sequence classification refers to the task of classifying sequences of text according to a given number of classes. In
this example, learn how to fine-tune a model on the `),ot=l("a"),Pi=n("IMDb dataset"),Fi=n(` to determine
whether a review is positive or negative.`),io=f(),d(me.$$.fragment),po=f(),K=l("h3"),_e=l("a"),La=l("span"),d(rt.$$.fragment),Ci=f(),Ba=l("span"),Di=n("Load IMDb dataset"),fo=f(),Fs=l("p"),Si=n("The \u{1F917} Datasets library makes it simple to load a dataset:"),ho=f(),d(lt.$$.fragment),uo=f(),we=l("p"),Ii=n("This loads a "),Oa=l("code"),Ni=n("DatasetDict"),Mi=n(" object which you can index into to view an example:"),co=f(),d(it.$$.fragment),mo=f(),X=l("h3"),ge=l("a"),Ha=l("span"),d(pt.$$.fragment),Li=f(),Wa=l("span"),Bi=n("Preprocess"),_o=f(),M=l("p"),Oi=n(`The next step is to tokenize the text into a readable format by the model. It is important to load the same tokenizer a
model was trained with to ensure appropriately tokenized words. Load the DistilBERT tokenizer with the
`),Cs=l("a"),Hi=n("AutoTokenizer"),Wi=n(" because we will eventually train a classifier using a pretrained "),ft=l("a"),Qi=n("DistilBERT"),Ri=n(" model:"),wo=f(),d(ht.$$.fragment),go=f(),Ds=l("p"),Ui=n(`Now that you have instantiated a tokenizer, create a function that will tokenize the text. You should also truncate
longer sequences in the text to be no longer than the model\u2019s maximum input length:`),$o=f(),d(ut.$$.fragment),bo=f(),L=l("p"),Vi=n("Use \u{1F917} Datasets "),Qa=l("code"),Yi=n("map"),Gi=n(` function to apply the preprocessing function to the entire dataset. You can also set
`),Ra=l("code"),Ji=n("batched=True"),Ki=n(` to apply the preprocessing function to multiple elements of the dataset at once for faster
preprocessing:`),ko=f(),d(dt.$$.fragment),vo=f(),F=l("p"),Xi=n("Lastly, pad your text so they are a uniform length. While it is possible to pad your text in the "),Ua=l("code"),Zi=n("tokenizer"),ep=n(` function
by setting `),Va=l("code"),tp=n("padding=True"),sp=n(`, it is more efficient to only pad the text to the length of the longest element in its
batch. This is known as `),Ya=l("strong"),ap=n("dynamic padding"),np=n(". You can do this with the "),Ga=l("code"),op=n("DataCollatorWithPadding"),rp=n(" function:"),xo=f(),d(ct.$$.fragment),yo=f(),Z=l("h3"),$e=l("a"),Ja=l("span"),d(mt.$$.fragment),lp=f(),Ka=l("span"),ip=n("Fine-tune with the Trainer API"),jo=f(),be=l("p"),pp=n("Now load your model with the "),Ss=l("a"),fp=n("AutoModelForSequenceClassification"),hp=n(" class along with the number of expected labels:"),Eo=f(),d(_t.$$.fragment),qo=f(),Is=l("p"),up=n("At this point, only three steps remain:"),To=f(),B=l("ol"),wt=l("li"),dp=n("Define your training hyperparameters in "),Ns=l("a"),cp=n("TrainingArguments"),mp=n("."),_p=f(),gt=l("li"),wp=n("Pass the training arguments to a "),Ms=l("a"),gp=n("Trainer"),$p=n(" along with the model, dataset, tokenizer, and data collator."),bp=f(),$t=l("li"),kp=n("Call "),Xa=l("code"),vp=n("Trainer.train()"),xp=n(" to fine-tune your model."),Ao=f(),d(bt.$$.fragment),zo=f(),ee=l("h3"),ke=l("a"),Za=l("span"),d(kt.$$.fragment),yp=f(),en=l("span"),jp=n("Fine-tune with TensorFlow"),Po=f(),Ls=l("p"),Ep=n("Fine-tuning with TensorFlow is just as easy, with only a few differences."),Fo=f(),D=l("p"),qp=n("Start by batching the processed examples together with dynamic padding using the "),Bs=l("a"),Tp=n("DataCollatorWithPadding"),Ap=n(` function.
Make sure you set `),tn=l("code"),zp=n('return_tensors="tf"'),Pp=n(" to return "),sn=l("code"),Fp=n("tf.Tensor"),Cp=n(" outputs instead of PyTorch tensors!"),Co=f(),d(vt.$$.fragment),Do=f(),S=l("p"),Dp=n("Next, convert your datasets to the "),an=l("code"),Sp=n("tf.data.Dataset"),Ip=n(" format with "),nn=l("code"),Np=n("to_tf_dataset"),Mp=n(`. Specify inputs and labels in the
`),on=l("code"),Lp=n("columns"),Bp=n(" argument:"),So=f(),d(xt.$$.fragment),Io=f(),Os=l("p"),Op=n("Set up an optimizer function, learning rate schedule, and some training hyperparameters:"),No=f(),d(yt.$$.fragment),Mo=f(),ve=l("p"),Hp=n("Load your model with the "),Hs=l("a"),Wp=n("TFAutoModelForSequenceClassification"),Qp=n(" class along with the number of expected labels:"),Lo=f(),d(jt.$$.fragment),Bo=f(),Ws=l("p"),Rp=n("Compile the model:"),Oo=f(),d(Et.$$.fragment),Ho=f(),xe=l("p"),Up=n("Finally, fine-tune the model by calling "),rn=l("code"),Vp=n("model.fit"),Yp=n(":"),Wo=f(),d(qt.$$.fragment),Qo=f(),Qs=l("a"),Ro=f(),te=l("h2"),ye=l("a"),ln=l("span"),d(Tt.$$.fragment),Gp=f(),pn=l("span"),Jp=n("Token classification with WNUT emerging entities"),Uo=f(),je=l("p"),Kp=n(`Token classification refers to the task of classifying individual tokens in a sentence. One of the most common token
classification tasks is Named Entity Recognition (NER). NER attempts to find a label for each entity in a sentence,
such as a person, location, or organization. In this example, learn how to fine-tune a model on the `),At=l("a"),Xp=n("WNUT 17"),Zp=n(" dataset to detect new entities."),Vo=f(),d(Ee.$$.fragment),Yo=f(),se=l("h3"),qe=l("a"),fn=l("span"),d(zt.$$.fragment),ef=f(),hn=l("span"),tf=n("Load WNUT 17 dataset"),Go=f(),Rs=l("p"),sf=n("Load the WNUT 17 dataset from the \u{1F917} Datasets library:"),Jo=f(),d(Pt.$$.fragment),Ko=f(),Us=l("p"),af=n("A quick look at the dataset shows the labels associated with each word in the sentence:"),Xo=f(),d(Ft.$$.fragment),Zo=f(),Vs=l("p"),nf=n("View the specific NER tags by:"),er=f(),d(Ct.$$.fragment),tr=f(),Ys=l("p"),of=n("A letter prefixes each NER tag which can mean:"),sr=f(),O=l("ul"),Gs=l("li"),un=l("code"),rf=n("B-"),lf=n(" indicates the beginning of an entity."),pf=f(),H=l("li"),dn=l("code"),ff=n("I-"),hf=n(" indicates a token is contained inside the same entity (e.g., the "),cn=l("code"),uf=n("State"),df=n(` token is a part of an entity like
`),mn=l("code"),cf=n("Empire State Building"),mf=n(")."),_f=f(),Js=l("li"),_n=l("code"),wf=n("0"),gf=n(" indicates the token doesn\u2019t correspond to any entity."),ar=f(),ae=l("h3"),Te=l("a"),wn=l("span"),d(Dt.$$.fragment),$f=f(),gn=l("span"),bf=n("Preprocess"),nr=f(),Ae=l("p"),kf=n("Now you need to tokenize the text. Load the DistilBERT tokenizer with an "),Ks=l("a"),vf=n("AutoTokenizer"),xf=n(":"),or=f(),d(St.$$.fragment),rr=f(),ze=l("p"),yf=n("Since the input has already been split into words, set "),$n=l("code"),jf=n("is_split_into_words=True"),Ef=n(` to tokenize the words into
subwords:`),lr=f(),d(It.$$.fragment),ir=f(),W=l("p"),qf=n("The addition of the special tokens "),bn=l("code"),Tf=n("[CLS]"),Af=n(" and "),kn=l("code"),zf=n("[SEP]"),Pf=n(` and subword tokenization creates a mismatch between the
input and labels. Realign the labels and tokens by:`),pr=f(),Q=l("ol"),Nt=l("li"),Ff=n("Mapping all tokens to their corresponding word with the "),vn=l("code"),Cf=n("word_ids"),Df=n(" method."),Sf=f(),ne=l("li"),If=n("Assigning the label "),xn=l("code"),Nf=n("-100"),Mf=n(" to the special tokens "),yn=l("code"),Lf=n("[CLS]"),Bf=n(" and \u201C[SEP]``` so the PyTorch loss function ignores\nthem."),Of=f(),Mt=l("li"),Hf=n("Only labeling the first token of a given word. Assign "),jn=l("code"),Wf=n("-100"),Qf=n(" to the other subtokens from the same word."),fr=f(),Xs=l("p"),Rf=n("Here is how you can create a function that will realign the labels and tokens:"),hr=f(),d(Lt.$$.fragment),ur=f(),Pe=l("p"),Uf=n("Now tokenize and align the labels over the entire dataset with \u{1F917} Datasets "),En=l("code"),Vf=n("map"),Yf=n(" function:"),dr=f(),d(Bt.$$.fragment),cr=f(),Zs=l("p"),Gf=n("Finally, pad your text and labels, so they are a uniform length:"),mr=f(),d(Ot.$$.fragment),_r=f(),oe=l("h3"),Fe=l("a"),qn=l("span"),d(Ht.$$.fragment),Jf=f(),Tn=l("span"),Kf=n("Fine-tune with the Trainer API"),wr=f(),Ce=l("p"),Xf=n("Load your model with the "),ea=l("a"),Zf=n("AutoModelForTokenClassification"),eh=n(" class along with the number of expected labels:"),gr=f(),d(Wt.$$.fragment),$r=f(),De=l("p"),th=n("Gather your training arguments in "),ta=l("a"),sh=n("TrainingArguments"),ah=n(":"),br=f(),d(Qt.$$.fragment),kr=f(),Se=l("p"),nh=n("Collect your model, training arguments, dataset, data collator, and tokenizer in "),sa=l("a"),oh=n("Trainer"),rh=n(":"),vr=f(),d(Rt.$$.fragment),xr=f(),aa=l("p"),lh=n("Fine-tune your model:"),yr=f(),d(Ut.$$.fragment),jr=f(),re=l("h3"),Ie=l("a"),An=l("span"),d(Vt.$$.fragment),ih=f(),zn=l("span"),ph=n("Fine-tune with TensorFlow"),Er=f(),na=l("p"),fh=n("Batch your examples together and pad your text and labels, so they are a uniform length:"),qr=f(),d(Yt.$$.fragment),Tr=f(),R=l("p"),hh=n("Convert your datasets to the "),Pn=l("code"),uh=n("tf.data.Dataset"),dh=n(" format with "),Fn=l("code"),ch=n("to_tf_dataset"),mh=n(":"),Ar=f(),d(Gt.$$.fragment),zr=f(),Ne=l("p"),_h=n("Load the model with the "),oa=l("a"),wh=n("TFAutoModelForTokenClassification"),gh=n(" class along with the number of expected labels:"),Pr=f(),d(Jt.$$.fragment),Fr=f(),ra=l("p"),$h=n("Set up an optimizer function, learning rate schedule, and some training hyperparameters:"),Cr=f(),d(Kt.$$.fragment),Dr=f(),la=l("p"),bh=n("Compile the model:"),Sr=f(),d(Xt.$$.fragment),Ir=f(),Me=l("p"),kh=n("Call "),Cn=l("code"),vh=n("model.fit"),xh=n(" to fine-tune your model:"),Nr=f(),d(Zt.$$.fragment),Mr=f(),ia=l("a"),Lr=f(),le=l("h2"),Le=l("a"),Dn=l("span"),d(es.$$.fragment),yh=f(),Sn=l("span"),jh=n("Question Answering with SQuAD"),Br=f(),Be=l("p"),Eh=n(`There are many types of question answering (QA) tasks. Extractive QA focuses on identifying the answer from the text
given a question. In this example, learn how to fine-tune a model on the `),ts=l("a"),qh=n("SQuAD"),Th=n(" dataset."),Or=f(),d(Oe.$$.fragment),Hr=f(),ie=l("h3"),He=l("a"),In=l("span"),d(ss.$$.fragment),Ah=f(),Nn=l("span"),zh=n("Load SQuAD dataset"),Wr=f(),pa=l("p"),Ph=n("Load the SQuAD dataset from the \u{1F917} Datasets library:"),Qr=f(),d(as.$$.fragment),Rr=f(),fa=l("p"),Fh=n("Take a look at an example from the dataset:"),Ur=f(),d(ns.$$.fragment),Vr=f(),pe=l("h3"),We=l("a"),Mn=l("span"),d(os.$$.fragment),Ch=f(),Ln=l("span"),Dh=n("Preprocess"),Yr=f(),Qe=l("p"),Sh=n("Load the DistilBERT tokenizer with an "),ha=l("a"),Ih=n("AutoTokenizer"),Nh=n(":"),Gr=f(),d(rs.$$.fragment),Jr=f(),ua=l("p"),Mh=n("There are a few things to be aware of when preprocessing text for question answering:"),Kr=f(),U=l("ol"),I=l("li"),Lh=n("Some examples in a dataset may have a very long "),Bn=l("code"),Bh=n("context"),Oh=n(` that exceeds the maximum input length of the model. You
can deal with this by truncating the `),On=l("code"),Hh=n("context"),Wh=n(" and set "),Hn=l("code"),Qh=n('truncation="only_second"'),Rh=n("."),Uh=f(),ls=l("li"),Vh=n(`Next, you need to map the start and end positions of the answer to the original context. Set
`),Wn=l("code"),Yh=n("return_offset_mapping=True"),Gh=n(" to handle this."),Jh=f(),is=l("li"),Kh=n("With the mapping in hand, you can find the start and end tokens of the answer. Use the "),Qn=l("code"),Xh=n("sequence_ids"),Zh=n(` method to
find which part of the offset corresponds to the question, and which part of the offset corresponds to the context.`),Xr=f(),da=l("p"),eu=n("Assemble everything in a preprocessing function as shown below:"),Zr=f(),d(ps.$$.fragment),el=f(),Re=l("p"),tu=n("Apply the preprocessing function over the entire dataset with \u{1F917} Datasets "),Rn=l("code"),su=n("map"),au=n(" function:"),tl=f(),d(fs.$$.fragment),sl=f(),ca=l("p"),nu=n("Batch the processed examples together:"),al=f(),d(hs.$$.fragment),nl=f(),fe=l("h3"),Ue=l("a"),Un=l("span"),d(us.$$.fragment),ou=f(),Vn=l("span"),ru=n("Fine-tune with the Trainer API"),ol=f(),Ve=l("p"),lu=n("Load your model with the "),ma=l("a"),iu=n("AutoModelForQuestionAnswering"),pu=n(" class:"),rl=f(),d(ds.$$.fragment),ll=f(),Ye=l("p"),fu=n("Gather your training arguments in "),_a=l("a"),hu=n("TrainingArguments"),uu=n(":"),il=f(),d(cs.$$.fragment),pl=f(),Ge=l("p"),du=n("Collect your model, training arguments, dataset, data collator, and tokenizer in "),wa=l("a"),cu=n("Trainer"),mu=n(":"),fl=f(),d(ms.$$.fragment),hl=f(),ga=l("p"),_u=n("Fine-tune your model:"),ul=f(),d(_s.$$.fragment),dl=f(),he=l("h3"),Je=l("a"),Yn=l("span"),d(ws.$$.fragment),wu=f(),Gn=l("span"),gu=n("Fine-tune with TensorFlow"),cl=f(),$a=l("p"),$u=n("Batch the processed examples together with a TensorFlow default data collator:"),ml=f(),d(gs.$$.fragment),_l=f(),V=l("p"),bu=n("Convert your datasets to the "),Jn=l("code"),ku=n("tf.data.Dataset"),vu=n(" format with the "),Kn=l("code"),xu=n("to_tf_dataset"),yu=n(" function:"),wl=f(),d($s.$$.fragment),gl=f(),ba=l("p"),ju=n("Set up an optimizer function, learning rate schedule, and some training hyperparameters:"),$l=f(),d(bs.$$.fragment),bl=f(),Ke=l("p"),Eu=n("Load your model with the "),ka=l("a"),qu=n("TFAutoModelForQuestionAnswering"),Tu=n(" class:"),kl=f(),d(ks.$$.fragment),vl=f(),va=l("p"),Au=n("Compile the model:"),xl=f(),d(vs.$$.fragment),yl=f(),Xe=l("p"),zu=n("Call "),Xn=l("code"),Pu=n("model.fit"),Fu=n(" to fine-tune the model:"),jl=f(),d(xs.$$.fragment),this.h()},l(e){const a=_m('[data-svelte="svelte-1phssyn"]',document.head);b=i(a,"META",{name:!0,content:!0}),a.forEach(t),E=h(e),k=i(e,"H1",{class:!0});var ys=p(k);y=i(ys,"A",{id:!0,class:!0,href:!0});var Zn=p(y);q=i(Zn,"SPAN",{});var eo=p(q);c(v.$$.fragment,eo),eo.forEach(t),Zn.forEach(t),P=h(ys),T=i(ys,"SPAN",{});var Iu=p(T);j=o(Iu,"How to fine-tune a model for common downstream tasks"),Iu.forEach(t),ys.forEach(t),x=h(e),c(A.$$.fragment,e),C=h(e),Es=i(e,"P",{});var Nu=p(Es);gi=o(Nu,`This guide will show you how to fine-tune \u{1F917} Transformers models for common downstream tasks. You will use the \u{1F917}
Datasets library to quickly load and preprocess the datasets, getting them ready for training with PyTorch and
TensorFlow.`),Nu.forEach(t),to=h(e),ue=i(e,"P",{});var ql=p(ue);$i=o(ql,`Before you begin, make sure you have the \u{1F917} Datasets library installed. For more detailed installation instructions,
refer to the \u{1F917} Datasets `),st=i(ql,"A",{href:!0,rel:!0});var Mu=p(st);bi=o(Mu,"installation page"),Mu.forEach(t),ki=o(ql,`. All of the
examples in this guide will use \u{1F917} Datasets to load and preprocess a dataset.`),ql.forEach(t),so=h(e),c(at.$$.fragment,e),ao=h(e),qs=i(e,"P",{});var Lu=p(qs);vi=o(Lu,"Learn how to fine-tune a model for:"),Lu.forEach(t),no=h(e),N=i(e,"UL",{});var xa=p(N);Da=i(xa,"LI",{});var Bu=p(Da);Ts=i(Bu,"A",{href:!0});var Ou=p(Ts);xi=o(Ou,"seq_imdb"),Ou.forEach(t),Bu.forEach(t),yi=h(xa),Sa=i(xa,"LI",{});var Hu=p(Sa);As=i(Hu,"A",{href:!0});var Wu=p(As);ji=o(Wu,"tok_ner"),Wu.forEach(t),Hu.forEach(t),Ei=h(xa),Ia=i(xa,"LI",{});var Qu=p(Ia);zs=i(Qu,"A",{href:!0});var Ru=p(zs);qi=o(Ru,"qa_squad"),Ru.forEach(t),Qu.forEach(t),xa.forEach(t),oo=h(e),Ps=i(e,"A",{id:!0}),p(Ps).forEach(t),ro=h(e),J=i(e,"H2",{class:!0});var Tl=p(J);de=i(Tl,"A",{id:!0,class:!0,href:!0});var Uu=p(de);Na=i(Uu,"SPAN",{});var Vu=p(Na);c(nt.$$.fragment,Vu),Vu.forEach(t),Uu.forEach(t),Ti=h(Tl),Ma=i(Tl,"SPAN",{});var Yu=p(Ma);Ai=o(Yu,"Sequence classification with IMDb reviews"),Yu.forEach(t),Tl.forEach(t),lo=h(e),ce=i(e,"P",{});var Al=p(ce);zi=o(Al,`Sequence classification refers to the task of classifying sequences of text according to a given number of classes. In
this example, learn how to fine-tune a model on the `),ot=i(Al,"A",{href:!0,rel:!0});var Gu=p(ot);Pi=o(Gu,"IMDb dataset"),Gu.forEach(t),Fi=o(Al,` to determine
whether a review is positive or negative.`),Al.forEach(t),io=h(e),c(me.$$.fragment,e),po=h(e),K=i(e,"H3",{class:!0});var zl=p(K);_e=i(zl,"A",{id:!0,class:!0,href:!0});var Ju=p(_e);La=i(Ju,"SPAN",{});var Ku=p(La);c(rt.$$.fragment,Ku),Ku.forEach(t),Ju.forEach(t),Ci=h(zl),Ba=i(zl,"SPAN",{});var Xu=p(Ba);Di=o(Xu,"Load IMDb dataset"),Xu.forEach(t),zl.forEach(t),fo=h(e),Fs=i(e,"P",{});var Zu=p(Fs);Si=o(Zu,"The \u{1F917} Datasets library makes it simple to load a dataset:"),Zu.forEach(t),ho=h(e),c(lt.$$.fragment,e),uo=h(e),we=i(e,"P",{});var Pl=p(we);Ii=o(Pl,"This loads a "),Oa=i(Pl,"CODE",{});var ed=p(Oa);Ni=o(ed,"DatasetDict"),ed.forEach(t),Mi=o(Pl," object which you can index into to view an example:"),Pl.forEach(t),co=h(e),c(it.$$.fragment,e),mo=h(e),X=i(e,"H3",{class:!0});var Fl=p(X);ge=i(Fl,"A",{id:!0,class:!0,href:!0});var td=p(ge);Ha=i(td,"SPAN",{});var sd=p(Ha);c(pt.$$.fragment,sd),sd.forEach(t),td.forEach(t),Li=h(Fl),Wa=i(Fl,"SPAN",{});var ad=p(Wa);Bi=o(ad,"Preprocess"),ad.forEach(t),Fl.forEach(t),_o=h(e),M=i(e,"P",{});var ya=p(M);Oi=o(ya,`The next step is to tokenize the text into a readable format by the model. It is important to load the same tokenizer a
model was trained with to ensure appropriately tokenized words. Load the DistilBERT tokenizer with the
`),Cs=i(ya,"A",{href:!0});var nd=p(Cs);Hi=o(nd,"AutoTokenizer"),nd.forEach(t),Wi=o(ya," because we will eventually train a classifier using a pretrained "),ft=i(ya,"A",{href:!0,rel:!0});var od=p(ft);Qi=o(od,"DistilBERT"),od.forEach(t),Ri=o(ya," model:"),ya.forEach(t),wo=h(e),c(ht.$$.fragment,e),go=h(e),Ds=i(e,"P",{});var rd=p(Ds);Ui=o(rd,`Now that you have instantiated a tokenizer, create a function that will tokenize the text. You should also truncate
longer sequences in the text to be no longer than the model\u2019s maximum input length:`),rd.forEach(t),$o=h(e),c(ut.$$.fragment,e),bo=h(e),L=i(e,"P",{});var ja=p(L);Vi=o(ja,"Use \u{1F917} Datasets "),Qa=i(ja,"CODE",{});var ld=p(Qa);Yi=o(ld,"map"),ld.forEach(t),Gi=o(ja,` function to apply the preprocessing function to the entire dataset. You can also set
`),Ra=i(ja,"CODE",{});var id=p(Ra);Ji=o(id,"batched=True"),id.forEach(t),Ki=o(ja,` to apply the preprocessing function to multiple elements of the dataset at once for faster
preprocessing:`),ja.forEach(t),ko=h(e),c(dt.$$.fragment,e),vo=h(e),F=i(e,"P",{});var Y=p(F);Xi=o(Y,"Lastly, pad your text so they are a uniform length. While it is possible to pad your text in the "),Ua=i(Y,"CODE",{});var pd=p(Ua);Zi=o(pd,"tokenizer"),pd.forEach(t),ep=o(Y,` function
by setting `),Va=i(Y,"CODE",{});var fd=p(Va);tp=o(fd,"padding=True"),fd.forEach(t),sp=o(Y,`, it is more efficient to only pad the text to the length of the longest element in its
batch. This is known as `),Ya=i(Y,"STRONG",{});var hd=p(Ya);ap=o(hd,"dynamic padding"),hd.forEach(t),np=o(Y,". You can do this with the "),Ga=i(Y,"CODE",{});var ud=p(Ga);op=o(ud,"DataCollatorWithPadding"),ud.forEach(t),rp=o(Y," function:"),Y.forEach(t),xo=h(e),c(ct.$$.fragment,e),yo=h(e),Z=i(e,"H3",{class:!0});var Cl=p(Z);$e=i(Cl,"A",{id:!0,class:!0,href:!0});var dd=p($e);Ja=i(dd,"SPAN",{});var cd=p(Ja);c(mt.$$.fragment,cd),cd.forEach(t),dd.forEach(t),lp=h(Cl),Ka=i(Cl,"SPAN",{});var md=p(Ka);ip=o(md,"Fine-tune with the Trainer API"),md.forEach(t),Cl.forEach(t),jo=h(e),be=i(e,"P",{});var Dl=p(be);pp=o(Dl,"Now load your model with the "),Ss=i(Dl,"A",{href:!0});var _d=p(Ss);fp=o(_d,"AutoModelForSequenceClassification"),_d.forEach(t),hp=o(Dl," class along with the number of expected labels:"),Dl.forEach(t),Eo=h(e),c(_t.$$.fragment,e),qo=h(e),Is=i(e,"P",{});var wd=p(Is);up=o(wd,"At this point, only three steps remain:"),wd.forEach(t),To=h(e),B=i(e,"OL",{});var Ea=p(B);wt=i(Ea,"LI",{});var Sl=p(wt);dp=o(Sl,"Define your training hyperparameters in "),Ns=i(Sl,"A",{href:!0});var gd=p(Ns);cp=o(gd,"TrainingArguments"),gd.forEach(t),mp=o(Sl,"."),Sl.forEach(t),_p=h(Ea),gt=i(Ea,"LI",{});var Il=p(gt);wp=o(Il,"Pass the training arguments to a "),Ms=i(Il,"A",{href:!0});var $d=p(Ms);gp=o($d,"Trainer"),$d.forEach(t),$p=o(Il," along with the model, dataset, tokenizer, and data collator."),Il.forEach(t),bp=h(Ea),$t=i(Ea,"LI",{});var Nl=p($t);kp=o(Nl,"Call "),Xa=i(Nl,"CODE",{});var bd=p(Xa);vp=o(bd,"Trainer.train()"),bd.forEach(t),xp=o(Nl," to fine-tune your model."),Nl.forEach(t),Ea.forEach(t),Ao=h(e),c(bt.$$.fragment,e),zo=h(e),ee=i(e,"H3",{class:!0});var Ml=p(ee);ke=i(Ml,"A",{id:!0,class:!0,href:!0});var kd=p(ke);Za=i(kd,"SPAN",{});var vd=p(Za);c(kt.$$.fragment,vd),vd.forEach(t),kd.forEach(t),yp=h(Ml),en=i(Ml,"SPAN",{});var xd=p(en);jp=o(xd,"Fine-tune with TensorFlow"),xd.forEach(t),Ml.forEach(t),Po=h(e),Ls=i(e,"P",{});var yd=p(Ls);Ep=o(yd,"Fine-tuning with TensorFlow is just as easy, with only a few differences."),yd.forEach(t),Fo=h(e),D=i(e,"P",{});var Ze=p(D);qp=o(Ze,"Start by batching the processed examples together with dynamic padding using the "),Bs=i(Ze,"A",{href:!0});var jd=p(Bs);Tp=o(jd,"DataCollatorWithPadding"),jd.forEach(t),Ap=o(Ze,` function.
Make sure you set `),tn=i(Ze,"CODE",{});var Ed=p(tn);zp=o(Ed,'return_tensors="tf"'),Ed.forEach(t),Pp=o(Ze," to return "),sn=i(Ze,"CODE",{});var qd=p(sn);Fp=o(qd,"tf.Tensor"),qd.forEach(t),Cp=o(Ze," outputs instead of PyTorch tensors!"),Ze.forEach(t),Co=h(e),c(vt.$$.fragment,e),Do=h(e),S=i(e,"P",{});var et=p(S);Dp=o(et,"Next, convert your datasets to the "),an=i(et,"CODE",{});var Td=p(an);Sp=o(Td,"tf.data.Dataset"),Td.forEach(t),Ip=o(et," format with "),nn=i(et,"CODE",{});var Ad=p(nn);Np=o(Ad,"to_tf_dataset"),Ad.forEach(t),Mp=o(et,`. Specify inputs and labels in the
`),on=i(et,"CODE",{});var zd=p(on);Lp=o(zd,"columns"),zd.forEach(t),Bp=o(et," argument:"),et.forEach(t),So=h(e),c(xt.$$.fragment,e),Io=h(e),Os=i(e,"P",{});var Pd=p(Os);Op=o(Pd,"Set up an optimizer function, learning rate schedule, and some training hyperparameters:"),Pd.forEach(t),No=h(e),c(yt.$$.fragment,e),Mo=h(e),ve=i(e,"P",{});var Ll=p(ve);Hp=o(Ll,"Load your model with the "),Hs=i(Ll,"A",{href:!0});var Fd=p(Hs);Wp=o(Fd,"TFAutoModelForSequenceClassification"),Fd.forEach(t),Qp=o(Ll," class along with the number of expected labels:"),Ll.forEach(t),Lo=h(e),c(jt.$$.fragment,e),Bo=h(e),Ws=i(e,"P",{});var Cd=p(Ws);Rp=o(Cd,"Compile the model:"),Cd.forEach(t),Oo=h(e),c(Et.$$.fragment,e),Ho=h(e),xe=i(e,"P",{});var Bl=p(xe);Up=o(Bl,"Finally, fine-tune the model by calling "),rn=i(Bl,"CODE",{});var Dd=p(rn);Vp=o(Dd,"model.fit"),Dd.forEach(t),Yp=o(Bl,":"),Bl.forEach(t),Wo=h(e),c(qt.$$.fragment,e),Qo=h(e),Qs=i(e,"A",{id:!0}),p(Qs).forEach(t),Ro=h(e),te=i(e,"H2",{class:!0});var Ol=p(te);ye=i(Ol,"A",{id:!0,class:!0,href:!0});var Sd=p(ye);ln=i(Sd,"SPAN",{});var Id=p(ln);c(Tt.$$.fragment,Id),Id.forEach(t),Sd.forEach(t),Gp=h(Ol),pn=i(Ol,"SPAN",{});var Nd=p(pn);Jp=o(Nd,"Token classification with WNUT emerging entities"),Nd.forEach(t),Ol.forEach(t),Uo=h(e),je=i(e,"P",{});var Hl=p(je);Kp=o(Hl,`Token classification refers to the task of classifying individual tokens in a sentence. One of the most common token
classification tasks is Named Entity Recognition (NER). NER attempts to find a label for each entity in a sentence,
such as a person, location, or organization. In this example, learn how to fine-tune a model on the `),At=i(Hl,"A",{href:!0,rel:!0});var Md=p(At);Xp=o(Md,"WNUT 17"),Md.forEach(t),Zp=o(Hl," dataset to detect new entities."),Hl.forEach(t),Vo=h(e),c(Ee.$$.fragment,e),Yo=h(e),se=i(e,"H3",{class:!0});var Wl=p(se);qe=i(Wl,"A",{id:!0,class:!0,href:!0});var Ld=p(qe);fn=i(Ld,"SPAN",{});var Bd=p(fn);c(zt.$$.fragment,Bd),Bd.forEach(t),Ld.forEach(t),ef=h(Wl),hn=i(Wl,"SPAN",{});var Od=p(hn);tf=o(Od,"Load WNUT 17 dataset"),Od.forEach(t),Wl.forEach(t),Go=h(e),Rs=i(e,"P",{});var Hd=p(Rs);sf=o(Hd,"Load the WNUT 17 dataset from the \u{1F917} Datasets library:"),Hd.forEach(t),Jo=h(e),c(Pt.$$.fragment,e),Ko=h(e),Us=i(e,"P",{});var Wd=p(Us);af=o(Wd,"A quick look at the dataset shows the labels associated with each word in the sentence:"),Wd.forEach(t),Xo=h(e),c(Ft.$$.fragment,e),Zo=h(e),Vs=i(e,"P",{});var Qd=p(Vs);nf=o(Qd,"View the specific NER tags by:"),Qd.forEach(t),er=h(e),c(Ct.$$.fragment,e),tr=h(e),Ys=i(e,"P",{});var Rd=p(Ys);of=o(Rd,"A letter prefixes each NER tag which can mean:"),Rd.forEach(t),sr=h(e),O=i(e,"UL",{});var qa=p(O);Gs=i(qa,"LI",{});var Cu=p(Gs);un=i(Cu,"CODE",{});var Ud=p(un);rf=o(Ud,"B-"),Ud.forEach(t),lf=o(Cu," indicates the beginning of an entity."),Cu.forEach(t),pf=h(qa),H=i(qa,"LI",{});var js=p(H);dn=i(js,"CODE",{});var Vd=p(dn);ff=o(Vd,"I-"),Vd.forEach(t),hf=o(js," indicates a token is contained inside the same entity (e.g., the "),cn=i(js,"CODE",{});var Yd=p(cn);uf=o(Yd,"State"),Yd.forEach(t),df=o(js,` token is a part of an entity like
`),mn=i(js,"CODE",{});var Gd=p(mn);cf=o(Gd,"Empire State Building"),Gd.forEach(t),mf=o(js,")."),js.forEach(t),_f=h(qa),Js=i(qa,"LI",{});var Du=p(Js);_n=i(Du,"CODE",{});var Jd=p(_n);wf=o(Jd,"0"),Jd.forEach(t),gf=o(Du," indicates the token doesn\u2019t correspond to any entity."),Du.forEach(t),qa.forEach(t),ar=h(e),ae=i(e,"H3",{class:!0});var Ql=p(ae);Te=i(Ql,"A",{id:!0,class:!0,href:!0});var Kd=p(Te);wn=i(Kd,"SPAN",{});var Xd=p(wn);c(Dt.$$.fragment,Xd),Xd.forEach(t),Kd.forEach(t),$f=h(Ql),gn=i(Ql,"SPAN",{});var Zd=p(gn);bf=o(Zd,"Preprocess"),Zd.forEach(t),Ql.forEach(t),nr=h(e),Ae=i(e,"P",{});var Rl=p(Ae);kf=o(Rl,"Now you need to tokenize the text. Load the DistilBERT tokenizer with an "),Ks=i(Rl,"A",{href:!0});var ec=p(Ks);vf=o(ec,"AutoTokenizer"),ec.forEach(t),xf=o(Rl,":"),Rl.forEach(t),or=h(e),c(St.$$.fragment,e),rr=h(e),ze=i(e,"P",{});var Ul=p(ze);yf=o(Ul,"Since the input has already been split into words, set "),$n=i(Ul,"CODE",{});var tc=p($n);jf=o(tc,"is_split_into_words=True"),tc.forEach(t),Ef=o(Ul,` to tokenize the words into
subwords:`),Ul.forEach(t),lr=h(e),c(It.$$.fragment,e),ir=h(e),W=i(e,"P",{});var Ta=p(W);qf=o(Ta,"The addition of the special tokens "),bn=i(Ta,"CODE",{});var sc=p(bn);Tf=o(sc,"[CLS]"),sc.forEach(t),Af=o(Ta," and "),kn=i(Ta,"CODE",{});var ac=p(kn);zf=o(ac,"[SEP]"),ac.forEach(t),Pf=o(Ta,` and subword tokenization creates a mismatch between the
input and labels. Realign the labels and tokens by:`),Ta.forEach(t),pr=h(e),Q=i(e,"OL",{});var Aa=p(Q);Nt=i(Aa,"LI",{});var Vl=p(Nt);Ff=o(Vl,"Mapping all tokens to their corresponding word with the "),vn=i(Vl,"CODE",{});var nc=p(vn);Cf=o(nc,"word_ids"),nc.forEach(t),Df=o(Vl," method."),Vl.forEach(t),Sf=h(Aa),ne=i(Aa,"LI",{});var za=p(ne);If=o(za,"Assigning the label "),xn=i(za,"CODE",{});var oc=p(xn);Nf=o(oc,"-100"),oc.forEach(t),Mf=o(za," to the special tokens "),yn=i(za,"CODE",{});var rc=p(yn);Lf=o(rc,"[CLS]"),rc.forEach(t),Bf=o(za," and \u201C[SEP]``` so the PyTorch loss function ignores\nthem."),za.forEach(t),Of=h(Aa),Mt=i(Aa,"LI",{});var Yl=p(Mt);Hf=o(Yl,"Only labeling the first token of a given word. Assign "),jn=i(Yl,"CODE",{});var lc=p(jn);Wf=o(lc,"-100"),lc.forEach(t),Qf=o(Yl," to the other subtokens from the same word."),Yl.forEach(t),Aa.forEach(t),fr=h(e),Xs=i(e,"P",{});var ic=p(Xs);Rf=o(ic,"Here is how you can create a function that will realign the labels and tokens:"),ic.forEach(t),hr=h(e),c(Lt.$$.fragment,e),ur=h(e),Pe=i(e,"P",{});var Gl=p(Pe);Uf=o(Gl,"Now tokenize and align the labels over the entire dataset with \u{1F917} Datasets "),En=i(Gl,"CODE",{});var pc=p(En);Vf=o(pc,"map"),pc.forEach(t),Yf=o(Gl," function:"),Gl.forEach(t),dr=h(e),c(Bt.$$.fragment,e),cr=h(e),Zs=i(e,"P",{});var fc=p(Zs);Gf=o(fc,"Finally, pad your text and labels, so they are a uniform length:"),fc.forEach(t),mr=h(e),c(Ot.$$.fragment,e),_r=h(e),oe=i(e,"H3",{class:!0});var Jl=p(oe);Fe=i(Jl,"A",{id:!0,class:!0,href:!0});var hc=p(Fe);qn=i(hc,"SPAN",{});var uc=p(qn);c(Ht.$$.fragment,uc),uc.forEach(t),hc.forEach(t),Jf=h(Jl),Tn=i(Jl,"SPAN",{});var dc=p(Tn);Kf=o(dc,"Fine-tune with the Trainer API"),dc.forEach(t),Jl.forEach(t),wr=h(e),Ce=i(e,"P",{});var Kl=p(Ce);Xf=o(Kl,"Load your model with the "),ea=i(Kl,"A",{href:!0});var cc=p(ea);Zf=o(cc,"AutoModelForTokenClassification"),cc.forEach(t),eh=o(Kl," class along with the number of expected labels:"),Kl.forEach(t),gr=h(e),c(Wt.$$.fragment,e),$r=h(e),De=i(e,"P",{});var Xl=p(De);th=o(Xl,"Gather your training arguments in "),ta=i(Xl,"A",{href:!0});var mc=p(ta);sh=o(mc,"TrainingArguments"),mc.forEach(t),ah=o(Xl,":"),Xl.forEach(t),br=h(e),c(Qt.$$.fragment,e),kr=h(e),Se=i(e,"P",{});var Zl=p(Se);nh=o(Zl,"Collect your model, training arguments, dataset, data collator, and tokenizer in "),sa=i(Zl,"A",{href:!0});var _c=p(sa);oh=o(_c,"Trainer"),_c.forEach(t),rh=o(Zl,":"),Zl.forEach(t),vr=h(e),c(Rt.$$.fragment,e),xr=h(e),aa=i(e,"P",{});var wc=p(aa);lh=o(wc,"Fine-tune your model:"),wc.forEach(t),yr=h(e),c(Ut.$$.fragment,e),jr=h(e),re=i(e,"H3",{class:!0});var ei=p(re);Ie=i(ei,"A",{id:!0,class:!0,href:!0});var gc=p(Ie);An=i(gc,"SPAN",{});var $c=p(An);c(Vt.$$.fragment,$c),$c.forEach(t),gc.forEach(t),ih=h(ei),zn=i(ei,"SPAN",{});var bc=p(zn);ph=o(bc,"Fine-tune with TensorFlow"),bc.forEach(t),ei.forEach(t),Er=h(e),na=i(e,"P",{});var kc=p(na);fh=o(kc,"Batch your examples together and pad your text and labels, so they are a uniform length:"),kc.forEach(t),qr=h(e),c(Yt.$$.fragment,e),Tr=h(e),R=i(e,"P",{});var Pa=p(R);hh=o(Pa,"Convert your datasets to the "),Pn=i(Pa,"CODE",{});var vc=p(Pn);uh=o(vc,"tf.data.Dataset"),vc.forEach(t),dh=o(Pa," format with "),Fn=i(Pa,"CODE",{});var xc=p(Fn);ch=o(xc,"to_tf_dataset"),xc.forEach(t),mh=o(Pa,":"),Pa.forEach(t),Ar=h(e),c(Gt.$$.fragment,e),zr=h(e),Ne=i(e,"P",{});var ti=p(Ne);_h=o(ti,"Load the model with the "),oa=i(ti,"A",{href:!0});var yc=p(oa);wh=o(yc,"TFAutoModelForTokenClassification"),yc.forEach(t),gh=o(ti," class along with the number of expected labels:"),ti.forEach(t),Pr=h(e),c(Jt.$$.fragment,e),Fr=h(e),ra=i(e,"P",{});var jc=p(ra);$h=o(jc,"Set up an optimizer function, learning rate schedule, and some training hyperparameters:"),jc.forEach(t),Cr=h(e),c(Kt.$$.fragment,e),Dr=h(e),la=i(e,"P",{});var Ec=p(la);bh=o(Ec,"Compile the model:"),Ec.forEach(t),Sr=h(e),c(Xt.$$.fragment,e),Ir=h(e),Me=i(e,"P",{});var si=p(Me);kh=o(si,"Call "),Cn=i(si,"CODE",{});var qc=p(Cn);vh=o(qc,"model.fit"),qc.forEach(t),xh=o(si," to fine-tune your model:"),si.forEach(t),Nr=h(e),c(Zt.$$.fragment,e),Mr=h(e),ia=i(e,"A",{id:!0}),p(ia).forEach(t),Lr=h(e),le=i(e,"H2",{class:!0});var ai=p(le);Le=i(ai,"A",{id:!0,class:!0,href:!0});var Tc=p(Le);Dn=i(Tc,"SPAN",{});var Ac=p(Dn);c(es.$$.fragment,Ac),Ac.forEach(t),Tc.forEach(t),yh=h(ai),Sn=i(ai,"SPAN",{});var zc=p(Sn);jh=o(zc,"Question Answering with SQuAD"),zc.forEach(t),ai.forEach(t),Br=h(e),Be=i(e,"P",{});var ni=p(Be);Eh=o(ni,`There are many types of question answering (QA) tasks. Extractive QA focuses on identifying the answer from the text
given a question. In this example, learn how to fine-tune a model on the `),ts=i(ni,"A",{href:!0,rel:!0});var Pc=p(ts);qh=o(Pc,"SQuAD"),Pc.forEach(t),Th=o(ni," dataset."),ni.forEach(t),Or=h(e),c(Oe.$$.fragment,e),Hr=h(e),ie=i(e,"H3",{class:!0});var oi=p(ie);He=i(oi,"A",{id:!0,class:!0,href:!0});var Fc=p(He);In=i(Fc,"SPAN",{});var Cc=p(In);c(ss.$$.fragment,Cc),Cc.forEach(t),Fc.forEach(t),Ah=h(oi),Nn=i(oi,"SPAN",{});var Dc=p(Nn);zh=o(Dc,"Load SQuAD dataset"),Dc.forEach(t),oi.forEach(t),Wr=h(e),pa=i(e,"P",{});var Sc=p(pa);Ph=o(Sc,"Load the SQuAD dataset from the \u{1F917} Datasets library:"),Sc.forEach(t),Qr=h(e),c(as.$$.fragment,e),Rr=h(e),fa=i(e,"P",{});var Ic=p(fa);Fh=o(Ic,"Take a look at an example from the dataset:"),Ic.forEach(t),Ur=h(e),c(ns.$$.fragment,e),Vr=h(e),pe=i(e,"H3",{class:!0});var ri=p(pe);We=i(ri,"A",{id:!0,class:!0,href:!0});var Nc=p(We);Mn=i(Nc,"SPAN",{});var Mc=p(Mn);c(os.$$.fragment,Mc),Mc.forEach(t),Nc.forEach(t),Ch=h(ri),Ln=i(ri,"SPAN",{});var Lc=p(Ln);Dh=o(Lc,"Preprocess"),Lc.forEach(t),ri.forEach(t),Yr=h(e),Qe=i(e,"P",{});var li=p(Qe);Sh=o(li,"Load the DistilBERT tokenizer with an "),ha=i(li,"A",{href:!0});var Bc=p(ha);Ih=o(Bc,"AutoTokenizer"),Bc.forEach(t),Nh=o(li,":"),li.forEach(t),Gr=h(e),c(rs.$$.fragment,e),Jr=h(e),ua=i(e,"P",{});var Oc=p(ua);Mh=o(Oc,"There are a few things to be aware of when preprocessing text for question answering:"),Oc.forEach(t),Kr=h(e),U=i(e,"OL",{});var Fa=p(U);I=i(Fa,"LI",{});var tt=p(I);Lh=o(tt,"Some examples in a dataset may have a very long "),Bn=i(tt,"CODE",{});var Hc=p(Bn);Bh=o(Hc,"context"),Hc.forEach(t),Oh=o(tt,` that exceeds the maximum input length of the model. You
can deal with this by truncating the `),On=i(tt,"CODE",{});var Wc=p(On);Hh=o(Wc,"context"),Wc.forEach(t),Wh=o(tt," and set "),Hn=i(tt,"CODE",{});var Qc=p(Hn);Qh=o(Qc,'truncation="only_second"'),Qc.forEach(t),Rh=o(tt,"."),tt.forEach(t),Uh=h(Fa),ls=i(Fa,"LI",{});var ii=p(ls);Vh=o(ii,`Next, you need to map the start and end positions of the answer to the original context. Set
`),Wn=i(ii,"CODE",{});var Rc=p(Wn);Yh=o(Rc,"return_offset_mapping=True"),Rc.forEach(t),Gh=o(ii," to handle this."),ii.forEach(t),Jh=h(Fa),is=i(Fa,"LI",{});var pi=p(is);Kh=o(pi,"With the mapping in hand, you can find the start and end tokens of the answer. Use the "),Qn=i(pi,"CODE",{});var Uc=p(Qn);Xh=o(Uc,"sequence_ids"),Uc.forEach(t),Zh=o(pi,` method to
find which part of the offset corresponds to the question, and which part of the offset corresponds to the context.`),pi.forEach(t),Fa.forEach(t),Xr=h(e),da=i(e,"P",{});var Vc=p(da);eu=o(Vc,"Assemble everything in a preprocessing function as shown below:"),Vc.forEach(t),Zr=h(e),c(ps.$$.fragment,e),el=h(e),Re=i(e,"P",{});var fi=p(Re);tu=o(fi,"Apply the preprocessing function over the entire dataset with \u{1F917} Datasets "),Rn=i(fi,"CODE",{});var Yc=p(Rn);su=o(Yc,"map"),Yc.forEach(t),au=o(fi," function:"),fi.forEach(t),tl=h(e),c(fs.$$.fragment,e),sl=h(e),ca=i(e,"P",{});var Gc=p(ca);nu=o(Gc,"Batch the processed examples together:"),Gc.forEach(t),al=h(e),c(hs.$$.fragment,e),nl=h(e),fe=i(e,"H3",{class:!0});var hi=p(fe);Ue=i(hi,"A",{id:!0,class:!0,href:!0});var Jc=p(Ue);Un=i(Jc,"SPAN",{});var Kc=p(Un);c(us.$$.fragment,Kc),Kc.forEach(t),Jc.forEach(t),ou=h(hi),Vn=i(hi,"SPAN",{});var Xc=p(Vn);ru=o(Xc,"Fine-tune with the Trainer API"),Xc.forEach(t),hi.forEach(t),ol=h(e),Ve=i(e,"P",{});var ui=p(Ve);lu=o(ui,"Load your model with the "),ma=i(ui,"A",{href:!0});var Zc=p(ma);iu=o(Zc,"AutoModelForQuestionAnswering"),Zc.forEach(t),pu=o(ui," class:"),ui.forEach(t),rl=h(e),c(ds.$$.fragment,e),ll=h(e),Ye=i(e,"P",{});var di=p(Ye);fu=o(di,"Gather your training arguments in "),_a=i(di,"A",{href:!0});var em=p(_a);hu=o(em,"TrainingArguments"),em.forEach(t),uu=o(di,":"),di.forEach(t),il=h(e),c(cs.$$.fragment,e),pl=h(e),Ge=i(e,"P",{});var ci=p(Ge);du=o(ci,"Collect your model, training arguments, dataset, data collator, and tokenizer in "),wa=i(ci,"A",{href:!0});var tm=p(wa);cu=o(tm,"Trainer"),tm.forEach(t),mu=o(ci,":"),ci.forEach(t),fl=h(e),c(ms.$$.fragment,e),hl=h(e),ga=i(e,"P",{});var sm=p(ga);_u=o(sm,"Fine-tune your model:"),sm.forEach(t),ul=h(e),c(_s.$$.fragment,e),dl=h(e),he=i(e,"H3",{class:!0});var mi=p(he);Je=i(mi,"A",{id:!0,class:!0,href:!0});var am=p(Je);Yn=i(am,"SPAN",{});var nm=p(Yn);c(ws.$$.fragment,nm),nm.forEach(t),am.forEach(t),wu=h(mi),Gn=i(mi,"SPAN",{});var om=p(Gn);gu=o(om,"Fine-tune with TensorFlow"),om.forEach(t),mi.forEach(t),cl=h(e),$a=i(e,"P",{});var rm=p($a);$u=o(rm,"Batch the processed examples together with a TensorFlow default data collator:"),rm.forEach(t),ml=h(e),c(gs.$$.fragment,e),_l=h(e),V=i(e,"P",{});var Ca=p(V);bu=o(Ca,"Convert your datasets to the "),Jn=i(Ca,"CODE",{});var lm=p(Jn);ku=o(lm,"tf.data.Dataset"),lm.forEach(t),vu=o(Ca," format with the "),Kn=i(Ca,"CODE",{});var im=p(Kn);xu=o(im,"to_tf_dataset"),im.forEach(t),yu=o(Ca," function:"),Ca.forEach(t),wl=h(e),c($s.$$.fragment,e),gl=h(e),ba=i(e,"P",{});var pm=p(ba);ju=o(pm,"Set up an optimizer function, learning rate schedule, and some training hyperparameters:"),pm.forEach(t),$l=h(e),c(bs.$$.fragment,e),bl=h(e),Ke=i(e,"P",{});var _i=p(Ke);Eu=o(_i,"Load your model with the "),ka=i(_i,"A",{href:!0});var fm=p(ka);qu=o(fm,"TFAutoModelForQuestionAnswering"),fm.forEach(t),Tu=o(_i," class:"),_i.forEach(t),kl=h(e),c(ks.$$.fragment,e),vl=h(e),va=i(e,"P",{});var hm=p(va);Au=o(hm,"Compile the model:"),hm.forEach(t),xl=h(e),c(vs.$$.fragment,e),yl=h(e),Xe=i(e,"P",{});var wi=p(Xe);zu=o(wi,"Call "),Xn=i(wi,"CODE",{});var um=p(Xn);Pu=o(um,"model.fit"),um.forEach(t),Fu=o(wi," to fine-tune the model:"),wi.forEach(t),jl=h(e),c(xs.$$.fragment,e),this.h()},h(){u(b,"name","hf:doc:metadata"),u(b,"content",JSON.stringify(vm)),u(y,"id","how-to-finetune-a-model-for-common-downstream-tasks"),u(y,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(y,"href","#how-to-finetune-a-model-for-common-downstream-tasks"),u(k,"class","relative group"),u(st,"href","https://huggingface.co/docs/datasets/installation.html"),u(st,"rel","nofollow"),u(Ts,"href","#seq_imdb"),u(As,"href","#tok_ner"),u(zs,"href","#qa_squad"),u(Ps,"id","seq_imdb"),u(de,"id","sequence-classification-with-imdb-reviews"),u(de,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(de,"href","#sequence-classification-with-imdb-reviews"),u(J,"class","relative group"),u(ot,"href","https://huggingface.co/datasets/imdb"),u(ot,"rel","nofollow"),u(_e,"id","load-imdb-dataset"),u(_e,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(_e,"href","#load-imdb-dataset"),u(K,"class","relative group"),u(ge,"id","preprocess"),u(ge,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(ge,"href","#preprocess"),u(X,"class","relative group"),u(Cs,"href","/docs/transformers/v4.14.1/en/model_doc/auto#transformers.AutoTokenizer"),u(ft,"href","https://huggingface.co/distilbert-base-uncased"),u(ft,"rel","nofollow"),u($e,"id","finetune-with-the-trainer-api"),u($e,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u($e,"href","#finetune-with-the-trainer-api"),u(Z,"class","relative group"),u(Ss,"href","/docs/transformers/v4.14.1/en/model_doc/auto#transformers.AutoModelForSequenceClassification"),u(Ns,"href","/docs/transformers/v4.14.1/en/main_classes/trainer#transformers.TrainingArguments"),u(Ms,"href","/docs/transformers/v4.14.1/en/main_classes/trainer#transformers.Trainer"),u(ke,"id","finetune-with-tensorflow"),u(ke,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(ke,"href","#finetune-with-tensorflow"),u(ee,"class","relative group"),u(Bs,"href","/docs/transformers/v4.14.1/en/main_classes/data_collator#transformers.DataCollatorWithPadding"),u(Hs,"href","/docs/transformers/v4.14.1/en/model_doc/auto#transformers.TFAutoModelForSequenceClassification"),u(Qs,"id","tok_ner"),u(ye,"id","token-classification-with-wnut-emerging-entities"),u(ye,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(ye,"href","#token-classification-with-wnut-emerging-entities"),u(te,"class","relative group"),u(At,"href","https://huggingface.co/datasets/wnut_17"),u(At,"rel","nofollow"),u(qe,"id","load-wnut-17-dataset"),u(qe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(qe,"href","#load-wnut-17-dataset"),u(se,"class","relative group"),u(Te,"id","preprocess"),u(Te,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Te,"href","#preprocess"),u(ae,"class","relative group"),u(Ks,"href","/docs/transformers/v4.14.1/en/model_doc/auto#transformers.AutoTokenizer"),u(Fe,"id","finetune-with-the-trainer-api"),u(Fe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Fe,"href","#finetune-with-the-trainer-api"),u(oe,"class","relative group"),u(ea,"href","/docs/transformers/v4.14.1/en/model_doc/auto#transformers.AutoModelForTokenClassification"),u(ta,"href","/docs/transformers/v4.14.1/en/main_classes/trainer#transformers.TrainingArguments"),u(sa,"href","/docs/transformers/v4.14.1/en/main_classes/trainer#transformers.Trainer"),u(Ie,"id","finetune-with-tensorflow"),u(Ie,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Ie,"href","#finetune-with-tensorflow"),u(re,"class","relative group"),u(oa,"href","/docs/transformers/v4.14.1/en/model_doc/auto#transformers.TFAutoModelForTokenClassification"),u(ia,"id","qa_squad"),u(Le,"id","question-answering-with-squad"),u(Le,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Le,"href","#question-answering-with-squad"),u(le,"class","relative group"),u(ts,"href","https://huggingface.co/datasets/squad"),u(ts,"rel","nofollow"),u(He,"id","load-squad-dataset"),u(He,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(He,"href","#load-squad-dataset"),u(ie,"class","relative group"),u(We,"id","preprocess"),u(We,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(We,"href","#preprocess"),u(pe,"class","relative group"),u(ha,"href","/docs/transformers/v4.14.1/en/model_doc/auto#transformers.AutoTokenizer"),u(Ue,"id","finetune-with-the-trainer-api"),u(Ue,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Ue,"href","#finetune-with-the-trainer-api"),u(fe,"class","relative group"),u(ma,"href","/docs/transformers/v4.14.1/en/model_doc/auto#transformers.AutoModelForQuestionAnswering"),u(_a,"href","/docs/transformers/v4.14.1/en/main_classes/trainer#transformers.TrainingArguments"),u(wa,"href","/docs/transformers/v4.14.1/en/main_classes/trainer#transformers.Trainer"),u(Je,"id","finetune-with-tensorflow"),u(Je,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Je,"href","#finetune-with-tensorflow"),u(he,"class","relative group"),u(ka,"href","/docs/transformers/v4.14.1/en/model_doc/auto#transformers.TFAutoModelForQuestionAnswering")},m(e,a){s(document.head,b),r(e,E,a),r(e,k,a),s(k,y),s(y,q),m(v,q,null),s(k,P),s(k,T),s(T,j),r(e,x,a),m(A,e,a),r(e,C,a),r(e,Es,a),s(Es,gi),r(e,to,a),r(e,ue,a),s(ue,$i),s(ue,st),s(st,bi),s(ue,ki),r(e,so,a),m(at,e,a),r(e,ao,a),r(e,qs,a),s(qs,vi),r(e,no,a),r(e,N,a),s(N,Da),s(Da,Ts),s(Ts,xi),s(N,yi),s(N,Sa),s(Sa,As),s(As,ji),s(N,Ei),s(N,Ia),s(Ia,zs),s(zs,qi),r(e,oo,a),r(e,Ps,a),r(e,ro,a),r(e,J,a),s(J,de),s(de,Na),m(nt,Na,null),s(J,Ti),s(J,Ma),s(Ma,Ai),r(e,lo,a),r(e,ce,a),s(ce,zi),s(ce,ot),s(ot,Pi),s(ce,Fi),r(e,io,a),m(me,e,a),r(e,po,a),r(e,K,a),s(K,_e),s(_e,La),m(rt,La,null),s(K,Ci),s(K,Ba),s(Ba,Di),r(e,fo,a),r(e,Fs,a),s(Fs,Si),r(e,ho,a),m(lt,e,a),r(e,uo,a),r(e,we,a),s(we,Ii),s(we,Oa),s(Oa,Ni),s(we,Mi),r(e,co,a),m(it,e,a),r(e,mo,a),r(e,X,a),s(X,ge),s(ge,Ha),m(pt,Ha,null),s(X,Li),s(X,Wa),s(Wa,Bi),r(e,_o,a),r(e,M,a),s(M,Oi),s(M,Cs),s(Cs,Hi),s(M,Wi),s(M,ft),s(ft,Qi),s(M,Ri),r(e,wo,a),m(ht,e,a),r(e,go,a),r(e,Ds,a),s(Ds,Ui),r(e,$o,a),m(ut,e,a),r(e,bo,a),r(e,L,a),s(L,Vi),s(L,Qa),s(Qa,Yi),s(L,Gi),s(L,Ra),s(Ra,Ji),s(L,Ki),r(e,ko,a),m(dt,e,a),r(e,vo,a),r(e,F,a),s(F,Xi),s(F,Ua),s(Ua,Zi),s(F,ep),s(F,Va),s(Va,tp),s(F,sp),s(F,Ya),s(Ya,ap),s(F,np),s(F,Ga),s(Ga,op),s(F,rp),r(e,xo,a),m(ct,e,a),r(e,yo,a),r(e,Z,a),s(Z,$e),s($e,Ja),m(mt,Ja,null),s(Z,lp),s(Z,Ka),s(Ka,ip),r(e,jo,a),r(e,be,a),s(be,pp),s(be,Ss),s(Ss,fp),s(be,hp),r(e,Eo,a),m(_t,e,a),r(e,qo,a),r(e,Is,a),s(Is,up),r(e,To,a),r(e,B,a),s(B,wt),s(wt,dp),s(wt,Ns),s(Ns,cp),s(wt,mp),s(B,_p),s(B,gt),s(gt,wp),s(gt,Ms),s(Ms,gp),s(gt,$p),s(B,bp),s(B,$t),s($t,kp),s($t,Xa),s(Xa,vp),s($t,xp),r(e,Ao,a),m(bt,e,a),r(e,zo,a),r(e,ee,a),s(ee,ke),s(ke,Za),m(kt,Za,null),s(ee,yp),s(ee,en),s(en,jp),r(e,Po,a),r(e,Ls,a),s(Ls,Ep),r(e,Fo,a),r(e,D,a),s(D,qp),s(D,Bs),s(Bs,Tp),s(D,Ap),s(D,tn),s(tn,zp),s(D,Pp),s(D,sn),s(sn,Fp),s(D,Cp),r(e,Co,a),m(vt,e,a),r(e,Do,a),r(e,S,a),s(S,Dp),s(S,an),s(an,Sp),s(S,Ip),s(S,nn),s(nn,Np),s(S,Mp),s(S,on),s(on,Lp),s(S,Bp),r(e,So,a),m(xt,e,a),r(e,Io,a),r(e,Os,a),s(Os,Op),r(e,No,a),m(yt,e,a),r(e,Mo,a),r(e,ve,a),s(ve,Hp),s(ve,Hs),s(Hs,Wp),s(ve,Qp),r(e,Lo,a),m(jt,e,a),r(e,Bo,a),r(e,Ws,a),s(Ws,Rp),r(e,Oo,a),m(Et,e,a),r(e,Ho,a),r(e,xe,a),s(xe,Up),s(xe,rn),s(rn,Vp),s(xe,Yp),r(e,Wo,a),m(qt,e,a),r(e,Qo,a),r(e,Qs,a),r(e,Ro,a),r(e,te,a),s(te,ye),s(ye,ln),m(Tt,ln,null),s(te,Gp),s(te,pn),s(pn,Jp),r(e,Uo,a),r(e,je,a),s(je,Kp),s(je,At),s(At,Xp),s(je,Zp),r(e,Vo,a),m(Ee,e,a),r(e,Yo,a),r(e,se,a),s(se,qe),s(qe,fn),m(zt,fn,null),s(se,ef),s(se,hn),s(hn,tf),r(e,Go,a),r(e,Rs,a),s(Rs,sf),r(e,Jo,a),m(Pt,e,a),r(e,Ko,a),r(e,Us,a),s(Us,af),r(e,Xo,a),m(Ft,e,a),r(e,Zo,a),r(e,Vs,a),s(Vs,nf),r(e,er,a),m(Ct,e,a),r(e,tr,a),r(e,Ys,a),s(Ys,of),r(e,sr,a),r(e,O,a),s(O,Gs),s(Gs,un),s(un,rf),s(Gs,lf),s(O,pf),s(O,H),s(H,dn),s(dn,ff),s(H,hf),s(H,cn),s(cn,uf),s(H,df),s(H,mn),s(mn,cf),s(H,mf),s(O,_f),s(O,Js),s(Js,_n),s(_n,wf),s(Js,gf),r(e,ar,a),r(e,ae,a),s(ae,Te),s(Te,wn),m(Dt,wn,null),s(ae,$f),s(ae,gn),s(gn,bf),r(e,nr,a),r(e,Ae,a),s(Ae,kf),s(Ae,Ks),s(Ks,vf),s(Ae,xf),r(e,or,a),m(St,e,a),r(e,rr,a),r(e,ze,a),s(ze,yf),s(ze,$n),s($n,jf),s(ze,Ef),r(e,lr,a),m(It,e,a),r(e,ir,a),r(e,W,a),s(W,qf),s(W,bn),s(bn,Tf),s(W,Af),s(W,kn),s(kn,zf),s(W,Pf),r(e,pr,a),r(e,Q,a),s(Q,Nt),s(Nt,Ff),s(Nt,vn),s(vn,Cf),s(Nt,Df),s(Q,Sf),s(Q,ne),s(ne,If),s(ne,xn),s(xn,Nf),s(ne,Mf),s(ne,yn),s(yn,Lf),s(ne,Bf),s(Q,Of),s(Q,Mt),s(Mt,Hf),s(Mt,jn),s(jn,Wf),s(Mt,Qf),r(e,fr,a),r(e,Xs,a),s(Xs,Rf),r(e,hr,a),m(Lt,e,a),r(e,ur,a),r(e,Pe,a),s(Pe,Uf),s(Pe,En),s(En,Vf),s(Pe,Yf),r(e,dr,a),m(Bt,e,a),r(e,cr,a),r(e,Zs,a),s(Zs,Gf),r(e,mr,a),m(Ot,e,a),r(e,_r,a),r(e,oe,a),s(oe,Fe),s(Fe,qn),m(Ht,qn,null),s(oe,Jf),s(oe,Tn),s(Tn,Kf),r(e,wr,a),r(e,Ce,a),s(Ce,Xf),s(Ce,ea),s(ea,Zf),s(Ce,eh),r(e,gr,a),m(Wt,e,a),r(e,$r,a),r(e,De,a),s(De,th),s(De,ta),s(ta,sh),s(De,ah),r(e,br,a),m(Qt,e,a),r(e,kr,a),r(e,Se,a),s(Se,nh),s(Se,sa),s(sa,oh),s(Se,rh),r(e,vr,a),m(Rt,e,a),r(e,xr,a),r(e,aa,a),s(aa,lh),r(e,yr,a),m(Ut,e,a),r(e,jr,a),r(e,re,a),s(re,Ie),s(Ie,An),m(Vt,An,null),s(re,ih),s(re,zn),s(zn,ph),r(e,Er,a),r(e,na,a),s(na,fh),r(e,qr,a),m(Yt,e,a),r(e,Tr,a),r(e,R,a),s(R,hh),s(R,Pn),s(Pn,uh),s(R,dh),s(R,Fn),s(Fn,ch),s(R,mh),r(e,Ar,a),m(Gt,e,a),r(e,zr,a),r(e,Ne,a),s(Ne,_h),s(Ne,oa),s(oa,wh),s(Ne,gh),r(e,Pr,a),m(Jt,e,a),r(e,Fr,a),r(e,ra,a),s(ra,$h),r(e,Cr,a),m(Kt,e,a),r(e,Dr,a),r(e,la,a),s(la,bh),r(e,Sr,a),m(Xt,e,a),r(e,Ir,a),r(e,Me,a),s(Me,kh),s(Me,Cn),s(Cn,vh),s(Me,xh),r(e,Nr,a),m(Zt,e,a),r(e,Mr,a),r(e,ia,a),r(e,Lr,a),r(e,le,a),s(le,Le),s(Le,Dn),m(es,Dn,null),s(le,yh),s(le,Sn),s(Sn,jh),r(e,Br,a),r(e,Be,a),s(Be,Eh),s(Be,ts),s(ts,qh),s(Be,Th),r(e,Or,a),m(Oe,e,a),r(e,Hr,a),r(e,ie,a),s(ie,He),s(He,In),m(ss,In,null),s(ie,Ah),s(ie,Nn),s(Nn,zh),r(e,Wr,a),r(e,pa,a),s(pa,Ph),r(e,Qr,a),m(as,e,a),r(e,Rr,a),r(e,fa,a),s(fa,Fh),r(e,Ur,a),m(ns,e,a),r(e,Vr,a),r(e,pe,a),s(pe,We),s(We,Mn),m(os,Mn,null),s(pe,Ch),s(pe,Ln),s(Ln,Dh),r(e,Yr,a),r(e,Qe,a),s(Qe,Sh),s(Qe,ha),s(ha,Ih),s(Qe,Nh),r(e,Gr,a),m(rs,e,a),r(e,Jr,a),r(e,ua,a),s(ua,Mh),r(e,Kr,a),r(e,U,a),s(U,I),s(I,Lh),s(I,Bn),s(Bn,Bh),s(I,Oh),s(I,On),s(On,Hh),s(I,Wh),s(I,Hn),s(Hn,Qh),s(I,Rh),s(U,Uh),s(U,ls),s(ls,Vh),s(ls,Wn),s(Wn,Yh),s(ls,Gh),s(U,Jh),s(U,is),s(is,Kh),s(is,Qn),s(Qn,Xh),s(is,Zh),r(e,Xr,a),r(e,da,a),s(da,eu),r(e,Zr,a),m(ps,e,a),r(e,el,a),r(e,Re,a),s(Re,tu),s(Re,Rn),s(Rn,su),s(Re,au),r(e,tl,a),m(fs,e,a),r(e,sl,a),r(e,ca,a),s(ca,nu),r(e,al,a),m(hs,e,a),r(e,nl,a),r(e,fe,a),s(fe,Ue),s(Ue,Un),m(us,Un,null),s(fe,ou),s(fe,Vn),s(Vn,ru),r(e,ol,a),r(e,Ve,a),s(Ve,lu),s(Ve,ma),s(ma,iu),s(Ve,pu),r(e,rl,a),m(ds,e,a),r(e,ll,a),r(e,Ye,a),s(Ye,fu),s(Ye,_a),s(_a,hu),s(Ye,uu),r(e,il,a),m(cs,e,a),r(e,pl,a),r(e,Ge,a),s(Ge,du),s(Ge,wa),s(wa,cu),s(Ge,mu),r(e,fl,a),m(ms,e,a),r(e,hl,a),r(e,ga,a),s(ga,_u),r(e,ul,a),m(_s,e,a),r(e,dl,a),r(e,he,a),s(he,Je),s(Je,Yn),m(ws,Yn,null),s(he,wu),s(he,Gn),s(Gn,gu),r(e,cl,a),r(e,$a,a),s($a,$u),r(e,ml,a),m(gs,e,a),r(e,_l,a),r(e,V,a),s(V,bu),s(V,Jn),s(Jn,ku),s(V,vu),s(V,Kn),s(Kn,xu),s(V,yu),r(e,wl,a),m($s,e,a),r(e,gl,a),r(e,ba,a),s(ba,ju),r(e,$l,a),m(bs,e,a),r(e,bl,a),r(e,Ke,a),s(Ke,Eu),s(Ke,ka),s(ka,qu),s(Ke,Tu),r(e,kl,a),m(ks,e,a),r(e,vl,a),r(e,va,a),s(va,Au),r(e,xl,a),m(vs,e,a),r(e,yl,a),r(e,Xe,a),s(Xe,zu),s(Xe,Xn),s(Xn,Pu),s(Xe,Fu),r(e,jl,a),m(xs,e,a),El=!0},p(e,[a]){const ys={};a&2&&(ys.$$scope={dirty:a,ctx:e}),me.$set(ys);const Zn={};a&2&&(Zn.$$scope={dirty:a,ctx:e}),Ee.$set(Zn);const eo={};a&2&&(eo.$$scope={dirty:a,ctx:e}),Oe.$set(eo)},i(e){El||(_(v.$$.fragment,e),_(A.$$.fragment,e),_(at.$$.fragment,e),_(nt.$$.fragment,e),_(me.$$.fragment,e),_(rt.$$.fragment,e),_(lt.$$.fragment,e),_(it.$$.fragment,e),_(pt.$$.fragment,e),_(ht.$$.fragment,e),_(ut.$$.fragment,e),_(dt.$$.fragment,e),_(ct.$$.fragment,e),_(mt.$$.fragment,e),_(_t.$$.fragment,e),_(bt.$$.fragment,e),_(kt.$$.fragment,e),_(vt.$$.fragment,e),_(xt.$$.fragment,e),_(yt.$$.fragment,e),_(jt.$$.fragment,e),_(Et.$$.fragment,e),_(qt.$$.fragment,e),_(Tt.$$.fragment,e),_(Ee.$$.fragment,e),_(zt.$$.fragment,e),_(Pt.$$.fragment,e),_(Ft.$$.fragment,e),_(Ct.$$.fragment,e),_(Dt.$$.fragment,e),_(St.$$.fragment,e),_(It.$$.fragment,e),_(Lt.$$.fragment,e),_(Bt.$$.fragment,e),_(Ot.$$.fragment,e),_(Ht.$$.fragment,e),_(Wt.$$.fragment,e),_(Qt.$$.fragment,e),_(Rt.$$.fragment,e),_(Ut.$$.fragment,e),_(Vt.$$.fragment,e),_(Yt.$$.fragment,e),_(Gt.$$.fragment,e),_(Jt.$$.fragment,e),_(Kt.$$.fragment,e),_(Xt.$$.fragment,e),_(Zt.$$.fragment,e),_(es.$$.fragment,e),_(Oe.$$.fragment,e),_(ss.$$.fragment,e),_(as.$$.fragment,e),_(ns.$$.fragment,e),_(os.$$.fragment,e),_(rs.$$.fragment,e),_(ps.$$.fragment,e),_(fs.$$.fragment,e),_(hs.$$.fragment,e),_(us.$$.fragment,e),_(ds.$$.fragment,e),_(cs.$$.fragment,e),_(ms.$$.fragment,e),_(_s.$$.fragment,e),_(ws.$$.fragment,e),_(gs.$$.fragment,e),_($s.$$.fragment,e),_(bs.$$.fragment,e),_(ks.$$.fragment,e),_(vs.$$.fragment,e),_(xs.$$.fragment,e),El=!0)},o(e){w(v.$$.fragment,e),w(A.$$.fragment,e),w(at.$$.fragment,e),w(nt.$$.fragment,e),w(me.$$.fragment,e),w(rt.$$.fragment,e),w(lt.$$.fragment,e),w(it.$$.fragment,e),w(pt.$$.fragment,e),w(ht.$$.fragment,e),w(ut.$$.fragment,e),w(dt.$$.fragment,e),w(ct.$$.fragment,e),w(mt.$$.fragment,e),w(_t.$$.fragment,e),w(bt.$$.fragment,e),w(kt.$$.fragment,e),w(vt.$$.fragment,e),w(xt.$$.fragment,e),w(yt.$$.fragment,e),w(jt.$$.fragment,e),w(Et.$$.fragment,e),w(qt.$$.fragment,e),w(Tt.$$.fragment,e),w(Ee.$$.fragment,e),w(zt.$$.fragment,e),w(Pt.$$.fragment,e),w(Ft.$$.fragment,e),w(Ct.$$.fragment,e),w(Dt.$$.fragment,e),w(St.$$.fragment,e),w(It.$$.fragment,e),w(Lt.$$.fragment,e),w(Bt.$$.fragment,e),w(Ot.$$.fragment,e),w(Ht.$$.fragment,e),w(Wt.$$.fragment,e),w(Qt.$$.fragment,e),w(Rt.$$.fragment,e),w(Ut.$$.fragment,e),w(Vt.$$.fragment,e),w(Yt.$$.fragment,e),w(Gt.$$.fragment,e),w(Jt.$$.fragment,e),w(Kt.$$.fragment,e),w(Xt.$$.fragment,e),w(Zt.$$.fragment,e),w(es.$$.fragment,e),w(Oe.$$.fragment,e),w(ss.$$.fragment,e),w(as.$$.fragment,e),w(ns.$$.fragment,e),w(os.$$.fragment,e),w(rs.$$.fragment,e),w(ps.$$.fragment,e),w(fs.$$.fragment,e),w(hs.$$.fragment,e),w(us.$$.fragment,e),w(ds.$$.fragment,e),w(cs.$$.fragment,e),w(ms.$$.fragment,e),w(_s.$$.fragment,e),w(ws.$$.fragment,e),w(gs.$$.fragment,e),w($s.$$.fragment,e),w(bs.$$.fragment,e),w(ks.$$.fragment,e),w(vs.$$.fragment,e),w(xs.$$.fragment,e),El=!1},d(e){t(b),e&&t(E),e&&t(k),g(v),e&&t(x),g(A,e),e&&t(C),e&&t(Es),e&&t(to),e&&t(ue),e&&t(so),g(at,e),e&&t(ao),e&&t(qs),e&&t(no),e&&t(N),e&&t(oo),e&&t(Ps),e&&t(ro),e&&t(J),g(nt),e&&t(lo),e&&t(ce),e&&t(io),g(me,e),e&&t(po),e&&t(K),g(rt),e&&t(fo),e&&t(Fs),e&&t(ho),g(lt,e),e&&t(uo),e&&t(we),e&&t(co),g(it,e),e&&t(mo),e&&t(X),g(pt),e&&t(_o),e&&t(M),e&&t(wo),g(ht,e),e&&t(go),e&&t(Ds),e&&t($o),g(ut,e),e&&t(bo),e&&t(L),e&&t(ko),g(dt,e),e&&t(vo),e&&t(F),e&&t(xo),g(ct,e),e&&t(yo),e&&t(Z),g(mt),e&&t(jo),e&&t(be),e&&t(Eo),g(_t,e),e&&t(qo),e&&t(Is),e&&t(To),e&&t(B),e&&t(Ao),g(bt,e),e&&t(zo),e&&t(ee),g(kt),e&&t(Po),e&&t(Ls),e&&t(Fo),e&&t(D),e&&t(Co),g(vt,e),e&&t(Do),e&&t(S),e&&t(So),g(xt,e),e&&t(Io),e&&t(Os),e&&t(No),g(yt,e),e&&t(Mo),e&&t(ve),e&&t(Lo),g(jt,e),e&&t(Bo),e&&t(Ws),e&&t(Oo),g(Et,e),e&&t(Ho),e&&t(xe),e&&t(Wo),g(qt,e),e&&t(Qo),e&&t(Qs),e&&t(Ro),e&&t(te),g(Tt),e&&t(Uo),e&&t(je),e&&t(Vo),g(Ee,e),e&&t(Yo),e&&t(se),g(zt),e&&t(Go),e&&t(Rs),e&&t(Jo),g(Pt,e),e&&t(Ko),e&&t(Us),e&&t(Xo),g(Ft,e),e&&t(Zo),e&&t(Vs),e&&t(er),g(Ct,e),e&&t(tr),e&&t(Ys),e&&t(sr),e&&t(O),e&&t(ar),e&&t(ae),g(Dt),e&&t(nr),e&&t(Ae),e&&t(or),g(St,e),e&&t(rr),e&&t(ze),e&&t(lr),g(It,e),e&&t(ir),e&&t(W),e&&t(pr),e&&t(Q),e&&t(fr),e&&t(Xs),e&&t(hr),g(Lt,e),e&&t(ur),e&&t(Pe),e&&t(dr),g(Bt,e),e&&t(cr),e&&t(Zs),e&&t(mr),g(Ot,e),e&&t(_r),e&&t(oe),g(Ht),e&&t(wr),e&&t(Ce),e&&t(gr),g(Wt,e),e&&t($r),e&&t(De),e&&t(br),g(Qt,e),e&&t(kr),e&&t(Se),e&&t(vr),g(Rt,e),e&&t(xr),e&&t(aa),e&&t(yr),g(Ut,e),e&&t(jr),e&&t(re),g(Vt),e&&t(Er),e&&t(na),e&&t(qr),g(Yt,e),e&&t(Tr),e&&t(R),e&&t(Ar),g(Gt,e),e&&t(zr),e&&t(Ne),e&&t(Pr),g(Jt,e),e&&t(Fr),e&&t(ra),e&&t(Cr),g(Kt,e),e&&t(Dr),e&&t(la),e&&t(Sr),g(Xt,e),e&&t(Ir),e&&t(Me),e&&t(Nr),g(Zt,e),e&&t(Mr),e&&t(ia),e&&t(Lr),e&&t(le),g(es),e&&t(Br),e&&t(Be),e&&t(Or),g(Oe,e),e&&t(Hr),e&&t(ie),g(ss),e&&t(Wr),e&&t(pa),e&&t(Qr),g(as,e),e&&t(Rr),e&&t(fa),e&&t(Ur),g(ns,e),e&&t(Vr),e&&t(pe),g(os),e&&t(Yr),e&&t(Qe),e&&t(Gr),g(rs,e),e&&t(Jr),e&&t(ua),e&&t(Kr),e&&t(U),e&&t(Xr),e&&t(da),e&&t(Zr),g(ps,e),e&&t(el),e&&t(Re),e&&t(tl),g(fs,e),e&&t(sl),e&&t(ca),e&&t(al),g(hs,e),e&&t(nl),e&&t(fe),g(us),e&&t(ol),e&&t(Ve),e&&t(rl),g(ds,e),e&&t(ll),e&&t(Ye),e&&t(il),g(cs,e),e&&t(pl),e&&t(Ge),e&&t(fl),g(ms,e),e&&t(hl),e&&t(ga),e&&t(ul),g(_s,e),e&&t(dl),e&&t(he),g(ws),e&&t(cl),e&&t($a),e&&t(ml),g(gs,e),e&&t(_l),e&&t(V),e&&t(wl),g($s,e),e&&t(gl),e&&t(ba),e&&t($l),g(bs,e),e&&t(bl),e&&t(Ke),e&&t(kl),g(ks,e),e&&t(vl),e&&t(va),e&&t(xl),g(vs,e),e&&t(yl),e&&t(Xe),e&&t(jl),g(xs,e)}}}const vm={local:"how-to-finetune-a-model-for-common-downstream-tasks",sections:[{local:"sequence-classification-with-imdb-reviews",sections:[{local:"load-imdb-dataset",title:"Load IMDb dataset"},{local:"preprocess",title:"Preprocess"},{local:"finetune-with-the-trainer-api",title:"Fine-tune with the Trainer API"},{local:"finetune-with-tensorflow",title:"Fine-tune with TensorFlow"}],title:"Sequence classification with IMDb reviews"},{local:"token-classification-with-wnut-emerging-entities",sections:[{local:"load-wnut-17-dataset",title:"Load WNUT 17 dataset"},{local:"preprocess",title:"Preprocess"},{local:"finetune-with-the-trainer-api",title:"Fine-tune with the Trainer API"},{local:"finetune-with-tensorflow",title:"Fine-tune with TensorFlow"}],title:"Token classification with WNUT emerging entities"},{local:"question-answering-with-squad",sections:[{local:"load-squad-dataset",title:"Load SQuAD dataset"},{local:"preprocess",title:"Preprocess"},{local:"finetune-with-the-trainer-api",title:"Fine-tune with the Trainer API"},{local:"finetune-with-tensorflow",title:"Fine-tune with TensorFlow"}],title:"Question Answering with SQuAD"}],title:"How to fine-tune a model for common downstream tasks"};function xm(G,b,E){let{fw:k}=b;return G.$$set=y=>{"fw"in y&&E(0,k=y.fw)},[k]}class zm extends dm{constructor(b){super();cm(this,b,xm,km,mm,{fw:0})}}export{zm as default,vm as metadata};
