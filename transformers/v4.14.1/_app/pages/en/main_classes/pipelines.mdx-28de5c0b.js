import{S as Lq,i as Gq,s as Uq,e as o,k as l,w as f,t as a,L as Nq,c as r,d as n,m as c,a as s,x as h,h as i,b as d,J as e,g as m,y as u,q as g,o as _,B as v}from"../../../chunks/vendor-b1433968.js";import{T as Fq}from"../../../chunks/Tip-c3840994.js";import{D as b}from"../../../chunks/Docstring-ff504c58.js";import{C as O}from"../../../chunks/CodeBlock-a320dbd7.js";import{I as y}from"../../../chunks/IconCopyLink-7029626d.js";import"../../../chunks/CopyButton-f65cb278.js";function Oq(mo){let x,ie,$,A,he;return{c(){x=o("p"),ie=a(`However, this is not automatically a win for performance. It can be either a 10x speedup or 5x slowdown depending
on hardware, data and the actual model being used.`),$=l(),A=o("p"),he=a("Example where it\u2019s most a speedup:")},l(E){x=r(E,"P",{});var R=s(x);ie=i(R,`However, this is not automatically a win for performance. It can be either a 10x speedup or 5x slowdown depending
on hardware, data and the actual model being used.`),R.forEach(n),$=c(E),A=r(E,"P",{});var ye=s(A);he=i(ye,"Example where it\u2019s most a speedup:"),ye.forEach(n)},m(E,R){m(E,x,R),e(x,ie),m(E,$,R),m(E,A,R),e(A,he)},d(E){E&&n(x),E&&n($),E&&n(A)}}}function Rq(mo){let x,ie,$,A,he;return{c(){x=o("p"),ie=a(`This pipeline only works for inputs with exactly one token masked. Experimental: We added support for multiple
masks. The returned values are raw model output, and correspond to disjoint probabilities where one might
expect joint probabilities (See `),$=o("a"),A=a("discussion"),he=a(")."),this.h()},l(E){x=r(E,"P",{});var R=s(x);ie=i(R,`This pipeline only works for inputs with exactly one token masked. Experimental: We added support for multiple
masks. The returned values are raw model output, and correspond to disjoint probabilities where one might
expect joint probabilities (See `),$=r(R,"A",{href:!0,rel:!0});var ye=s($);A=i(ye,"discussion"),ye.forEach(n),he=i(R,")."),R.forEach(n),this.h()},h(){d($,"href","https://github.com/huggingface/transformers/pull/10222"),d($,"rel","nofollow")},m(E,R){m(E,x,R),e(x,ie),e(x,$),e($,A),e(x,he)},d(E){E&&n(x)}}}function Qq(mo){let x,ie,$,A,he,E,R,ye,Lu,hm,Ut,Gu,ha,Uu,Nu,um,ua,Ou,gm,Nt,el,fo,Ru,ga,Qu,Wu,Hu,ho,tl,Vu,Bu,w,nl,_a,Zu,Ku,ol,va,Xu,Yu,rl,ba,Ju,eg,sl,wa,tg,ng,al,ka,og,rg,il,Ta,sg,ag,ll,Pa,ig,lg,cl,ya,cg,dg,dl,xa,pg,mg,pl,$a,fg,hg,ml,Ea,ug,gg,fl,qa,_g,vg,hl,Aa,bg,wg,ul,Ca,kg,Tg,gl,za,Pg,yg,_l,Da,xg,$g,vl,ja,Eg,_m,Qe,Ot,bl,uo,qg,wl,Ag,vm,Rt,Cg,kl,zg,Dg,bm,Ia,jg,wm,go,km,Qt,Ig,_o,Mg,Sg,Tm,vo,Pm,Wt,Fg,Tl,Lg,Gg,ym,bo,xm,Ht,Ug,Pl,Ng,Og,$m,wo,Em,Q,ko,Rg,To,Qg,Ma,Wg,Hg,Vg,yl,Bg,Zg,We,Po,Kg,Sa,Xg,Yg,Jg,yo,e_,Fa,t_,n_,o_,xl,r_,s_,$l,a_,i_,xo,qm,He,Vt,El,$o,l_,ql,c_,Am,be,d_,Al,p_,m_,Cl,f_,h_,zl,u_,g_,Cm,Eo,zm,Bt,Dm,qo,jm,Ao,Im,La,__,Mm,Co,Sm,Zt,v_,Dl,b_,w_,Fm,zo,Lm,Ga,k_,Gm,Ua,T_,Um,le,jl,Il,Ml,P_,y_,Sl,Fl,x_,$_,Ll,Gl,E_,q_,Do,Ul,A_,C_,Ve,Nl,z_,D_,Ol,j_,I_,Rl,M_,S_,Ql,Wl,F_,Nm,Be,Kt,Hl,jo,L_,Vl,G_,Om,Na,U_,Rm,Xt,N_,Bl,O_,R_,Qm,Oa,Q_,Wm,Ra,Zl,W_,Hm,Io,Vm,Qa,H_,Bm,Ze,Yt,Kl,Mo,V_,Xl,B_,Zm,Wa,Ha,Z_,Km,Ke,Jt,Yl,So,K_,Jl,X_,Xm,Xe,en,ec,Fo,Y_,tc,J_,Ym,ee,Lo,ev,Go,tv,nc,nv,ov,rv,Ye,sv,Va,av,iv,oc,lv,cv,dv,Uo,pv,No,mv,fv,hv,tn,Oo,uv,Ro,gv,Ba,_v,vv,Jm,Je,nn,rc,Qo,bv,sc,wv,ef,ue,Wo,kv,ac,Tv,Pv,ic,yv,xv,on,Ho,$v,Vo,Ev,Za,qv,Av,tf,et,rn,lc,Bo,Cv,cc,zv,nf,z,Zo,Dv,xe,jv,Ka,Iv,Mv,Xa,Sv,Fv,dc,Lv,Gv,Uv,pc,Nv,Ov,Ko,Rv,sn,Xo,Qv,Yo,Wv,mc,Hv,Vv,Bv,an,Jo,Zv,fc,Kv,Xv,qe,er,Yv,hc,Jv,e1,ge,t1,uc,n1,o1,gc,r1,s1,_c,a1,i1,vc,l1,c1,d1,ln,tr,p1,$e,m1,bc,f1,h1,wc,u1,g1,kc,_1,v1,of,M,nr,b1,Tc,w1,k1,tt,T1,Ya,P1,y1,Pc,x1,$1,E1,_e,q1,yc,A1,C1,xc,z1,D1,$c,j1,I1,or,M1,S1,F1,Ec,L1,G1,rr,U1,cn,sr,N1,qc,O1,rf,nt,dn,Ac,ar,R1,Cc,Q1,sf,te,ir,W1,zc,H1,V1,ot,B1,Ja,Z1,K1,Dc,X1,Y1,J1,lr,eb,cr,tb,nb,ob,pn,dr,rb,jc,sb,af,rt,mn,Ic,pr,ab,Mc,ib,lf,W,mr,lb,st,cb,Sc,db,pb,ei,mb,fb,hb,at,ub,ti,gb,_b,Fc,vb,bb,wb,fr,kb,hr,Tb,Pb,yb,fn,xb,hn,ur,$b,Lc,Eb,cf,it,un,Gc,gr,qb,Uc,Ab,df,ne,_r,Cb,vr,zb,Nc,Db,jb,Ib,lt,Mb,ni,Sb,Fb,Oc,Lb,Gb,Ub,br,Nb,wr,Ob,Rb,Qb,gn,kr,Wb,Rc,Hb,pf,ct,_n,Qc,Tr,Vb,Wc,Bb,mf,oe,Pr,Zb,yr,Kb,Hc,Xb,Yb,Jb,dt,ew,oi,tw,nw,Vc,ow,rw,sw,xr,aw,$r,iw,lw,cw,vn,Er,dw,Bc,pw,ff,pt,bn,Zc,qr,mw,Kc,fw,hf,D,Ar,hw,mt,uw,Xc,gw,_w,ri,vw,bw,ww,ft,kw,si,Tw,Pw,Yc,yw,xw,$w,Cr,Ew,zr,qw,Aw,Cw,Ae,Dr,zw,Jc,Dw,jw,ed,Iw,Mw,wn,jr,Sw,td,Fw,Lw,kn,Ir,Gw,nd,Uw,Nw,Tn,Mr,Ow,od,Rw,uf,Pn,Qw,ai,Ww,Hw,gf,ht,yn,rd,Sr,Vw,sd,Bw,_f,re,Fr,Zw,Lr,Kw,ad,Xw,Yw,Jw,ut,e4,ii,t4,n4,id,o4,r4,s4,Gr,a4,Ur,i4,l4,c4,xn,Nr,d4,ld,p4,vf,gt,$n,cd,Or,m4,dd,f4,bf,j,Rr,h4,_t,u4,pd,g4,_4,li,v4,b4,w4,vt,k4,ci,T4,P4,md,y4,x4,$4,Qr,E4,Wr,q4,A4,C4,En,Hr,z4,fd,D4,j4,Ce,Vr,I4,bt,M4,hd,S4,F4,ud,L4,G4,U4,gd,N4,O4,ze,Br,R4,Zr,Q4,_d,W4,H4,V4,vd,B4,Z4,qn,Kr,K4,bd,X4,wf,wt,An,wd,Xr,Y4,kd,J4,kf,S,Yr,ek,Td,tk,nk,kt,ok,di,rk,sk,Pd,ak,ik,lk,F,ck,yd,dk,pk,xd,mk,fk,$d,hk,uk,Ed,gk,_k,qd,vk,bk,Ad,wk,kk,Jr,Tk,Pk,yk,Cd,xk,$k,es,Ek,Cn,ts,qk,zd,Ak,Tf,Tt,zn,Dd,ns,Ck,jd,zk,Pf,se,os,Dk,rs,jk,Id,Ik,Mk,Sk,Pt,Fk,pi,Lk,Gk,Md,Uk,Nk,Ok,ss,Rk,as,Qk,Wk,Hk,C,is,Vk,Sd,Bk,Zk,H,Fd,Ld,Kk,Xk,Gd,Ud,Yk,Jk,Nd,Od,eT,tT,Rd,Qd,nT,oT,Wd,Hd,rT,sT,Vd,Bd,aT,iT,Zd,Kd,lT,cT,ls,dT,Xd,pT,mT,fT,Yd,hT,uT,cs,gT,Jd,_T,vT,ep,bT,wT,ds,yf,yt,Dn,tp,ps,kT,np,TT,xf,V,ms,PT,xt,yT,op,xT,$T,mi,ET,qT,AT,$t,CT,fi,zT,DT,rp,jT,IT,MT,fs,ST,sp,FT,LT,GT,hs,UT,us,NT,OT,RT,jn,gs,QT,ap,WT,$f,Et,In,ip,_s,HT,lp,VT,Ef,ae,vs,BT,bs,ZT,cp,KT,XT,YT,qt,JT,hi,eP,tP,dp,nP,oP,rP,ws,sP,ks,aP,iP,lP,Mn,Ts,cP,pp,dP,qf,At,Sn,mp,Ps,pP,fp,mP,Af,I,ys,fP,hp,hP,uP,Ct,gP,ui,_P,vP,up,bP,wP,kP,xs,TP,$s,PP,yP,xP,gp,$P,EP,Es,qP,Fn,qs,AP,_p,CP,zP,Ln,As,DP,vp,jP,Cf,zt,Gn,bp,Cs,IP,wp,MP,zf,q,zs,SP,Dt,FP,kp,LP,GP,gi,UP,NP,OP,jt,RP,_i,QP,WP,Tp,HP,VP,BP,Ds,ZP,js,KP,XP,YP,Un,Is,JP,Pp,ey,ty,De,Ms,ny,yp,oy,ry,xp,sy,ay,Nn,Ss,iy,$p,ly,cy,On,Fs,dy,Ep,py,my,Rn,Ls,fy,qp,hy,Df,It,Qn,Ap,Gs,uy,Cp,gy,jf,L,Us,_y,zp,vy,by,Mt,wy,vi,ky,Ty,Dp,Py,yy,xy,Ns,$y,Os,Ey,qy,Ay,jp,Cy,zy,Rs,Dy,Wn,Qs,jy,Ip,Iy,If,St,Hn,Mp,Ws,My,Sp,Sy,Mf,B,Hs,Fy,Vs,Ly,Fp,Gy,Uy,Ny,Ee,Oy,Lp,Ry,Qy,Gp,Wy,Hy,Up,Vy,By,Zy,Ft,Ky,bi,Xy,Yy,Np,Jy,e2,t2,Bs,n2,Zs,o2,r2,s2,Vn,Ks,a2,Xs,i2,wi,l2,c2,Sf,Lt,Bn,Op,Ys,d2,ki,p2,Rp,m2,Ff,T,Js,f2,Qp,h2,u2,Wp,g2,_2,Hp,v2,b2,Vp,w2,k2,ve,T2,Ti,P2,y2,Bp,x2,$2,Zp,E2,q2,Kp,A2,C2,z2,Zn,ea,D2,Xp,j2,I2,G,ta,M2,Yp,S2,F2,Jp,L2,G2,Kn,Xn,em,na,U2,tm,N2,O2,nm,R2,Q2,Yn,Jn,om,oa,W2,rm,H2,V2,sm,B2,Z2,eo,ra,K2,am,X2,Y2,to,sa,J2,aa,e0,im,t0,n0,o0,no,ia,r0,la,s0,lm,a0,i0,l0,oo,ca,c0,Gt,d0,cm,p0,m0,dm,f0,h0,u0,ro,da,g0,pm,_0,v0,so,pa,b0,ma,w0,mm,k0,T0,Lf;return E=new y({}),uo=new y({}),go=new O({props:{code:`pipe = pipeline("text-classification")
pipe("This restaurant is awesome"),`,highlighted:`&gt;&gt;&gt; pipe = <span class="hljs-built_in">pipeline</span>(<span class="hljs-string">&quot;text-classification&quot;</span>)
&gt;&gt;&gt; <span class="hljs-built_in">pipe</span>(<span class="hljs-string">&quot;This restaurant is awesome&quot;</span>)
<span class="hljs-selector-attr">[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: 0.9998743534088135}]</span>`}}),vo=new O({props:{code:`pipe = pipeline(model="roberta-large-mnli")
pipe("This restaurant is awesome"),`,highlighted:`&gt;&gt;&gt; pipe = <span class="hljs-built_in">pipeline</span>(model=<span class="hljs-string">&quot;roberta-large-mnli&quot;</span>)
&gt;&gt;&gt; <span class="hljs-built_in">pipe</span>(<span class="hljs-string">&quot;This restaurant is awesome&quot;</span>)
<span class="hljs-selector-attr">[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: 0.9998743534088135}]</span>`}}),bo=new O({props:{code:`pipe = pipeline("text-classification")
pipe(["This restaurant is awesome", "This restaurant is aweful"]),`,highlighted:`&gt;&gt;&gt; <span class="hljs-keyword">pipe</span> = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>)
&gt;&gt;&gt; <span class="hljs-keyword">pipe</span>([<span class="hljs-string">&quot;This restaurant is awesome&quot;</span>, <span class="hljs-string">&quot;This restaurant is aweful&quot;</span>])
[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0</span>.<span class="hljs-number">9998743534088135</span>},
 {<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;NEGATIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0</span>.<span class="hljs-number">9996669292449951</span>}]`}}),wo=new O({props:{code:`import datasets
from transformers import pipeline
from transformers.pipelines.base import KeyDataset
import tqdm

pipe = pipeline("automatic-speech-recognition", model="facebook/wav2vec2-base-960h", device=0)
dataset = datasets.load_dataset("superb", name="asr", split="test")

# KeyDataset (only _pt_) will simply return the item in the dict returned by the dataset item
# as we're not interested in the _target_ part of the dataset.
for out in tqdm.tqdm(pipe(KeyDataset(dataset, "file"))):
    print(out)
    # {"text": "NUMBER TEN FRESH NELLY IS WAITING ON YOU GOOD NIGHT HUSBAND"}
    # {"text": ....}
    # ....,`,highlighted:`import datasets
<span class="hljs-keyword">from</span> transformers import pipeline
<span class="hljs-keyword">from</span> transformers.pipelines.base import KeyDataset
import tqdm

pipe = pipeline(<span class="hljs-string">&quot;automatic-speech-recognition&quot;</span>, <span class="hljs-attribute">model</span>=<span class="hljs-string">&quot;facebook/wav2vec2-base-960h&quot;</span>, <span class="hljs-attribute">device</span>=0)
dataset = datasets.load_dataset(<span class="hljs-string">&quot;superb&quot;</span>, <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;asr&quot;</span>, <span class="hljs-attribute">split</span>=<span class="hljs-string">&quot;test&quot;</span>)

<span class="hljs-comment"># KeyDataset (only _pt_) will simply return the item in the dict returned by the dataset item</span>
<span class="hljs-comment"># as we&#x27;re not interested in the _target_ part of the dataset.</span>
<span class="hljs-keyword">for</span> out <span class="hljs-keyword">in</span> tqdm.tqdm(pipe(KeyDataset(dataset, <span class="hljs-string">&quot;file&quot;</span>))):
    <span class="hljs-built_in">print</span>(out)
    # {<span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;NUMBER TEN FRESH NELLY IS WAITING ON YOU GOOD NIGHT HUSBAND&quot;</span>}
    # {<span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>}
    # <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>`}}),ko=new b({props:{name:"transformers.pipeline",anchor:"transformers.pipeline",parameters:[{name:"task",val:": str = None"},{name:"model",val:": typing.Optional = None"},{name:"config",val:": typing.Union[str, transformers.configuration_utils.PretrainedConfig, NoneType] = None"},{name:"tokenizer",val:": typing.Union[str, transformers.tokenization_utils.PreTrainedTokenizer, NoneType] = None"},{name:"feature_extractor",val:": typing.Union[str, ForwardRef('SequenceFeatureExtractor'), NoneType] = None"},{name:"framework",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"use_fast",val:": bool = True"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"model_kwargs",val:": typing.Dict[str, typing.Any] = None"},{name:"pipeline_class",val:": typing.Optional[typing.Any] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines.py#L362",parametersDescription:[{anchor:"transformers.pipeline.task",description:`<strong>task</strong> (<code>str</code>) &#x2014;
The task defining which pipeline will be returned. Currently accepted tasks are:</p>
<ul>
<li><code>&quot;audio-classification&quot;</code>: will return a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.AudioClassificationPipeline">AudioClassificationPipeline</a>:.</li>
<li><code>&quot;automatic-speech-recognition&quot;</code>: will return a
<a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.AutomaticSpeechRecognitionPipeline">AutomaticSpeechRecognitionPipeline</a>:.</li>
<li><code>&quot;conversational&quot;</code>: will return a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.ConversationalPipeline">ConversationalPipeline</a>:.</li>
<li><code>&quot;feature-extraction&quot;</code>: will return a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.FeatureExtractionPipeline">FeatureExtractionPipeline</a>:.</li>
<li><code>&quot;fill-mask&quot;</code>: will return a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.FillMaskPipeline">FillMaskPipeline</a>:.</li>
<li><code>&quot;image-classification&quot;</code>: will return a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.ImageClassificationPipeline">ImageClassificationPipeline</a>:.</li>
<li><code>&quot;question-answering&quot;</code>: will return a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.QuestionAnsweringPipeline">QuestionAnsweringPipeline</a>:.</li>
<li><code>&quot;table-question-answering&quot;</code>: will return a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.TableQuestionAnsweringPipeline">TableQuestionAnsweringPipeline</a>:.</li>
<li><code>&quot;text2text-generation&quot;</code>: will return a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.Text2TextGenerationPipeline">Text2TextGenerationPipeline</a>:.</li>
<li><code>&quot;text-classification&quot;</code> (alias &#x201C;&#x201C;sentiment-analysis&#x201D; available): will return a</li>
<li><code>&quot;text-generation&quot;</code>: will return a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.TextGenerationPipeline">TextGenerationPipeline</a>:.</li>
<li><code>&quot;token-classification&quot;</code> (alias <code>&quot;ner&quot;</code> available): will return a
<a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.TokenClassificationPipeline">TokenClassificationPipeline</a>:.</li>
<li><code>&quot;translation&quot;</code>: will return a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.TranslationPipeline">TranslationPipeline</a>:.</li>
<li><code>&quot;translation_xx_to_yy&quot;</code>: will return a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.TranslationPipeline">TranslationPipeline</a>:.</li>
<li><code>&quot;summarization&quot;</code>: will return a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.SummarizationPipeline">SummarizationPipeline</a>:.</li>
<li><code>&quot;zero-shot-classification&quot;</code>: will return a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.ZeroShotClassificationPipeline">ZeroShotClassificationPipeline</a>:.</li>
</ul>`,name:"task"},{anchor:"transformers.pipeline.model",description:`<strong>model</strong> (<code>str</code> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>, <em>optional</em>) &#x2014;
The model that will be used by the pipeline to make predictions. This can be a model identifier or an
actual instance of a pretrained model inheriting from <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> (for PyTorch)
or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> (for TensorFlow).</p>
<p>If not provided, the default for the <code>task</code> will be loaded.`,name:"model"},{anchor:"transformers.pipeline.config",description:`<strong>config</strong> (<code>str</code> or <a href="/docs/transformers/v4.14.1/en/main_classes/configuration#transformers.PretrainedConfig">PretrainedConfig</a>, <em>optional</em>) &#x2014;
The configuration that will be used by the pipeline to instantiate the model. This can be a model
identifier or an actual pretrained model configuration inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/configuration#transformers.PretrainedConfig">PretrainedConfig</a>.</p>
<p>If not provided, the default configuration file for the requested model will be used. That means that if
<code>model</code> is given, its default configuration will be used. However, if <code>model</code> is not supplied,
this <code>task</code>&#x2019;s default model&#x2019;s config is used instead.`,name:"config"},{anchor:"transformers.pipeline.tokenizer",description:`<strong>tokenizer</strong> (<code>str</code> or <a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>, <em>optional</em>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This can be a model
identifier or an actual pretrained tokenizer inheriting from <a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.</p>
<p>If not provided, the default tokenizer for the given <code>model</code> will be loaded (if it is a string). If
<code>model</code> is not specified or not a string, then the default tokenizer for <code>config</code> is loaded (if
it is a string). However, if <code>config</code> is also not given or not a string, then the default tokenizer
for the given <code>task</code> will be loaded.`,name:"tokenizer"},{anchor:"transformers.pipeline.feature_extractor",description:`<strong>feature_extractor</strong> (<code>str</code> or <code>PreTrainedFeatureExtractor</code>, <em>optional</em>) &#x2014;
The feature extractor that will be used by the pipeline to encode data for the model. This can be a model
identifier or an actual pretrained feature extractor inheriting from
<code>PreTrainedFeatureExtractor</code>.</p>
<p>Feature extractors are used for non-NLP models, such as Speech or Vision models as well as multi-modal
models. Multi-modal models will also require a tokenizer to be passed.</p>
<p>If not provided, the default feature extractor for the given <code>model</code> will be loaded (if it is a
string). If <code>model</code> is not specified or not a string, then the default feature extractor for
<code>config</code> is loaded (if it is a string). However, if <code>config</code> is also not given or not a string,
then the default feature extractor for the given <code>task</code> will be loaded.`,name:"feature_extractor"},{anchor:"transformers.pipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.pipeline.revision(str,",description:`<strong>revision(<code>str</code>,</strong> <em>optional</em>, defaults to <code>&quot;main&quot;</code>) &#x2014;
When passing a task name or a string model identifier: The specific model version to use. It can be a
branch name, a tag name, or a commit id, since we use a git-based system for storing models and other
artifacts on huggingface.co, so <code>revision</code> can be any identifier allowed by git.`,name:"revision(str,"},{anchor:"transformers.pipeline.use_fast",description:`<strong>use_fast</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to use a Fast tokenizer if possible (a <a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast">PreTrainedTokenizerFast</a>).`,name:"use_fast"},{anchor:"transformers.pipeline.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code> or <em>bool</em>, <em>optional</em>) &#x2014;
The token to use as HTTP bearer authorization for remote files. If <code>True</code>, will use the token
generated when running <code>transformers-cli login</code> (stored in <code>~/.huggingface</code>).
revision(<code>str</code>, <em>optional</em>, defaults to <code>&quot;main&quot;</code>):
model_kwargs &#x2014;
Additional dictionary of keyword arguments passed along to the model&#x2019;s <code>from_pretrained(..., **model_kwargs)</code> function.
kwargs &#x2014;
Additional keyword arguments passed along to the specific pipeline init (see the documentation for the
corresponding pipeline class for possible values).`,name:"use_auth_token"}],returnDescription:`
<p>A suitable pipeline for the task.</p>
`,returnType:`
<p>[\`~transformers.Pipeline\u201C]</p>
`}}),xo=new O({props:{code:`from transformers import pipeline, AutoModelForTokenClassification, AutoTokenizer

# Sentiment analysis pipeline
pipeline('sentiment-analysis')

# Question answering pipeline, specifying the checkpoint identifier
pipeline('question-answering', model='distilbert-base-cased-distilled-squad', tokenizer='bert-base-cased')

# Named entity recognition pipeline, passing in a specific model and tokenizer
model = AutoModelForTokenClassification.from_pretrained("dbmdz/bert-large-cased-finetuned-conll03-english")
tokenizer = AutoTokenizer.from_pretrained("bert-base-cased")
pipeline('ner', model=model, tokenizer=tokenizer),`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline, AutoModelForTokenClassification, AutoTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Sentiment analysis pipeline</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pipeline(<span class="hljs-string">&#x27;sentiment-analysis&#x27;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Question answering pipeline, specifying the checkpoint identifier</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pipeline(<span class="hljs-string">&#x27;question-answering&#x27;</span>, model=<span class="hljs-string">&#x27;distilbert-base-cased-distilled-squad&#x27;</span>, tokenizer=<span class="hljs-string">&#x27;bert-base-cased&#x27;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Named entity recognition pipeline, passing in a specific model and tokenizer</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = AutoModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;dbmdz/bert-large-cased-finetuned-conll03-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;bert-base-cased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>pipeline(<span class="hljs-string">&#x27;ner&#x27;</span>, model=model, tokenizer=tokenizer)`}}),$o=new y({}),Eo=new O({props:{code:`from transformers import pipeline                                                   
from transformers.pipelines.base import KeyDataset
import datasets
import tqdm                                                                         

dataset = datasets.load_dataset("imdb", name="plain_text", split="unsupervised")
pipe = pipeline("text-classification", device=0)
for out in pipe(KeyDataset(dataset, "text"), batch_size=8, truncation="only_first"):
    print(out)
    # [{'label': 'POSITIVE', 'score': 0.9998743534088135}]
    # Exactly the same output as before, but the content are passed
    # as batches to the model,`,highlighted:`<span class="hljs-keyword">from</span> transformers import pipeline                                                   
<span class="hljs-keyword">from</span> transformers.pipelines.base import KeyDataset
import datasets
import tqdm                                                                         

dataset = datasets.load_dataset(<span class="hljs-string">&quot;imdb&quot;</span>, <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;plain_text&quot;</span>, <span class="hljs-attribute">split</span>=<span class="hljs-string">&quot;unsupervised&quot;</span>)
pipe = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>, <span class="hljs-attribute">device</span>=0)
<span class="hljs-keyword">for</span> out <span class="hljs-keyword">in</span> pipe(KeyDataset(dataset, <span class="hljs-string">&quot;text&quot;</span>), <span class="hljs-attribute">batch_size</span>=8, <span class="hljs-attribute">truncation</span>=<span class="hljs-string">&quot;only_first&quot;</span>):
    <span class="hljs-built_in">print</span>(out)
    # [{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: 0.9998743534088135}]
    # Exactly the same output as before, but the content are passed
    # as batches <span class="hljs-keyword">to</span> the model`}}),Bt=new Fq({props:{warning:!0,$$slots:{default:[Oq]},$$scope:{ctx:mo}}}),qo=new O({props:{code:`from transformers import pipeline                                                   
from torch.utils.data import Dataset                                                
import tqdm                                                                         


pipe = pipeline("text-classification", device=0)                                    


class MyDataset(Dataset):                                                           
    def __len__(self):                                                              
        return 5000                                                                 

    def __getitem__(self, i):                                                       
        return "This is a test"                                                     


dataset = MyDataset()   

for batch_size in [1, 8, 64, 256]:
    print("-" * 30)                                                                     
    print(f"Streaming batch_size={batch_size}")    
    for out in tqdm.tqdm(pipe(dataset, batch_size=batch_size), total=len(dataset)):              
        pass,`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline                                                   
<span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset                                                
<span class="hljs-keyword">import</span> tqdm                                                                         


pipe = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>, device=<span class="hljs-number">0</span>)                                    


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):                                                           
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):                                                              
        <span class="hljs-keyword">return</span> <span class="hljs-number">5000</span>                                                                 

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, i</span>):                                                       
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is a test&quot;</span>                                                     


dataset = MyDataset()   

<span class="hljs-keyword">for</span> batch_size <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">64</span>, <span class="hljs-number">256</span>]:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">30</span>)                                                                     
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Streaming batch_size=<span class="hljs-subst">{batch_size}</span>&quot;</span>)    
    <span class="hljs-keyword">for</span> out <span class="hljs-keyword">in</span> tqdm.tqdm(pipe(dataset, batch_size=batch_size), total=<span class="hljs-built_in">len</span>(dataset)):              
        <span class="hljs-keyword">pass</span>`}}),Ao=new O({props:{code:`# On GTX 970
------------------------------
Streaming no batching
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:26<00:00, 187.52it/s]
------------------------------
Streaming batch_size=8
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:04<00:00, 1205.95it/s]
------------------------------
Streaming batch_size=64
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:02<00:00, 2478.24it/s]
------------------------------
Streaming batch_size=256
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:01<00:00, 2554.43it/s]
(diminishing returns, saturated the GPU),`,highlighted:`<span class="hljs-section"># On GTX 970
------------------------------</span>
Streaming no batching
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:26&lt;00:00, 187.52it/s]
<span class="hljs-code">------------------------------
Streaming batch_size=8
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:04&lt;00:00, 1205.95it/s]
------------------------------</span>
Streaming batch<span class="hljs-emphasis">_size=64
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:02&lt;00:00, 2478.24it/s]
------------------------------
Streaming batch_</span>size=256
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:01&lt;00:00, 2554.43it/s]
(diminishing returns, saturated the GPU)`}}),Co=new O({props:{code:`class MyDataset(Dataset):                                                           
    def __len__(self):                                                              
        return 5000                                                                 

    def __getitem__(self, i):                                                       
        if i % 64 == 0:                                                          
            n = 100                                                              
        else:                                                                    
            n = 1                                                                
        return "This is a test" * n,`,highlighted:`<span class="hljs-keyword">class</span> <span class="hljs-symbol">MyDataset</span>(<span class="hljs-symbol">Dataset</span>):                                                           
    <span class="hljs-symbol">def</span> <span class="hljs-symbol">__len__</span>(<span class="hljs-symbol">self</span>):                                                              
        <span class="hljs-symbol">return</span> <span class="hljs-symbol">5000</span>                                                                 

    <span class="hljs-symbol">def</span> <span class="hljs-symbol">__getitem__</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">i</span></span>):                                                       
        <span class="hljs-symbol">if</span> <span class="hljs-symbol">i</span> % <span class="hljs-symbol">64</span> == <span class="hljs-symbol">0:                                                          
            <span class="hljs-symbol">n</span></span> = <span class="hljs-symbol">100</span>                                                              
        <span class="hljs-symbol">else:                                                                    
            <span class="hljs-symbol">n</span></span> = <span class="hljs-symbol">1</span>                                                                
        <span class="hljs-symbol">return</span> &quot;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">test</span>&quot; * <span class="hljs-symbol">n</span>`}}),zo=new O({props:{code:`------------------------------
Streaming no batching
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:05<00:00, 183.69it/s]
------------------------------
Streaming batch_size=8
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:03<00:00, 265.74it/s]
------------------------------
Streaming batch_size=64
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:26<00:00, 37.80it/s]
------------------------------
Streaming batch_size=256
  0%|                                                                                 | 0/1000 [00:00<?, ?it/s]
Traceback (most recent call last):
  File "/home/nicolas/src/transformers/test.py", line 42, in <module>
    for out in tqdm.tqdm(pipe(dataset, batch_size=256), total=len(dataset)):
....
    q = q / math.sqrt(dim_per_head)  # (bs, n_heads, q_length, dim_per_head)
RuntimeError: CUDA out of memory. Tried to allocate 376.00 MiB (GPU 0; 3.95 GiB total capacity; 1.72 GiB already allocated; 354.88 MiB free; 2.46 GiB reserved in total by PyTorch),`,highlighted:`<span class="hljs-comment">------------------------------</span>
Streaming no batching
<span class="hljs-number">100</span>%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| <span class="hljs-number">1000</span>/<span class="hljs-number">1000</span> [<span class="hljs-number">00</span>:<span class="hljs-number">05</span>&lt;<span class="hljs-number">00</span>:<span class="hljs-number">00</span>, <span class="hljs-number">183.69</span><span class="hljs-keyword">it</span>/s]
<span class="hljs-comment">------------------------------</span>
Streaming batch_size=<span class="hljs-number">8</span>
<span class="hljs-number">100</span>%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| <span class="hljs-number">1000</span>/<span class="hljs-number">1000</span> [<span class="hljs-number">00</span>:<span class="hljs-number">03</span>&lt;<span class="hljs-number">00</span>:<span class="hljs-number">00</span>, <span class="hljs-number">265.74</span><span class="hljs-keyword">it</span>/s]
<span class="hljs-comment">------------------------------</span>
Streaming batch_size=<span class="hljs-number">64</span>
<span class="hljs-number">100</span>%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| <span class="hljs-number">1000</span>/<span class="hljs-number">1000</span> [<span class="hljs-number">00</span>:<span class="hljs-number">26</span>&lt;<span class="hljs-number">00</span>:<span class="hljs-number">00</span>, <span class="hljs-number">37.80</span><span class="hljs-keyword">it</span>/s]
<span class="hljs-comment">------------------------------</span>
Streaming batch_size=<span class="hljs-number">256</span>
  <span class="hljs-number">0</span>%|                                                                                 | <span class="hljs-number">0</span>/<span class="hljs-number">1000</span> [<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-meta">&lt;?</span>, ?<span class="hljs-keyword">it</span>/s]
Traceback (most recent call <span class="hljs-keyword">last</span>):
  File <span class="hljs-string">&quot;/home/nicolas/src/transformers/test.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">42</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    <span class="hljs-keyword">for</span> out <span class="hljs-keyword">in</span> tqdm.tqdm(pipe(dataset, batch_size=<span class="hljs-number">256</span>), total=<span class="hljs-built_in">len</span>(dataset)):
....
    q = q / math.<span class="hljs-built_in">sqrt</span>(dim_per_head)  <span class="hljs-comment"># (bs, n_heads, q_length, dim_per_head)</span>
RuntimeError: CUDA out <span class="hljs-keyword">of</span> memory. Tried <span class="hljs-built_in">to</span> allocate <span class="hljs-number">376.00</span> MiB (GPU <span class="hljs-number">0</span>; <span class="hljs-number">3.95</span> GiB total capacity; <span class="hljs-number">1.72</span> GiB already allocated; <span class="hljs-number">354.88</span> MiB free; <span class="hljs-number">2.46</span> GiB reserved <span class="hljs-keyword">in</span> total <span class="hljs-keyword">by</span> PyTorch)`}}),jo=new y({}),Io=new O({props:{code:`class MyPipeline(TextClassificationPipeline):
    def postprocess(...):
        ...
        scores = scores * 100
        ...

my_pipeline = MyPipeline(model=model, tokenizer=tokenizer, ...)
# or if you use _pipeline_ function, then:
my_pipeline = pipeline(model="xxxx", pipeline_class=MyPipeline),`,highlighted:`class MyPipeline(TextClassificationPipeline):
    def postprocess(<span class="hljs-built_in">..</span>.):
        <span class="hljs-built_in">..</span>.
        scores = scores * 100
        <span class="hljs-built_in">..</span>.

my_pipeline = MyPipeline(<span class="hljs-attribute">model</span>=model, <span class="hljs-attribute">tokenizer</span>=tokenizer, <span class="hljs-built_in">..</span>.)
<span class="hljs-comment"># or if you use _pipeline_ function, then:</span>
my_pipeline = pipeline(<span class="hljs-attribute">model</span>=<span class="hljs-string">&quot;xxxx&quot;</span>, <span class="hljs-attribute">pipeline_class</span>=MyPipeline)`}}),Mo=new y({}),So=new y({}),Fo=new y({}),Lo=new b({props:{name:"class transformers.AudioClassificationPipeline",anchor:"transformers.AudioClassificationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/audio_classification.py#L67",parametersDescription:[{anchor:"transformers.AudioClassificationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.AudioClassificationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.AudioClassificationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.AudioClassificationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.AudioClassificationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.AudioClassificationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.AudioClassificationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.AudioClassificationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.AudioClassificationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.AudioClassificationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}]}}),Oo=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.AudioClassificationPipeline.__call__",parameters:[{name:"inputs",val:": typing.Union[numpy.ndarray, bytes, str]"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/audio_classification.py#L90",parametersDescription:[{anchor:"transformers.AudioClassificationPipeline.__call__.inputs",description:`<strong>inputs</strong> (<code>np.ndarray</code> or <code>bytes</code> or <code>str</code>) &#x2014;
The inputs is either a raw waveform (<code>np.ndarray</code> of shape (n, ) of type <code>np.float32</code> or
<code>np.float64</code>) at the correct sampling rate (no further check will be done) or a <code>str</code> that is
the filename of the audio file, the file will be read at the correct sampling rate to get the waveform
using <em>ffmpeg</em>. This requires <em>ffmpeg</em> to be installed on the system. If <em>inputs</em> is <code>bytes</code> it is
supposed to be the content of an audio file and is interpreted by <em>ffmpeg</em> in the same way.`,name:"inputs"},{anchor:"transformers.AudioClassificationPipeline.__call__.top_k",description:`<strong>top_k</strong> (<code>int</code>, <em>optional</em>, defaults to None) &#x2014;
The number of top labels that will be returned by the pipeline. If the provided number is <em>None</em> or
higher than the number of labels available in the model configuration, it will default to the number of
labels.`,name:"top_k"}],returnDescription:`
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 The label predicted.</li>
<li><strong>score</strong> (<code>float</code>) \u2014 The corresponding probability.</li>
</ul>
`,returnType:`
<p>A list of <code>dict</code> with the following keys</p>
`}}),Qo=new y({}),Wo=new b({props:{name:"class transformers.AutomaticSpeechRecognitionPipeline",anchor:"transformers.AutomaticSpeechRecognitionPipeline",parameters:[{name:"feature_extractor",val:": typing.Union[ForwardRef('SequenceFeatureExtractor'), str]"},{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/automatic_speech_recognition.py#L69"}}),Ho=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.AutomaticSpeechRecognitionPipeline.__call__",parameters:[{name:"inputs",val:": typing.Union[numpy.ndarray, bytes, str]"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/automatic_speech_recognition.py#L111",parametersDescription:[{anchor:"transformers.AutomaticSpeechRecognitionPipeline.__call__.inputs",description:`<strong>inputs</strong> (<code>np.ndarray</code> or <code>bytes</code> or <code>str</code>) &#x2014;
The inputs is either a raw waveform (<code>np.ndarray</code> of shape (n, ) of type <code>np.float32</code> or
<code>np.float64</code>) at the correct sampling rate (no further check will be done) or a <code>str</code> that is
the filename of the audio file, the file will be read at the correct sampling rate to get the waveform
using <em>ffmpeg</em>. This requires <em>ffmpeg</em> to be installed on the system. If <em>inputs</em> is <code>bytes</code> it is
supposed to be the content of an audio file and is interpreted by <em>ffmpeg</em> in the same way.`,name:"inputs"}],returnDescription:`
<ul>
<li><strong>text</strong> (<code>str</code>) \u2014 The recognized text.</li>
</ul>
`,returnType:`
<p>A <code>dict</code> with the following keys</p>
`}}),Bo=new y({}),Zo=new b({props:{name:"class transformers.Conversation",anchor:"transformers.Conversation",parameters:[{name:"text",val:": str = None"},{name:"conversation_id",val:": UUID = None"},{name:"past_user_inputs",val:" = None"},{name:"generated_responses",val:" = None"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/conversational.py#L19",parametersDescription:[{anchor:"transformers.Conversation.text",description:`<strong>text</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The initial user input to start the conversation. If not provided, a user input needs to be provided
manually using the <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.Conversation.add_user_input">add_user_input()</a> method before the conversation can
begin.`,name:"text"},{anchor:"transformers.Conversation.conversation_id",description:`<strong>conversation_id</strong> (<code>uuid.UUID</code>, <em>optional</em>) &#x2014;
Unique identifier for the conversation. If not provided, a random UUID4 id will be assigned to the
conversation.`,name:"conversation_id"},{anchor:"transformers.Conversation.past_user_inputs",description:`<strong>past_user_inputs</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
Eventual past history of the conversation of the user. You don&#x2019;t need to pass it manually if you use the
pipeline interactively but if you want to recreate history you need to set both <code>past_user_inputs</code> and
<code>generated_responses</code> with equal length lists of strings`,name:"past_user_inputs"},{anchor:"transformers.Conversation.generated_responses",description:`<strong>generated_responses</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
Eventual past history of the conversation of the model. You don&#x2019;t need to pass it manually if you use the
pipeline interactively but if you want to recreate history you need to set both <code>past_user_inputs</code> and
<code>generated_responses</code> with equal length lists of strings`,name:"generated_responses"}]}}),Ko=new O({props:{code:`conversation = Conversation("Going to the movies tonight - any suggestions?")

# Steps usually performed by the model when generating a response:
# 1. Mark the user input as processed (moved to the history)
conversation.mark_processed()
# 2. Append a mode response
conversation.append_response("The Big lebowski.")

conversation.add_user_input("Is it good?"),`,highlighted:`conversation = Conversation(<span class="hljs-string">&quot;Going to the movies tonight - any suggestions?&quot;</span>)

<span class="hljs-comment"># Steps usually performed by the model when generating a response:</span>
<span class="hljs-comment"># 1. Mark the user input as processed (moved to the history)</span>
conversation.mark_processed()
<span class="hljs-comment"># 2. Append a mode response</span>
conversation.append_response(<span class="hljs-string">&quot;The Big lebowski.&quot;</span>)

conversation.add_user_input(<span class="hljs-string">&quot;Is it good?&quot;</span>)`}}),Xo=new b({props:{name:"add\\_user\\_input",anchor:"transformers.Conversation.add_user_input",parameters:[{name:"text",val:": str"},{name:"overwrite",val:": bool = False"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/conversational.py#L84",parametersDescription:[{anchor:"transformers.Conversation.add_user_input.text",description:"<strong>text</strong> (<code>str</code>) &#x2014; The user input for the next conversation round.",name:"text"},{anchor:"transformers.Conversation.add_user_input.overwrite",description:`<strong>overwrite</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not existing and unprocessed user input should be overwritten when this function is called.`,name:"overwrite"}]}}),Jo=new b({props:{name:"append\\_response",anchor:"transformers.Conversation.append_response",parameters:[{name:"response",val:": str"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/conversational.py#L118",parametersDescription:[{anchor:"transformers.Conversation.append_response.response",description:"<strong>response</strong> (<code>str</code>) &#x2014; The model generated response.",name:"response"}]}}),er=new b({props:{name:"iter\\_texts",anchor:"transformers.Conversation.iter_texts",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/conversational.py#L127"}}),tr=new b({props:{name:"mark\\_processed",anchor:"transformers.Conversation.mark_processed",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/conversational.py#L109"}}),nr=new b({props:{name:"class transformers.ConversationalPipeline",anchor:"transformers.ConversationalPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/conversational.py#L166",parametersDescription:[{anchor:"transformers.ConversationalPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.ConversationalPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.ConversationalPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.ConversationalPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>          If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.ConversationalPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.ConversationalPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.ConversationalPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.ConversationalPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.ConversationalPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.ConversationalPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"},{anchor:"transformers.ConversationalPipeline.min_length_for_response",description:`<strong>min_length_for_response</strong> (<code>int</code>, <em>optional</em>, defaults to 32) &#x2014;
The minimum length (in number of tokens) for a response.`,name:"min_length_for_response"},{anchor:"transformers.ConversationalPipeline.minimum_tokens",description:`<strong>minimum_tokens</strong> (<code>int</code>, <em>optional</em>, defaults to 10) &#x2014;
The minimum length of tokens to leave for a response.`,name:"minimum_tokens"}]}}),rr=new O({props:{code:`conversational_pipeline = pipeline("conversational")

conversation_1 = Conversation("Going to the movies tonight - any suggestions?")
conversation_2 = Conversation("What's the last book you have read?")

conversational_pipeline([conversation_1, conversation_2])

conversation_1.add_user_input("Is it an action movie?")
conversation_2.add_user_input("What is the genre of this book?")

conversational_pipeline([conversation_1, conversation_2]),`,highlighted:`conversational_pipeline = pipeline(<span class="hljs-string">&quot;conversational&quot;</span>)

conversation_1 = Conversation(<span class="hljs-string">&quot;Going to the movies tonight - any suggestions?&quot;</span>)
conversation_2 = Conversation(<span class="hljs-string">&quot;What&#x27;s the last book you have read?&quot;</span>)

conversational_pipeline([conversation_1, conversation_2])

conversation_1.add_user_input(<span class="hljs-string">&quot;Is it an action movie?&quot;</span>)
conversation_2.add_user_input(<span class="hljs-string">&quot;What is the genre of this book?&quot;</span>)

conversational_pipeline([conversation_1, conversation_2])`}}),sr=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.ConversationalPipeline.__call__",parameters:[{name:"conversations",val:": typing.Union[transformers.pipelines.conversational.Conversation, typing.List[transformers.pipelines.conversational.Conversation]]"},{name:"num_workers",val:" = 0"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/conversational.py#L220",parametersDescription:[{anchor:"transformers.ConversationalPipeline.__call__.conversations",description:`<strong>conversations</strong> (a <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.Conversation">Conversation</a> or a list of <a href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.Conversation">Conversation</a>) &#x2014;
Conversations to generate responses for.`,name:"conversations"},{anchor:"transformers.ConversationalPipeline.__call__.clean_up_tokenization_spaces",description:`<strong>clean_up_tokenization_spaces</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to clean up the potential extra spaces in the text output.
generate_kwargs &#x2014;
Additional keyword arguments to pass along to the generate method of the model (see the generate method
corresponding to your framework <a href="./model#generative-models">here</a>).`,name:"clean_up_tokenization_spaces"}],returnDescription:`
<p>Conversation(s) with
updated generated responses for those containing a new user input.</p>
`,returnType:`
<p><a
  href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.Conversation"
>Conversation</a> or a list of <a
  href="/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.Conversation"
>Conversation</a></p>
`}}),ar=new y({}),ir=new b({props:{name:"class transformers.FeatureExtractionPipeline",anchor:"transformers.FeatureExtractionPipeline",parameters:[{name:"model",val:": typing.Union[ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel')]"},{name:"tokenizer",val:": typing.Optional[transformers.tokenization_utils.PreTrainedTokenizer] = None"},{name:"feature_extractor",val:": typing.Optional[ForwardRef('SequenceFeatureExtractor')] = None"},{name:"modelcard",val:": typing.Optional[transformers.modelcard.ModelCard] = None"},{name:"framework",val:": typing.Optional[str] = None"},{name:"task",val:": str = ''"},{name:"args_parser",val:": ArgumentHandler = None"},{name:"device",val:": int = -1"},{name:"binary_output",val:": bool = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/feature_extraction.py#L7",parametersDescription:[{anchor:"transformers.FeatureExtractionPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.FeatureExtractionPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.FeatureExtractionPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.FeatureExtractionPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.FeatureExtractionPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.FeatureExtractionPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.FeatureExtractionPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"}]}}),dr=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.FeatureExtractionPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/feature_extraction.py#L70",parametersDescription:[{anchor:"transformers.FeatureExtractionPipeline.__call__.args",description:"<strong>args</strong> (<code>str</code> or <code>List[str]</code>) &#x2014; One or several texts (or one list of texts) to get the features of.",name:"args"}],returnDescription:`
<p>The features computed by the model.</p>
`,returnType:`
<p>A nested list of <code>float</code></p>
`}}),pr=new y({}),mr=new b({props:{name:"class transformers.FillMaskPipeline",anchor:"transformers.FillMaskPipeline",parameters:[{name:"model",val:": typing.Union[ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel')]"},{name:"tokenizer",val:": typing.Optional[transformers.tokenization_utils.PreTrainedTokenizer] = None"},{name:"feature_extractor",val:": typing.Optional[ForwardRef('SequenceFeatureExtractor')] = None"},{name:"modelcard",val:": typing.Optional[transformers.modelcard.ModelCard] = None"},{name:"framework",val:": typing.Optional[str] = None"},{name:"task",val:": str = ''"},{name:"args_parser",val:": ArgumentHandler = None"},{name:"device",val:": int = -1"},{name:"binary_output",val:": bool = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/fill_mask.py#L33",parametersDescription:[{anchor:"transformers.FillMaskPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.FillMaskPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.FillMaskPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.FillMaskPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.FillMaskPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.FillMaskPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.FillMaskPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.FillMaskPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.FillMaskPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.FillMaskPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"},{anchor:"transformers.FillMaskPipeline.top_k",description:`<strong>top_k</strong> (<code>int</code>, defaults to 5) &#x2014;
The number of predictions to return.`,name:"top_k"},{anchor:"transformers.FillMaskPipeline.targets",description:`<strong>targets</strong> (<code>str</code> or <code>List[str]</code>, <em>optional</em>) &#x2014;
When passed, the model will limit the scores to the passed targets instead of looking up in the whole
vocab. If the provided targets are not in the model vocab, they will be tokenized and the first resulting
token will be used (with a warning, and that might be slower).`,name:"targets"}]}}),fn=new Fq({props:{$$slots:{default:[Rq]},$$scope:{ctx:mo}}}),ur=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.FillMaskPipeline.__call__",parameters:[{name:"inputs",val:""},{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/fill_mask.py#L203",parametersDescription:[{anchor:"transformers.FillMaskPipeline.__call__.args",description:`<strong>args</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
One or several texts (or one list of prompts) with masked tokens.`,name:"args"},{anchor:"transformers.FillMaskPipeline.__call__.targets",description:`<strong>targets</strong> (<code>str</code> or <code>List[str]</code>, <em>optional</em>) &#x2014;
When passed, the model will limit the scores to the passed targets instead of looking up in the whole
vocab. If the provided targets are not in the model vocab, they will be tokenized and the first
resulting token will be used (with a warning, and that might be slower).`,name:"targets"},{anchor:"transformers.FillMaskPipeline.__call__.top_k",description:`<strong>top_k</strong> (<code>int</code>, <em>optional</em>) &#x2014;
When passed, overrides the number of predictions to return.`,name:"top_k"}],returnDescription:`
<p>Each result comes as list of dictionaries with the following keys:</p>
<ul>
<li><strong>sequence</strong> (<code>str</code>) \u2014 The corresponding input with the mask token prediction.</li>
<li><strong>score</strong> (<code>float</code>) \u2014 The corresponding probability.</li>
<li><strong>token</strong> (<code>int</code>) \u2014 The predicted token id (to replace the masked one).</li>
<li><strong>token</strong> (<code>str</code>) \u2014 The predicted token (to replace the masked one).</li>
</ul>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),gr=new y({}),_r=new b({props:{name:"class transformers.ImageClassificationPipeline",anchor:"transformers.ImageClassificationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/image_classification.py#L20",parametersDescription:[{anchor:"transformers.ImageClassificationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.ImageClassificationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.ImageClassificationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.ImageClassificationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.ImageClassificationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.ImageClassificationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.ImageClassificationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.ImageClassificationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.ImageClassificationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.ImageClassificationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}]}}),kr=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.ImageClassificationPipeline.__call__",parameters:[{name:"images",val:": typing.Union[str, typing.List[str], ForwardRef('Image.Image'), typing.List[ForwardRef('Image.Image')]]"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/image_classification.py#L47",parametersDescription:[{anchor:"transformers.ImageClassificationPipeline.__call__.images",description:`<strong>images</strong> (<code>str</code>, <code>List[str]</code>, <code>PIL.Image</code> or <code>List[PIL.Image]</code>) &#x2014;
The pipeline handles three types of images:</p>
<ul>
<li>A string containing a http link pointing to an image</li>
<li>A string containing a local path to an image</li>
<li>An image loaded in PIL directly</li>
</ul>
<p>The pipeline accepts either a single image or a batch of images, which must then be passed as a string.
Images in a batch must all be in the same format: all as http links, all as local paths, or all as PIL
images.`,name:"images"},{anchor:"transformers.ImageClassificationPipeline.__call__.top_k",description:`<strong>top_k</strong> (<code>int</code>, <em>optional</em>, defaults to 5) &#x2014;
The number of top labels that will be returned by the pipeline. If the provided number is higher than
the number of labels available in the model configuration, it will default to the number of labels.`,name:"top_k"}],returnDescription:`
<p>A dictionary or a list of dictionaries containing result. If the input is a single image, will return a
dictionary, if the input is a list of several images, will return a list of dictionaries corresponding to
the images.</p>
<p>The dictionaries contain the following keys:</p>
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 The label identified by the model.</li>
<li><strong>score</strong> (<code>int</code>) \u2014 The score attributed by the model for that label.</li>
</ul>
`}}),Tr=new y({}),Pr=new b({props:{name:"class transformers.ImageSegmentationPipeline",anchor:"transformers.ImageSegmentationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/image_segmentation.py#L30",parametersDescription:[{anchor:"transformers.ImageSegmentationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.ImageSegmentationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.ImageSegmentationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.ImageSegmentationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.ImageSegmentationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.ImageSegmentationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.ImageSegmentationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.ImageSegmentationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.ImageSegmentationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.ImageSegmentationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}]}}),Er=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.ImageSegmentationPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/image_segmentation.py#L59",parametersDescription:[{anchor:"transformers.ImageSegmentationPipeline.__call__.images",description:`<strong>images</strong> (<code>str</code>, <code>List[str]</code>, <code>PIL.Image</code> or <code>List[PIL.Image]</code>) &#x2014;
The pipeline handles three types of images:</p>
<ul>
<li>A string containing an HTTP(S) link pointing to an image</li>
<li>A string containing a local path to an image</li>
<li>An image loaded in PIL directly</li>
</ul>
<p>The pipeline accepts either a single image or a batch of images. Images in a batch must all be in the
same format: all as HTTP(S) links, all as local paths, or all as PIL images.`,name:"images"},{anchor:"transformers.ImageSegmentationPipeline.__call__.threshold",description:`<strong>threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.9) &#x2014;
The probability necessary to make a prediction.`,name:"threshold"},{anchor:"transformers.ImageSegmentationPipeline.__call__.mask_threshold",description:`<strong>mask_threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.5) &#x2014;
Threshold to use when turning the predicted masks into binary values.`,name:"mask_threshold"}],returnDescription:`
<p>A dictionary or a list of dictionaries containing the result. If the input is a single image, will return a
dictionary, if the input is a list of several images, will return a list of dictionaries corresponding to
each image.</p>
<p>The dictionaries contain the following keys:</p>
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 The class label identified by the model.</li>
<li><strong>score</strong> (<code>float</code>) \u2014 The score attributed by the model for that label.</li>
<li><strong>mask</strong> (<code>str</code>) \u2014 base64 string of a grayscale (single-channel) PNG image that contain masks
information. The PNG image has size (heigth, width) of the original image. Pixel values in the image are
either 0 or 255 (i.e. mask is absent VS mask is present).</li>
</ul>
`}}),qr=new y({}),Ar=new b({props:{name:"class transformers.TokenClassificationPipeline",anchor:"transformers.TokenClassificationPipeline",parameters:[{name:"args_parser",val:" = <transformers.pipelines.token_classification.TokenClassificationArgumentHandler object at 0x7f740a5740a0>"},{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/token_classification.py#L85",parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.TokenClassificationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.TokenClassificationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.TokenClassificationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.TokenClassificationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.TokenClassificationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.TokenClassificationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.TokenClassificationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.TokenClassificationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.TokenClassificationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"},{anchor:"transformers.TokenClassificationPipeline.ignore_labels",description:`<strong>ignore_labels</strong> (<code>List[str]</code>, defaults to <code>[&quot;O&quot;]</code>) &#x2014;
A list of labels to ignore.`,name:"ignore_labels"},{anchor:"transformers.TokenClassificationPipeline.grouped_entities",description:`<strong>grouped_entities</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
DEPRECATED, use <code>aggregation_strategy</code> instead. Whether or not to group the tokens corresponding to
the same entity together in the predictions or not.`,name:"grouped_entities"},{anchor:"transformers.TokenClassificationPipeline.aggregation_strategy",description:`<strong>aggregation_strategy</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;none&quot;</code>) &#x2014; The strategy to fuse (or not) tokens based on the model prediction.</p>
<ul>
<li>&#x201C;none&#x201D; : Will simply not do any aggregation and simply return raw results from the model</li>
<li>&#x201C;simple&#x201D; : Will attempt to group entities following the default schema. (A, B-TAG), (B, I-TAG), (C,
I-TAG), (D, B-TAG2) (E, B-TAG2) will end up being [{&#x201C;word&#x201D;: ABC, &#x201C;entity&#x201D;: &#x201C;TAG&#x201D;}, {&#x201C;word&#x201D;: &#x201C;D&#x201D;,
&#x201C;entity&#x201D;: &#x201C;TAG2&#x201D;}, {&#x201C;word&#x201D;: &#x201C;E&#x201D;, &#x201C;entity&#x201D;: &#x201C;TAG2&#x201D;}] Notice that two consecutive B tags will end up as
different entities. On word based languages, we might end up splitting words undesirably : Imagine
Microsoft being tagged as [{&#x201C;word&#x201D;: &#x201C;Micro&#x201D;, &#x201C;entity&#x201D;: &#x201C;ENTERPRISE&#x201D;}, {&#x201C;word&#x201D;: &#x201C;soft&#x201D;, &#x201C;entity&#x201D;:
&#x201C;NAME&#x201D;}]. Look for FIRST, MAX, AVERAGE for ways to mitigate that and disambiguate words (on languages
that support that meaning, which is basically tokens separated by a space). These mitigations will
only work on real words, &#x201C;New york&#x201D; might still be tagged with two different entities.</li>
<li>&#x201C;first&#x201D; : (works only on word based models) Will use the <code>SIMPLE</code> strategy except that words,
cannot end up with different tags. Words will simply use the tag of the first token of the word when
there is ambiguity.</li>
<li>&#x201C;average&#x201D; : (works only on word based models) Will use the <code>SIMPLE</code> strategy except that words,
cannot end up with different tags. scores will be averaged first across tokens, and then the maximum
label is applied.</li>
<li>&#x201C;max&#x201D; : (works only on word based models) Will use the <code>SIMPLE</code> strategy except that words,
cannot end up with different tags. Word entity will simply be the token with the maximum score.</li>
</ul>`,name:"aggregation_strategy"}]}}),Dr=new b({props:{name:"aggregate\\_words",anchor:"transformers.TokenClassificationPipeline.aggregate_words",parameters:[{name:"entities",val:": typing.List[dict]"},{name:"aggregation_strategy",val:": AggregationStrategy"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/token_classification.py#L366"}}),jr=new b({props:{name:"gather\\_pre\\_entities",anchor:"transformers.TokenClassificationPipeline.gather_pre_entities",parameters:[{name:"sentence",val:": str"},{name:"input_ids",val:": ndarray"},{name:"scores",val:": ndarray"},{name:"offset_mapping",val:": typing.Union[typing.List[typing.Tuple[int, int]], NoneType]"},{name:"special_tokens_mask",val:": ndarray"},{name:"aggregation_strategy",val:": AggregationStrategy"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/token_classification.py#L252"}}),Ir=new b({props:{name:"group\\_entities",anchor:"transformers.TokenClassificationPipeline.group_entities",parameters:[{name:"entities",val:": typing.List[dict]"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/token_classification.py#L428",parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.group_entities.entities",description:"<strong>entities</strong> (<code>dict</code>) &#x2014; The entities predicted by the pipeline.",name:"entities"}]}}),Mr=new b({props:{name:"group\\_sub\\_entities",anchor:"transformers.TokenClassificationPipeline.group_sub_entities",parameters:[{name:"entities",val:": typing.List[dict]"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/token_classification.py#L393",parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.group_sub_entities.entities",description:"<strong>entities</strong> (<code>dict</code>) &#x2014; The entities predicted by the pipeline.",name:"entities"}]}}),Sr=new y({}),Fr=new b({props:{name:"class transformers.ObjectDetectionPipeline",anchor:"transformers.ObjectDetectionPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/object_detection.py#L25",parametersDescription:[{anchor:"transformers.ObjectDetectionPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.ObjectDetectionPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.ObjectDetectionPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.ObjectDetectionPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.ObjectDetectionPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.ObjectDetectionPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.ObjectDetectionPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.ObjectDetectionPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.ObjectDetectionPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.ObjectDetectionPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}]}}),Nr=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.ObjectDetectionPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/object_detection.py#L52",parametersDescription:[{anchor:"transformers.ObjectDetectionPipeline.__call__.images",description:`<strong>images</strong> (<code>str</code>, <code>List[str]</code>, <code>PIL.Image</code> or <code>List[PIL.Image]</code>) &#x2014;
The pipeline handles three types of images:</p>
<ul>
<li>A string containing an HTTP(S) link pointing to an image</li>
<li>A string containing a local path to an image</li>
<li>An image loaded in PIL directly</li>
</ul>
<p>The pipeline accepts either a single image or a batch of images. Images in a batch must all be in the
same format: all as HTTP(S) links, all as local paths, or all as PIL images.`,name:"images"},{anchor:"transformers.ObjectDetectionPipeline.__call__.threshold",description:`<strong>threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.9) &#x2014;
The probability necessary to make a prediction.`,name:"threshold"}],returnDescription:`
<p>A list of dictionaries or a list of list of dictionaries containing the result. If the input is a single
image, will return a list of dictionaries, if the input is a list of several images, will return a list of
list of dictionaries corresponding to each image.</p>
<p>The dictionaries contain the following keys:</p>
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 The class label identified by the model.</li>
<li><strong>score</strong> (<code>float</code>) \u2014 The score attributed by the model for that label.</li>
<li><strong>box</strong> (<code>List[Dict[str, int]]</code>) \u2014 The bounding box of detected object in image\u2019s original size.</li>
</ul>
`}}),Or=new y({}),Rr=new b({props:{name:"class transformers.QuestionAnsweringPipeline",anchor:"transformers.QuestionAnsweringPipeline",parameters:[{name:"model",val:": typing.Union[ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel')]"},{name:"tokenizer",val:": PreTrainedTokenizer"},{name:"modelcard",val:": typing.Optional[transformers.modelcard.ModelCard] = None"},{name:"framework",val:": typing.Optional[str] = None"},{name:"device",val:": int = -1"},{name:"task",val:": str = ''"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/question_answering.py#L102",parametersDescription:[{anchor:"transformers.QuestionAnsweringPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.QuestionAnsweringPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.QuestionAnsweringPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.QuestionAnsweringPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.QuestionAnsweringPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.QuestionAnsweringPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.QuestionAnsweringPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.QuestionAnsweringPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.QuestionAnsweringPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.QuestionAnsweringPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}]}}),Hr=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.QuestionAnsweringPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/question_answering.py#L204",parametersDescription:[{anchor:"transformers.QuestionAnsweringPipeline.__call__.args",description:`<strong>args</strong> (<code>SquadExample</code> or a list of <code>SquadExample</code>) &#x2014;
One or several <code>SquadExample</code> containing the question and context.`,name:"args"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.X",description:`<strong>X</strong> (<code>SquadExample</code> or a list of <code>SquadExample</code>, <em>optional</em>) &#x2014;
One or several <code>SquadExample</code> containing the question and context (will be treated
the same way as if passed as the first positional argument).`,name:"X"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.data",description:`<strong>data</strong> (<code>SquadExample</code> or a list of <code>SquadExample</code>, <em>optional</em>) &#x2014;
One or several <code>SquadExample</code> containing the question and context (will be treated
the same way as if passed as the first positional argument).`,name:"data"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.question",description:`<strong>question</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
One or several question(s) (must be used in conjunction with the <code>context</code> argument).`,name:"question"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.context",description:`<strong>context</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
One or several context(s) associated with the question(s) (must be used in conjunction with the
<code>question</code> argument).`,name:"context"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.topk",description:`<strong>topk</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
The number of answers to return (will be chosen by order of likelihood). Note that we return less than
topk answers if there are not enough options available within the context.`,name:"topk"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.doc_stride",description:`<strong>doc_stride</strong> (<code>int</code>, <em>optional</em>, defaults to 128) &#x2014;
If the context is too long to fit with the question for the model, it will be split in several chunks
with some overlap. This argument controls the size of that overlap.`,name:"doc_stride"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.max_answer_len",description:`<strong>max_answer_len</strong> (<code>int</code>, <em>optional</em>, defaults to 15) &#x2014;
The maximum length of predicted answers (e.g., only answers with a shorter length are considered).`,name:"max_answer_len"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.max_seq_len",description:`<strong>max_seq_len</strong> (<code>int</code>, <em>optional</em>, defaults to 384) &#x2014;
The maximum length of the total sentence (context + question) after tokenization. The context will be
split in several chunks (using <code>doc_stride</code>) if needed.`,name:"max_seq_len"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.max_question_len",description:`<strong>max_question_len</strong> (<code>int</code>, <em>optional</em>, defaults to 64) &#x2014;
The maximum length of the question after tokenization. It will be truncated if needed.`,name:"max_question_len"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.handle_impossible_answer",description:`<strong>handle_impossible_answer</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not we accept impossible as an answer.`,name:"handle_impossible_answer"}],returnDescription:`
<p>Each result comes as a dictionary with the following keys:</p>
<ul>
<li><strong>score</strong> (<code>float</code>) \u2014 The probability associated to the answer.</li>
<li><strong>start</strong> (<code>int</code>) \u2014 The character start index of the answer (in the tokenized version of the
input).</li>
<li><strong>end</strong> (<code>int</code>) \u2014 The character end index of the answer (in the tokenized version of the input).</li>
<li><strong>answer</strong> (<code>str</code>) \u2014 The answer to the question.</li>
</ul>
`,returnType:`
<p>A <code>dict</code> or a list of <code>dict</code></p>
`}}),Vr=new b({props:{name:"create\\_sample",anchor:"transformers.QuestionAnsweringPipeline.create_sample",parameters:[{name:"question",val:": typing.Union[str, typing.List[str]]"},{name:"context",val:": typing.Union[str, typing.List[str]]"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/question_answering.py#L143",parametersDescription:[{anchor:"transformers.QuestionAnsweringPipeline.create_sample.question",description:"<strong>question</strong> (<code>str</code> or <code>List[str]</code>) &#x2014; The question(s) asked.",name:"question"},{anchor:"transformers.QuestionAnsweringPipeline.create_sample.context",description:"<strong>context</strong> (<code>str</code> or <code>List[str]</code>) &#x2014; The context(s) in which we will look for the answer.",name:"context"}],returnDescription:`
<p>The corresponding <code>SquadExample</code>
grouping question and context.</p>
`,returnType:`
<p>One or a list of <code>SquadExample</code></p>
`}}),Br=new b({props:{name:"decode",anchor:"transformers.QuestionAnsweringPipeline.decode",parameters:[{name:"start",val:": ndarray"},{name:"end",val:": ndarray"},{name:"topk",val:": int"},{name:"max_answer_len",val:": int"},{name:"undesired_tokens",val:": ndarray"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/question_answering.py#L479",parametersDescription:[{anchor:"transformers.QuestionAnsweringPipeline.decode.start",description:"<strong>start</strong> (<code>np.ndarray</code>) &#x2014; Individual start probabilities for each token.",name:"start"},{anchor:"transformers.QuestionAnsweringPipeline.decode.end",description:"<strong>end</strong> (<code>np.ndarray</code>) &#x2014; Individual end probabilities for each token.",name:"end"},{anchor:"transformers.QuestionAnsweringPipeline.decode.topk",description:"<strong>topk</strong> (<code>int</code>) &#x2014; Indicates how many possible answer span(s) to extract from the model output.",name:"topk"},{anchor:"transformers.QuestionAnsweringPipeline.decode.max_answer_len",description:"<strong>max_answer_len</strong> (<code>int</code>) &#x2014; Maximum size of the answer to extract from the model&#x2019;s output.",name:"max_answer_len"},{anchor:"transformers.QuestionAnsweringPipeline.decode.undesired_tokens",description:"<strong>undesired_tokens</strong> (<code>np.ndarray</code>) &#x2014; Mask determining tokens that can be part of the answer",name:"undesired_tokens"}]}}),Kr=new b({props:{name:"span\\_to\\_answer",anchor:"transformers.QuestionAnsweringPipeline.span_to_answer",parameters:[{name:"text",val:": str"},{name:"start",val:": int"},{name:"end",val:": int"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/question_answering.py#L528",parametersDescription:[{anchor:"transformers.QuestionAnsweringPipeline.span_to_answer.text",description:"<strong>text</strong> (<code>str</code>) &#x2014; The actual context to extract the answer from.",name:"text"},{anchor:"transformers.QuestionAnsweringPipeline.span_to_answer.start",description:"<strong>start</strong> (<code>int</code>) &#x2014; The answer starting token index.",name:"start"},{anchor:"transformers.QuestionAnsweringPipeline.span_to_answer.end",description:"<strong>end</strong> (<code>int</code>) &#x2014; The answer end token index.",name:"end"}],returnDescription:`
<p>str, \u2018start\u2019: int, \u2018end\u2019: int}_</p>
`,returnType:`
<p>Dictionary like :obj:_{\u2018answer\u2019</p>
`}}),Xr=new y({}),Yr=new b({props:{name:"class transformers.SummarizationPipeline",anchor:"transformers.SummarizationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/text2text_generation.py#L174",parametersDescription:[{anchor:"transformers.SummarizationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.SummarizationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.SummarizationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.SummarizationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>          If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.SummarizationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.SummarizationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.SummarizationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.SummarizationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.SummarizationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.SummarizationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}]}}),es=new O({props:{code:`# use bart in pytorch
summarizer = pipeline("summarization")
summarizer("An apple a day, keeps the doctor away", min_length=5, max_length=20)

# use t5 in tf
summarizer = pipeline("summarization", model="t5-base", tokenizer="t5-base", framework="tf")
summarizer("An apple a day, keeps the doctor away", min_length=5, max_length=20),`,highlighted:`<span class="hljs-comment"># use bart in pytorch</span>
summarizer = pipeline(<span class="hljs-string">&quot;summarization&quot;</span>)
summarizer(<span class="hljs-string">&quot;An apple a day, keeps the doctor away&quot;</span>, min_length=<span class="hljs-number">5</span>, max_length=<span class="hljs-number">20</span>)

<span class="hljs-comment"># use t5 in tf</span>
summarizer = pipeline(<span class="hljs-string">&quot;summarization&quot;</span>, model=<span class="hljs-string">&quot;t5-base&quot;</span>, tokenizer=<span class="hljs-string">&quot;t5-base&quot;</span>, framework=<span class="hljs-string">&quot;tf&quot;</span>)
summarizer(<span class="hljs-string">&quot;An apple a day, keeps the doctor away&quot;</span>, min_length=<span class="hljs-number">5</span>, max_length=<span class="hljs-number">20</span>)`}}),ts=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.SummarizationPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/text2text_generation.py#L199",parametersDescription:[{anchor:"transformers.SummarizationPipeline.__call__.documents",description:`<strong>documents</strong> (<em>str</em> or <code>List[str]</code>) &#x2014;
One or several articles (or one list of articles) to summarize.`,name:"documents"},{anchor:"transformers.SummarizationPipeline.__call__.return_text",description:`<strong>return_text</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to include the decoded texts in the outputs`,name:"return_text"},{anchor:"transformers.SummarizationPipeline.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to include the tensors of predictions (as token indices) in the outputs.`,name:"return_tensors"},{anchor:"transformers.SummarizationPipeline.__call__.clean_up_tokenization_spaces",description:`<strong>clean_up_tokenization_spaces</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to clean up the potential extra spaces in the text output.
generate_kwargs &#x2014;
Additional keyword arguments to pass along to the generate method of the model (see the generate method
corresponding to your framework <a href="./model#generative-models">here</a>).`,name:"clean_up_tokenization_spaces"}],returnDescription:`
<p>Each result comes as a dictionary with the following keys:</p>
<ul>
<li><strong>summary_text</strong> (<code>str</code>, present when <code>return_text=True</code>) \u2014 The summary of the corresponding
input.</li>
<li><strong>summary_token_ids</strong> (<code>torch.Tensor</code> or <code>tf.Tensor</code>, present when <code>return_tensors=True</code>) \u2014
The token ids of the summary.</li>
</ul>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),ns=new y({}),os=new b({props:{name:"class transformers.TableQuestionAnsweringPipeline",anchor:"transformers.TableQuestionAnsweringPipeline",parameters:[{name:"args_parser",val:" = <transformers.pipelines.table_question_answering.TableQuestionAnsweringArgumentHandler object at 0x7f740a5dc880>"},{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/table_question_answering.py#L83",parametersDescription:[{anchor:"transformers.TableQuestionAnsweringPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.TableQuestionAnsweringPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.TableQuestionAnsweringPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.TableQuestionAnsweringPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.TableQuestionAnsweringPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.TableQuestionAnsweringPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.TableQuestionAnsweringPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.TableQuestionAnsweringPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.TableQuestionAnsweringPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.TableQuestionAnsweringPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}]}}),is=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.TableQuestionAnsweringPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/table_question_answering.py#L244",parametersDescription:[{anchor:"transformers.TableQuestionAnsweringPipeline.__call__.table",description:`<strong>table</strong> (<code>pd.DataFrame</code> or <code>Dict</code>) &#x2014;
Pandas DataFrame or dictionary that will be converted to a DataFrame containing all the table values.
See above for an example of dictionary.`,name:"table"},{anchor:"transformers.TableQuestionAnsweringPipeline.__call__.query",description:`<strong>query</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
Query or list of queries that will be sent to the model alongside the table.`,name:"query"},{anchor:"transformers.TableQuestionAnsweringPipeline.__call__.sequential",description:`<strong>sequential</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to do inference sequentially or as a batch. Batching is faster, but models like SQA require the
inference to be done sequentially to extract relations within sequences, given their conversational
nature.`,name:"sequential"},{anchor:"transformers.TableQuestionAnsweringPipeline.__call__.padding",description:`<strong>padding</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/v4.14.1/en/internal/file_utils#transformers.file_utils.PaddingStrategy">PaddingStrategy</a>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls padding. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;longest&apos;</code>: Pad to the longest sequence in the batch (or no padding if only a
single sequence if provided).</li>
<li><code>&apos;max_length&apos;</code>: Pad to a maximum length specified with the argument <code>max_length</code> or to the
maximum acceptable input length for the model if that argument is not provided.</li>
<li><code>False</code> or <code>&apos;do_not_pad&apos;</code> (default): No padding (i.e., can output a batch with sequences of
different lengths).</li>
</ul>`,name:"padding"},{anchor:"transformers.TableQuestionAnsweringPipeline.__call__.truncation",description:`<strong>truncation</strong> (<code>bool</code>, <code>str</code> or <code>TapasTruncationStrategy</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls truncation. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;drop_rows_to_fit&apos;</code>: Truncate to a maximum length specified with the argument
<code>max_length</code> or to the maximum acceptable input length for the model if that argument is not
provided. This will truncate row by row, removing rows from the table.</li>
<li><code>False</code> or <code>&apos;do_not_truncate&apos;</code> (default): No truncation (i.e., can output batch with
sequence lengths greater than the model maximum admissible input size).</li>
</ul>`,name:"truncation"}],returnDescription:`
<p>Each result is a dictionary with the following
keys:</p>
<ul>
<li><strong>answer</strong> (<code>str</code>) \u2014 The answer of the query given the table. If there is an aggregator, the answer
will be preceded by <code>AGGREGATOR &gt;</code>.</li>
<li><strong>coordinates</strong> (<code>List[Tuple[int, int]]</code>) \u2014 Coordinates of the cells of the answers.</li>
<li><strong>cells</strong> (<code>List[str]</code>) \u2014 List of strings made up of the answer cell values.</li>
<li><strong>aggregator</strong> (<code>str</code>) \u2014 If the model has an aggregator, this returns the aggregator.</li>
</ul>
`,returnType:`
<p>A dictionary or a list of dictionaries containing results</p>
`}}),cs=new O({props:{code:`data = {
"actors": ["brad pitt", "leonardo di caprio", "george clooney"],
"age": ["56", "45", "59"],
"number of movies": ["87", "53", "69"],
"date of birth": ["7 february 1967", "10 june 1996", "28 november 1967"],
},`,highlighted:`data = {
<span class="hljs-string">&quot;actors&quot;</span>: [<span class="hljs-string">&quot;brad pitt&quot;</span>, <span class="hljs-string">&quot;leonardo di caprio&quot;</span>, <span class="hljs-string">&quot;george clooney&quot;</span>],
<span class="hljs-string">&quot;age&quot;</span>: [<span class="hljs-string">&quot;56&quot;</span>, <span class="hljs-string">&quot;45&quot;</span>, <span class="hljs-string">&quot;59&quot;</span>],
<span class="hljs-string">&quot;number of movies&quot;</span>: [<span class="hljs-string">&quot;87&quot;</span>, <span class="hljs-string">&quot;53&quot;</span>, <span class="hljs-string">&quot;69&quot;</span>],
<span class="hljs-string">&quot;date of birth&quot;</span>: [<span class="hljs-string">&quot;7 february 1967&quot;</span>, <span class="hljs-string">&quot;10 june 1996&quot;</span>, <span class="hljs-string">&quot;28 november 1967&quot;</span>],
}`}}),ds=new O({props:{code:`import pandas as pd
table = pd.DataFrame.from_dict(data),`,highlighted:`<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
table = pd.DataFrame.from_dict(data)`}}),ps=new y({}),ms=new b({props:{name:"class transformers.TextClassificationPipeline",anchor:"transformers.TextClassificationPipeline",parameters:[{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/text_classification.py#L47",parametersDescription:[{anchor:"transformers.TextClassificationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.TextClassificationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.TextClassificationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.TextClassificationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.TextClassificationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.TextClassificationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.TextClassificationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.TextClassificationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.TextClassificationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.TextClassificationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"},{anchor:"transformers.TextClassificationPipeline.return_all_scores",description:`<strong>return_all_scores</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to return all prediction scores or just the one of the predicted class.`,name:"return_all_scores"},{anchor:"transformers.TextClassificationPipeline.function_to_apply",description:`<strong>function_to_apply</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;default&quot;</code>) &#x2014;
The function to apply to the model outputs in order to retrieve the scores. Accepts four different values:</p>
<ul>
<li><code>&quot;default&quot;</code>: if the model has a single label, will apply the sigmoid function on the output. If the
model has several labels, will apply the softmax function on the output.</li>
<li><code>&quot;sigmoid&quot;</code>: Applies the sigmoid function on the output.</li>
<li><code>&quot;softmax&quot;</code>: Applies the softmax function on the output.</li>
<li><code>&quot;none&quot;</code>: Does not apply any function on the output.</li>
</ul>`,name:"function_to_apply"}]}}),gs=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.TextClassificationPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/text_classification.py#L93",parametersDescription:[{anchor:"transformers.TextClassificationPipeline.__call__.args",description:`<strong>args</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
One or several texts (or one list of prompts) to classify.`,name:"args"},{anchor:"transformers.TextClassificationPipeline.__call__.return_all_scores",description:`<strong>return_all_scores</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to return scores for all labels.`,name:"return_all_scores"},{anchor:"transformers.TextClassificationPipeline.__call__.function_to_apply",description:`<strong>function_to_apply</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;default&quot;</code>) &#x2014;
The function to apply to the model outputs in order to retrieve the scores. Accepts four different
values:</p>
<p>If this argument is not specified, then it will apply the following functions according to the number
of labels:</p>
<ul>
<li>If the model has a single label, will apply the sigmoid function on the output.</li>
<li>If the model has several labels, will apply the softmax function on the output.</li>
</ul>
<p>Possible values are:</p>
<ul>
<li><code>&quot;sigmoid&quot;</code>: Applies the sigmoid function on the output.</li>
<li><code>&quot;softmax&quot;</code>: Applies the softmax function on the output.</li>
<li><code>&quot;none&quot;</code>: Does not apply any function on the output.</li>
</ul>`,name:"function_to_apply"}],returnDescription:`
<p>Each result comes as list of dictionaries with the following keys:</p>
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 The label predicted.</li>
<li><strong>score</strong> (<code>float</code>) \u2014 The corresponding probability.</li>
</ul>
<p>If <code>self.return_all_scores=True</code>, one such dictionary is returned per label.</p>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),_s=new y({}),vs=new b({props:{name:"class transformers.TextGenerationPipeline",anchor:"transformers.TextGenerationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/text_generation.py#L16",parametersDescription:[{anchor:"transformers.TextGenerationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.TextGenerationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.TextGenerationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.TextGenerationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.TextGenerationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.TextGenerationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.TextGenerationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.TextGenerationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.TextGenerationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.TextGenerationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}]}}),Ts=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.TextGenerationPipeline.__call__",parameters:[{name:"text_inputs",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/text_generation.py#L132",parametersDescription:[{anchor:"transformers.TextGenerationPipeline.__call__.args",description:`<strong>args</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
One or several prompts (or one list of prompts) to complete.`,name:"args"},{anchor:"transformers.TextGenerationPipeline.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to include the tensors of predictions (as token indices) in the outputs.`,name:"return_tensors"},{anchor:"transformers.TextGenerationPipeline.__call__.return_text",description:`<strong>return_text</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to include the decoded texts in the outputs.`,name:"return_text"},{anchor:"transformers.TextGenerationPipeline.__call__.return_full_text",description:`<strong>return_full_text</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
If set to <code>False</code> only added text is returned, otherwise the full text is returned Only meaningful
if <em>return_text</em> is set to True.`,name:"return_full_text"},{anchor:"transformers.TextGenerationPipeline.__call__.clean_up_tokenization_spaces",description:`<strong>clean_up_tokenization_spaces</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to clean up the potential extra spaces in the text output.`,name:"clean_up_tokenization_spaces"},{anchor:"transformers.TextGenerationPipeline.__call__.prefix",description:`<strong>prefix</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Prefix added to prompt.`,name:"prefix"},{anchor:"transformers.TextGenerationPipeline.__call__.handle_long_generation",description:`<strong>handle_long_generation</strong> (<code>str</code>, <em>optional</em>) &#x2014;
By default, this pipelines does not handle long generation (ones that exceed in one form or the other
the model maximum length). There is no perfect way to adress this (more info
:<a href="https://github.com/huggingface/transformers/issues/14033#issuecomment-948385227" rel="nofollow">https://github.com/huggingface/transformers/issues/14033#issuecomment-948385227</a>). This provides common
strategies to work around that problem depending on your use case.</p>
<ul>
<li><code>None</code> : default strategy where nothing in particular happens</li>
<li><code>&quot;hole&quot;</code>: Truncates left of input, and leaves a gap wide enough to let generation happen (might
truncate a lot of the prompt and not suitable when generation exceed the model capacity)</li>
</ul>`,name:"handle_long_generation"}],returnDescription:`
<p>Each result comes as a dictionary with the following keys:</p>
<ul>
<li><strong>generated_text</strong> (<code>str</code>, present when <code>return_text=True</code>) \u2014 The generated text.</li>
<li><strong>generated_token_ids</strong> (<code>torch.Tensor</code> or <code>tf.Tensor</code>, present when <code>return_tensors=True</code>)
\u2014 The token ids of the generated text.</li>
</ul>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),Ps=new y({}),ys=new b({props:{name:"class transformers.Text2TextGenerationPipeline",anchor:"transformers.Text2TextGenerationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/text2text_generation.py#L26",parametersDescription:[{anchor:"transformers.Text2TextGenerationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.Text2TextGenerationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.Text2TextGenerationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.Text2TextGenerationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>          If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.Text2TextGenerationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.Text2TextGenerationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.Text2TextGenerationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.Text2TextGenerationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.Text2TextGenerationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.Text2TextGenerationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}]}}),Es=new O({props:{code:`text2text_generator = pipeline("text2text-generation")
text2text_generator("question: What is 42 ? context: 42 is the answer to life, the universe and everything"),`,highlighted:`text2text_generator = pipeline(<span class="hljs-string">&quot;text2text-generation&quot;</span>)
text2text_generator(<span class="hljs-string">&quot;question: What is 42 ? context: 42 is the answer to life, the universe and everything&quot;</span>)`}}),qs=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.Text2TextGenerationPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/text2text_generation.py#L108",parametersDescription:[{anchor:"transformers.Text2TextGenerationPipeline.__call__.args",description:`<strong>args</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
Input text for the encoder.`,name:"args"},{anchor:"transformers.Text2TextGenerationPipeline.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to include the tensors of predictions (as token indices) in the outputs.`,name:"return_tensors"},{anchor:"transformers.Text2TextGenerationPipeline.__call__.return_text",description:`<strong>return_text</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to include the decoded texts in the outputs.`,name:"return_text"},{anchor:"transformers.Text2TextGenerationPipeline.__call__.clean_up_tokenization_spaces",description:`<strong>clean_up_tokenization_spaces</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to clean up the potential extra spaces in the text output.`,name:"clean_up_tokenization_spaces"},{anchor:"transformers.Text2TextGenerationPipeline.__call__.truncation",description:`<strong>truncation</strong> (<code>TruncationStrategy</code>, <em>optional</em>, defaults to <code>TruncationStrategy.DO_NOT_TRUNCATE</code>) &#x2014;
The truncation strategy for the tokenization within the pipeline.
<code>TruncationStrategy.DO_NOT_TRUNCATE</code> (default) will never truncate, but it is sometimes desirable
to truncate the input to fit the model&#x2019;s max_length instead of throwing an error down the line.
generate_kwargs &#x2014;
Additional keyword arguments to pass along to the generate method of the model (see the generate method
corresponding to your framework <a href="./model#generative-models">here</a>).`,name:"truncation"}],returnDescription:`
<p>Each result comes as a dictionary with the following keys:</p>
<ul>
<li><strong>generated_text</strong> (<code>str</code>, present when <code>return_text=True</code>) \u2014 The generated text.</li>
<li><strong>generated_token_ids</strong> (<code>torch.Tensor</code> or <code>tf.Tensor</code>, present when <code>return_tensors=True</code>)
\u2014 The token ids of the generated text.</li>
</ul>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),As=new b({props:{name:"check\\_inputs",anchor:"transformers.Text2TextGenerationPipeline.check_inputs",parameters:[{name:"input_length",val:": int"},{name:"min_length",val:": int"},{name:"max_length",val:": int"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/text2text_generation.py#L81"}}),Cs=new y({}),zs=new b({props:{name:"class transformers.TokenClassificationPipeline",anchor:"transformers.TokenClassificationPipeline",parameters:[{name:"args_parser",val:" = <transformers.pipelines.token_classification.TokenClassificationArgumentHandler object at 0x7f740a5740a0>"},{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/token_classification.py#L85",parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.TokenClassificationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.TokenClassificationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.TokenClassificationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.TokenClassificationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.TokenClassificationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.TokenClassificationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.TokenClassificationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.TokenClassificationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.TokenClassificationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"},{anchor:"transformers.TokenClassificationPipeline.ignore_labels",description:`<strong>ignore_labels</strong> (<code>List[str]</code>, defaults to <code>[&quot;O&quot;]</code>) &#x2014;
A list of labels to ignore.`,name:"ignore_labels"},{anchor:"transformers.TokenClassificationPipeline.grouped_entities",description:`<strong>grouped_entities</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
DEPRECATED, use <code>aggregation_strategy</code> instead. Whether or not to group the tokens corresponding to
the same entity together in the predictions or not.`,name:"grouped_entities"},{anchor:"transformers.TokenClassificationPipeline.aggregation_strategy",description:`<strong>aggregation_strategy</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;none&quot;</code>) &#x2014; The strategy to fuse (or not) tokens based on the model prediction.</p>
<ul>
<li>&#x201C;none&#x201D; : Will simply not do any aggregation and simply return raw results from the model</li>
<li>&#x201C;simple&#x201D; : Will attempt to group entities following the default schema. (A, B-TAG), (B, I-TAG), (C,
I-TAG), (D, B-TAG2) (E, B-TAG2) will end up being [{&#x201C;word&#x201D;: ABC, &#x201C;entity&#x201D;: &#x201C;TAG&#x201D;}, {&#x201C;word&#x201D;: &#x201C;D&#x201D;,
&#x201C;entity&#x201D;: &#x201C;TAG2&#x201D;}, {&#x201C;word&#x201D;: &#x201C;E&#x201D;, &#x201C;entity&#x201D;: &#x201C;TAG2&#x201D;}] Notice that two consecutive B tags will end up as
different entities. On word based languages, we might end up splitting words undesirably : Imagine
Microsoft being tagged as [{&#x201C;word&#x201D;: &#x201C;Micro&#x201D;, &#x201C;entity&#x201D;: &#x201C;ENTERPRISE&#x201D;}, {&#x201C;word&#x201D;: &#x201C;soft&#x201D;, &#x201C;entity&#x201D;:
&#x201C;NAME&#x201D;}]. Look for FIRST, MAX, AVERAGE for ways to mitigate that and disambiguate words (on languages
that support that meaning, which is basically tokens separated by a space). These mitigations will
only work on real words, &#x201C;New york&#x201D; might still be tagged with two different entities.</li>
<li>&#x201C;first&#x201D; : (works only on word based models) Will use the <code>SIMPLE</code> strategy except that words,
cannot end up with different tags. Words will simply use the tag of the first token of the word when
there is ambiguity.</li>
<li>&#x201C;average&#x201D; : (works only on word based models) Will use the <code>SIMPLE</code> strategy except that words,
cannot end up with different tags. scores will be averaged first across tokens, and then the maximum
label is applied.</li>
<li>&#x201C;max&#x201D; : (works only on word based models) Will use the <code>SIMPLE</code> strategy except that words,
cannot end up with different tags. Word entity will simply be the token with the maximum score.</li>
</ul>`,name:"aggregation_strategy"}]}}),Is=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.TokenClassificationPipeline.__call__",parameters:[{name:"inputs",val:": typing.Union[str, typing.List[str]]"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/token_classification.py#L160",parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.__call__.inputs",description:`<strong>inputs</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
One or several texts (or one list of texts) for token classification.`,name:"inputs"}],returnDescription:`
<p>Each result comes as a list of dictionaries (one for each token in
the corresponding input, or each entity if this pipeline was instantiated with an aggregation_strategy)
with the following keys:</p>
<ul>
<li><strong>word</strong> (<code>str</code>) \u2014 The token/word classified.</li>
<li><strong>score</strong> (<code>float</code>) \u2014 The corresponding probability for <code>entity</code>.</li>
<li><strong>entity</strong> (<code>str</code>) \u2014 The entity predicted for that token/word (it is named <em>entity_group</em> when
<em>aggregation_strategy</em> is not <code>"none"</code>.</li>
<li><strong>index</strong> (<code>int</code>, only present when <code>aggregation_strategy="none"</code>) \u2014 The index of the
corresponding token in the sentence.</li>
<li><strong>start</strong> (<code>int</code>, <em>optional</em>) \u2014 The index of the start of the corresponding entity in the sentence.
Only exists if the offsets are available within the tokenizer</li>
<li><strong>end</strong> (<code>int</code>, <em>optional</em>) \u2014 The index of the end of the corresponding entity in the sentence.
Only exists if the offsets are available within the tokenizer</li>
</ul>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),Ms=new b({props:{name:"aggregate\\_words",anchor:"transformers.TokenClassificationPipeline.aggregate_words",parameters:[{name:"entities",val:": typing.List[dict]"},{name:"aggregation_strategy",val:": AggregationStrategy"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/token_classification.py#L366"}}),Ss=new b({props:{name:"gather\\_pre\\_entities",anchor:"transformers.TokenClassificationPipeline.gather_pre_entities",parameters:[{name:"sentence",val:": str"},{name:"input_ids",val:": ndarray"},{name:"scores",val:": ndarray"},{name:"offset_mapping",val:": typing.Union[typing.List[typing.Tuple[int, int]], NoneType]"},{name:"special_tokens_mask",val:": ndarray"},{name:"aggregation_strategy",val:": AggregationStrategy"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/token_classification.py#L252"}}),Fs=new b({props:{name:"group\\_entities",anchor:"transformers.TokenClassificationPipeline.group_entities",parameters:[{name:"entities",val:": typing.List[dict]"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/token_classification.py#L428",parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.group_entities.entities",description:"<strong>entities</strong> (<code>dict</code>) &#x2014; The entities predicted by the pipeline.",name:"entities"}]}}),Ls=new b({props:{name:"group\\_sub\\_entities",anchor:"transformers.TokenClassificationPipeline.group_sub_entities",parameters:[{name:"entities",val:": typing.List[dict]"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/token_classification.py#L393",parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.group_sub_entities.entities",description:"<strong>entities</strong> (<code>dict</code>) &#x2014; The entities predicted by the pipeline.",name:"entities"}]}}),Gs=new y({}),Us=new b({props:{name:"class transformers.TranslationPipeline",anchor:"transformers.TranslationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/text2text_generation.py#L241",parametersDescription:[{anchor:"transformers.TranslationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.TranslationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.TranslationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.TranslationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>          If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.TranslationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.TranslationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.TranslationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.TranslationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.TranslationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.TranslationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}]}}),Rs=new O({props:{code:`en_fr_translator = pipeline("translation_en_to_fr")
en_fr_translator("How old are you?"),`,highlighted:`en_fr_translator = pipeline(<span class="hljs-string">&quot;translation_en_to_fr&quot;</span>)
en_fr_translator(<span class="hljs-string">&quot;How old are you?&quot;</span>)`}}),Qs=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.TranslationPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/text2text_generation.py#L292",parametersDescription:[{anchor:"transformers.TranslationPipeline.__call__.args",description:`<strong>args</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
Texts to be translated.`,name:"args"},{anchor:"transformers.TranslationPipeline.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to include the tensors of predictions (as token indices) in the outputs.`,name:"return_tensors"},{anchor:"transformers.TranslationPipeline.__call__.return_text",description:`<strong>return_text</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to include the decoded texts in the outputs.`,name:"return_text"},{anchor:"transformers.TranslationPipeline.__call__.clean_up_tokenization_spaces",description:`<strong>clean_up_tokenization_spaces</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to clean up the potential extra spaces in the text output.`,name:"clean_up_tokenization_spaces"},{anchor:"transformers.TranslationPipeline.__call__.src_lang",description:`<strong>src_lang</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The language of the input. Might be required for multilingual models. Will not have any effect for
single pair translation models`,name:"src_lang"},{anchor:"transformers.TranslationPipeline.__call__.tgt_lang",description:`<strong>tgt_lang</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The language of the desired output. Might be required for multilingual models. Will not have any effect
for single pair translation models
generate_kwargs &#x2014;
Additional keyword arguments to pass along to the generate method of the model (see the generate method
corresponding to your framework <a href="./model#generative-models">here</a>).`,name:"tgt_lang"}],returnDescription:`
<p>Each result comes as a dictionary with the following keys:</p>
<ul>
<li><strong>translation_text</strong> (<code>str</code>, present when <code>return_text=True</code>) \u2014 The translation.</li>
<li><strong>translation_token_ids</strong> (<code>torch.Tensor</code> or <code>tf.Tensor</code>, present when <code>return_tensors=True</code>)
\u2014 The token ids of the translation.</li>
</ul>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),Ws=new y({}),Hs=new b({props:{name:"class transformers.ZeroShotClassificationPipeline",anchor:"transformers.ZeroShotClassificationPipeline",parameters:[{name:"args_parser",val:" = <transformers.pipelines.zero_shot_classification.ZeroShotClassificationArgumentHandler object at 0x7f740a574970>"},{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/zero_shot_classification.py#L47",parametersDescription:[{anchor:"transformers.ZeroShotClassificationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.ZeroShotClassificationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.ZeroShotClassificationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.ZeroShotClassificationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.ZeroShotClassificationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.ZeroShotClassificationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.ZeroShotClassificationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.ZeroShotClassificationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.ZeroShotClassificationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.ZeroShotClassificationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}]}}),Ks=new b({props:{name:"\\_\\_call\\_\\_",anchor:"transformers.ZeroShotClassificationPipeline.__call__",parameters:[{name:"sequences",val:": typing.Union[str, typing.List[str]]"},{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/zero_shot_classification.py#L150",parametersDescription:[{anchor:"transformers.ZeroShotClassificationPipeline.__call__.sequences",description:`<strong>sequences</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
The sequence(s) to classify, will be truncated if the model input is too large.`,name:"sequences"},{anchor:"transformers.ZeroShotClassificationPipeline.__call__.candidate_labels",description:`<strong>candidate_labels</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
The set of possible class labels to classify each sequence into. Can be a single label, a string of
comma-separated labels, or a list of labels.`,name:"candidate_labels"},{anchor:"transformers.ZeroShotClassificationPipeline.__call__.hypothesis_template",description:`<strong>hypothesis_template</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;This example is {}.&quot;</code>) &#x2014;
The template used to turn each label into an NLI-style hypothesis. This template must include a {} or
similar syntax for the candidate label to be inserted into the template. For example, the default
template is <code>&quot;This example is {}.&quot;</code> With the candidate label <code>&quot;sports&quot;</code>, this would be fed
into the model like <code>&quot;&lt;cls&gt; sequence to classify &lt;sep&gt; This example is sports . &lt;sep&gt;&quot;</code>. The
default template works well in many cases, but it may be worthwhile to experiment with different
templates depending on the task setting.`,name:"hypothesis_template"},{anchor:"transformers.ZeroShotClassificationPipeline.__call__.multi_label",description:`<strong>multi_label</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not multiple candidate labels can be true. If <code>False</code>, the scores are normalized such
that the sum of the label likelihoods for each sequence is 1. If <code>True</code>, the labels are considered
independent and probabilities are normalized for each candidate by doing a softmax of the entailment
score vs. the contradiction score.`,name:"multi_label"}],returnDescription:`
<p>Each result comes as a dictionary with the following keys:</p>
<ul>
<li><strong>sequence</strong> (<code>str</code>) \u2014 The sequence for which this is the output.</li>
<li><strong>labels</strong> (<code>List[str]</code>) \u2014 The labels sorted by order of likelihood.</li>
<li><strong>scores</strong> (<code>List[float]</code>) \u2014 The probabilities for each of the labels.</li>
</ul>
`,returnType:`
<p>A <code>dict</code> or a list of <code>dict</code></p>
`}}),Ys=new y({}),Js=new b({props:{name:"class transformers.Pipeline",anchor:"transformers.Pipeline",parameters:[{name:"model",val:": typing.Union[ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel')]"},{name:"tokenizer",val:": typing.Optional[transformers.tokenization_utils.PreTrainedTokenizer] = None"},{name:"feature_extractor",val:": typing.Optional[ForwardRef('SequenceFeatureExtractor')] = None"},{name:"modelcard",val:": typing.Optional[transformers.modelcard.ModelCard] = None"},{name:"framework",val:": typing.Optional[str] = None"},{name:"task",val:": str = ''"},{name:"args_parser",val:": ArgumentHandler = None"},{name:"device",val:": int = -1"},{name:"binary_output",val:": bool = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/base.py#L806",parametersDescription:[{anchor:"transformers.Pipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/v4.14.1/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for
TensorFlow.`,name:"model"},{anchor:"transformers.Pipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/v4.14.1/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.Pipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.Pipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework
must be installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model
is provided.`,name:"framework"},{anchor:"transformers.Pipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.Pipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.Pipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with pipelines</a> .`,name:"batch_size"},{anchor:"transformers.Pipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/v4.14.1/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.Pipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.Pipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}]}}),ea=new b({props:{name:"check\\_model\\_type",anchor:"transformers.Pipeline.check_model_type",parameters:[{name:"supported_models",val:": typing.Union[typing.List[str], dict]"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/base.py#L956",parametersDescription:[{anchor:"transformers.Pipeline.check_model_type.supported_models",description:`<strong>supported_models</strong> (<code>List[str]</code> or <code>dict</code>) &#x2014;
The list of models supported by the pipeline, or a dictionary with model class values.`,name:"supported_models"}]}}),ta=new b({props:{name:"device\\_placement",anchor:"transformers.Pipeline.device_placement",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/base.py#L900",returnDescription:`
<p>Context manager</p>
`}}),na=new y({}),oa=new y({}),ra=new b({props:{name:"ensure\\_tensor\\_on\\_device",anchor:"transformers.Pipeline.ensure_tensor_on_device",parameters:[{name:"**inputs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/base.py#L925",parametersDescription:[{anchor:"transformers.Pipeline.ensure_tensor_on_device.inputs",description:"<strong>inputs</strong> (keyword arguments that should be <code>torch.Tensor</code>, the rest is ignored) &#x2014; The tensors to place on <code>self.device</code>.",name:"inputs"},{anchor:"transformers.Pipeline.ensure_tensor_on_device.Recursive",description:"<strong>Recursive</strong> on lists <strong>only</strong>. &#x2014;",name:"Recursive"}],returnDescription:`
<p>The same as <code>inputs</code> but on the proper device.</p>
`,returnType:`
<p><code>Dict[str, torch.Tensor]</code></p>
`}}),sa=new b({props:{name:"postprocess",anchor:"transformers.Pipeline.postprocess",parameters:[{name:"model_outputs",val:": ModelOutput"},{name:"**postprocess_parameters",val:": typing.Dict"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/base.py#L1012"}}),ia=new b({props:{name:"predict",anchor:"transformers.Pipeline.predict",parameters:[{name:"X",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/base.py#L894"}}),ca=new b({props:{name:"preprocess",anchor:"transformers.Pipeline.preprocess",parameters:[{name:"input_",val:": typing.Any"},{name:"**preprocess_parameters",val:": typing.Dict"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/base.py#L991"}}),da=new b({props:{name:"save\\_pretrained",anchor:"transformers.Pipeline.save_pretrained",parameters:[{name:"save_directory",val:": str"}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/base.py#L864",parametersDescription:[{anchor:"transformers.Pipeline.save_pretrained.save_directory",description:`<strong>save_directory</strong> (<code>str</code>) &#x2014;
A path to the directory where to saved. It will be created if it doesn&#x2019;t exist.`,name:"save_directory"}]}}),pa=new b({props:{name:"transform",anchor:"transformers.Pipeline.transform",parameters:[{name:"X",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.14.1/src/transformers/pipelines/base.py#L888"}}),{c(){x=o("meta"),ie=l(),$=o("h1"),A=o("a"),he=o("span"),f(E.$$.fragment),R=l(),ye=o("span"),Lu=a("Pipelines"),hm=l(),Ut=o("p"),Gu=a(`The pipelines are a great and easy way to use models for inference. These pipelines are objects that abstract most of
the complex code from the library, offering a simple API dedicated to several tasks, including Named Entity
Recognition, Masked Language Modeling, Sentiment Analysis, Feature Extraction and Question Answering. See the
`),ha=o("a"),Uu=a("task summary"),Nu=a(" for examples of use."),um=l(),ua=o("p"),Ou=a("There are two categories of pipeline abstractions to be aware about:"),gm=l(),Nt=o("ul"),el=o("li"),fo=o("p"),Ru=a("The "),ga=o("a"),Qu=a("pipeline()"),Wu=a(" which is the most powerful object encapsulating all other pipelines."),Hu=l(),ho=o("li"),tl=o("p"),Vu=a("The other task-specific pipelines:"),Bu=l(),w=o("ul"),nl=o("li"),_a=o("a"),Zu=a("AudioClassificationPipeline"),Ku=l(),ol=o("li"),va=o("a"),Xu=a("AutomaticSpeechRecognitionPipeline"),Yu=l(),rl=o("li"),ba=o("a"),Ju=a("ConversationalPipeline"),eg=l(),sl=o("li"),wa=o("a"),tg=a("FeatureExtractionPipeline"),ng=l(),al=o("li"),ka=o("a"),og=a("FillMaskPipeline"),rg=l(),il=o("li"),Ta=o("a"),sg=a("ImageClassificationPipeline"),ag=l(),ll=o("li"),Pa=o("a"),ig=a("ImageSegmentationPipeline"),lg=l(),cl=o("li"),ya=o("a"),cg=a("ObjectDetectionPipeline"),dg=l(),dl=o("li"),xa=o("a"),pg=a("QuestionAnsweringPipeline"),mg=l(),pl=o("li"),$a=o("a"),fg=a("SummarizationPipeline"),hg=l(),ml=o("li"),Ea=o("a"),ug=a("TableQuestionAnsweringPipeline"),gg=l(),fl=o("li"),qa=o("a"),_g=a("TextClassificationPipeline"),vg=l(),hl=o("li"),Aa=o("a"),bg=a("TextGenerationPipeline"),wg=l(),ul=o("li"),Ca=o("a"),kg=a("Text2TextGenerationPipeline"),Tg=l(),gl=o("li"),za=o("a"),Pg=a("TokenClassificationPipeline"),yg=l(),_l=o("li"),Da=o("a"),xg=a("TranslationPipeline"),$g=l(),vl=o("li"),ja=o("a"),Eg=a("ZeroShotClassificationPipeline"),_m=l(),Qe=o("h2"),Ot=o("a"),bl=o("span"),f(uo.$$.fragment),qg=l(),wl=o("span"),Ag=a("The pipeline abstraction"),vm=l(),Rt=o("p"),Cg=a("The "),kl=o("em"),zg=a("pipeline"),Dg=a(` abstraction is a wrapper around all the other available pipelines. It is instantiated as any other
pipeline but can provide additional quality of life.`),bm=l(),Ia=o("p"),jg=a("Simple call on one item:"),wm=l(),f(go.$$.fragment),km=l(),Qt=o("p"),Ig=a("If you want to use a specific model from the "),_o=o("a"),Mg=a("hub"),Sg=a(` you can ignore the task if the model on
the hub already defines it:`),Tm=l(),f(vo.$$.fragment),Pm=l(),Wt=o("p"),Fg=a("To call a pipeline on many items, you can either call with a "),Tl=o("em"),Lg=a("list"),Gg=a("."),ym=l(),f(bo.$$.fragment),xm=l(),Ht=o("p"),Ug=a("To iterate of full datasets it is recommended to use a "),Pl=o("code"),Ng=a("dataset"),Og=a(` directly. This means you don\u2019t need to allocate
the whole dataset at once, nor do you need to do batching yourself. This should work just as fast as custom loops on
GPU. If it doesn\u2019t don\u2019t hesitate to create an issue.`),$m=l(),f(wo.$$.fragment),Em=l(),Q=o("div"),f(ko.$$.fragment),Rg=l(),To=o("p"),Qg=a("Utility factory method to build a "),Ma=o("a"),Wg=a("Pipeline"),Hg=a("."),Vg=l(),yl=o("p"),Bg=a("Pipelines are made of:"),Zg=l(),We=o("ul"),Po=o("li"),Kg=a("A "),Sa=o("a"),Xg=a("tokenizer"),Yg=a(" in charge of mapping raw textual input to token."),Jg=l(),yo=o("li"),e_=a("A "),Fa=o("a"),t_=a("model"),n_=a(" to make predictions from the inputs."),o_=l(),xl=o("li"),r_=a("Some (optional) post processing for enhancing model\u2019s output."),s_=l(),$l=o("p"),a_=a("Examples:"),i_=l(),f(xo.$$.fragment),qm=l(),He=o("h2"),Vt=o("a"),El=o("span"),f($o.$$.fragment),l_=l(),ql=o("span"),c_=a("Pipeline batching"),Am=l(),be=o("p"),d_=a("All pipelines (except "),Al=o("em"),p_=a("zero-shot-classification"),m_=a(" and "),Cl=o("em"),f_=a("question-answering"),h_=a(` currently) can use batching. This will work
whenever the pipeline uses its streaming ability (so when passing lists or `),zl=o("code"),u_=a("Dataset"),g_=a(")."),Cm=l(),f(Eo.$$.fragment),zm=l(),f(Bt.$$.fragment),Dm=l(),f(qo.$$.fragment),jm=l(),f(Ao.$$.fragment),Im=l(),La=o("p"),__=a("Example where it\u2019s most a slowdown:"),Mm=l(),f(Co.$$.fragment),Sm=l(),Zt=o("p"),v_=a("This is a occasional very long sentence compared to the other. In that case, the "),Dl=o("strong"),b_=a("whole"),w_=a(` batch will need to be 400
tokens long, so the whole batch will be [64, 400] instead of [64, 4], leading to the high slowdown. Even worse, on
bigger batches, the program simply crashes.`),Fm=l(),f(zo.$$.fragment),Lm=l(),Ga=o("p"),k_=a(`There are no good (general) solutions for this problem, and your mileage may vary depending on your use cases. Rule of
thumb:`),Gm=l(),Ua=o("p"),T_=a("For users, a rule of thumb is:"),Um=l(),le=o("ul"),jl=o("li"),Il=o("p"),Ml=o("strong"),P_=a(`Measure performance on your load, with your hardware. Measure, measure, and keep measuring. Real numbers are the
only way to go.`),y_=l(),Sl=o("li"),Fl=o("p"),x_=a("If you are latency constrained (live product doing inference), don\u2019t batch"),$_=l(),Ll=o("li"),Gl=o("p"),E_=a("If you are using CPU, don\u2019t batch."),q_=l(),Do=o("li"),Ul=o("p"),A_=a("If you are using throughput (you want to run your model on a bunch of static data), on GPU, then:"),C_=l(),Ve=o("ul"),Nl=o("li"),z_=a(`If you have no clue about the size of the sequence_length (\u201Cnatural\u201D data), by default don\u2019t batch, measure and
try tentatively to add it, add OOM checks to recover when it will fail (and it will at some point if you don\u2019t
control the sequence_length.)`),D_=l(),Ol=o("li"),j_=a(`If your sequence_length is super regular, then batching is more likely to be VERY interesting, measure and push
it until you get OOMs.`),I_=l(),Rl=o("li"),M_=a("The larger the GPU the more likely batching is going to be more interesting"),S_=l(),Ql=o("li"),Wl=o("p"),F_=a("As soon as you enable batching, make sure you can handle OOMs nicely."),Nm=l(),Be=o("h2"),Kt=o("a"),Hl=o("span"),f(jo.$$.fragment),L_=l(),Vl=o("span"),G_=a("Pipeline custom code"),Om=l(),Na=o("p"),U_=a("If you want to override a specific pipeline."),Rm=l(),Xt=o("p"),N_=a(`Don\u2019t hesitate to create an issue for your task at hand, the goal of the pipeline is to be easy to use and support most
cases, so `),Bl=o("code"),O_=a("transformers"),R_=a(" could maybe support your use case."),Qm=l(),Oa=o("p"),Q_=a("If you want to try simply you can:"),Wm=l(),Ra=o("ul"),Zl=o("li"),W_=a("Subclass your pipeline of choice"),Hm=l(),f(Io.$$.fragment),Vm=l(),Qa=o("p"),H_=a("That should enable you to do all the custom code you want."),Bm=l(),Ze=o("h2"),Yt=o("a"),Kl=o("span"),f(Mo.$$.fragment),V_=l(),Xl=o("span"),B_=a("Implementing a pipeline"),Zm=l(),Wa=o("p"),Ha=o("a"),Z_=a("Implementing a new pipeline"),Km=l(),Ke=o("h2"),Jt=o("a"),Yl=o("span"),f(So.$$.fragment),K_=l(),Jl=o("span"),X_=a("The task specific pipelines"),Xm=l(),Xe=o("h3"),en=o("a"),ec=o("span"),f(Fo.$$.fragment),Y_=l(),tc=o("span"),J_=a("AudioClassificationPipeline"),Ym=l(),ee=o("div"),f(Lo.$$.fragment),ev=l(),Go=o("p"),tv=a("Audio classification pipeline using any "),nc=o("code"),nv=a("AutoModelForAudioClassification"),ov=a(`. This pipeline predicts the class of
a raw waveform or an audio file. In case of an audio file, ffmpeg should be installed to support multiple audio
formats.`),rv=l(),Ye=o("p"),sv=a("This pipeline can currently be loaded from "),Va=o("a"),av=a("pipeline()"),iv=a(` using the following task identifier:
`),oc=o("code"),lv=a('"audio-classification"'),cv=a("."),dv=l(),Uo=o("p"),pv=a("See the list of available models on "),No=o("a"),mv=a("huggingface.co/models"),fv=a("."),hv=l(),tn=o("div"),f(Oo.$$.fragment),uv=l(),Ro=o("p"),gv=a("Classify the sequence(s) given as inputs. See the "),Ba=o("a"),_v=a("AutomaticSpeechRecognitionPipeline"),vv=a(`
documentation for more information.`),Jm=l(),Je=o("h3"),nn=o("a"),rc=o("span"),f(Qo.$$.fragment),bv=l(),sc=o("span"),wv=a("AutomaticSpeechRecognitionPipeline"),ef=l(),ue=o("div"),f(Wo.$$.fragment),kv=l(),ac=o("p"),Tv=a("Pipeline that aims at extracting spoken text contained within some audio."),Pv=l(),ic=o("p"),yv=a(`The input can be either a raw waveform or a audio file. In case of the audio file, ffmpeg should be installed for
to support multiple audio formats`),xv=l(),on=o("div"),f(Ho.$$.fragment),$v=l(),Vo=o("p"),Ev=a("Classify the sequence(s) given as inputs. See the "),Za=o("a"),qv=a("AutomaticSpeechRecognitionPipeline"),Av=a(`
documentation for more information.`),tf=l(),et=o("h3"),rn=o("a"),lc=o("span"),f(Bo.$$.fragment),Cv=l(),cc=o("span"),zv=a("ConversationalPipeline"),nf=l(),z=o("div"),f(Zo.$$.fragment),Dv=l(),xe=o("p"),jv=a(`Utility class containing a conversation and its history. This class is meant to be used as an input to the
`),Ka=o("a"),Iv=a("ConversationalPipeline"),Mv=a(`. The conversation contains a number of utility function to manage the
addition of new user input and generated model responses. A conversation needs to contain an unprocessed user input
before being passed to the `),Xa=o("a"),Sv=a("ConversationalPipeline"),Fv=a(`. This user input is either created when
the class is instantiated, or by calling `),dc=o("code"),Lv=a('conversational_pipeline.append_response("input")'),Gv=a(` after a
conversation turn.`),Uv=l(),pc=o("p"),Nv=a("Usage:"),Ov=l(),f(Ko.$$.fragment),Rv=l(),sn=o("div"),f(Xo.$$.fragment),Qv=l(),Yo=o("p"),Wv=a("Add a user input to the conversation for the next round. This populates the internal "),mc=o("code"),Hv=a("new_user_input"),Vv=a(`
field.`),Bv=l(),an=o("div"),f(Jo.$$.fragment),Zv=l(),fc=o("p"),Kv=a("Append a response to the list of generated responses."),Xv=l(),qe=o("div"),f(er.$$.fragment),Yv=l(),hc=o("p"),Jv=a("Iterates over all blobs of the conversation."),e1=l(),ge=o("p"),t1=a("Returns: Iterator of (is_user, text_chunk) in chronological order of the conversation. "),uc=o("code"),n1=a("is_user"),o1=a(` is a
`),gc=o("code"),r1=a("bool"),s1=a(", "),_c=o("code"),a1=a("text_chunks"),i1=a(" is a "),vc=o("code"),l1=a("str"),c1=a("."),d1=l(),ln=o("div"),f(tr.$$.fragment),p1=l(),$e=o("p"),m1=a("Mark the conversation as processed (moves the content of "),bc=o("code"),f1=a("new_user_input"),h1=a(" to "),wc=o("code"),u1=a("past_user_inputs"),g1=a(`) and
empties the `),kc=o("code"),_1=a("new_user_input"),v1=a(" field."),of=l(),M=o("div"),f(nr.$$.fragment),b1=l(),Tc=o("p"),w1=a("Multi-turn conversational pipeline."),k1=l(),tt=o("p"),T1=a("This conversational pipeline can currently be loaded from "),Ya=o("a"),P1=a("pipeline()"),y1=a(` using the following task
identifier: `),Pc=o("code"),x1=a('"conversational"'),$1=a("."),E1=l(),_e=o("p"),q1=a(`The models that this pipeline can use are models that have been fine-tuned on a multi-turn conversational task,
currently: `),yc=o("em"),A1=a("\u2018microsoft/DialoGPT-small\u2019"),C1=a(", "),xc=o("em"),z1=a("\u2018microsoft/DialoGPT-medium\u2019"),D1=a(", "),$c=o("em"),j1=a("\u2018microsoft/DialoGPT-large\u2019"),I1=a(`. See the
up-to-date list of available models on `),or=o("a"),M1=a("huggingface.co/models"),S1=a("."),F1=l(),Ec=o("p"),L1=a("Usage:"),G1=l(),f(rr.$$.fragment),U1=l(),cn=o("div"),f(sr.$$.fragment),N1=l(),qc=o("p"),O1=a("Generate responses for the conversation(s) given as inputs."),rf=l(),nt=o("h3"),dn=o("a"),Ac=o("span"),f(ar.$$.fragment),R1=l(),Cc=o("span"),Q1=a("FeatureExtractionPipeline"),sf=l(),te=o("div"),f(ir.$$.fragment),W1=l(),zc=o("p"),H1=a(`Feature extraction pipeline using no model head. This pipeline extracts the hidden states from the base
transformer, which can be used as features in downstream tasks.`),V1=l(),ot=o("p"),B1=a("This feature extraction pipeline can currently be loaded from "),Ja=o("a"),Z1=a("pipeline()"),K1=a(` using the task
identifier: `),Dc=o("code"),X1=a('"feature-extraction"'),Y1=a("."),J1=l(),lr=o("p"),eb=a(`All models may be used for this pipeline. See a list of all models, including community-contributed models on
`),cr=o("a"),tb=a("huggingface.co/models"),nb=a("."),ob=l(),pn=o("div"),f(dr.$$.fragment),rb=l(),jc=o("p"),sb=a("Extract the features of the input(s)."),af=l(),rt=o("h3"),mn=o("a"),Ic=o("span"),f(pr.$$.fragment),ab=l(),Mc=o("span"),ib=a("FillMaskPipeline"),lf=l(),W=o("div"),f(mr.$$.fragment),lb=l(),st=o("p"),cb=a("Masked language modeling prediction pipeline using any "),Sc=o("code"),db=a("ModelWithLMHead"),pb=a(". See the "),ei=o("a"),mb=a(`masked language modeling
examples`),fb=a(" for more information."),hb=l(),at=o("p"),ub=a("This mask filling pipeline can currently be loaded from "),ti=o("a"),gb=a("pipeline()"),_b=a(` using the following task
identifier: `),Fc=o("code"),vb=a('"fill-mask"'),bb=a("."),wb=l(),fr=o("p"),kb=a(`The models that this pipeline can use are models that have been trained with a masked language modeling objective,
which includes the bi-directional models in the library. See the up-to-date list of available models on
`),hr=o("a"),Tb=a("huggingface.co/models"),Pb=a("."),yb=l(),f(fn.$$.fragment),xb=l(),hn=o("div"),f(ur.$$.fragment),$b=l(),Lc=o("p"),Eb=a("Fill the masked token in the text(s) given as inputs."),cf=l(),it=o("h3"),un=o("a"),Gc=o("span"),f(gr.$$.fragment),qb=l(),Uc=o("span"),Ab=a("ImageClassificationPipeline"),df=l(),ne=o("div"),f(_r.$$.fragment),Cb=l(),vr=o("p"),zb=a("Image classification pipeline using any "),Nc=o("code"),Db=a("AutoModelForImageClassification"),jb=a(`. This pipeline predicts the class of
an image.`),Ib=l(),lt=o("p"),Mb=a("This image classification pipeline can currently be loaded from "),ni=o("a"),Sb=a("pipeline()"),Fb=a(` using the following
task identifier: `),Oc=o("code"),Lb=a('"image-classification"'),Gb=a("."),Ub=l(),br=o("p"),Nb=a("See the list of available models on "),wr=o("a"),Ob=a("huggingface.co/models"),Rb=a("."),Qb=l(),gn=o("div"),f(kr.$$.fragment),Wb=l(),Rc=o("p"),Hb=a("Assign labels to the image(s) passed as inputs."),pf=l(),ct=o("h3"),_n=o("a"),Qc=o("span"),f(Tr.$$.fragment),Vb=l(),Wc=o("span"),Bb=a("ImageSegmentationPipeline"),mf=l(),oe=o("div"),f(Pr.$$.fragment),Zb=l(),yr=o("p"),Kb=a("Image segmentation pipeline using any "),Hc=o("code"),Xb=a("AutoModelForImageSegmentation"),Yb=a(`. This pipeline predicts masks of objects
and their classes.`),Jb=l(),dt=o("p"),ew=a("This image segmntation pipeline can currently be loaded from "),oi=o("a"),tw=a("pipeline()"),nw=a(` using the following
task identifier: `),Vc=o("code"),ow=a('"image-segmentation"'),rw=a("."),sw=l(),xr=o("p"),aw=a("See the list of available models on "),$r=o("a"),iw=a("huggingface.co/models"),lw=a("."),cw=l(),vn=o("div"),f(Er.$$.fragment),dw=l(),Bc=o("p"),pw=a("Perform segmentation (detect masks & classes) in the image(s) passed as inputs."),ff=l(),pt=o("h3"),bn=o("a"),Zc=o("span"),f(qr.$$.fragment),mw=l(),Kc=o("span"),fw=a("NerPipeline"),hf=l(),D=o("div"),f(Ar.$$.fragment),hw=l(),mt=o("p"),uw=a("Named Entity Recognition pipeline using any "),Xc=o("code"),gw=a("ModelForTokenClassification"),_w=a(". See the "),ri=o("a"),vw=a(`named entity recognition
examples`),bw=a(" for more information."),ww=l(),ft=o("p"),kw=a("This token recognition pipeline can currently be loaded from "),si=o("a"),Tw=a("pipeline()"),Pw=a(` using the following
task identifier: `),Yc=o("code"),yw=a('"ner"'),xw=a(` (for predicting the classes of tokens in a sequence: person, organisation, location
or miscellaneous).`),$w=l(),Cr=o("p"),Ew=a(`The models that this pipeline can use are models that have been fine-tuned on a token classification task. See the
up-to-date list of available models on `),zr=o("a"),qw=a("huggingface.co/models"),Aw=a("."),Cw=l(),Ae=o("div"),f(Dr.$$.fragment),zw=l(),Jc=o("p"),Dw=a("Override tokens from a given word that disagree to force agreement on word boundaries."),jw=l(),ed=o("p"),Iw=a(`Example: micro|soft| com|pany| B-ENT I-NAME I-ENT I-ENT will be rewritten with first strategy as microsoft|
company| B-ENT I-ENT`),Mw=l(),wn=o("div"),f(jr.$$.fragment),Sw=l(),td=o("p"),Fw=a("Fuse various numpy arrays into dicts with all the information needed for aggregation"),Lw=l(),kn=o("div"),f(Ir.$$.fragment),Gw=l(),nd=o("p"),Uw=a("Find and group together the adjacent tokens with the same entity predicted."),Nw=l(),Tn=o("div"),f(Mr.$$.fragment),Ow=l(),od=o("p"),Rw=a("Group together the adjacent tokens with the same entity predicted."),uf=l(),Pn=o("p"),Qw=a("See "),ai=o("a"),Ww=a("TokenClassificationPipeline"),Hw=a(" for all details."),gf=l(),ht=o("h3"),yn=o("a"),rd=o("span"),f(Sr.$$.fragment),Vw=l(),sd=o("span"),Bw=a("ObjectDetectionPipeline"),_f=l(),re=o("div"),f(Fr.$$.fragment),Zw=l(),Lr=o("p"),Kw=a("Object detection pipeline using any "),ad=o("code"),Xw=a("AutoModelForObjectDetection"),Yw=a(`. This pipeline predicts bounding boxes of
objects and their classes.`),Jw=l(),ut=o("p"),e4=a("This object detection pipeline can currently be loaded from "),ii=o("a"),t4=a("pipeline()"),n4=a(` using the following task
identifier: `),id=o("code"),o4=a('"object-detection"'),r4=a("."),s4=l(),Gr=o("p"),a4=a("See the list of available models on "),Ur=o("a"),i4=a("huggingface.co/models"),l4=a("."),c4=l(),xn=o("div"),f(Nr.$$.fragment),d4=l(),ld=o("p"),p4=a("Detect objects (bounding boxes & classes) in the image(s) passed as inputs."),vf=l(),gt=o("h3"),$n=o("a"),cd=o("span"),f(Or.$$.fragment),m4=l(),dd=o("span"),f4=a("QuestionAnsweringPipeline"),bf=l(),j=o("div"),f(Rr.$$.fragment),h4=l(),_t=o("p"),u4=a("Question Answering pipeline using any "),pd=o("code"),g4=a("ModelForQuestionAnswering"),_4=a(". See the "),li=o("a"),v4=a("question answering examples"),b4=a(" for more information."),w4=l(),vt=o("p"),k4=a("This question answering pipeline can currently be loaded from "),ci=o("a"),T4=a("pipeline()"),P4=a(` using the following
task identifier: `),md=o("code"),y4=a('"question-answering"'),x4=a("."),$4=l(),Qr=o("p"),E4=a(`The models that this pipeline can use are models that have been fine-tuned on a question answering task. See the
up-to-date list of available models on `),Wr=o("a"),q4=a("huggingface.co/models"),A4=a("."),C4=l(),En=o("div"),f(Hr.$$.fragment),z4=l(),fd=o("p"),D4=a("Answer the question(s) given as inputs by using the context(s)."),j4=l(),Ce=o("div"),f(Vr.$$.fragment),I4=l(),bt=o("p"),M4=a("QuestionAnsweringPipeline leverages the "),hd=o("code"),S4=a("SquadExample"),F4=a(` internally. This helper method
encapsulate all the logic for converting question(s) and context(s) to `),ud=o("code"),L4=a("SquadExample"),G4=a("."),U4=l(),gd=o("p"),N4=a("We currently support extractive question answering."),O4=l(),ze=o("div"),f(Br.$$.fragment),R4=l(),Zr=o("p"),Q4=a("Take the output of any "),_d=o("code"),W4=a("ModelForQuestionAnswering"),H4=a(` and will generate probabilities for each span to be the
actual answer.`),V4=l(),vd=o("p"),B4=a(`In addition, it filters out some unwanted/impossible cases like answer len being greater than max_answer_len or
answer end position being before the starting position. The method supports output the k-best answer through
the topk argument.`),Z4=l(),qn=o("div"),f(Kr.$$.fragment),K4=l(),bd=o("p"),X4=a("When decoding from token probabilities, this method maps token indexes to actual word in the initial context."),wf=l(),wt=o("h3"),An=o("a"),wd=o("span"),f(Xr.$$.fragment),Y4=l(),kd=o("span"),J4=a("SummarizationPipeline"),kf=l(),S=o("div"),f(Yr.$$.fragment),ek=l(),Td=o("p"),tk=a("Summarize news articles and other documents."),nk=l(),kt=o("p"),ok=a("This summarizing pipeline can currently be loaded from "),di=o("a"),rk=a("pipeline()"),sk=a(` using the following task
identifier: `),Pd=o("code"),ak=a('"summarization"'),ik=a("."),lk=l(),F=o("p"),ck=a(`The models that this pipeline can use are models that have been fine-tuned on a summarization task, which is
currently, \u2019`),yd=o("em"),dk=a("bart-large-cnn"),pk=a("\u2019, \u2019"),xd=o("em"),mk=a("t5-small"),fk=a("\u2019, \u2019"),$d=o("em"),hk=a("t5-base"),uk=a("\u2019, \u2019"),Ed=o("em"),gk=a("t5-large"),_k=a("\u2019, \u2019"),qd=o("em"),vk=a("t5-3b"),bk=a("\u2019, \u2019"),Ad=o("em"),wk=a("t5-11b"),kk=a(`\u2019. See the up-to-date
list of available models on `),Jr=o("a"),Tk=a("huggingface.co/models"),Pk=a("."),yk=l(),Cd=o("p"),xk=a("Usage:"),$k=l(),f(es.$$.fragment),Ek=l(),Cn=o("div"),f(ts.$$.fragment),qk=l(),zd=o("p"),Ak=a("Summarize the text(s) given as inputs."),Tf=l(),Tt=o("h3"),zn=o("a"),Dd=o("span"),f(ns.$$.fragment),Ck=l(),jd=o("span"),zk=a("TableQuestionAnsweringPipeline"),Pf=l(),se=o("div"),f(os.$$.fragment),Dk=l(),rs=o("p"),jk=a("Table Question Answering pipeline using a "),Id=o("code"),Ik=a("ModelForTableQuestionAnswering"),Mk=a(`. This pipeline is only available in
PyTorch.`),Sk=l(),Pt=o("p"),Fk=a("This tabular question answering pipeline can currently be loaded from "),pi=o("a"),Lk=a("pipeline()"),Gk=a(` using the
following task identifier: `),Md=o("code"),Uk=a('"table-question-answering"'),Nk=a("."),Ok=l(),ss=o("p"),Rk=a(`The models that this pipeline can use are models that have been fine-tuned on a tabular question answering task.
See the up-to-date list of available models on `),as=o("a"),Qk=a("huggingface.co/models"),Wk=a("."),Hk=l(),C=o("div"),f(is.$$.fragment),Vk=l(),Sd=o("p"),Bk=a("Answers queries according to a table. The pipeline accepts several types of inputs which are detailed below:"),Zk=l(),H=o("ul"),Fd=o("li"),Ld=o("code"),Kk=a("pipeline(table, query)"),Xk=l(),Gd=o("li"),Ud=o("code"),Yk=a("pipeline(table, [query])"),Jk=l(),Nd=o("li"),Od=o("code"),eT=a("pipeline(table=table, query=query)"),tT=l(),Rd=o("li"),Qd=o("code"),nT=a("pipeline(table=table, query=[query])"),oT=l(),Wd=o("li"),Hd=o("code"),rT=a('pipeline({"table": table, "query": query})'),sT=l(),Vd=o("li"),Bd=o("code"),aT=a('pipeline({"table": table, "query": [query]})'),iT=l(),Zd=o("li"),Kd=o("code"),lT=a('pipeline([{"table": table, "query": query}, {"table": table, "query": query}])'),cT=l(),ls=o("p"),dT=a("The "),Xd=o("code"),pT=a("table"),mT=a(" argument should be a dict or a DataFrame built from that dict, containing the whole table:"),fT=l(),Yd=o("p"),hT=a("Example:"),uT=l(),f(cs.$$.fragment),gT=l(),Jd=o("p"),_T=a("This dictionary can be passed in as such, or can be converted to a pandas DataFrame:"),vT=l(),ep=o("p"),bT=a("Example:"),wT=l(),f(ds.$$.fragment),yf=l(),yt=o("h3"),Dn=o("a"),tp=o("span"),f(ps.$$.fragment),kT=l(),np=o("span"),TT=a("TextClassificationPipeline"),xf=l(),V=o("div"),f(ms.$$.fragment),PT=l(),xt=o("p"),yT=a("Text classification pipeline using any "),op=o("code"),xT=a("ModelForSequenceClassification"),$T=a(". See the "),mi=o("a"),ET=a(`sequence classification
examples`),qT=a(" for more information."),AT=l(),$t=o("p"),CT=a("This text classification pipeline can currently be loaded from "),fi=o("a"),zT=a("pipeline()"),DT=a(` using the following
task identifier: `),rp=o("code"),jT=a('"sentiment-analysis"'),IT=a(` (for classifying sequences according to positive or negative
sentiments).`),MT=l(),fs=o("p"),ST=a("If multiple classification labels are available ("),sp=o("code"),FT=a("model.config.num_labels >= 2"),LT=a(`), the pipeline will run a
softmax over the results. If there is a single label, the pipeline will run a sigmoid over the result.`),GT=l(),hs=o("p"),UT=a(`The models that this pipeline can use are models that have been fine-tuned on a sequence classification task. See
the up-to-date list of available models on `),us=o("a"),NT=a("huggingface.co/models"),OT=a("."),RT=l(),jn=o("div"),f(gs.$$.fragment),QT=l(),ap=o("p"),WT=a("Classify the text(s) given as inputs."),$f=l(),Et=o("h3"),In=o("a"),ip=o("span"),f(_s.$$.fragment),HT=l(),lp=o("span"),VT=a("TextGenerationPipeline"),Ef=l(),ae=o("div"),f(vs.$$.fragment),BT=l(),bs=o("p"),ZT=a("Language generation pipeline using any "),cp=o("code"),KT=a("ModelWithLMHead"),XT=a(`. This pipeline predicts the words that will follow a
specified text prompt.`),YT=l(),qt=o("p"),JT=a("This language generation pipeline can currently be loaded from "),hi=o("a"),eP=a("pipeline()"),tP=a(` using the following
task identifier: `),dp=o("code"),nP=a('"text-generation"'),oP=a("."),rP=l(),ws=o("p"),sP=a(`The models that this pipeline can use are models that have been trained with an autoregressive language modeling
objective, which includes the uni-directional models in the library (e.g. gpt2). See the list of available models
on `),ks=o("a"),aP=a("huggingface.co/models"),iP=a("."),lP=l(),Mn=o("div"),f(Ts.$$.fragment),cP=l(),pp=o("p"),dP=a("Complete the prompt(s) given as inputs."),qf=l(),At=o("h3"),Sn=o("a"),mp=o("span"),f(Ps.$$.fragment),pP=l(),fp=o("span"),mP=a("Text2TextGenerationPipeline"),Af=l(),I=o("div"),f(ys.$$.fragment),fP=l(),hp=o("p"),hP=a("Pipeline for text to text generation using seq2seq models."),uP=l(),Ct=o("p"),gP=a("This Text2TextGenerationPipeline pipeline can currently be loaded from "),ui=o("a"),_P=a("pipeline()"),vP=a(` using the
following task identifier: `),up=o("code"),bP=a('"text2text-generation"'),wP=a("."),kP=l(),xs=o("p"),TP=a(`The models that this pipeline can use are models that have been fine-tuned on a translation task. See the
up-to-date list of available models on `),$s=o("a"),PP=a("huggingface.co/models"),yP=a("."),xP=l(),gp=o("p"),$P=a("Usage:"),EP=l(),f(Es.$$.fragment),qP=l(),Fn=o("div"),f(qs.$$.fragment),AP=l(),_p=o("p"),CP=a("Generate the output text(s) using text(s) given as inputs."),zP=l(),Ln=o("div"),f(As.$$.fragment),DP=l(),vp=o("p"),jP=a("Checks whether there might be something wrong with given input with regard to the model."),Cf=l(),zt=o("h3"),Gn=o("a"),bp=o("span"),f(Cs.$$.fragment),IP=l(),wp=o("span"),MP=a("TokenClassificationPipeline"),zf=l(),q=o("div"),f(zs.$$.fragment),SP=l(),Dt=o("p"),FP=a("Named Entity Recognition pipeline using any "),kp=o("code"),LP=a("ModelForTokenClassification"),GP=a(". See the "),gi=o("a"),UP=a(`named entity recognition
examples`),NP=a(" for more information."),OP=l(),jt=o("p"),RP=a("This token recognition pipeline can currently be loaded from "),_i=o("a"),QP=a("pipeline()"),WP=a(` using the following
task identifier: `),Tp=o("code"),HP=a('"ner"'),VP=a(` (for predicting the classes of tokens in a sequence: person, organisation, location
or miscellaneous).`),BP=l(),Ds=o("p"),ZP=a(`The models that this pipeline can use are models that have been fine-tuned on a token classification task. See the
up-to-date list of available models on `),js=o("a"),KP=a("huggingface.co/models"),XP=a("."),YP=l(),Un=o("div"),f(Is.$$.fragment),JP=l(),Pp=o("p"),ey=a("Classify each token of the text(s) given as inputs."),ty=l(),De=o("div"),f(Ms.$$.fragment),ny=l(),yp=o("p"),oy=a("Override tokens from a given word that disagree to force agreement on word boundaries."),ry=l(),xp=o("p"),sy=a(`Example: micro|soft| com|pany| B-ENT I-NAME I-ENT I-ENT will be rewritten with first strategy as microsoft|
company| B-ENT I-ENT`),ay=l(),Nn=o("div"),f(Ss.$$.fragment),iy=l(),$p=o("p"),ly=a("Fuse various numpy arrays into dicts with all the information needed for aggregation"),cy=l(),On=o("div"),f(Fs.$$.fragment),dy=l(),Ep=o("p"),py=a("Find and group together the adjacent tokens with the same entity predicted."),my=l(),Rn=o("div"),f(Ls.$$.fragment),fy=l(),qp=o("p"),hy=a("Group together the adjacent tokens with the same entity predicted."),Df=l(),It=o("h3"),Qn=o("a"),Ap=o("span"),f(Gs.$$.fragment),uy=l(),Cp=o("span"),gy=a("TranslationPipeline"),jf=l(),L=o("div"),f(Us.$$.fragment),_y=l(),zp=o("p"),vy=a("Translates from one language to another."),by=l(),Mt=o("p"),wy=a("This translation pipeline can currently be loaded from "),vi=o("a"),ky=a("pipeline()"),Ty=a(` using the following task
identifier: `),Dp=o("code"),Py=a('"translation_xx_to_yy"'),yy=a("."),xy=l(),Ns=o("p"),$y=a(`The models that this pipeline can use are models that have been fine-tuned on a translation task. See the
up-to-date list of available models on `),Os=o("a"),Ey=a("huggingface.co/models"),qy=a("."),Ay=l(),jp=o("p"),Cy=a("Usage:"),zy=l(),f(Rs.$$.fragment),Dy=l(),Wn=o("div"),f(Qs.$$.fragment),jy=l(),Ip=o("p"),Iy=a("Translate the text(s) given as inputs."),If=l(),St=o("h3"),Hn=o("a"),Mp=o("span"),f(Ws.$$.fragment),My=l(),Sp=o("span"),Sy=a("ZeroShotClassificationPipeline"),Mf=l(),B=o("div"),f(Hs.$$.fragment),Fy=l(),Vs=o("p"),Ly=a("NLI-based zero-shot classification pipeline using a "),Fp=o("code"),Gy=a("ModelForSequenceClassification"),Uy=a(` trained on NLI (natural
language inference) tasks.`),Ny=l(),Ee=o("p"),Oy=a(`Any combination of sequences and labels can be passed and each combination will be posed as a premise/hypothesis
pair and passed to the pretrained model. Then, the logit for `),Lp=o("em"),Ry=a("entailment"),Qy=a(` is taken as the logit for the candidate
label being valid. Any NLI model can be used, but the id of the `),Gp=o("em"),Wy=a("entailment"),Hy=a(` label must be included in the model
config\u2019s :attr:`),Up=o("em"),Vy=a("~transformers.PretrainedConfig.label2id"),By=a("."),Zy=l(),Ft=o("p"),Ky=a("This NLI pipeline can currently be loaded from "),bi=o("a"),Xy=a("pipeline()"),Yy=a(` using the following task identifier:
`),Np=o("code"),Jy=a('"zero-shot-classification"'),e2=a("."),t2=l(),Bs=o("p"),n2=a(`The models that this pipeline can use are models that have been fine-tuned on an NLI task. See the up-to-date list
of available models on `),Zs=o("a"),o2=a("huggingface.co/models"),r2=a("."),s2=l(),Vn=o("div"),f(Ks.$$.fragment),a2=l(),Xs=o("p"),i2=a("Classify the sequence(s) given as inputs. See the "),wi=o("a"),l2=a("ZeroShotClassificationPipeline"),c2=a(`
documentation for more information.`),Sf=l(),Lt=o("h2"),Bn=o("a"),Op=o("span"),f(Ys.$$.fragment),d2=l(),ki=o("span"),p2=a("Parent class: "),Rp=o("code"),m2=a("Pipeline"),Ff=l(),T=o("div"),f(Js.$$.fragment),f2=l(),Qp=o("p"),h2=a(`The Pipeline class is the class from which all pipelines inherit. Refer to this class for methods shared across
different pipelines.`),u2=l(),Wp=o("p"),g2=a(`Base class implementing pipelined operations. Pipeline workflow is defined as a sequence of the following
operations:`),_2=l(),Hp=o("p"),v2=a("Input -> Tokenization -> Model Inference -> Post-Processing (task dependent) -> Output"),b2=l(),Vp=o("p"),w2=a("Pipeline supports running on CPU or GPU through the device argument (see below)."),k2=l(),ve=o("p"),T2=a("Some pipeline, like for instance "),Ti=o("a"),P2=a("FeatureExtractionPipeline"),y2=a(" ("),Bp=o("code"),x2=a("'feature-extraction'"),$2=a(` )
output large tensor object as nested-lists. In order to avoid dumping such large structure as textual data we
provide the `),Zp=o("code"),E2=a("binary_output"),q2=a(" constructor argument. If set to "),Kp=o("code"),A2=a("True"),C2=a(`, the output will be stored in the
pickle format.`),z2=l(),Zn=o("div"),f(ea.$$.fragment),D2=l(),Xp=o("p"),j2=a("Check if the model class is in supported by the pipeline."),I2=l(),G=o("div"),f(ta.$$.fragment),M2=l(),Yp=o("p"),S2=a("Context Manager allowing tensor allocation on the user-specified device in framework agnostic way."),F2=l(),Jp=o("p"),L2=a("Examples::"),G2=l(),Kn=o("h1"),Xn=o("a"),em=o("span"),f(na.$$.fragment),U2=l(),tm=o("span"),N2=a("Explicitly ask for tensor allocation on CUDA device :0"),O2=l(),nm=o("p"),R2=a(`pipe = pipeline(\u2026, device=0)
with pipe.device_placement():`),Q2=l(),Yn=o("h1"),Jn=o("a"),om=o("span"),f(oa.$$.fragment),W2=l(),rm=o("span"),H2=a("Every framework specific tensor allocation will be done on the request device"),V2=l(),sm=o("p"),B2=a("output = pipe(\u2026)"),Z2=l(),eo=o("div"),f(ra.$$.fragment),K2=l(),am=o("p"),X2=a("Ensure PyTorch tensors are on the specified device."),Y2=l(),to=o("div"),f(sa.$$.fragment),J2=l(),aa=o("p"),e0=a("Postprocess will receive the raw outputs of the "),im=o("code"),t0=a("_forward"),n0=a(` method, generally tensors, and reformat them into
something more friendly. Generally it will output a list or a dict or results (containing just strings and
numbers).`),o0=l(),no=o("div"),f(ia.$$.fragment),r0=l(),la=o("p"),s0=a("Scikit / Keras interface to transformers\u2019 pipelines. This method will forward to "),lm=o("strong"),a0=a("call"),i0=a("()."),l0=l(),oo=o("div"),f(ca.$$.fragment),c0=l(),Gt=o("p"),d0=a("Preprocess will take the "),cm=o("code"),p0=a("input_"),m0=a(` of a specific pipeline and return a dictionnary of everything necessary for
`),dm=o("code"),f0=a("_forward"),h0=a(" to run properly. It should contain at least one tensor, but might have arbitrary other items."),u0=l(),ro=o("div"),f(da.$$.fragment),g0=l(),pm=o("p"),_0=a("Save the pipeline\u2019s model and tokenizer."),v0=l(),so=o("div"),f(pa.$$.fragment),b0=l(),ma=o("p"),w0=a("Scikit / Keras interface to transformers\u2019 pipelines. This method will forward to "),mm=o("strong"),k0=a("call"),T0=a("()."),this.h()},l(t){const p=Nq('[data-svelte="svelte-1phssyn"]',document.head);x=r(p,"META",{name:!0,content:!0}),p.forEach(n),ie=c(t),$=r(t,"H1",{class:!0});var fa=s($);A=r(fa,"A",{id:!0,class:!0,href:!0});var fm=s(A);he=r(fm,"SPAN",{});var y0=s(he);h(E.$$.fragment,y0),y0.forEach(n),fm.forEach(n),R=c(fa),ye=r(fa,"SPAN",{});var x0=s(ye);Lu=i(x0,"Pipelines"),x0.forEach(n),fa.forEach(n),hm=c(t),Ut=r(t,"P",{});var Gf=s(Ut);Gu=i(Gf,`The pipelines are a great and easy way to use models for inference. These pipelines are objects that abstract most of
the complex code from the library, offering a simple API dedicated to several tasks, including Named Entity
Recognition, Masked Language Modeling, Sentiment Analysis, Feature Extraction and Question Answering. See the
`),ha=r(Gf,"A",{href:!0});var $0=s(ha);Uu=i($0,"task summary"),$0.forEach(n),Nu=i(Gf," for examples of use."),Gf.forEach(n),um=c(t),ua=r(t,"P",{});var E0=s(ua);Ou=i(E0,"There are two categories of pipeline abstractions to be aware about:"),E0.forEach(n),gm=c(t),Nt=r(t,"UL",{});var Uf=s(Nt);el=r(Uf,"LI",{});var q0=s(el);fo=r(q0,"P",{});var Nf=s(fo);Ru=i(Nf,"The "),ga=r(Nf,"A",{href:!0});var A0=s(ga);Qu=i(A0,"pipeline()"),A0.forEach(n),Wu=i(Nf," which is the most powerful object encapsulating all other pipelines."),Nf.forEach(n),q0.forEach(n),Hu=c(Uf),ho=r(Uf,"LI",{});var Of=s(ho);tl=r(Of,"P",{});var C0=s(tl);Vu=i(C0,"The other task-specific pipelines:"),C0.forEach(n),Bu=c(Of),w=r(Of,"UL",{});var k=s(w);nl=r(k,"LI",{});var z0=s(nl);_a=r(z0,"A",{href:!0});var D0=s(_a);Zu=i(D0,"AudioClassificationPipeline"),D0.forEach(n),z0.forEach(n),Ku=c(k),ol=r(k,"LI",{});var j0=s(ol);va=r(j0,"A",{href:!0});var I0=s(va);Xu=i(I0,"AutomaticSpeechRecognitionPipeline"),I0.forEach(n),j0.forEach(n),Yu=c(k),rl=r(k,"LI",{});var M0=s(rl);ba=r(M0,"A",{href:!0});var S0=s(ba);Ju=i(S0,"ConversationalPipeline"),S0.forEach(n),M0.forEach(n),eg=c(k),sl=r(k,"LI",{});var F0=s(sl);wa=r(F0,"A",{href:!0});var L0=s(wa);tg=i(L0,"FeatureExtractionPipeline"),L0.forEach(n),F0.forEach(n),ng=c(k),al=r(k,"LI",{});var G0=s(al);ka=r(G0,"A",{href:!0});var U0=s(ka);og=i(U0,"FillMaskPipeline"),U0.forEach(n),G0.forEach(n),rg=c(k),il=r(k,"LI",{});var N0=s(il);Ta=r(N0,"A",{href:!0});var O0=s(Ta);sg=i(O0,"ImageClassificationPipeline"),O0.forEach(n),N0.forEach(n),ag=c(k),ll=r(k,"LI",{});var R0=s(ll);Pa=r(R0,"A",{href:!0});var Q0=s(Pa);ig=i(Q0,"ImageSegmentationPipeline"),Q0.forEach(n),R0.forEach(n),lg=c(k),cl=r(k,"LI",{});var W0=s(cl);ya=r(W0,"A",{href:!0});var H0=s(ya);cg=i(H0,"ObjectDetectionPipeline"),H0.forEach(n),W0.forEach(n),dg=c(k),dl=r(k,"LI",{});var V0=s(dl);xa=r(V0,"A",{href:!0});var B0=s(xa);pg=i(B0,"QuestionAnsweringPipeline"),B0.forEach(n),V0.forEach(n),mg=c(k),pl=r(k,"LI",{});var Z0=s(pl);$a=r(Z0,"A",{href:!0});var K0=s($a);fg=i(K0,"SummarizationPipeline"),K0.forEach(n),Z0.forEach(n),hg=c(k),ml=r(k,"LI",{});var X0=s(ml);Ea=r(X0,"A",{href:!0});var Y0=s(Ea);ug=i(Y0,"TableQuestionAnsweringPipeline"),Y0.forEach(n),X0.forEach(n),gg=c(k),fl=r(k,"LI",{});var J0=s(fl);qa=r(J0,"A",{href:!0});var ex=s(qa);_g=i(ex,"TextClassificationPipeline"),ex.forEach(n),J0.forEach(n),vg=c(k),hl=r(k,"LI",{});var tx=s(hl);Aa=r(tx,"A",{href:!0});var nx=s(Aa);bg=i(nx,"TextGenerationPipeline"),nx.forEach(n),tx.forEach(n),wg=c(k),ul=r(k,"LI",{});var ox=s(ul);Ca=r(ox,"A",{href:!0});var rx=s(Ca);kg=i(rx,"Text2TextGenerationPipeline"),rx.forEach(n),ox.forEach(n),Tg=c(k),gl=r(k,"LI",{});var sx=s(gl);za=r(sx,"A",{href:!0});var ax=s(za);Pg=i(ax,"TokenClassificationPipeline"),ax.forEach(n),sx.forEach(n),yg=c(k),_l=r(k,"LI",{});var ix=s(_l);Da=r(ix,"A",{href:!0});var lx=s(Da);xg=i(lx,"TranslationPipeline"),lx.forEach(n),ix.forEach(n),$g=c(k),vl=r(k,"LI",{});var cx=s(vl);ja=r(cx,"A",{href:!0});var dx=s(ja);Eg=i(dx,"ZeroShotClassificationPipeline"),dx.forEach(n),cx.forEach(n),k.forEach(n),Of.forEach(n),Uf.forEach(n),_m=c(t),Qe=r(t,"H2",{class:!0});var Rf=s(Qe);Ot=r(Rf,"A",{id:!0,class:!0,href:!0});var px=s(Ot);bl=r(px,"SPAN",{});var mx=s(bl);h(uo.$$.fragment,mx),mx.forEach(n),px.forEach(n),qg=c(Rf),wl=r(Rf,"SPAN",{});var fx=s(wl);Ag=i(fx,"The pipeline abstraction"),fx.forEach(n),Rf.forEach(n),vm=c(t),Rt=r(t,"P",{});var Qf=s(Rt);Cg=i(Qf,"The "),kl=r(Qf,"EM",{});var hx=s(kl);zg=i(hx,"pipeline"),hx.forEach(n),Dg=i(Qf,` abstraction is a wrapper around all the other available pipelines. It is instantiated as any other
pipeline but can provide additional quality of life.`),Qf.forEach(n),bm=c(t),Ia=r(t,"P",{});var ux=s(Ia);jg=i(ux,"Simple call on one item:"),ux.forEach(n),wm=c(t),h(go.$$.fragment,t),km=c(t),Qt=r(t,"P",{});var Wf=s(Qt);Ig=i(Wf,"If you want to use a specific model from the "),_o=r(Wf,"A",{href:!0,rel:!0});var gx=s(_o);Mg=i(gx,"hub"),gx.forEach(n),Sg=i(Wf,` you can ignore the task if the model on
the hub already defines it:`),Wf.forEach(n),Tm=c(t),h(vo.$$.fragment,t),Pm=c(t),Wt=r(t,"P",{});var Hf=s(Wt);Fg=i(Hf,"To call a pipeline on many items, you can either call with a "),Tl=r(Hf,"EM",{});var _x=s(Tl);Lg=i(_x,"list"),_x.forEach(n),Gg=i(Hf,"."),Hf.forEach(n),ym=c(t),h(bo.$$.fragment,t),xm=c(t),Ht=r(t,"P",{});var Vf=s(Ht);Ug=i(Vf,"To iterate of full datasets it is recommended to use a "),Pl=r(Vf,"CODE",{});var vx=s(Pl);Ng=i(vx,"dataset"),vx.forEach(n),Og=i(Vf,` directly. This means you don\u2019t need to allocate
the whole dataset at once, nor do you need to do batching yourself. This should work just as fast as custom loops on
GPU. If it doesn\u2019t don\u2019t hesitate to create an issue.`),Vf.forEach(n),$m=c(t),h(wo.$$.fragment,t),Em=c(t),Q=r(t,"DIV",{class:!0});var we=s(Q);h(ko.$$.fragment,we),Rg=c(we),To=r(we,"P",{});var Bf=s(To);Qg=i(Bf,"Utility factory method to build a "),Ma=r(Bf,"A",{href:!0});var bx=s(Ma);Wg=i(bx,"Pipeline"),bx.forEach(n),Hg=i(Bf,"."),Bf.forEach(n),Vg=c(we),yl=r(we,"P",{});var wx=s(yl);Bg=i(wx,"Pipelines are made of:"),wx.forEach(n),Zg=c(we),We=r(we,"UL",{});var Pi=s(We);Po=r(Pi,"LI",{});var Zf=s(Po);Kg=i(Zf,"A "),Sa=r(Zf,"A",{href:!0});var kx=s(Sa);Xg=i(kx,"tokenizer"),kx.forEach(n),Yg=i(Zf," in charge of mapping raw textual input to token."),Zf.forEach(n),Jg=c(Pi),yo=r(Pi,"LI",{});var Kf=s(yo);e_=i(Kf,"A "),Fa=r(Kf,"A",{href:!0});var Tx=s(Fa);t_=i(Tx,"model"),Tx.forEach(n),n_=i(Kf," to make predictions from the inputs."),Kf.forEach(n),o_=c(Pi),xl=r(Pi,"LI",{});var Px=s(xl);r_=i(Px,"Some (optional) post processing for enhancing model\u2019s output."),Px.forEach(n),Pi.forEach(n),s_=c(we),$l=r(we,"P",{});var yx=s($l);a_=i(yx,"Examples:"),yx.forEach(n),i_=c(we),h(xo.$$.fragment,we),we.forEach(n),qm=c(t),He=r(t,"H2",{class:!0});var Xf=s(He);Vt=r(Xf,"A",{id:!0,class:!0,href:!0});var xx=s(Vt);El=r(xx,"SPAN",{});var $x=s(El);h($o.$$.fragment,$x),$x.forEach(n),xx.forEach(n),l_=c(Xf),ql=r(Xf,"SPAN",{});var Ex=s(ql);c_=i(Ex,"Pipeline batching"),Ex.forEach(n),Xf.forEach(n),Am=c(t),be=r(t,"P",{});var ao=s(be);d_=i(ao,"All pipelines (except "),Al=r(ao,"EM",{});var qx=s(Al);p_=i(qx,"zero-shot-classification"),qx.forEach(n),m_=i(ao," and "),Cl=r(ao,"EM",{});var Ax=s(Cl);f_=i(Ax,"question-answering"),Ax.forEach(n),h_=i(ao,` currently) can use batching. This will work
whenever the pipeline uses its streaming ability (so when passing lists or `),zl=r(ao,"CODE",{});var Cx=s(zl);u_=i(Cx,"Dataset"),Cx.forEach(n),g_=i(ao,")."),ao.forEach(n),Cm=c(t),h(Eo.$$.fragment,t),zm=c(t),h(Bt.$$.fragment,t),Dm=c(t),h(qo.$$.fragment,t),jm=c(t),h(Ao.$$.fragment,t),Im=c(t),La=r(t,"P",{});var zx=s(La);__=i(zx,"Example where it\u2019s most a slowdown:"),zx.forEach(n),Mm=c(t),h(Co.$$.fragment,t),Sm=c(t),Zt=r(t,"P",{});var Yf=s(Zt);v_=i(Yf,"This is a occasional very long sentence compared to the other. In that case, the "),Dl=r(Yf,"STRONG",{});var Dx=s(Dl);b_=i(Dx,"whole"),Dx.forEach(n),w_=i(Yf,` batch will need to be 400
tokens long, so the whole batch will be [64, 400] instead of [64, 4], leading to the high slowdown. Even worse, on
bigger batches, the program simply crashes.`),Yf.forEach(n),Fm=c(t),h(zo.$$.fragment,t),Lm=c(t),Ga=r(t,"P",{});var jx=s(Ga);k_=i(jx,`There are no good (general) solutions for this problem, and your mileage may vary depending on your use cases. Rule of
thumb:`),jx.forEach(n),Gm=c(t),Ua=r(t,"P",{});var Ix=s(Ua);T_=i(Ix,"For users, a rule of thumb is:"),Ix.forEach(n),Um=c(t),le=r(t,"UL",{});var je=s(le);jl=r(je,"LI",{});var Mx=s(jl);Il=r(Mx,"P",{});var Sx=s(Il);Ml=r(Sx,"STRONG",{});var Fx=s(Ml);P_=i(Fx,`Measure performance on your load, with your hardware. Measure, measure, and keep measuring. Real numbers are the
only way to go.`),Fx.forEach(n),Sx.forEach(n),Mx.forEach(n),y_=c(je),Sl=r(je,"LI",{});var Lx=s(Sl);Fl=r(Lx,"P",{});var Gx=s(Fl);x_=i(Gx,"If you are latency constrained (live product doing inference), don\u2019t batch"),Gx.forEach(n),Lx.forEach(n),$_=c(je),Ll=r(je,"LI",{});var Ux=s(Ll);Gl=r(Ux,"P",{});var Nx=s(Gl);E_=i(Nx,"If you are using CPU, don\u2019t batch."),Nx.forEach(n),Ux.forEach(n),q_=c(je),Do=r(je,"LI",{});var Jf=s(Do);Ul=r(Jf,"P",{});var Ox=s(Ul);A_=i(Ox,"If you are using throughput (you want to run your model on a bunch of static data), on GPU, then:"),Ox.forEach(n),C_=c(Jf),Ve=r(Jf,"UL",{});var yi=s(Ve);Nl=r(yi,"LI",{});var Rx=s(Nl);z_=i(Rx,`If you have no clue about the size of the sequence_length (\u201Cnatural\u201D data), by default don\u2019t batch, measure and
try tentatively to add it, add OOM checks to recover when it will fail (and it will at some point if you don\u2019t
control the sequence_length.)`),Rx.forEach(n),D_=c(yi),Ol=r(yi,"LI",{});var Qx=s(Ol);j_=i(Qx,`If your sequence_length is super regular, then batching is more likely to be VERY interesting, measure and push
it until you get OOMs.`),Qx.forEach(n),I_=c(yi),Rl=r(yi,"LI",{});var Wx=s(Rl);M_=i(Wx,"The larger the GPU the more likely batching is going to be more interesting"),Wx.forEach(n),yi.forEach(n),Jf.forEach(n),S_=c(je),Ql=r(je,"LI",{});var Hx=s(Ql);Wl=r(Hx,"P",{});var Vx=s(Wl);F_=i(Vx,"As soon as you enable batching, make sure you can handle OOMs nicely."),Vx.forEach(n),Hx.forEach(n),je.forEach(n),Nm=c(t),Be=r(t,"H2",{class:!0});var eh=s(Be);Kt=r(eh,"A",{id:!0,class:!0,href:!0});var Bx=s(Kt);Hl=r(Bx,"SPAN",{});var Zx=s(Hl);h(jo.$$.fragment,Zx),Zx.forEach(n),Bx.forEach(n),L_=c(eh),Vl=r(eh,"SPAN",{});var Kx=s(Vl);G_=i(Kx,"Pipeline custom code"),Kx.forEach(n),eh.forEach(n),Om=c(t),Na=r(t,"P",{});var Xx=s(Na);U_=i(Xx,"If you want to override a specific pipeline."),Xx.forEach(n),Rm=c(t),Xt=r(t,"P",{});var th=s(Xt);N_=i(th,`Don\u2019t hesitate to create an issue for your task at hand, the goal of the pipeline is to be easy to use and support most
cases, so `),Bl=r(th,"CODE",{});var Yx=s(Bl);O_=i(Yx,"transformers"),Yx.forEach(n),R_=i(th," could maybe support your use case."),th.forEach(n),Qm=c(t),Oa=r(t,"P",{});var Jx=s(Oa);Q_=i(Jx,"If you want to try simply you can:"),Jx.forEach(n),Wm=c(t),Ra=r(t,"UL",{});var e$=s(Ra);Zl=r(e$,"LI",{});var t$=s(Zl);W_=i(t$,"Subclass your pipeline of choice"),t$.forEach(n),e$.forEach(n),Hm=c(t),h(Io.$$.fragment,t),Vm=c(t),Qa=r(t,"P",{});var n$=s(Qa);H_=i(n$,"That should enable you to do all the custom code you want."),n$.forEach(n),Bm=c(t),Ze=r(t,"H2",{class:!0});var nh=s(Ze);Yt=r(nh,"A",{id:!0,class:!0,href:!0});var o$=s(Yt);Kl=r(o$,"SPAN",{});var r$=s(Kl);h(Mo.$$.fragment,r$),r$.forEach(n),o$.forEach(n),V_=c(nh),Xl=r(nh,"SPAN",{});var s$=s(Xl);B_=i(s$,"Implementing a pipeline"),s$.forEach(n),nh.forEach(n),Zm=c(t),Wa=r(t,"P",{});var a$=s(Wa);Ha=r(a$,"A",{href:!0});var i$=s(Ha);Z_=i(i$,"Implementing a new pipeline"),i$.forEach(n),a$.forEach(n),Km=c(t),Ke=r(t,"H2",{class:!0});var oh=s(Ke);Jt=r(oh,"A",{id:!0,class:!0,href:!0});var l$=s(Jt);Yl=r(l$,"SPAN",{});var c$=s(Yl);h(So.$$.fragment,c$),c$.forEach(n),l$.forEach(n),K_=c(oh),Jl=r(oh,"SPAN",{});var d$=s(Jl);X_=i(d$,"The task specific pipelines"),d$.forEach(n),oh.forEach(n),Xm=c(t),Xe=r(t,"H3",{class:!0});var rh=s(Xe);en=r(rh,"A",{id:!0,class:!0,href:!0});var p$=s(en);ec=r(p$,"SPAN",{});var m$=s(ec);h(Fo.$$.fragment,m$),m$.forEach(n),p$.forEach(n),Y_=c(rh),tc=r(rh,"SPAN",{});var f$=s(tc);J_=i(f$,"AudioClassificationPipeline"),f$.forEach(n),rh.forEach(n),Ym=c(t),ee=r(t,"DIV",{class:!0});var Ie=s(ee);h(Lo.$$.fragment,Ie),ev=c(Ie),Go=r(Ie,"P",{});var sh=s(Go);tv=i(sh,"Audio classification pipeline using any "),nc=r(sh,"CODE",{});var h$=s(nc);nv=i(h$,"AutoModelForAudioClassification"),h$.forEach(n),ov=i(sh,`. This pipeline predicts the class of
a raw waveform or an audio file. In case of an audio file, ffmpeg should be installed to support multiple audio
formats.`),sh.forEach(n),rv=c(Ie),Ye=r(Ie,"P",{});var xi=s(Ye);sv=i(xi,"This pipeline can currently be loaded from "),Va=r(xi,"A",{href:!0});var u$=s(Va);av=i(u$,"pipeline()"),u$.forEach(n),iv=i(xi,` using the following task identifier:
`),oc=r(xi,"CODE",{});var g$=s(oc);lv=i(g$,'"audio-classification"'),g$.forEach(n),cv=i(xi,"."),xi.forEach(n),dv=c(Ie),Uo=r(Ie,"P",{});var ah=s(Uo);pv=i(ah,"See the list of available models on "),No=r(ah,"A",{href:!0,rel:!0});var _$=s(No);mv=i(_$,"huggingface.co/models"),_$.forEach(n),fv=i(ah,"."),ah.forEach(n),hv=c(Ie),tn=r(Ie,"DIV",{class:!0});var ih=s(tn);h(Oo.$$.fragment,ih),uv=c(ih),Ro=r(ih,"P",{});var lh=s(Ro);gv=i(lh,"Classify the sequence(s) given as inputs. See the "),Ba=r(lh,"A",{href:!0});var v$=s(Ba);_v=i(v$,"AutomaticSpeechRecognitionPipeline"),v$.forEach(n),vv=i(lh,`
documentation for more information.`),lh.forEach(n),ih.forEach(n),Ie.forEach(n),Jm=c(t),Je=r(t,"H3",{class:!0});var ch=s(Je);nn=r(ch,"A",{id:!0,class:!0,href:!0});var b$=s(nn);rc=r(b$,"SPAN",{});var w$=s(rc);h(Qo.$$.fragment,w$),w$.forEach(n),b$.forEach(n),bv=c(ch),sc=r(ch,"SPAN",{});var k$=s(sc);wv=i(k$,"AutomaticSpeechRecognitionPipeline"),k$.forEach(n),ch.forEach(n),ef=c(t),ue=r(t,"DIV",{class:!0});var io=s(ue);h(Wo.$$.fragment,io),kv=c(io),ac=r(io,"P",{});var T$=s(ac);Tv=i(T$,"Pipeline that aims at extracting spoken text contained within some audio."),T$.forEach(n),Pv=c(io),ic=r(io,"P",{});var P$=s(ic);yv=i(P$,`The input can be either a raw waveform or a audio file. In case of the audio file, ffmpeg should be installed for
to support multiple audio formats`),P$.forEach(n),xv=c(io),on=r(io,"DIV",{class:!0});var dh=s(on);h(Ho.$$.fragment,dh),$v=c(dh),Vo=r(dh,"P",{});var ph=s(Vo);Ev=i(ph,"Classify the sequence(s) given as inputs. See the "),Za=r(ph,"A",{href:!0});var y$=s(Za);qv=i(y$,"AutomaticSpeechRecognitionPipeline"),y$.forEach(n),Av=i(ph,`
documentation for more information.`),ph.forEach(n),dh.forEach(n),io.forEach(n),tf=c(t),et=r(t,"H3",{class:!0});var mh=s(et);rn=r(mh,"A",{id:!0,class:!0,href:!0});var x$=s(rn);lc=r(x$,"SPAN",{});var $$=s(lc);h(Bo.$$.fragment,$$),$$.forEach(n),x$.forEach(n),Cv=c(mh),cc=r(mh,"SPAN",{});var E$=s(cc);zv=i(E$,"ConversationalPipeline"),E$.forEach(n),mh.forEach(n),nf=c(t),z=r(t,"DIV",{class:!0});var Z=s(z);h(Zo.$$.fragment,Z),Dv=c(Z),xe=r(Z,"P",{});var lo=s(xe);jv=i(lo,`Utility class containing a conversation and its history. This class is meant to be used as an input to the
`),Ka=r(lo,"A",{href:!0});var q$=s(Ka);Iv=i(q$,"ConversationalPipeline"),q$.forEach(n),Mv=i(lo,`. The conversation contains a number of utility function to manage the
addition of new user input and generated model responses. A conversation needs to contain an unprocessed user input
before being passed to the `),Xa=r(lo,"A",{href:!0});var A$=s(Xa);Sv=i(A$,"ConversationalPipeline"),A$.forEach(n),Fv=i(lo,`. This user input is either created when
the class is instantiated, or by calling `),dc=r(lo,"CODE",{});var C$=s(dc);Lv=i(C$,'conversational_pipeline.append_response("input")'),C$.forEach(n),Gv=i(lo,` after a
conversation turn.`),lo.forEach(n),Uv=c(Z),pc=r(Z,"P",{});var z$=s(pc);Nv=i(z$,"Usage:"),z$.forEach(n),Ov=c(Z),h(Ko.$$.fragment,Z),Rv=c(Z),sn=r(Z,"DIV",{class:!0});var fh=s(sn);h(Xo.$$.fragment,fh),Qv=c(fh),Yo=r(fh,"P",{});var hh=s(Yo);Wv=i(hh,"Add a user input to the conversation for the next round. This populates the internal "),mc=r(hh,"CODE",{});var D$=s(mc);Hv=i(D$,"new_user_input"),D$.forEach(n),Vv=i(hh,`
field.`),hh.forEach(n),fh.forEach(n),Bv=c(Z),an=r(Z,"DIV",{class:!0});var uh=s(an);h(Jo.$$.fragment,uh),Zv=c(uh),fc=r(uh,"P",{});var j$=s(fc);Kv=i(j$,"Append a response to the list of generated responses."),j$.forEach(n),uh.forEach(n),Xv=c(Z),qe=r(Z,"DIV",{class:!0});var $i=s(qe);h(er.$$.fragment,$i),Yv=c($i),hc=r($i,"P",{});var I$=s(hc);Jv=i(I$,"Iterates over all blobs of the conversation."),I$.forEach(n),e1=c($i),ge=r($i,"P",{});var Me=s(ge);t1=i(Me,"Returns: Iterator of (is_user, text_chunk) in chronological order of the conversation. "),uc=r(Me,"CODE",{});var M$=s(uc);n1=i(M$,"is_user"),M$.forEach(n),o1=i(Me,` is a
`),gc=r(Me,"CODE",{});var S$=s(gc);r1=i(S$,"bool"),S$.forEach(n),s1=i(Me,", "),_c=r(Me,"CODE",{});var F$=s(_c);a1=i(F$,"text_chunks"),F$.forEach(n),i1=i(Me," is a "),vc=r(Me,"CODE",{});var L$=s(vc);l1=i(L$,"str"),L$.forEach(n),c1=i(Me,"."),Me.forEach(n),$i.forEach(n),d1=c(Z),ln=r(Z,"DIV",{class:!0});var gh=s(ln);h(tr.$$.fragment,gh),p1=c(gh),$e=r(gh,"P",{});var co=s($e);m1=i(co,"Mark the conversation as processed (moves the content of "),bc=r(co,"CODE",{});var G$=s(bc);f1=i(G$,"new_user_input"),G$.forEach(n),h1=i(co," to "),wc=r(co,"CODE",{});var U$=s(wc);u1=i(U$,"past_user_inputs"),U$.forEach(n),g1=i(co,`) and
empties the `),kc=r(co,"CODE",{});var N$=s(kc);_1=i(N$,"new_user_input"),N$.forEach(n),v1=i(co," field."),co.forEach(n),gh.forEach(n),Z.forEach(n),of=c(t),M=r(t,"DIV",{class:!0});var ce=s(M);h(nr.$$.fragment,ce),b1=c(ce),Tc=r(ce,"P",{});var O$=s(Tc);w1=i(O$,"Multi-turn conversational pipeline."),O$.forEach(n),k1=c(ce),tt=r(ce,"P",{});var Ei=s(tt);T1=i(Ei,"This conversational pipeline can currently be loaded from "),Ya=r(Ei,"A",{href:!0});var R$=s(Ya);P1=i(R$,"pipeline()"),R$.forEach(n),y1=i(Ei,` using the following task
identifier: `),Pc=r(Ei,"CODE",{});var Q$=s(Pc);x1=i(Q$,'"conversational"'),Q$.forEach(n),$1=i(Ei,"."),Ei.forEach(n),E1=c(ce),_e=r(ce,"P",{});var Se=s(_e);q1=i(Se,`The models that this pipeline can use are models that have been fine-tuned on a multi-turn conversational task,
currently: `),yc=r(Se,"EM",{});var W$=s(yc);A1=i(W$,"\u2018microsoft/DialoGPT-small\u2019"),W$.forEach(n),C1=i(Se,", "),xc=r(Se,"EM",{});var H$=s(xc);z1=i(H$,"\u2018microsoft/DialoGPT-medium\u2019"),H$.forEach(n),D1=i(Se,", "),$c=r(Se,"EM",{});var V$=s($c);j1=i(V$,"\u2018microsoft/DialoGPT-large\u2019"),V$.forEach(n),I1=i(Se,`. See the
up-to-date list of available models on `),or=r(Se,"A",{href:!0,rel:!0});var B$=s(or);M1=i(B$,"huggingface.co/models"),B$.forEach(n),S1=i(Se,"."),Se.forEach(n),F1=c(ce),Ec=r(ce,"P",{});var Z$=s(Ec);L1=i(Z$,"Usage:"),Z$.forEach(n),G1=c(ce),h(rr.$$.fragment,ce),U1=c(ce),cn=r(ce,"DIV",{class:!0});var _h=s(cn);h(sr.$$.fragment,_h),N1=c(_h),qc=r(_h,"P",{});var K$=s(qc);O1=i(K$,"Generate responses for the conversation(s) given as inputs."),K$.forEach(n),_h.forEach(n),ce.forEach(n),rf=c(t),nt=r(t,"H3",{class:!0});var vh=s(nt);dn=r(vh,"A",{id:!0,class:!0,href:!0});var X$=s(dn);Ac=r(X$,"SPAN",{});var Y$=s(Ac);h(ar.$$.fragment,Y$),Y$.forEach(n),X$.forEach(n),R1=c(vh),Cc=r(vh,"SPAN",{});var J$=s(Cc);Q1=i(J$,"FeatureExtractionPipeline"),J$.forEach(n),vh.forEach(n),sf=c(t),te=r(t,"DIV",{class:!0});var Fe=s(te);h(ir.$$.fragment,Fe),W1=c(Fe),zc=r(Fe,"P",{});var eE=s(zc);H1=i(eE,`Feature extraction pipeline using no model head. This pipeline extracts the hidden states from the base
transformer, which can be used as features in downstream tasks.`),eE.forEach(n),V1=c(Fe),ot=r(Fe,"P",{});var qi=s(ot);B1=i(qi,"This feature extraction pipeline can currently be loaded from "),Ja=r(qi,"A",{href:!0});var tE=s(Ja);Z1=i(tE,"pipeline()"),tE.forEach(n),K1=i(qi,` using the task
identifier: `),Dc=r(qi,"CODE",{});var nE=s(Dc);X1=i(nE,'"feature-extraction"'),nE.forEach(n),Y1=i(qi,"."),qi.forEach(n),J1=c(Fe),lr=r(Fe,"P",{});var bh=s(lr);eb=i(bh,`All models may be used for this pipeline. See a list of all models, including community-contributed models on
`),cr=r(bh,"A",{href:!0,rel:!0});var oE=s(cr);tb=i(oE,"huggingface.co/models"),oE.forEach(n),nb=i(bh,"."),bh.forEach(n),ob=c(Fe),pn=r(Fe,"DIV",{class:!0});var wh=s(pn);h(dr.$$.fragment,wh),rb=c(wh),jc=r(wh,"P",{});var rE=s(jc);sb=i(rE,"Extract the features of the input(s)."),rE.forEach(n),wh.forEach(n),Fe.forEach(n),af=c(t),rt=r(t,"H3",{class:!0});var kh=s(rt);mn=r(kh,"A",{id:!0,class:!0,href:!0});var sE=s(mn);Ic=r(sE,"SPAN",{});var aE=s(Ic);h(pr.$$.fragment,aE),aE.forEach(n),sE.forEach(n),ab=c(kh),Mc=r(kh,"SPAN",{});var iE=s(Mc);ib=i(iE,"FillMaskPipeline"),iE.forEach(n),kh.forEach(n),lf=c(t),W=r(t,"DIV",{class:!0});var ke=s(W);h(mr.$$.fragment,ke),lb=c(ke),st=r(ke,"P",{});var Ai=s(st);cb=i(Ai,"Masked language modeling prediction pipeline using any "),Sc=r(Ai,"CODE",{});var lE=s(Sc);db=i(lE,"ModelWithLMHead"),lE.forEach(n),pb=i(Ai,". See the "),ei=r(Ai,"A",{href:!0});var cE=s(ei);mb=i(cE,`masked language modeling
examples`),cE.forEach(n),fb=i(Ai," for more information."),Ai.forEach(n),hb=c(ke),at=r(ke,"P",{});var Ci=s(at);ub=i(Ci,"This mask filling pipeline can currently be loaded from "),ti=r(Ci,"A",{href:!0});var dE=s(ti);gb=i(dE,"pipeline()"),dE.forEach(n),_b=i(Ci,` using the following task
identifier: `),Fc=r(Ci,"CODE",{});var pE=s(Fc);vb=i(pE,'"fill-mask"'),pE.forEach(n),bb=i(Ci,"."),Ci.forEach(n),wb=c(ke),fr=r(ke,"P",{});var Th=s(fr);kb=i(Th,`The models that this pipeline can use are models that have been trained with a masked language modeling objective,
which includes the bi-directional models in the library. See the up-to-date list of available models on
`),hr=r(Th,"A",{href:!0,rel:!0});var mE=s(hr);Tb=i(mE,"huggingface.co/models"),mE.forEach(n),Pb=i(Th,"."),Th.forEach(n),yb=c(ke),h(fn.$$.fragment,ke),xb=c(ke),hn=r(ke,"DIV",{class:!0});var Ph=s(hn);h(ur.$$.fragment,Ph),$b=c(Ph),Lc=r(Ph,"P",{});var fE=s(Lc);Eb=i(fE,"Fill the masked token in the text(s) given as inputs."),fE.forEach(n),Ph.forEach(n),ke.forEach(n),cf=c(t),it=r(t,"H3",{class:!0});var yh=s(it);un=r(yh,"A",{id:!0,class:!0,href:!0});var hE=s(un);Gc=r(hE,"SPAN",{});var uE=s(Gc);h(gr.$$.fragment,uE),uE.forEach(n),hE.forEach(n),qb=c(yh),Uc=r(yh,"SPAN",{});var gE=s(Uc);Ab=i(gE,"ImageClassificationPipeline"),gE.forEach(n),yh.forEach(n),df=c(t),ne=r(t,"DIV",{class:!0});var Le=s(ne);h(_r.$$.fragment,Le),Cb=c(Le),vr=r(Le,"P",{});var xh=s(vr);zb=i(xh,"Image classification pipeline using any "),Nc=r(xh,"CODE",{});var _E=s(Nc);Db=i(_E,"AutoModelForImageClassification"),_E.forEach(n),jb=i(xh,`. This pipeline predicts the class of
an image.`),xh.forEach(n),Ib=c(Le),lt=r(Le,"P",{});var zi=s(lt);Mb=i(zi,"This image classification pipeline can currently be loaded from "),ni=r(zi,"A",{href:!0});var vE=s(ni);Sb=i(vE,"pipeline()"),vE.forEach(n),Fb=i(zi,` using the following
task identifier: `),Oc=r(zi,"CODE",{});var bE=s(Oc);Lb=i(bE,'"image-classification"'),bE.forEach(n),Gb=i(zi,"."),zi.forEach(n),Ub=c(Le),br=r(Le,"P",{});var $h=s(br);Nb=i($h,"See the list of available models on "),wr=r($h,"A",{href:!0,rel:!0});var wE=s(wr);Ob=i(wE,"huggingface.co/models"),wE.forEach(n),Rb=i($h,"."),$h.forEach(n),Qb=c(Le),gn=r(Le,"DIV",{class:!0});var Eh=s(gn);h(kr.$$.fragment,Eh),Wb=c(Eh),Rc=r(Eh,"P",{});var kE=s(Rc);Hb=i(kE,"Assign labels to the image(s) passed as inputs."),kE.forEach(n),Eh.forEach(n),Le.forEach(n),pf=c(t),ct=r(t,"H3",{class:!0});var qh=s(ct);_n=r(qh,"A",{id:!0,class:!0,href:!0});var TE=s(_n);Qc=r(TE,"SPAN",{});var PE=s(Qc);h(Tr.$$.fragment,PE),PE.forEach(n),TE.forEach(n),Vb=c(qh),Wc=r(qh,"SPAN",{});var yE=s(Wc);Bb=i(yE,"ImageSegmentationPipeline"),yE.forEach(n),qh.forEach(n),mf=c(t),oe=r(t,"DIV",{class:!0});var Ge=s(oe);h(Pr.$$.fragment,Ge),Zb=c(Ge),yr=r(Ge,"P",{});var Ah=s(yr);Kb=i(Ah,"Image segmentation pipeline using any "),Hc=r(Ah,"CODE",{});var xE=s(Hc);Xb=i(xE,"AutoModelForImageSegmentation"),xE.forEach(n),Yb=i(Ah,`. This pipeline predicts masks of objects
and their classes.`),Ah.forEach(n),Jb=c(Ge),dt=r(Ge,"P",{});var Di=s(dt);ew=i(Di,"This image segmntation pipeline can currently be loaded from "),oi=r(Di,"A",{href:!0});var $E=s(oi);tw=i($E,"pipeline()"),$E.forEach(n),nw=i(Di,` using the following
task identifier: `),Vc=r(Di,"CODE",{});var EE=s(Vc);ow=i(EE,'"image-segmentation"'),EE.forEach(n),rw=i(Di,"."),Di.forEach(n),sw=c(Ge),xr=r(Ge,"P",{});var Ch=s(xr);aw=i(Ch,"See the list of available models on "),$r=r(Ch,"A",{href:!0,rel:!0});var qE=s($r);iw=i(qE,"huggingface.co/models"),qE.forEach(n),lw=i(Ch,"."),Ch.forEach(n),cw=c(Ge),vn=r(Ge,"DIV",{class:!0});var zh=s(vn);h(Er.$$.fragment,zh),dw=c(zh),Bc=r(zh,"P",{});var AE=s(Bc);pw=i(AE,"Perform segmentation (detect masks & classes) in the image(s) passed as inputs."),AE.forEach(n),zh.forEach(n),Ge.forEach(n),ff=c(t),pt=r(t,"H3",{class:!0});var Dh=s(pt);bn=r(Dh,"A",{id:!0,class:!0,href:!0});var CE=s(bn);Zc=r(CE,"SPAN",{});var zE=s(Zc);h(qr.$$.fragment,zE),zE.forEach(n),CE.forEach(n),mw=c(Dh),Kc=r(Dh,"SPAN",{});var DE=s(Kc);fw=i(DE,"NerPipeline"),DE.forEach(n),Dh.forEach(n),hf=c(t),D=r(t,"DIV",{class:!0});var K=s(D);h(Ar.$$.fragment,K),hw=c(K),mt=r(K,"P",{});var ji=s(mt);uw=i(ji,"Named Entity Recognition pipeline using any "),Xc=r(ji,"CODE",{});var jE=s(Xc);gw=i(jE,"ModelForTokenClassification"),jE.forEach(n),_w=i(ji,". See the "),ri=r(ji,"A",{href:!0});var IE=s(ri);vw=i(IE,`named entity recognition
examples`),IE.forEach(n),bw=i(ji," for more information."),ji.forEach(n),ww=c(K),ft=r(K,"P",{});var Ii=s(ft);kw=i(Ii,"This token recognition pipeline can currently be loaded from "),si=r(Ii,"A",{href:!0});var ME=s(si);Tw=i(ME,"pipeline()"),ME.forEach(n),Pw=i(Ii,` using the following
task identifier: `),Yc=r(Ii,"CODE",{});var SE=s(Yc);yw=i(SE,'"ner"'),SE.forEach(n),xw=i(Ii,` (for predicting the classes of tokens in a sequence: person, organisation, location
or miscellaneous).`),Ii.forEach(n),$w=c(K),Cr=r(K,"P",{});var jh=s(Cr);Ew=i(jh,`The models that this pipeline can use are models that have been fine-tuned on a token classification task. See the
up-to-date list of available models on `),zr=r(jh,"A",{href:!0,rel:!0});var FE=s(zr);qw=i(FE,"huggingface.co/models"),FE.forEach(n),Aw=i(jh,"."),jh.forEach(n),Cw=c(K),Ae=r(K,"DIV",{class:!0});var Mi=s(Ae);h(Dr.$$.fragment,Mi),zw=c(Mi),Jc=r(Mi,"P",{});var LE=s(Jc);Dw=i(LE,"Override tokens from a given word that disagree to force agreement on word boundaries."),LE.forEach(n),jw=c(Mi),ed=r(Mi,"P",{});var GE=s(ed);Iw=i(GE,`Example: micro|soft| com|pany| B-ENT I-NAME I-ENT I-ENT will be rewritten with first strategy as microsoft|
company| B-ENT I-ENT`),GE.forEach(n),Mi.forEach(n),Mw=c(K),wn=r(K,"DIV",{class:!0});var Ih=s(wn);h(jr.$$.fragment,Ih),Sw=c(Ih),td=r(Ih,"P",{});var UE=s(td);Fw=i(UE,"Fuse various numpy arrays into dicts with all the information needed for aggregation"),UE.forEach(n),Ih.forEach(n),Lw=c(K),kn=r(K,"DIV",{class:!0});var Mh=s(kn);h(Ir.$$.fragment,Mh),Gw=c(Mh),nd=r(Mh,"P",{});var NE=s(nd);Uw=i(NE,"Find and group together the adjacent tokens with the same entity predicted."),NE.forEach(n),Mh.forEach(n),Nw=c(K),Tn=r(K,"DIV",{class:!0});var Sh=s(Tn);h(Mr.$$.fragment,Sh),Ow=c(Sh),od=r(Sh,"P",{});var OE=s(od);Rw=i(OE,"Group together the adjacent tokens with the same entity predicted."),OE.forEach(n),Sh.forEach(n),K.forEach(n),uf=c(t),Pn=r(t,"P",{});var Fh=s(Pn);Qw=i(Fh,"See "),ai=r(Fh,"A",{href:!0});var RE=s(ai);Ww=i(RE,"TokenClassificationPipeline"),RE.forEach(n),Hw=i(Fh," for all details."),Fh.forEach(n),gf=c(t),ht=r(t,"H3",{class:!0});var Lh=s(ht);yn=r(Lh,"A",{id:!0,class:!0,href:!0});var QE=s(yn);rd=r(QE,"SPAN",{});var WE=s(rd);h(Sr.$$.fragment,WE),WE.forEach(n),QE.forEach(n),Vw=c(Lh),sd=r(Lh,"SPAN",{});var HE=s(sd);Bw=i(HE,"ObjectDetectionPipeline"),HE.forEach(n),Lh.forEach(n),_f=c(t),re=r(t,"DIV",{class:!0});var Ue=s(re);h(Fr.$$.fragment,Ue),Zw=c(Ue),Lr=r(Ue,"P",{});var Gh=s(Lr);Kw=i(Gh,"Object detection pipeline using any "),ad=r(Gh,"CODE",{});var VE=s(ad);Xw=i(VE,"AutoModelForObjectDetection"),VE.forEach(n),Yw=i(Gh,`. This pipeline predicts bounding boxes of
objects and their classes.`),Gh.forEach(n),Jw=c(Ue),ut=r(Ue,"P",{});var Si=s(ut);e4=i(Si,"This object detection pipeline can currently be loaded from "),ii=r(Si,"A",{href:!0});var BE=s(ii);t4=i(BE,"pipeline()"),BE.forEach(n),n4=i(Si,` using the following task
identifier: `),id=r(Si,"CODE",{});var ZE=s(id);o4=i(ZE,'"object-detection"'),ZE.forEach(n),r4=i(Si,"."),Si.forEach(n),s4=c(Ue),Gr=r(Ue,"P",{});var Uh=s(Gr);a4=i(Uh,"See the list of available models on "),Ur=r(Uh,"A",{href:!0,rel:!0});var KE=s(Ur);i4=i(KE,"huggingface.co/models"),KE.forEach(n),l4=i(Uh,"."),Uh.forEach(n),c4=c(Ue),xn=r(Ue,"DIV",{class:!0});var Nh=s(xn);h(Nr.$$.fragment,Nh),d4=c(Nh),ld=r(Nh,"P",{});var XE=s(ld);p4=i(XE,"Detect objects (bounding boxes & classes) in the image(s) passed as inputs."),XE.forEach(n),Nh.forEach(n),Ue.forEach(n),vf=c(t),gt=r(t,"H3",{class:!0});var Oh=s(gt);$n=r(Oh,"A",{id:!0,class:!0,href:!0});var YE=s($n);cd=r(YE,"SPAN",{});var JE=s(cd);h(Or.$$.fragment,JE),JE.forEach(n),YE.forEach(n),m4=c(Oh),dd=r(Oh,"SPAN",{});var e3=s(dd);f4=i(e3,"QuestionAnsweringPipeline"),e3.forEach(n),Oh.forEach(n),bf=c(t),j=r(t,"DIV",{class:!0});var X=s(j);h(Rr.$$.fragment,X),h4=c(X),_t=r(X,"P",{});var Fi=s(_t);u4=i(Fi,"Question Answering pipeline using any "),pd=r(Fi,"CODE",{});var t3=s(pd);g4=i(t3,"ModelForQuestionAnswering"),t3.forEach(n),_4=i(Fi,". See the "),li=r(Fi,"A",{href:!0});var n3=s(li);v4=i(n3,"question answering examples"),n3.forEach(n),b4=i(Fi," for more information."),Fi.forEach(n),w4=c(X),vt=r(X,"P",{});var Li=s(vt);k4=i(Li,"This question answering pipeline can currently be loaded from "),ci=r(Li,"A",{href:!0});var o3=s(ci);T4=i(o3,"pipeline()"),o3.forEach(n),P4=i(Li,` using the following
task identifier: `),md=r(Li,"CODE",{});var r3=s(md);y4=i(r3,'"question-answering"'),r3.forEach(n),x4=i(Li,"."),Li.forEach(n),$4=c(X),Qr=r(X,"P",{});var Rh=s(Qr);E4=i(Rh,`The models that this pipeline can use are models that have been fine-tuned on a question answering task. See the
up-to-date list of available models on `),Wr=r(Rh,"A",{href:!0,rel:!0});var s3=s(Wr);q4=i(s3,"huggingface.co/models"),s3.forEach(n),A4=i(Rh,"."),Rh.forEach(n),C4=c(X),En=r(X,"DIV",{class:!0});var Qh=s(En);h(Hr.$$.fragment,Qh),z4=c(Qh),fd=r(Qh,"P",{});var a3=s(fd);D4=i(a3,"Answer the question(s) given as inputs by using the context(s)."),a3.forEach(n),Qh.forEach(n),j4=c(X),Ce=r(X,"DIV",{class:!0});var Gi=s(Ce);h(Vr.$$.fragment,Gi),I4=c(Gi),bt=r(Gi,"P",{});var Ui=s(bt);M4=i(Ui,"QuestionAnsweringPipeline leverages the "),hd=r(Ui,"CODE",{});var i3=s(hd);S4=i(i3,"SquadExample"),i3.forEach(n),F4=i(Ui,` internally. This helper method
encapsulate all the logic for converting question(s) and context(s) to `),ud=r(Ui,"CODE",{});var l3=s(ud);L4=i(l3,"SquadExample"),l3.forEach(n),G4=i(Ui,"."),Ui.forEach(n),U4=c(Gi),gd=r(Gi,"P",{});var c3=s(gd);N4=i(c3,"We currently support extractive question answering."),c3.forEach(n),Gi.forEach(n),O4=c(X),ze=r(X,"DIV",{class:!0});var Ni=s(ze);h(Br.$$.fragment,Ni),R4=c(Ni),Zr=r(Ni,"P",{});var Wh=s(Zr);Q4=i(Wh,"Take the output of any "),_d=r(Wh,"CODE",{});var d3=s(_d);W4=i(d3,"ModelForQuestionAnswering"),d3.forEach(n),H4=i(Wh,` and will generate probabilities for each span to be the
actual answer.`),Wh.forEach(n),V4=c(Ni),vd=r(Ni,"P",{});var p3=s(vd);B4=i(p3,`In addition, it filters out some unwanted/impossible cases like answer len being greater than max_answer_len or
answer end position being before the starting position. The method supports output the k-best answer through
the topk argument.`),p3.forEach(n),Ni.forEach(n),Z4=c(X),qn=r(X,"DIV",{class:!0});var Hh=s(qn);h(Kr.$$.fragment,Hh),K4=c(Hh),bd=r(Hh,"P",{});var m3=s(bd);X4=i(m3,"When decoding from token probabilities, this method maps token indexes to actual word in the initial context."),m3.forEach(n),Hh.forEach(n),X.forEach(n),wf=c(t),wt=r(t,"H3",{class:!0});var Vh=s(wt);An=r(Vh,"A",{id:!0,class:!0,href:!0});var f3=s(An);wd=r(f3,"SPAN",{});var h3=s(wd);h(Xr.$$.fragment,h3),h3.forEach(n),f3.forEach(n),Y4=c(Vh),kd=r(Vh,"SPAN",{});var u3=s(kd);J4=i(u3,"SummarizationPipeline"),u3.forEach(n),Vh.forEach(n),kf=c(t),S=r(t,"DIV",{class:!0});var de=s(S);h(Yr.$$.fragment,de),ek=c(de),Td=r(de,"P",{});var g3=s(Td);tk=i(g3,"Summarize news articles and other documents."),g3.forEach(n),nk=c(de),kt=r(de,"P",{});var Oi=s(kt);ok=i(Oi,"This summarizing pipeline can currently be loaded from "),di=r(Oi,"A",{href:!0});var _3=s(di);rk=i(_3,"pipeline()"),_3.forEach(n),sk=i(Oi,` using the following task
identifier: `),Pd=r(Oi,"CODE",{});var v3=s(Pd);ak=i(v3,'"summarization"'),v3.forEach(n),ik=i(Oi,"."),Oi.forEach(n),lk=c(de),F=r(de,"P",{});var Y=s(F);ck=i(Y,`The models that this pipeline can use are models that have been fine-tuned on a summarization task, which is
currently, \u2019`),yd=r(Y,"EM",{});var b3=s(yd);dk=i(b3,"bart-large-cnn"),b3.forEach(n),pk=i(Y,"\u2019, \u2019"),xd=r(Y,"EM",{});var w3=s(xd);mk=i(w3,"t5-small"),w3.forEach(n),fk=i(Y,"\u2019, \u2019"),$d=r(Y,"EM",{});var k3=s($d);hk=i(k3,"t5-base"),k3.forEach(n),uk=i(Y,"\u2019, \u2019"),Ed=r(Y,"EM",{});var T3=s(Ed);gk=i(T3,"t5-large"),T3.forEach(n),_k=i(Y,"\u2019, \u2019"),qd=r(Y,"EM",{});var P3=s(qd);vk=i(P3,"t5-3b"),P3.forEach(n),bk=i(Y,"\u2019, \u2019"),Ad=r(Y,"EM",{});var y3=s(Ad);wk=i(y3,"t5-11b"),y3.forEach(n),kk=i(Y,`\u2019. See the up-to-date
list of available models on `),Jr=r(Y,"A",{href:!0,rel:!0});var x3=s(Jr);Tk=i(x3,"huggingface.co/models"),x3.forEach(n),Pk=i(Y,"."),Y.forEach(n),yk=c(de),Cd=r(de,"P",{});var $3=s(Cd);xk=i($3,"Usage:"),$3.forEach(n),$k=c(de),h(es.$$.fragment,de),Ek=c(de),Cn=r(de,"DIV",{class:!0});var Bh=s(Cn);h(ts.$$.fragment,Bh),qk=c(Bh),zd=r(Bh,"P",{});var E3=s(zd);Ak=i(E3,"Summarize the text(s) given as inputs."),E3.forEach(n),Bh.forEach(n),de.forEach(n),Tf=c(t),Tt=r(t,"H3",{class:!0});var Zh=s(Tt);zn=r(Zh,"A",{id:!0,class:!0,href:!0});var q3=s(zn);Dd=r(q3,"SPAN",{});var A3=s(Dd);h(ns.$$.fragment,A3),A3.forEach(n),q3.forEach(n),Ck=c(Zh),jd=r(Zh,"SPAN",{});var C3=s(jd);zk=i(C3,"TableQuestionAnsweringPipeline"),C3.forEach(n),Zh.forEach(n),Pf=c(t),se=r(t,"DIV",{class:!0});var Ne=s(se);h(os.$$.fragment,Ne),Dk=c(Ne),rs=r(Ne,"P",{});var Kh=s(rs);jk=i(Kh,"Table Question Answering pipeline using a "),Id=r(Kh,"CODE",{});var z3=s(Id);Ik=i(z3,"ModelForTableQuestionAnswering"),z3.forEach(n),Mk=i(Kh,`. This pipeline is only available in
PyTorch.`),Kh.forEach(n),Sk=c(Ne),Pt=r(Ne,"P",{});var Ri=s(Pt);Fk=i(Ri,"This tabular question answering pipeline can currently be loaded from "),pi=r(Ri,"A",{href:!0});var D3=s(pi);Lk=i(D3,"pipeline()"),D3.forEach(n),Gk=i(Ri,` using the
following task identifier: `),Md=r(Ri,"CODE",{});var j3=s(Md);Uk=i(j3,'"table-question-answering"'),j3.forEach(n),Nk=i(Ri,"."),Ri.forEach(n),Ok=c(Ne),ss=r(Ne,"P",{});var Xh=s(ss);Rk=i(Xh,`The models that this pipeline can use are models that have been fine-tuned on a tabular question answering task.
See the up-to-date list of available models on `),as=r(Xh,"A",{href:!0,rel:!0});var I3=s(as);Qk=i(I3,"huggingface.co/models"),I3.forEach(n),Wk=i(Xh,"."),Xh.forEach(n),Hk=c(Ne),C=r(Ne,"DIV",{class:!0});var U=s(C);h(is.$$.fragment,U),Vk=c(U),Sd=r(U,"P",{});var M3=s(Sd);Bk=i(M3,"Answers queries according to a table. The pipeline accepts several types of inputs which are detailed below:"),M3.forEach(n),Zk=c(U),H=r(U,"UL",{});var pe=s(H);Fd=r(pe,"LI",{});var S3=s(Fd);Ld=r(S3,"CODE",{});var F3=s(Ld);Kk=i(F3,"pipeline(table, query)"),F3.forEach(n),S3.forEach(n),Xk=c(pe),Gd=r(pe,"LI",{});var L3=s(Gd);Ud=r(L3,"CODE",{});var G3=s(Ud);Yk=i(G3,"pipeline(table, [query])"),G3.forEach(n),L3.forEach(n),Jk=c(pe),Nd=r(pe,"LI",{});var U3=s(Nd);Od=r(U3,"CODE",{});var N3=s(Od);eT=i(N3,"pipeline(table=table, query=query)"),N3.forEach(n),U3.forEach(n),tT=c(pe),Rd=r(pe,"LI",{});var O3=s(Rd);Qd=r(O3,"CODE",{});var R3=s(Qd);nT=i(R3,"pipeline(table=table, query=[query])"),R3.forEach(n),O3.forEach(n),oT=c(pe),Wd=r(pe,"LI",{});var Q3=s(Wd);Hd=r(Q3,"CODE",{});var W3=s(Hd);rT=i(W3,'pipeline({"table": table, "query": query})'),W3.forEach(n),Q3.forEach(n),sT=c(pe),Vd=r(pe,"LI",{});var H3=s(Vd);Bd=r(H3,"CODE",{});var V3=s(Bd);aT=i(V3,'pipeline({"table": table, "query": [query]})'),V3.forEach(n),H3.forEach(n),iT=c(pe),Zd=r(pe,"LI",{});var B3=s(Zd);Kd=r(B3,"CODE",{});var Z3=s(Kd);lT=i(Z3,'pipeline([{"table": table, "query": query}, {"table": table, "query": query}])'),Z3.forEach(n),B3.forEach(n),pe.forEach(n),cT=c(U),ls=r(U,"P",{});var Yh=s(ls);dT=i(Yh,"The "),Xd=r(Yh,"CODE",{});var K3=s(Xd);pT=i(K3,"table"),K3.forEach(n),mT=i(Yh," argument should be a dict or a DataFrame built from that dict, containing the whole table:"),Yh.forEach(n),fT=c(U),Yd=r(U,"P",{});var X3=s(Yd);hT=i(X3,"Example:"),X3.forEach(n),uT=c(U),h(cs.$$.fragment,U),gT=c(U),Jd=r(U,"P",{});var Y3=s(Jd);_T=i(Y3,"This dictionary can be passed in as such, or can be converted to a pandas DataFrame:"),Y3.forEach(n),vT=c(U),ep=r(U,"P",{});var J3=s(ep);bT=i(J3,"Example:"),J3.forEach(n),wT=c(U),h(ds.$$.fragment,U),U.forEach(n),Ne.forEach(n),yf=c(t),yt=r(t,"H3",{class:!0});var Jh=s(yt);Dn=r(Jh,"A",{id:!0,class:!0,href:!0});var e5=s(Dn);tp=r(e5,"SPAN",{});var t5=s(tp);h(ps.$$.fragment,t5),t5.forEach(n),e5.forEach(n),kT=c(Jh),np=r(Jh,"SPAN",{});var n5=s(np);TT=i(n5,"TextClassificationPipeline"),n5.forEach(n),Jh.forEach(n),xf=c(t),V=r(t,"DIV",{class:!0});var Te=s(V);h(ms.$$.fragment,Te),PT=c(Te),xt=r(Te,"P",{});var Qi=s(xt);yT=i(Qi,"Text classification pipeline using any "),op=r(Qi,"CODE",{});var o5=s(op);xT=i(o5,"ModelForSequenceClassification"),o5.forEach(n),$T=i(Qi,". See the "),mi=r(Qi,"A",{href:!0});var r5=s(mi);ET=i(r5,`sequence classification
examples`),r5.forEach(n),qT=i(Qi," for more information."),Qi.forEach(n),AT=c(Te),$t=r(Te,"P",{});var Wi=s($t);CT=i(Wi,"This text classification pipeline can currently be loaded from "),fi=r(Wi,"A",{href:!0});var s5=s(fi);zT=i(s5,"pipeline()"),s5.forEach(n),DT=i(Wi,` using the following
task identifier: `),rp=r(Wi,"CODE",{});var a5=s(rp);jT=i(a5,'"sentiment-analysis"'),a5.forEach(n),IT=i(Wi,` (for classifying sequences according to positive or negative
sentiments).`),Wi.forEach(n),MT=c(Te),fs=r(Te,"P",{});var eu=s(fs);ST=i(eu,"If multiple classification labels are available ("),sp=r(eu,"CODE",{});var i5=s(sp);FT=i(i5,"model.config.num_labels >= 2"),i5.forEach(n),LT=i(eu,`), the pipeline will run a
softmax over the results. If there is a single label, the pipeline will run a sigmoid over the result.`),eu.forEach(n),GT=c(Te),hs=r(Te,"P",{});var tu=s(hs);UT=i(tu,`The models that this pipeline can use are models that have been fine-tuned on a sequence classification task. See
the up-to-date list of available models on `),us=r(tu,"A",{href:!0,rel:!0});var l5=s(us);NT=i(l5,"huggingface.co/models"),l5.forEach(n),OT=i(tu,"."),tu.forEach(n),RT=c(Te),jn=r(Te,"DIV",{class:!0});var nu=s(jn);h(gs.$$.fragment,nu),QT=c(nu),ap=r(nu,"P",{});var c5=s(ap);WT=i(c5,"Classify the text(s) given as inputs."),c5.forEach(n),nu.forEach(n),Te.forEach(n),$f=c(t),Et=r(t,"H3",{class:!0});var ou=s(Et);In=r(ou,"A",{id:!0,class:!0,href:!0});var d5=s(In);ip=r(d5,"SPAN",{});var p5=s(ip);h(_s.$$.fragment,p5),p5.forEach(n),d5.forEach(n),HT=c(ou),lp=r(ou,"SPAN",{});var m5=s(lp);VT=i(m5,"TextGenerationPipeline"),m5.forEach(n),ou.forEach(n),Ef=c(t),ae=r(t,"DIV",{class:!0});var Oe=s(ae);h(vs.$$.fragment,Oe),BT=c(Oe),bs=r(Oe,"P",{});var ru=s(bs);ZT=i(ru,"Language generation pipeline using any "),cp=r(ru,"CODE",{});var f5=s(cp);KT=i(f5,"ModelWithLMHead"),f5.forEach(n),XT=i(ru,`. This pipeline predicts the words that will follow a
specified text prompt.`),ru.forEach(n),YT=c(Oe),qt=r(Oe,"P",{});var Hi=s(qt);JT=i(Hi,"This language generation pipeline can currently be loaded from "),hi=r(Hi,"A",{href:!0});var h5=s(hi);eP=i(h5,"pipeline()"),h5.forEach(n),tP=i(Hi,` using the following
task identifier: `),dp=r(Hi,"CODE",{});var u5=s(dp);nP=i(u5,'"text-generation"'),u5.forEach(n),oP=i(Hi,"."),Hi.forEach(n),rP=c(Oe),ws=r(Oe,"P",{});var su=s(ws);sP=i(su,`The models that this pipeline can use are models that have been trained with an autoregressive language modeling
objective, which includes the uni-directional models in the library (e.g. gpt2). See the list of available models
on `),ks=r(su,"A",{href:!0,rel:!0});var g5=s(ks);aP=i(g5,"huggingface.co/models"),g5.forEach(n),iP=i(su,"."),su.forEach(n),lP=c(Oe),Mn=r(Oe,"DIV",{class:!0});var au=s(Mn);h(Ts.$$.fragment,au),cP=c(au),pp=r(au,"P",{});var _5=s(pp);dP=i(_5,"Complete the prompt(s) given as inputs."),_5.forEach(n),au.forEach(n),Oe.forEach(n),qf=c(t),At=r(t,"H3",{class:!0});var iu=s(At);Sn=r(iu,"A",{id:!0,class:!0,href:!0});var v5=s(Sn);mp=r(v5,"SPAN",{});var b5=s(mp);h(Ps.$$.fragment,b5),b5.forEach(n),v5.forEach(n),pP=c(iu),fp=r(iu,"SPAN",{});var w5=s(fp);mP=i(w5,"Text2TextGenerationPipeline"),w5.forEach(n),iu.forEach(n),Af=c(t),I=r(t,"DIV",{class:!0});var J=s(I);h(ys.$$.fragment,J),fP=c(J),hp=r(J,"P",{});var k5=s(hp);hP=i(k5,"Pipeline for text to text generation using seq2seq models."),k5.forEach(n),uP=c(J),Ct=r(J,"P",{});var Vi=s(Ct);gP=i(Vi,"This Text2TextGenerationPipeline pipeline can currently be loaded from "),ui=r(Vi,"A",{href:!0});var T5=s(ui);_P=i(T5,"pipeline()"),T5.forEach(n),vP=i(Vi,` using the
following task identifier: `),up=r(Vi,"CODE",{});var P5=s(up);bP=i(P5,'"text2text-generation"'),P5.forEach(n),wP=i(Vi,"."),Vi.forEach(n),kP=c(J),xs=r(J,"P",{});var lu=s(xs);TP=i(lu,`The models that this pipeline can use are models that have been fine-tuned on a translation task. See the
up-to-date list of available models on `),$s=r(lu,"A",{href:!0,rel:!0});var y5=s($s);PP=i(y5,"huggingface.co/models"),y5.forEach(n),yP=i(lu,"."),lu.forEach(n),xP=c(J),gp=r(J,"P",{});var x5=s(gp);$P=i(x5,"Usage:"),x5.forEach(n),EP=c(J),h(Es.$$.fragment,J),qP=c(J),Fn=r(J,"DIV",{class:!0});var cu=s(Fn);h(qs.$$.fragment,cu),AP=c(cu),_p=r(cu,"P",{});var $5=s(_p);CP=i($5,"Generate the output text(s) using text(s) given as inputs."),$5.forEach(n),cu.forEach(n),zP=c(J),Ln=r(J,"DIV",{class:!0});var du=s(Ln);h(As.$$.fragment,du),DP=c(du),vp=r(du,"P",{});var E5=s(vp);jP=i(E5,"Checks whether there might be something wrong with given input with regard to the model."),E5.forEach(n),du.forEach(n),J.forEach(n),Cf=c(t),zt=r(t,"H3",{class:!0});var pu=s(zt);Gn=r(pu,"A",{id:!0,class:!0,href:!0});var q5=s(Gn);bp=r(q5,"SPAN",{});var A5=s(bp);h(Cs.$$.fragment,A5),A5.forEach(n),q5.forEach(n),IP=c(pu),wp=r(pu,"SPAN",{});var C5=s(wp);MP=i(C5,"TokenClassificationPipeline"),C5.forEach(n),pu.forEach(n),zf=c(t),q=r(t,"DIV",{class:!0});var N=s(q);h(zs.$$.fragment,N),SP=c(N),Dt=r(N,"P",{});var Bi=s(Dt);FP=i(Bi,"Named Entity Recognition pipeline using any "),kp=r(Bi,"CODE",{});var z5=s(kp);LP=i(z5,"ModelForTokenClassification"),z5.forEach(n),GP=i(Bi,". See the "),gi=r(Bi,"A",{href:!0});var D5=s(gi);UP=i(D5,`named entity recognition
examples`),D5.forEach(n),NP=i(Bi," for more information."),Bi.forEach(n),OP=c(N),jt=r(N,"P",{});var Zi=s(jt);RP=i(Zi,"This token recognition pipeline can currently be loaded from "),_i=r(Zi,"A",{href:!0});var j5=s(_i);QP=i(j5,"pipeline()"),j5.forEach(n),WP=i(Zi,` using the following
task identifier: `),Tp=r(Zi,"CODE",{});var I5=s(Tp);HP=i(I5,'"ner"'),I5.forEach(n),VP=i(Zi,` (for predicting the classes of tokens in a sequence: person, organisation, location
or miscellaneous).`),Zi.forEach(n),BP=c(N),Ds=r(N,"P",{});var mu=s(Ds);ZP=i(mu,`The models that this pipeline can use are models that have been fine-tuned on a token classification task. See the
up-to-date list of available models on `),js=r(mu,"A",{href:!0,rel:!0});var M5=s(js);KP=i(M5,"huggingface.co/models"),M5.forEach(n),XP=i(mu,"."),mu.forEach(n),YP=c(N),Un=r(N,"DIV",{class:!0});var fu=s(Un);h(Is.$$.fragment,fu),JP=c(fu),Pp=r(fu,"P",{});var S5=s(Pp);ey=i(S5,"Classify each token of the text(s) given as inputs."),S5.forEach(n),fu.forEach(n),ty=c(N),De=r(N,"DIV",{class:!0});var Ki=s(De);h(Ms.$$.fragment,Ki),ny=c(Ki),yp=r(Ki,"P",{});var F5=s(yp);oy=i(F5,"Override tokens from a given word that disagree to force agreement on word boundaries."),F5.forEach(n),ry=c(Ki),xp=r(Ki,"P",{});var L5=s(xp);sy=i(L5,`Example: micro|soft| com|pany| B-ENT I-NAME I-ENT I-ENT will be rewritten with first strategy as microsoft|
company| B-ENT I-ENT`),L5.forEach(n),Ki.forEach(n),ay=c(N),Nn=r(N,"DIV",{class:!0});var hu=s(Nn);h(Ss.$$.fragment,hu),iy=c(hu),$p=r(hu,"P",{});var G5=s($p);ly=i(G5,"Fuse various numpy arrays into dicts with all the information needed for aggregation"),G5.forEach(n),hu.forEach(n),cy=c(N),On=r(N,"DIV",{class:!0});var uu=s(On);h(Fs.$$.fragment,uu),dy=c(uu),Ep=r(uu,"P",{});var U5=s(Ep);py=i(U5,"Find and group together the adjacent tokens with the same entity predicted."),U5.forEach(n),uu.forEach(n),my=c(N),Rn=r(N,"DIV",{class:!0});var gu=s(Rn);h(Ls.$$.fragment,gu),fy=c(gu),qp=r(gu,"P",{});var N5=s(qp);hy=i(N5,"Group together the adjacent tokens with the same entity predicted."),N5.forEach(n),gu.forEach(n),N.forEach(n),Df=c(t),It=r(t,"H3",{class:!0});var _u=s(It);Qn=r(_u,"A",{id:!0,class:!0,href:!0});var O5=s(Qn);Ap=r(O5,"SPAN",{});var R5=s(Ap);h(Gs.$$.fragment,R5),R5.forEach(n),O5.forEach(n),uy=c(_u),Cp=r(_u,"SPAN",{});var Q5=s(Cp);gy=i(Q5,"TranslationPipeline"),Q5.forEach(n),_u.forEach(n),jf=c(t),L=r(t,"DIV",{class:!0});var me=s(L);h(Us.$$.fragment,me),_y=c(me),zp=r(me,"P",{});var W5=s(zp);vy=i(W5,"Translates from one language to another."),W5.forEach(n),by=c(me),Mt=r(me,"P",{});var Xi=s(Mt);wy=i(Xi,"This translation pipeline can currently be loaded from "),vi=r(Xi,"A",{href:!0});var H5=s(vi);ky=i(H5,"pipeline()"),H5.forEach(n),Ty=i(Xi,` using the following task
identifier: `),Dp=r(Xi,"CODE",{});var V5=s(Dp);Py=i(V5,'"translation_xx_to_yy"'),V5.forEach(n),yy=i(Xi,"."),Xi.forEach(n),xy=c(me),Ns=r(me,"P",{});var vu=s(Ns);$y=i(vu,`The models that this pipeline can use are models that have been fine-tuned on a translation task. See the
up-to-date list of available models on `),Os=r(vu,"A",{href:!0,rel:!0});var B5=s(Os);Ey=i(B5,"huggingface.co/models"),B5.forEach(n),qy=i(vu,"."),vu.forEach(n),Ay=c(me),jp=r(me,"P",{});var Z5=s(jp);Cy=i(Z5,"Usage:"),Z5.forEach(n),zy=c(me),h(Rs.$$.fragment,me),Dy=c(me),Wn=r(me,"DIV",{class:!0});var bu=s(Wn);h(Qs.$$.fragment,bu),jy=c(bu),Ip=r(bu,"P",{});var K5=s(Ip);Iy=i(K5,"Translate the text(s) given as inputs."),K5.forEach(n),bu.forEach(n),me.forEach(n),If=c(t),St=r(t,"H3",{class:!0});var wu=s(St);Hn=r(wu,"A",{id:!0,class:!0,href:!0});var X5=s(Hn);Mp=r(X5,"SPAN",{});var Y5=s(Mp);h(Ws.$$.fragment,Y5),Y5.forEach(n),X5.forEach(n),My=c(wu),Sp=r(wu,"SPAN",{});var J5=s(Sp);Sy=i(J5,"ZeroShotClassificationPipeline"),J5.forEach(n),wu.forEach(n),Mf=c(t),B=r(t,"DIV",{class:!0});var Pe=s(B);h(Hs.$$.fragment,Pe),Fy=c(Pe),Vs=r(Pe,"P",{});var ku=s(Vs);Ly=i(ku,"NLI-based zero-shot classification pipeline using a "),Fp=r(ku,"CODE",{});var eq=s(Fp);Gy=i(eq,"ModelForSequenceClassification"),eq.forEach(n),Uy=i(ku,` trained on NLI (natural
language inference) tasks.`),ku.forEach(n),Ny=c(Pe),Ee=r(Pe,"P",{});var po=s(Ee);Oy=i(po,`Any combination of sequences and labels can be passed and each combination will be posed as a premise/hypothesis
pair and passed to the pretrained model. Then, the logit for `),Lp=r(po,"EM",{});var tq=s(Lp);Ry=i(tq,"entailment"),tq.forEach(n),Qy=i(po,` is taken as the logit for the candidate
label being valid. Any NLI model can be used, but the id of the `),Gp=r(po,"EM",{});var nq=s(Gp);Wy=i(nq,"entailment"),nq.forEach(n),Hy=i(po,` label must be included in the model
config\u2019s :attr:`),Up=r(po,"EM",{});var oq=s(Up);Vy=i(oq,"~transformers.PretrainedConfig.label2id"),oq.forEach(n),By=i(po,"."),po.forEach(n),Zy=c(Pe),Ft=r(Pe,"P",{});var Yi=s(Ft);Ky=i(Yi,"This NLI pipeline can currently be loaded from "),bi=r(Yi,"A",{href:!0});var rq=s(bi);Xy=i(rq,"pipeline()"),rq.forEach(n),Yy=i(Yi,` using the following task identifier:
`),Np=r(Yi,"CODE",{});var sq=s(Np);Jy=i(sq,'"zero-shot-classification"'),sq.forEach(n),e2=i(Yi,"."),Yi.forEach(n),t2=c(Pe),Bs=r(Pe,"P",{});var Tu=s(Bs);n2=i(Tu,`The models that this pipeline can use are models that have been fine-tuned on an NLI task. See the up-to-date list
of available models on `),Zs=r(Tu,"A",{href:!0,rel:!0});var aq=s(Zs);o2=i(aq,"huggingface.co/models"),aq.forEach(n),r2=i(Tu,"."),Tu.forEach(n),s2=c(Pe),Vn=r(Pe,"DIV",{class:!0});var Pu=s(Vn);h(Ks.$$.fragment,Pu),a2=c(Pu),Xs=r(Pu,"P",{});var yu=s(Xs);i2=i(yu,"Classify the sequence(s) given as inputs. See the "),wi=r(yu,"A",{href:!0});var iq=s(wi);l2=i(iq,"ZeroShotClassificationPipeline"),iq.forEach(n),c2=i(yu,`
documentation for more information.`),yu.forEach(n),Pu.forEach(n),Pe.forEach(n),Sf=c(t),Lt=r(t,"H2",{class:!0});var xu=s(Lt);Bn=r(xu,"A",{id:!0,class:!0,href:!0});var lq=s(Bn);Op=r(lq,"SPAN",{});var cq=s(Op);h(Ys.$$.fragment,cq),cq.forEach(n),lq.forEach(n),d2=c(xu),ki=r(xu,"SPAN",{});var P0=s(ki);p2=i(P0,"Parent class: "),Rp=r(P0,"CODE",{});var dq=s(Rp);m2=i(dq,"Pipeline"),dq.forEach(n),P0.forEach(n),xu.forEach(n),Ff=c(t),T=r(t,"DIV",{class:!0});var P=s(T);h(Js.$$.fragment,P),f2=c(P),Qp=r(P,"P",{});var pq=s(Qp);h2=i(pq,`The Pipeline class is the class from which all pipelines inherit. Refer to this class for methods shared across
different pipelines.`),pq.forEach(n),u2=c(P),Wp=r(P,"P",{});var mq=s(Wp);g2=i(mq,`Base class implementing pipelined operations. Pipeline workflow is defined as a sequence of the following
operations:`),mq.forEach(n),_2=c(P),Hp=r(P,"P",{});var fq=s(Hp);v2=i(fq,"Input -> Tokenization -> Model Inference -> Post-Processing (task dependent) -> Output"),fq.forEach(n),b2=c(P),Vp=r(P,"P",{});var hq=s(Vp);w2=i(hq,"Pipeline supports running on CPU or GPU through the device argument (see below)."),hq.forEach(n),k2=c(P),ve=r(P,"P",{});var Re=s(ve);T2=i(Re,"Some pipeline, like for instance "),Ti=r(Re,"A",{href:!0});var uq=s(Ti);P2=i(uq,"FeatureExtractionPipeline"),uq.forEach(n),y2=i(Re," ("),Bp=r(Re,"CODE",{});var gq=s(Bp);x2=i(gq,"'feature-extraction'"),gq.forEach(n),$2=i(Re,` )
output large tensor object as nested-lists. In order to avoid dumping such large structure as textual data we
provide the `),Zp=r(Re,"CODE",{});var _q=s(Zp);E2=i(_q,"binary_output"),_q.forEach(n),q2=i(Re," constructor argument. If set to "),Kp=r(Re,"CODE",{});var vq=s(Kp);A2=i(vq,"True"),vq.forEach(n),C2=i(Re,`, the output will be stored in the
pickle format.`),Re.forEach(n),z2=c(P),Zn=r(P,"DIV",{class:!0});var $u=s(Zn);h(ea.$$.fragment,$u),D2=c($u),Xp=r($u,"P",{});var bq=s(Xp);j2=i(bq,"Check if the model class is in supported by the pipeline."),bq.forEach(n),$u.forEach(n),I2=c(P),G=r(P,"DIV",{class:!0});var fe=s(G);h(ta.$$.fragment,fe),M2=c(fe),Yp=r(fe,"P",{});var wq=s(Yp);S2=i(wq,"Context Manager allowing tensor allocation on the user-specified device in framework agnostic way."),wq.forEach(n),F2=c(fe),Jp=r(fe,"P",{});var kq=s(Jp);L2=i(kq,"Examples::"),kq.forEach(n),G2=c(fe),Kn=r(fe,"H1",{class:!0});var Eu=s(Kn);Xn=r(Eu,"A",{id:!0,class:!0,href:!0});var Tq=s(Xn);em=r(Tq,"SPAN",{});var Pq=s(em);h(na.$$.fragment,Pq),Pq.forEach(n),Tq.forEach(n),U2=c(Eu),tm=r(Eu,"SPAN",{});var yq=s(tm);N2=i(yq,"Explicitly ask for tensor allocation on CUDA device :0"),yq.forEach(n),Eu.forEach(n),O2=c(fe),nm=r(fe,"P",{});var xq=s(nm);R2=i(xq,`pipe = pipeline(\u2026, device=0)
with pipe.device_placement():`),xq.forEach(n),Q2=c(fe),Yn=r(fe,"H1",{class:!0});var qu=s(Yn);Jn=r(qu,"A",{id:!0,class:!0,href:!0});var $q=s(Jn);om=r($q,"SPAN",{});var Eq=s(om);h(oa.$$.fragment,Eq),Eq.forEach(n),$q.forEach(n),W2=c(qu),rm=r(qu,"SPAN",{});var qq=s(rm);H2=i(qq,"Every framework specific tensor allocation will be done on the request device"),qq.forEach(n),qu.forEach(n),V2=c(fe),sm=r(fe,"P",{});var Aq=s(sm);B2=i(Aq,"output = pipe(\u2026)"),Aq.forEach(n),fe.forEach(n),Z2=c(P),eo=r(P,"DIV",{class:!0});var Au=s(eo);h(ra.$$.fragment,Au),K2=c(Au),am=r(Au,"P",{});var Cq=s(am);X2=i(Cq,"Ensure PyTorch tensors are on the specified device."),Cq.forEach(n),Au.forEach(n),Y2=c(P),to=r(P,"DIV",{class:!0});var Cu=s(to);h(sa.$$.fragment,Cu),J2=c(Cu),aa=r(Cu,"P",{});var zu=s(aa);e0=i(zu,"Postprocess will receive the raw outputs of the "),im=r(zu,"CODE",{});var zq=s(im);t0=i(zq,"_forward"),zq.forEach(n),n0=i(zu,` method, generally tensors, and reformat them into
something more friendly. Generally it will output a list or a dict or results (containing just strings and
numbers).`),zu.forEach(n),Cu.forEach(n),o0=c(P),no=r(P,"DIV",{class:!0});var Du=s(no);h(ia.$$.fragment,Du),r0=c(Du),la=r(Du,"P",{});var ju=s(la);s0=i(ju,"Scikit / Keras interface to transformers\u2019 pipelines. This method will forward to "),lm=r(ju,"STRONG",{});var Dq=s(lm);a0=i(Dq,"call"),Dq.forEach(n),i0=i(ju,"()."),ju.forEach(n),Du.forEach(n),l0=c(P),oo=r(P,"DIV",{class:!0});var Iu=s(oo);h(ca.$$.fragment,Iu),c0=c(Iu),Gt=r(Iu,"P",{});var Ji=s(Gt);d0=i(Ji,"Preprocess will take the "),cm=r(Ji,"CODE",{});var jq=s(cm);p0=i(jq,"input_"),jq.forEach(n),m0=i(Ji,` of a specific pipeline and return a dictionnary of everything necessary for
`),dm=r(Ji,"CODE",{});var Iq=s(dm);f0=i(Iq,"_forward"),Iq.forEach(n),h0=i(Ji," to run properly. It should contain at least one tensor, but might have arbitrary other items."),Ji.forEach(n),Iu.forEach(n),u0=c(P),ro=r(P,"DIV",{class:!0});var Mu=s(ro);h(da.$$.fragment,Mu),g0=c(Mu),pm=r(Mu,"P",{});var Mq=s(pm);_0=i(Mq,"Save the pipeline\u2019s model and tokenizer."),Mq.forEach(n),Mu.forEach(n),v0=c(P),so=r(P,"DIV",{class:!0});var Su=s(so);h(pa.$$.fragment,Su),b0=c(Su),ma=r(Su,"P",{});var Fu=s(ma);w0=i(Fu,"Scikit / Keras interface to transformers\u2019 pipelines. This method will forward to "),mm=r(Fu,"STRONG",{});var Sq=s(mm);k0=i(Sq,"call"),Sq.forEach(n),T0=i(Fu,"()."),Fu.forEach(n),Su.forEach(n),P.forEach(n),this.h()},h(){d(x,"name","hf:doc:metadata"),d(x,"content",JSON.stringify(Wq)),d(A,"id","pipelines"),d(A,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(A,"href","#pipelines"),d($,"class","relative group"),d(ha,"href","/docs/transformers/v4.14.1/en/../task_summary"),d(ga,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(_a,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.AudioClassificationPipeline"),d(va,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.AutomaticSpeechRecognitionPipeline"),d(ba,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.ConversationalPipeline"),d(wa,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.FeatureExtractionPipeline"),d(ka,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.FillMaskPipeline"),d(Ta,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.ImageClassificationPipeline"),d(Pa,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.ImageSegmentationPipeline"),d(ya,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.ObjectDetectionPipeline"),d(xa,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.QuestionAnsweringPipeline"),d($a,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.SummarizationPipeline"),d(Ea,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.TableQuestionAnsweringPipeline"),d(qa,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.TextClassificationPipeline"),d(Aa,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.TextGenerationPipeline"),d(Ca,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.Text2TextGenerationPipeline"),d(za,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.TokenClassificationPipeline"),d(Da,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.TranslationPipeline"),d(ja,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.ZeroShotClassificationPipeline"),d(Ot,"id","transformers.pipeline"),d(Ot,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Ot,"href","#transformers.pipeline"),d(Qe,"class","relative group"),d(_o,"href","https://huggingface.co"),d(_o,"rel","nofollow"),d(Ma,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.Pipeline"),d(Sa,"href","/docs/transformers/v4.14.1/en/tokenizer"),d(Fa,"href","/docs/transformers/v4.14.1/en/model"),d(Q,"class","docstring"),d(Vt,"id","pipeline-batching"),d(Vt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Vt,"href","#pipeline-batching"),d(He,"class","relative group"),d(Kt,"id","pipeline-custom-code"),d(Kt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Kt,"href","#pipeline-custom-code"),d(Be,"class","relative group"),d(Yt,"id","implementing-a-pipeline"),d(Yt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Yt,"href","#implementing-a-pipeline"),d(Ze,"class","relative group"),d(Ha,"href","/docs/transformers/v4.14.1/en/../add_new_pipeline"),d(Jt,"id","the-task-specific-pipelines"),d(Jt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Jt,"href","#the-task-specific-pipelines"),d(Ke,"class","relative group"),d(en,"id","transformers.AudioClassificationPipeline"),d(en,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(en,"href","#transformers.AudioClassificationPipeline"),d(Xe,"class","relative group"),d(Va,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(No,"href","https://huggingface.co/models?filter=audio-classification"),d(No,"rel","nofollow"),d(Ba,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.AutomaticSpeechRecognitionPipeline"),d(tn,"class","docstring"),d(ee,"class","docstring"),d(nn,"id","transformers.AutomaticSpeechRecognitionPipeline"),d(nn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(nn,"href","#transformers.AutomaticSpeechRecognitionPipeline"),d(Je,"class","relative group"),d(Za,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.AutomaticSpeechRecognitionPipeline"),d(on,"class","docstring"),d(ue,"class","docstring"),d(rn,"id","transformers.Conversation"),d(rn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(rn,"href","#transformers.Conversation"),d(et,"class","relative group"),d(Ka,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.ConversationalPipeline"),d(Xa,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.ConversationalPipeline"),d(sn,"class","docstring"),d(an,"class","docstring"),d(qe,"class","docstring"),d(ln,"class","docstring"),d(z,"class","docstring"),d(Ya,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(or,"href","https://huggingface.co/models?filter=conversational"),d(or,"rel","nofollow"),d(cn,"class","docstring"),d(M,"class","docstring"),d(dn,"id","transformers.FeatureExtractionPipeline"),d(dn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(dn,"href","#transformers.FeatureExtractionPipeline"),d(nt,"class","relative group"),d(Ja,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(cr,"href","https://huggingface.co/models"),d(cr,"rel","nofollow"),d(pn,"class","docstring"),d(te,"class","docstring"),d(mn,"id","transformers.FillMaskPipeline"),d(mn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(mn,"href","#transformers.FillMaskPipeline"),d(rt,"class","relative group"),d(ei,"href","../task_summary#masked-language-modeling"),d(ti,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(hr,"href","https://huggingface.co/models?filter=fill-mask"),d(hr,"rel","nofollow"),d(hn,"class","docstring"),d(W,"class","docstring"),d(un,"id","transformers.ImageClassificationPipeline"),d(un,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(un,"href","#transformers.ImageClassificationPipeline"),d(it,"class","relative group"),d(ni,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(wr,"href","https://huggingface.co/models?filter=image-classification"),d(wr,"rel","nofollow"),d(gn,"class","docstring"),d(ne,"class","docstring"),d(_n,"id","transformers.ImageSegmentationPipeline"),d(_n,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(_n,"href","#transformers.ImageSegmentationPipeline"),d(ct,"class","relative group"),d(oi,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d($r,"href","https://huggingface.co/models?filter=image-segmentation"),d($r,"rel","nofollow"),d(vn,"class","docstring"),d(oe,"class","docstring"),d(bn,"id","transformers.TokenClassificationPipeline"),d(bn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(bn,"href","#transformers.TokenClassificationPipeline"),d(pt,"class","relative group"),d(ri,"href","../task_summary#named-entity-recognition"),d(si,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(zr,"href","https://huggingface.co/models?filter=token-classification"),d(zr,"rel","nofollow"),d(Ae,"class","docstring"),d(wn,"class","docstring"),d(kn,"class","docstring"),d(Tn,"class","docstring"),d(D,"class","docstring"),d(ai,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.TokenClassificationPipeline"),d(yn,"id","transformers.ObjectDetectionPipeline"),d(yn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(yn,"href","#transformers.ObjectDetectionPipeline"),d(ht,"class","relative group"),d(ii,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(Ur,"href","https://huggingface.co/models?filter=object-detection"),d(Ur,"rel","nofollow"),d(xn,"class","docstring"),d(re,"class","docstring"),d($n,"id","transformers.QuestionAnsweringPipeline"),d($n,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d($n,"href","#transformers.QuestionAnsweringPipeline"),d(gt,"class","relative group"),d(li,"href","../task_summary#question-answering"),d(ci,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(Wr,"href","https://huggingface.co/models?filter=question-answering"),d(Wr,"rel","nofollow"),d(En,"class","docstring"),d(Ce,"class","docstring"),d(ze,"class","docstring"),d(qn,"class","docstring"),d(j,"class","docstring"),d(An,"id","transformers.SummarizationPipeline"),d(An,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(An,"href","#transformers.SummarizationPipeline"),d(wt,"class","relative group"),d(di,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(Jr,"href","https://huggingface.co/models?filter=summarization"),d(Jr,"rel","nofollow"),d(Cn,"class","docstring"),d(S,"class","docstring"),d(zn,"id","transformers.TableQuestionAnsweringPipeline"),d(zn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(zn,"href","#transformers.TableQuestionAnsweringPipeline"),d(Tt,"class","relative group"),d(pi,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(as,"href","https://huggingface.co/models?filter=table-question-answering"),d(as,"rel","nofollow"),d(C,"class","docstring"),d(se,"class","docstring"),d(Dn,"id","transformers.TextClassificationPipeline"),d(Dn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Dn,"href","#transformers.TextClassificationPipeline"),d(yt,"class","relative group"),d(mi,"href","../task_summary#sequence-classification"),d(fi,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(us,"href","https://huggingface.co/models?filter=text-classification"),d(us,"rel","nofollow"),d(jn,"class","docstring"),d(V,"class","docstring"),d(In,"id","transformers.TextGenerationPipeline"),d(In,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(In,"href","#transformers.TextGenerationPipeline"),d(Et,"class","relative group"),d(hi,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(ks,"href","https://huggingface.co/models?filter=text-generation"),d(ks,"rel","nofollow"),d(Mn,"class","docstring"),d(ae,"class","docstring"),d(Sn,"id","transformers.Text2TextGenerationPipeline"),d(Sn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Sn,"href","#transformers.Text2TextGenerationPipeline"),d(At,"class","relative group"),d(ui,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d($s,"href","https://huggingface.co/models?filter=text2text-generation"),d($s,"rel","nofollow"),d(Fn,"class","docstring"),d(Ln,"class","docstring"),d(I,"class","docstring"),d(Gn,"id","transformers.TokenClassificationPipeline"),d(Gn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Gn,"href","#transformers.TokenClassificationPipeline"),d(zt,"class","relative group"),d(gi,"href","../task_summary#named-entity-recognition"),d(_i,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(js,"href","https://huggingface.co/models?filter=token-classification"),d(js,"rel","nofollow"),d(Un,"class","docstring"),d(De,"class","docstring"),d(Nn,"class","docstring"),d(On,"class","docstring"),d(Rn,"class","docstring"),d(q,"class","docstring"),d(Qn,"id","transformers.TranslationPipeline"),d(Qn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Qn,"href","#transformers.TranslationPipeline"),d(It,"class","relative group"),d(vi,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(Os,"href","https://huggingface.co/models?filter=translation"),d(Os,"rel","nofollow"),d(Wn,"class","docstring"),d(L,"class","docstring"),d(Hn,"id","transformers.ZeroShotClassificationPipeline"),d(Hn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Hn,"href","#transformers.ZeroShotClassificationPipeline"),d(St,"class","relative group"),d(bi,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.pipeline"),d(Zs,"href","https://huggingface.co/models?search=nli"),d(Zs,"rel","nofollow"),d(wi,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.ZeroShotClassificationPipeline"),d(Vn,"class","docstring"),d(B,"class","docstring"),d(Bn,"id","transformers.Pipeline"),d(Bn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Bn,"href","#transformers.Pipeline"),d(Lt,"class","relative group"),d(Ti,"href","/docs/transformers/v4.14.1/en/main_classes/pipelines#transformers.FeatureExtractionPipeline"),d(Zn,"class","docstring"),d(Xn,"id","explicitly-ask-for-tensor-allocation-on-cuda-device-:0"),d(Xn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Xn,"href","#explicitly-ask-for-tensor-allocation-on-cuda-device-:0"),d(Kn,"class","relative group"),d(Jn,"id","every-framework-specific-tensor-allocation-will-be-done-on-the-request-device"),d(Jn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Jn,"href","#every-framework-specific-tensor-allocation-will-be-done-on-the-request-device"),d(Yn,"class","relative group"),d(G,"class","docstring"),d(eo,"class","docstring"),d(to,"class","docstring"),d(no,"class","docstring"),d(oo,"class","docstring"),d(ro,"class","docstring"),d(so,"class","docstring"),d(T,"class","docstring")},m(t,p){e(document.head,x),m(t,ie,p),m(t,$,p),e($,A),e(A,he),u(E,he,null),e($,R),e($,ye),e(ye,Lu),m(t,hm,p),m(t,Ut,p),e(Ut,Gu),e(Ut,ha),e(ha,Uu),e(Ut,Nu),m(t,um,p),m(t,ua,p),e(ua,Ou),m(t,gm,p),m(t,Nt,p),e(Nt,el),e(el,fo),e(fo,Ru),e(fo,ga),e(ga,Qu),e(fo,Wu),e(Nt,Hu),e(Nt,ho),e(ho,tl),e(tl,Vu),e(ho,Bu),e(ho,w),e(w,nl),e(nl,_a),e(_a,Zu),e(w,Ku),e(w,ol),e(ol,va),e(va,Xu),e(w,Yu),e(w,rl),e(rl,ba),e(ba,Ju),e(w,eg),e(w,sl),e(sl,wa),e(wa,tg),e(w,ng),e(w,al),e(al,ka),e(ka,og),e(w,rg),e(w,il),e(il,Ta),e(Ta,sg),e(w,ag),e(w,ll),e(ll,Pa),e(Pa,ig),e(w,lg),e(w,cl),e(cl,ya),e(ya,cg),e(w,dg),e(w,dl),e(dl,xa),e(xa,pg),e(w,mg),e(w,pl),e(pl,$a),e($a,fg),e(w,hg),e(w,ml),e(ml,Ea),e(Ea,ug),e(w,gg),e(w,fl),e(fl,qa),e(qa,_g),e(w,vg),e(w,hl),e(hl,Aa),e(Aa,bg),e(w,wg),e(w,ul),e(ul,Ca),e(Ca,kg),e(w,Tg),e(w,gl),e(gl,za),e(za,Pg),e(w,yg),e(w,_l),e(_l,Da),e(Da,xg),e(w,$g),e(w,vl),e(vl,ja),e(ja,Eg),m(t,_m,p),m(t,Qe,p),e(Qe,Ot),e(Ot,bl),u(uo,bl,null),e(Qe,qg),e(Qe,wl),e(wl,Ag),m(t,vm,p),m(t,Rt,p),e(Rt,Cg),e(Rt,kl),e(kl,zg),e(Rt,Dg),m(t,bm,p),m(t,Ia,p),e(Ia,jg),m(t,wm,p),u(go,t,p),m(t,km,p),m(t,Qt,p),e(Qt,Ig),e(Qt,_o),e(_o,Mg),e(Qt,Sg),m(t,Tm,p),u(vo,t,p),m(t,Pm,p),m(t,Wt,p),e(Wt,Fg),e(Wt,Tl),e(Tl,Lg),e(Wt,Gg),m(t,ym,p),u(bo,t,p),m(t,xm,p),m(t,Ht,p),e(Ht,Ug),e(Ht,Pl),e(Pl,Ng),e(Ht,Og),m(t,$m,p),u(wo,t,p),m(t,Em,p),m(t,Q,p),u(ko,Q,null),e(Q,Rg),e(Q,To),e(To,Qg),e(To,Ma),e(Ma,Wg),e(To,Hg),e(Q,Vg),e(Q,yl),e(yl,Bg),e(Q,Zg),e(Q,We),e(We,Po),e(Po,Kg),e(Po,Sa),e(Sa,Xg),e(Po,Yg),e(We,Jg),e(We,yo),e(yo,e_),e(yo,Fa),e(Fa,t_),e(yo,n_),e(We,o_),e(We,xl),e(xl,r_),e(Q,s_),e(Q,$l),e($l,a_),e(Q,i_),u(xo,Q,null),m(t,qm,p),m(t,He,p),e(He,Vt),e(Vt,El),u($o,El,null),e(He,l_),e(He,ql),e(ql,c_),m(t,Am,p),m(t,be,p),e(be,d_),e(be,Al),e(Al,p_),e(be,m_),e(be,Cl),e(Cl,f_),e(be,h_),e(be,zl),e(zl,u_),e(be,g_),m(t,Cm,p),u(Eo,t,p),m(t,zm,p),u(Bt,t,p),m(t,Dm,p),u(qo,t,p),m(t,jm,p),u(Ao,t,p),m(t,Im,p),m(t,La,p),e(La,__),m(t,Mm,p),u(Co,t,p),m(t,Sm,p),m(t,Zt,p),e(Zt,v_),e(Zt,Dl),e(Dl,b_),e(Zt,w_),m(t,Fm,p),u(zo,t,p),m(t,Lm,p),m(t,Ga,p),e(Ga,k_),m(t,Gm,p),m(t,Ua,p),e(Ua,T_),m(t,Um,p),m(t,le,p),e(le,jl),e(jl,Il),e(Il,Ml),e(Ml,P_),e(le,y_),e(le,Sl),e(Sl,Fl),e(Fl,x_),e(le,$_),e(le,Ll),e(Ll,Gl),e(Gl,E_),e(le,q_),e(le,Do),e(Do,Ul),e(Ul,A_),e(Do,C_),e(Do,Ve),e(Ve,Nl),e(Nl,z_),e(Ve,D_),e(Ve,Ol),e(Ol,j_),e(Ve,I_),e(Ve,Rl),e(Rl,M_),e(le,S_),e(le,Ql),e(Ql,Wl),e(Wl,F_),m(t,Nm,p),m(t,Be,p),e(Be,Kt),e(Kt,Hl),u(jo,Hl,null),e(Be,L_),e(Be,Vl),e(Vl,G_),m(t,Om,p),m(t,Na,p),e(Na,U_),m(t,Rm,p),m(t,Xt,p),e(Xt,N_),e(Xt,Bl),e(Bl,O_),e(Xt,R_),m(t,Qm,p),m(t,Oa,p),e(Oa,Q_),m(t,Wm,p),m(t,Ra,p),e(Ra,Zl),e(Zl,W_),m(t,Hm,p),u(Io,t,p),m(t,Vm,p),m(t,Qa,p),e(Qa,H_),m(t,Bm,p),m(t,Ze,p),e(Ze,Yt),e(Yt,Kl),u(Mo,Kl,null),e(Ze,V_),e(Ze,Xl),e(Xl,B_),m(t,Zm,p),m(t,Wa,p),e(Wa,Ha),e(Ha,Z_),m(t,Km,p),m(t,Ke,p),e(Ke,Jt),e(Jt,Yl),u(So,Yl,null),e(Ke,K_),e(Ke,Jl),e(Jl,X_),m(t,Xm,p),m(t,Xe,p),e(Xe,en),e(en,ec),u(Fo,ec,null),e(Xe,Y_),e(Xe,tc),e(tc,J_),m(t,Ym,p),m(t,ee,p),u(Lo,ee,null),e(ee,ev),e(ee,Go),e(Go,tv),e(Go,nc),e(nc,nv),e(Go,ov),e(ee,rv),e(ee,Ye),e(Ye,sv),e(Ye,Va),e(Va,av),e(Ye,iv),e(Ye,oc),e(oc,lv),e(Ye,cv),e(ee,dv),e(ee,Uo),e(Uo,pv),e(Uo,No),e(No,mv),e(Uo,fv),e(ee,hv),e(ee,tn),u(Oo,tn,null),e(tn,uv),e(tn,Ro),e(Ro,gv),e(Ro,Ba),e(Ba,_v),e(Ro,vv),m(t,Jm,p),m(t,Je,p),e(Je,nn),e(nn,rc),u(Qo,rc,null),e(Je,bv),e(Je,sc),e(sc,wv),m(t,ef,p),m(t,ue,p),u(Wo,ue,null),e(ue,kv),e(ue,ac),e(ac,Tv),e(ue,Pv),e(ue,ic),e(ic,yv),e(ue,xv),e(ue,on),u(Ho,on,null),e(on,$v),e(on,Vo),e(Vo,Ev),e(Vo,Za),e(Za,qv),e(Vo,Av),m(t,tf,p),m(t,et,p),e(et,rn),e(rn,lc),u(Bo,lc,null),e(et,Cv),e(et,cc),e(cc,zv),m(t,nf,p),m(t,z,p),u(Zo,z,null),e(z,Dv),e(z,xe),e(xe,jv),e(xe,Ka),e(Ka,Iv),e(xe,Mv),e(xe,Xa),e(Xa,Sv),e(xe,Fv),e(xe,dc),e(dc,Lv),e(xe,Gv),e(z,Uv),e(z,pc),e(pc,Nv),e(z,Ov),u(Ko,z,null),e(z,Rv),e(z,sn),u(Xo,sn,null),e(sn,Qv),e(sn,Yo),e(Yo,Wv),e(Yo,mc),e(mc,Hv),e(Yo,Vv),e(z,Bv),e(z,an),u(Jo,an,null),e(an,Zv),e(an,fc),e(fc,Kv),e(z,Xv),e(z,qe),u(er,qe,null),e(qe,Yv),e(qe,hc),e(hc,Jv),e(qe,e1),e(qe,ge),e(ge,t1),e(ge,uc),e(uc,n1),e(ge,o1),e(ge,gc),e(gc,r1),e(ge,s1),e(ge,_c),e(_c,a1),e(ge,i1),e(ge,vc),e(vc,l1),e(ge,c1),e(z,d1),e(z,ln),u(tr,ln,null),e(ln,p1),e(ln,$e),e($e,m1),e($e,bc),e(bc,f1),e($e,h1),e($e,wc),e(wc,u1),e($e,g1),e($e,kc),e(kc,_1),e($e,v1),m(t,of,p),m(t,M,p),u(nr,M,null),e(M,b1),e(M,Tc),e(Tc,w1),e(M,k1),e(M,tt),e(tt,T1),e(tt,Ya),e(Ya,P1),e(tt,y1),e(tt,Pc),e(Pc,x1),e(tt,$1),e(M,E1),e(M,_e),e(_e,q1),e(_e,yc),e(yc,A1),e(_e,C1),e(_e,xc),e(xc,z1),e(_e,D1),e(_e,$c),e($c,j1),e(_e,I1),e(_e,or),e(or,M1),e(_e,S1),e(M,F1),e(M,Ec),e(Ec,L1),e(M,G1),u(rr,M,null),e(M,U1),e(M,cn),u(sr,cn,null),e(cn,N1),e(cn,qc),e(qc,O1),m(t,rf,p),m(t,nt,p),e(nt,dn),e(dn,Ac),u(ar,Ac,null),e(nt,R1),e(nt,Cc),e(Cc,Q1),m(t,sf,p),m(t,te,p),u(ir,te,null),e(te,W1),e(te,zc),e(zc,H1),e(te,V1),e(te,ot),e(ot,B1),e(ot,Ja),e(Ja,Z1),e(ot,K1),e(ot,Dc),e(Dc,X1),e(ot,Y1),e(te,J1),e(te,lr),e(lr,eb),e(lr,cr),e(cr,tb),e(lr,nb),e(te,ob),e(te,pn),u(dr,pn,null),e(pn,rb),e(pn,jc),e(jc,sb),m(t,af,p),m(t,rt,p),e(rt,mn),e(mn,Ic),u(pr,Ic,null),e(rt,ab),e(rt,Mc),e(Mc,ib),m(t,lf,p),m(t,W,p),u(mr,W,null),e(W,lb),e(W,st),e(st,cb),e(st,Sc),e(Sc,db),e(st,pb),e(st,ei),e(ei,mb),e(st,fb),e(W,hb),e(W,at),e(at,ub),e(at,ti),e(ti,gb),e(at,_b),e(at,Fc),e(Fc,vb),e(at,bb),e(W,wb),e(W,fr),e(fr,kb),e(fr,hr),e(hr,Tb),e(fr,Pb),e(W,yb),u(fn,W,null),e(W,xb),e(W,hn),u(ur,hn,null),e(hn,$b),e(hn,Lc),e(Lc,Eb),m(t,cf,p),m(t,it,p),e(it,un),e(un,Gc),u(gr,Gc,null),e(it,qb),e(it,Uc),e(Uc,Ab),m(t,df,p),m(t,ne,p),u(_r,ne,null),e(ne,Cb),e(ne,vr),e(vr,zb),e(vr,Nc),e(Nc,Db),e(vr,jb),e(ne,Ib),e(ne,lt),e(lt,Mb),e(lt,ni),e(ni,Sb),e(lt,Fb),e(lt,Oc),e(Oc,Lb),e(lt,Gb),e(ne,Ub),e(ne,br),e(br,Nb),e(br,wr),e(wr,Ob),e(br,Rb),e(ne,Qb),e(ne,gn),u(kr,gn,null),e(gn,Wb),e(gn,Rc),e(Rc,Hb),m(t,pf,p),m(t,ct,p),e(ct,_n),e(_n,Qc),u(Tr,Qc,null),e(ct,Vb),e(ct,Wc),e(Wc,Bb),m(t,mf,p),m(t,oe,p),u(Pr,oe,null),e(oe,Zb),e(oe,yr),e(yr,Kb),e(yr,Hc),e(Hc,Xb),e(yr,Yb),e(oe,Jb),e(oe,dt),e(dt,ew),e(dt,oi),e(oi,tw),e(dt,nw),e(dt,Vc),e(Vc,ow),e(dt,rw),e(oe,sw),e(oe,xr),e(xr,aw),e(xr,$r),e($r,iw),e(xr,lw),e(oe,cw),e(oe,vn),u(Er,vn,null),e(vn,dw),e(vn,Bc),e(Bc,pw),m(t,ff,p),m(t,pt,p),e(pt,bn),e(bn,Zc),u(qr,Zc,null),e(pt,mw),e(pt,Kc),e(Kc,fw),m(t,hf,p),m(t,D,p),u(Ar,D,null),e(D,hw),e(D,mt),e(mt,uw),e(mt,Xc),e(Xc,gw),e(mt,_w),e(mt,ri),e(ri,vw),e(mt,bw),e(D,ww),e(D,ft),e(ft,kw),e(ft,si),e(si,Tw),e(ft,Pw),e(ft,Yc),e(Yc,yw),e(ft,xw),e(D,$w),e(D,Cr),e(Cr,Ew),e(Cr,zr),e(zr,qw),e(Cr,Aw),e(D,Cw),e(D,Ae),u(Dr,Ae,null),e(Ae,zw),e(Ae,Jc),e(Jc,Dw),e(Ae,jw),e(Ae,ed),e(ed,Iw),e(D,Mw),e(D,wn),u(jr,wn,null),e(wn,Sw),e(wn,td),e(td,Fw),e(D,Lw),e(D,kn),u(Ir,kn,null),e(kn,Gw),e(kn,nd),e(nd,Uw),e(D,Nw),e(D,Tn),u(Mr,Tn,null),e(Tn,Ow),e(Tn,od),e(od,Rw),m(t,uf,p),m(t,Pn,p),e(Pn,Qw),e(Pn,ai),e(ai,Ww),e(Pn,Hw),m(t,gf,p),m(t,ht,p),e(ht,yn),e(yn,rd),u(Sr,rd,null),e(ht,Vw),e(ht,sd),e(sd,Bw),m(t,_f,p),m(t,re,p),u(Fr,re,null),e(re,Zw),e(re,Lr),e(Lr,Kw),e(Lr,ad),e(ad,Xw),e(Lr,Yw),e(re,Jw),e(re,ut),e(ut,e4),e(ut,ii),e(ii,t4),e(ut,n4),e(ut,id),e(id,o4),e(ut,r4),e(re,s4),e(re,Gr),e(Gr,a4),e(Gr,Ur),e(Ur,i4),e(Gr,l4),e(re,c4),e(re,xn),u(Nr,xn,null),e(xn,d4),e(xn,ld),e(ld,p4),m(t,vf,p),m(t,gt,p),e(gt,$n),e($n,cd),u(Or,cd,null),e(gt,m4),e(gt,dd),e(dd,f4),m(t,bf,p),m(t,j,p),u(Rr,j,null),e(j,h4),e(j,_t),e(_t,u4),e(_t,pd),e(pd,g4),e(_t,_4),e(_t,li),e(li,v4),e(_t,b4),e(j,w4),e(j,vt),e(vt,k4),e(vt,ci),e(ci,T4),e(vt,P4),e(vt,md),e(md,y4),e(vt,x4),e(j,$4),e(j,Qr),e(Qr,E4),e(Qr,Wr),e(Wr,q4),e(Qr,A4),e(j,C4),e(j,En),u(Hr,En,null),e(En,z4),e(En,fd),e(fd,D4),e(j,j4),e(j,Ce),u(Vr,Ce,null),e(Ce,I4),e(Ce,bt),e(bt,M4),e(bt,hd),e(hd,S4),e(bt,F4),e(bt,ud),e(ud,L4),e(bt,G4),e(Ce,U4),e(Ce,gd),e(gd,N4),e(j,O4),e(j,ze),u(Br,ze,null),e(ze,R4),e(ze,Zr),e(Zr,Q4),e(Zr,_d),e(_d,W4),e(Zr,H4),e(ze,V4),e(ze,vd),e(vd,B4),e(j,Z4),e(j,qn),u(Kr,qn,null),e(qn,K4),e(qn,bd),e(bd,X4),m(t,wf,p),m(t,wt,p),e(wt,An),e(An,wd),u(Xr,wd,null),e(wt,Y4),e(wt,kd),e(kd,J4),m(t,kf,p),m(t,S,p),u(Yr,S,null),e(S,ek),e(S,Td),e(Td,tk),e(S,nk),e(S,kt),e(kt,ok),e(kt,di),e(di,rk),e(kt,sk),e(kt,Pd),e(Pd,ak),e(kt,ik),e(S,lk),e(S,F),e(F,ck),e(F,yd),e(yd,dk),e(F,pk),e(F,xd),e(xd,mk),e(F,fk),e(F,$d),e($d,hk),e(F,uk),e(F,Ed),e(Ed,gk),e(F,_k),e(F,qd),e(qd,vk),e(F,bk),e(F,Ad),e(Ad,wk),e(F,kk),e(F,Jr),e(Jr,Tk),e(F,Pk),e(S,yk),e(S,Cd),e(Cd,xk),e(S,$k),u(es,S,null),e(S,Ek),e(S,Cn),u(ts,Cn,null),e(Cn,qk),e(Cn,zd),e(zd,Ak),m(t,Tf,p),m(t,Tt,p),e(Tt,zn),e(zn,Dd),u(ns,Dd,null),e(Tt,Ck),e(Tt,jd),e(jd,zk),m(t,Pf,p),m(t,se,p),u(os,se,null),e(se,Dk),e(se,rs),e(rs,jk),e(rs,Id),e(Id,Ik),e(rs,Mk),e(se,Sk),e(se,Pt),e(Pt,Fk),e(Pt,pi),e(pi,Lk),e(Pt,Gk),e(Pt,Md),e(Md,Uk),e(Pt,Nk),e(se,Ok),e(se,ss),e(ss,Rk),e(ss,as),e(as,Qk),e(ss,Wk),e(se,Hk),e(se,C),u(is,C,null),e(C,Vk),e(C,Sd),e(Sd,Bk),e(C,Zk),e(C,H),e(H,Fd),e(Fd,Ld),e(Ld,Kk),e(H,Xk),e(H,Gd),e(Gd,Ud),e(Ud,Yk),e(H,Jk),e(H,Nd),e(Nd,Od),e(Od,eT),e(H,tT),e(H,Rd),e(Rd,Qd),e(Qd,nT),e(H,oT),e(H,Wd),e(Wd,Hd),e(Hd,rT),e(H,sT),e(H,Vd),e(Vd,Bd),e(Bd,aT),e(H,iT),e(H,Zd),e(Zd,Kd),e(Kd,lT),e(C,cT),e(C,ls),e(ls,dT),e(ls,Xd),e(Xd,pT),e(ls,mT),e(C,fT),e(C,Yd),e(Yd,hT),e(C,uT),u(cs,C,null),e(C,gT),e(C,Jd),e(Jd,_T),e(C,vT),e(C,ep),e(ep,bT),e(C,wT),u(ds,C,null),m(t,yf,p),m(t,yt,p),e(yt,Dn),e(Dn,tp),u(ps,tp,null),e(yt,kT),e(yt,np),e(np,TT),m(t,xf,p),m(t,V,p),u(ms,V,null),e(V,PT),e(V,xt),e(xt,yT),e(xt,op),e(op,xT),e(xt,$T),e(xt,mi),e(mi,ET),e(xt,qT),e(V,AT),e(V,$t),e($t,CT),e($t,fi),e(fi,zT),e($t,DT),e($t,rp),e(rp,jT),e($t,IT),e(V,MT),e(V,fs),e(fs,ST),e(fs,sp),e(sp,FT),e(fs,LT),e(V,GT),e(V,hs),e(hs,UT),e(hs,us),e(us,NT),e(hs,OT),e(V,RT),e(V,jn),u(gs,jn,null),e(jn,QT),e(jn,ap),e(ap,WT),m(t,$f,p),m(t,Et,p),e(Et,In),e(In,ip),u(_s,ip,null),e(Et,HT),e(Et,lp),e(lp,VT),m(t,Ef,p),m(t,ae,p),u(vs,ae,null),e(ae,BT),e(ae,bs),e(bs,ZT),e(bs,cp),e(cp,KT),e(bs,XT),e(ae,YT),e(ae,qt),e(qt,JT),e(qt,hi),e(hi,eP),e(qt,tP),e(qt,dp),e(dp,nP),e(qt,oP),e(ae,rP),e(ae,ws),e(ws,sP),e(ws,ks),e(ks,aP),e(ws,iP),e(ae,lP),e(ae,Mn),u(Ts,Mn,null),e(Mn,cP),e(Mn,pp),e(pp,dP),m(t,qf,p),m(t,At,p),e(At,Sn),e(Sn,mp),u(Ps,mp,null),e(At,pP),e(At,fp),e(fp,mP),m(t,Af,p),m(t,I,p),u(ys,I,null),e(I,fP),e(I,hp),e(hp,hP),e(I,uP),e(I,Ct),e(Ct,gP),e(Ct,ui),e(ui,_P),e(Ct,vP),e(Ct,up),e(up,bP),e(Ct,wP),e(I,kP),e(I,xs),e(xs,TP),e(xs,$s),e($s,PP),e(xs,yP),e(I,xP),e(I,gp),e(gp,$P),e(I,EP),u(Es,I,null),e(I,qP),e(I,Fn),u(qs,Fn,null),e(Fn,AP),e(Fn,_p),e(_p,CP),e(I,zP),e(I,Ln),u(As,Ln,null),e(Ln,DP),e(Ln,vp),e(vp,jP),m(t,Cf,p),m(t,zt,p),e(zt,Gn),e(Gn,bp),u(Cs,bp,null),e(zt,IP),e(zt,wp),e(wp,MP),m(t,zf,p),m(t,q,p),u(zs,q,null),e(q,SP),e(q,Dt),e(Dt,FP),e(Dt,kp),e(kp,LP),e(Dt,GP),e(Dt,gi),e(gi,UP),e(Dt,NP),e(q,OP),e(q,jt),e(jt,RP),e(jt,_i),e(_i,QP),e(jt,WP),e(jt,Tp),e(Tp,HP),e(jt,VP),e(q,BP),e(q,Ds),e(Ds,ZP),e(Ds,js),e(js,KP),e(Ds,XP),e(q,YP),e(q,Un),u(Is,Un,null),e(Un,JP),e(Un,Pp),e(Pp,ey),e(q,ty),e(q,De),u(Ms,De,null),e(De,ny),e(De,yp),e(yp,oy),e(De,ry),e(De,xp),e(xp,sy),e(q,ay),e(q,Nn),u(Ss,Nn,null),e(Nn,iy),e(Nn,$p),e($p,ly),e(q,cy),e(q,On),u(Fs,On,null),e(On,dy),e(On,Ep),e(Ep,py),e(q,my),e(q,Rn),u(Ls,Rn,null),e(Rn,fy),e(Rn,qp),e(qp,hy),m(t,Df,p),m(t,It,p),e(It,Qn),e(Qn,Ap),u(Gs,Ap,null),e(It,uy),e(It,Cp),e(Cp,gy),m(t,jf,p),m(t,L,p),u(Us,L,null),e(L,_y),e(L,zp),e(zp,vy),e(L,by),e(L,Mt),e(Mt,wy),e(Mt,vi),e(vi,ky),e(Mt,Ty),e(Mt,Dp),e(Dp,Py),e(Mt,yy),e(L,xy),e(L,Ns),e(Ns,$y),e(Ns,Os),e(Os,Ey),e(Ns,qy),e(L,Ay),e(L,jp),e(jp,Cy),e(L,zy),u(Rs,L,null),e(L,Dy),e(L,Wn),u(Qs,Wn,null),e(Wn,jy),e(Wn,Ip),e(Ip,Iy),m(t,If,p),m(t,St,p),e(St,Hn),e(Hn,Mp),u(Ws,Mp,null),e(St,My),e(St,Sp),e(Sp,Sy),m(t,Mf,p),m(t,B,p),u(Hs,B,null),e(B,Fy),e(B,Vs),e(Vs,Ly),e(Vs,Fp),e(Fp,Gy),e(Vs,Uy),e(B,Ny),e(B,Ee),e(Ee,Oy),e(Ee,Lp),e(Lp,Ry),e(Ee,Qy),e(Ee,Gp),e(Gp,Wy),e(Ee,Hy),e(Ee,Up),e(Up,Vy),e(Ee,By),e(B,Zy),e(B,Ft),e(Ft,Ky),e(Ft,bi),e(bi,Xy),e(Ft,Yy),e(Ft,Np),e(Np,Jy),e(Ft,e2),e(B,t2),e(B,Bs),e(Bs,n2),e(Bs,Zs),e(Zs,o2),e(Bs,r2),e(B,s2),e(B,Vn),u(Ks,Vn,null),e(Vn,a2),e(Vn,Xs),e(Xs,i2),e(Xs,wi),e(wi,l2),e(Xs,c2),m(t,Sf,p),m(t,Lt,p),e(Lt,Bn),e(Bn,Op),u(Ys,Op,null),e(Lt,d2),e(Lt,ki),e(ki,p2),e(ki,Rp),e(Rp,m2),m(t,Ff,p),m(t,T,p),u(Js,T,null),e(T,f2),e(T,Qp),e(Qp,h2),e(T,u2),e(T,Wp),e(Wp,g2),e(T,_2),e(T,Hp),e(Hp,v2),e(T,b2),e(T,Vp),e(Vp,w2),e(T,k2),e(T,ve),e(ve,T2),e(ve,Ti),e(Ti,P2),e(ve,y2),e(ve,Bp),e(Bp,x2),e(ve,$2),e(ve,Zp),e(Zp,E2),e(ve,q2),e(ve,Kp),e(Kp,A2),e(ve,C2),e(T,z2),e(T,Zn),u(ea,Zn,null),e(Zn,D2),e(Zn,Xp),e(Xp,j2),e(T,I2),e(T,G),u(ta,G,null),e(G,M2),e(G,Yp),e(Yp,S2),e(G,F2),e(G,Jp),e(Jp,L2),e(G,G2),e(G,Kn),e(Kn,Xn),e(Xn,em),u(na,em,null),e(Kn,U2),e(Kn,tm),e(tm,N2),e(G,O2),e(G,nm),e(nm,R2),e(G,Q2),e(G,Yn),e(Yn,Jn),e(Jn,om),u(oa,om,null),e(Yn,W2),e(Yn,rm),e(rm,H2),e(G,V2),e(G,sm),e(sm,B2),e(T,Z2),e(T,eo),u(ra,eo,null),e(eo,K2),e(eo,am),e(am,X2),e(T,Y2),e(T,to),u(sa,to,null),e(to,J2),e(to,aa),e(aa,e0),e(aa,im),e(im,t0),e(aa,n0),e(T,o0),e(T,no),u(ia,no,null),e(no,r0),e(no,la),e(la,s0),e(la,lm),e(lm,a0),e(la,i0),e(T,l0),e(T,oo),u(ca,oo,null),e(oo,c0),e(oo,Gt),e(Gt,d0),e(Gt,cm),e(cm,p0),e(Gt,m0),e(Gt,dm),e(dm,f0),e(Gt,h0),e(T,u0),e(T,ro),u(da,ro,null),e(ro,g0),e(ro,pm),e(pm,_0),e(T,v0),e(T,so),u(pa,so,null),e(so,b0),e(so,ma),e(ma,w0),e(ma,mm),e(mm,k0),e(ma,T0),Lf=!0},p(t,[p]){const fa={};p&2&&(fa.$$scope={dirty:p,ctx:t}),Bt.$set(fa);const fm={};p&2&&(fm.$$scope={dirty:p,ctx:t}),fn.$set(fm)},i(t){Lf||(g(E.$$.fragment,t),g(uo.$$.fragment,t),g(go.$$.fragment,t),g(vo.$$.fragment,t),g(bo.$$.fragment,t),g(wo.$$.fragment,t),g(ko.$$.fragment,t),g(xo.$$.fragment,t),g($o.$$.fragment,t),g(Eo.$$.fragment,t),g(Bt.$$.fragment,t),g(qo.$$.fragment,t),g(Ao.$$.fragment,t),g(Co.$$.fragment,t),g(zo.$$.fragment,t),g(jo.$$.fragment,t),g(Io.$$.fragment,t),g(Mo.$$.fragment,t),g(So.$$.fragment,t),g(Fo.$$.fragment,t),g(Lo.$$.fragment,t),g(Oo.$$.fragment,t),g(Qo.$$.fragment,t),g(Wo.$$.fragment,t),g(Ho.$$.fragment,t),g(Bo.$$.fragment,t),g(Zo.$$.fragment,t),g(Ko.$$.fragment,t),g(Xo.$$.fragment,t),g(Jo.$$.fragment,t),g(er.$$.fragment,t),g(tr.$$.fragment,t),g(nr.$$.fragment,t),g(rr.$$.fragment,t),g(sr.$$.fragment,t),g(ar.$$.fragment,t),g(ir.$$.fragment,t),g(dr.$$.fragment,t),g(pr.$$.fragment,t),g(mr.$$.fragment,t),g(fn.$$.fragment,t),g(ur.$$.fragment,t),g(gr.$$.fragment,t),g(_r.$$.fragment,t),g(kr.$$.fragment,t),g(Tr.$$.fragment,t),g(Pr.$$.fragment,t),g(Er.$$.fragment,t),g(qr.$$.fragment,t),g(Ar.$$.fragment,t),g(Dr.$$.fragment,t),g(jr.$$.fragment,t),g(Ir.$$.fragment,t),g(Mr.$$.fragment,t),g(Sr.$$.fragment,t),g(Fr.$$.fragment,t),g(Nr.$$.fragment,t),g(Or.$$.fragment,t),g(Rr.$$.fragment,t),g(Hr.$$.fragment,t),g(Vr.$$.fragment,t),g(Br.$$.fragment,t),g(Kr.$$.fragment,t),g(Xr.$$.fragment,t),g(Yr.$$.fragment,t),g(es.$$.fragment,t),g(ts.$$.fragment,t),g(ns.$$.fragment,t),g(os.$$.fragment,t),g(is.$$.fragment,t),g(cs.$$.fragment,t),g(ds.$$.fragment,t),g(ps.$$.fragment,t),g(ms.$$.fragment,t),g(gs.$$.fragment,t),g(_s.$$.fragment,t),g(vs.$$.fragment,t),g(Ts.$$.fragment,t),g(Ps.$$.fragment,t),g(ys.$$.fragment,t),g(Es.$$.fragment,t),g(qs.$$.fragment,t),g(As.$$.fragment,t),g(Cs.$$.fragment,t),g(zs.$$.fragment,t),g(Is.$$.fragment,t),g(Ms.$$.fragment,t),g(Ss.$$.fragment,t),g(Fs.$$.fragment,t),g(Ls.$$.fragment,t),g(Gs.$$.fragment,t),g(Us.$$.fragment,t),g(Rs.$$.fragment,t),g(Qs.$$.fragment,t),g(Ws.$$.fragment,t),g(Hs.$$.fragment,t),g(Ks.$$.fragment,t),g(Ys.$$.fragment,t),g(Js.$$.fragment,t),g(ea.$$.fragment,t),g(ta.$$.fragment,t),g(na.$$.fragment,t),g(oa.$$.fragment,t),g(ra.$$.fragment,t),g(sa.$$.fragment,t),g(ia.$$.fragment,t),g(ca.$$.fragment,t),g(da.$$.fragment,t),g(pa.$$.fragment,t),Lf=!0)},o(t){_(E.$$.fragment,t),_(uo.$$.fragment,t),_(go.$$.fragment,t),_(vo.$$.fragment,t),_(bo.$$.fragment,t),_(wo.$$.fragment,t),_(ko.$$.fragment,t),_(xo.$$.fragment,t),_($o.$$.fragment,t),_(Eo.$$.fragment,t),_(Bt.$$.fragment,t),_(qo.$$.fragment,t),_(Ao.$$.fragment,t),_(Co.$$.fragment,t),_(zo.$$.fragment,t),_(jo.$$.fragment,t),_(Io.$$.fragment,t),_(Mo.$$.fragment,t),_(So.$$.fragment,t),_(Fo.$$.fragment,t),_(Lo.$$.fragment,t),_(Oo.$$.fragment,t),_(Qo.$$.fragment,t),_(Wo.$$.fragment,t),_(Ho.$$.fragment,t),_(Bo.$$.fragment,t),_(Zo.$$.fragment,t),_(Ko.$$.fragment,t),_(Xo.$$.fragment,t),_(Jo.$$.fragment,t),_(er.$$.fragment,t),_(tr.$$.fragment,t),_(nr.$$.fragment,t),_(rr.$$.fragment,t),_(sr.$$.fragment,t),_(ar.$$.fragment,t),_(ir.$$.fragment,t),_(dr.$$.fragment,t),_(pr.$$.fragment,t),_(mr.$$.fragment,t),_(fn.$$.fragment,t),_(ur.$$.fragment,t),_(gr.$$.fragment,t),_(_r.$$.fragment,t),_(kr.$$.fragment,t),_(Tr.$$.fragment,t),_(Pr.$$.fragment,t),_(Er.$$.fragment,t),_(qr.$$.fragment,t),_(Ar.$$.fragment,t),_(Dr.$$.fragment,t),_(jr.$$.fragment,t),_(Ir.$$.fragment,t),_(Mr.$$.fragment,t),_(Sr.$$.fragment,t),_(Fr.$$.fragment,t),_(Nr.$$.fragment,t),_(Or.$$.fragment,t),_(Rr.$$.fragment,t),_(Hr.$$.fragment,t),_(Vr.$$.fragment,t),_(Br.$$.fragment,t),_(Kr.$$.fragment,t),_(Xr.$$.fragment,t),_(Yr.$$.fragment,t),_(es.$$.fragment,t),_(ts.$$.fragment,t),_(ns.$$.fragment,t),_(os.$$.fragment,t),_(is.$$.fragment,t),_(cs.$$.fragment,t),_(ds.$$.fragment,t),_(ps.$$.fragment,t),_(ms.$$.fragment,t),_(gs.$$.fragment,t),_(_s.$$.fragment,t),_(vs.$$.fragment,t),_(Ts.$$.fragment,t),_(Ps.$$.fragment,t),_(ys.$$.fragment,t),_(Es.$$.fragment,t),_(qs.$$.fragment,t),_(As.$$.fragment,t),_(Cs.$$.fragment,t),_(zs.$$.fragment,t),_(Is.$$.fragment,t),_(Ms.$$.fragment,t),_(Ss.$$.fragment,t),_(Fs.$$.fragment,t),_(Ls.$$.fragment,t),_(Gs.$$.fragment,t),_(Us.$$.fragment,t),_(Rs.$$.fragment,t),_(Qs.$$.fragment,t),_(Ws.$$.fragment,t),_(Hs.$$.fragment,t),_(Ks.$$.fragment,t),_(Ys.$$.fragment,t),_(Js.$$.fragment,t),_(ea.$$.fragment,t),_(ta.$$.fragment,t),_(na.$$.fragment,t),_(oa.$$.fragment,t),_(ra.$$.fragment,t),_(sa.$$.fragment,t),_(ia.$$.fragment,t),_(ca.$$.fragment,t),_(da.$$.fragment,t),_(pa.$$.fragment,t),Lf=!1},d(t){n(x),t&&n(ie),t&&n($),v(E),t&&n(hm),t&&n(Ut),t&&n(um),t&&n(ua),t&&n(gm),t&&n(Nt),t&&n(_m),t&&n(Qe),v(uo),t&&n(vm),t&&n(Rt),t&&n(bm),t&&n(Ia),t&&n(wm),v(go,t),t&&n(km),t&&n(Qt),t&&n(Tm),v(vo,t),t&&n(Pm),t&&n(Wt),t&&n(ym),v(bo,t),t&&n(xm),t&&n(Ht),t&&n($m),v(wo,t),t&&n(Em),t&&n(Q),v(ko),v(xo),t&&n(qm),t&&n(He),v($o),t&&n(Am),t&&n(be),t&&n(Cm),v(Eo,t),t&&n(zm),v(Bt,t),t&&n(Dm),v(qo,t),t&&n(jm),v(Ao,t),t&&n(Im),t&&n(La),t&&n(Mm),v(Co,t),t&&n(Sm),t&&n(Zt),t&&n(Fm),v(zo,t),t&&n(Lm),t&&n(Ga),t&&n(Gm),t&&n(Ua),t&&n(Um),t&&n(le),t&&n(Nm),t&&n(Be),v(jo),t&&n(Om),t&&n(Na),t&&n(Rm),t&&n(Xt),t&&n(Qm),t&&n(Oa),t&&n(Wm),t&&n(Ra),t&&n(Hm),v(Io,t),t&&n(Vm),t&&n(Qa),t&&n(Bm),t&&n(Ze),v(Mo),t&&n(Zm),t&&n(Wa),t&&n(Km),t&&n(Ke),v(So),t&&n(Xm),t&&n(Xe),v(Fo),t&&n(Ym),t&&n(ee),v(Lo),v(Oo),t&&n(Jm),t&&n(Je),v(Qo),t&&n(ef),t&&n(ue),v(Wo),v(Ho),t&&n(tf),t&&n(et),v(Bo),t&&n(nf),t&&n(z),v(Zo),v(Ko),v(Xo),v(Jo),v(er),v(tr),t&&n(of),t&&n(M),v(nr),v(rr),v(sr),t&&n(rf),t&&n(nt),v(ar),t&&n(sf),t&&n(te),v(ir),v(dr),t&&n(af),t&&n(rt),v(pr),t&&n(lf),t&&n(W),v(mr),v(fn),v(ur),t&&n(cf),t&&n(it),v(gr),t&&n(df),t&&n(ne),v(_r),v(kr),t&&n(pf),t&&n(ct),v(Tr),t&&n(mf),t&&n(oe),v(Pr),v(Er),t&&n(ff),t&&n(pt),v(qr),t&&n(hf),t&&n(D),v(Ar),v(Dr),v(jr),v(Ir),v(Mr),t&&n(uf),t&&n(Pn),t&&n(gf),t&&n(ht),v(Sr),t&&n(_f),t&&n(re),v(Fr),v(Nr),t&&n(vf),t&&n(gt),v(Or),t&&n(bf),t&&n(j),v(Rr),v(Hr),v(Vr),v(Br),v(Kr),t&&n(wf),t&&n(wt),v(Xr),t&&n(kf),t&&n(S),v(Yr),v(es),v(ts),t&&n(Tf),t&&n(Tt),v(ns),t&&n(Pf),t&&n(se),v(os),v(is),v(cs),v(ds),t&&n(yf),t&&n(yt),v(ps),t&&n(xf),t&&n(V),v(ms),v(gs),t&&n($f),t&&n(Et),v(_s),t&&n(Ef),t&&n(ae),v(vs),v(Ts),t&&n(qf),t&&n(At),v(Ps),t&&n(Af),t&&n(I),v(ys),v(Es),v(qs),v(As),t&&n(Cf),t&&n(zt),v(Cs),t&&n(zf),t&&n(q),v(zs),v(Is),v(Ms),v(Ss),v(Fs),v(Ls),t&&n(Df),t&&n(It),v(Gs),t&&n(jf),t&&n(L),v(Us),v(Rs),v(Qs),t&&n(If),t&&n(St),v(Ws),t&&n(Mf),t&&n(B),v(Hs),v(Ks),t&&n(Sf),t&&n(Lt),v(Ys),t&&n(Ff),t&&n(T),v(Js),v(ea),v(ta),v(na),v(oa),v(ra),v(sa),v(ia),v(ca),v(da),v(pa)}}}const Wq={local:"pipelines",sections:[{local:"transformers.pipeline",title:"The pipeline abstraction"},{local:"pipeline-batching",title:"Pipeline batching"},{local:"pipeline-custom-code",title:"Pipeline custom code"},{local:"implementing-a-pipeline",title:"Implementing a pipeline"},{local:"the-task-specific-pipelines",sections:[{local:"transformers.AudioClassificationPipeline",title:"AudioClassificationPipeline"},{local:"transformers.AutomaticSpeechRecognitionPipeline",title:"AutomaticSpeechRecognitionPipeline"},{local:"transformers.Conversation",title:"ConversationalPipeline"},{local:"transformers.FeatureExtractionPipeline",title:"FeatureExtractionPipeline"},{local:"transformers.FillMaskPipeline",title:"FillMaskPipeline"},{local:"transformers.ImageClassificationPipeline",title:"ImageClassificationPipeline"},{local:"transformers.ImageSegmentationPipeline",title:"ImageSegmentationPipeline"},{local:"transformers.TokenClassificationPipeline",title:"NerPipeline"},{local:"transformers.ObjectDetectionPipeline",title:"ObjectDetectionPipeline"},{local:"transformers.QuestionAnsweringPipeline",title:"QuestionAnsweringPipeline"},{local:"transformers.SummarizationPipeline",title:"SummarizationPipeline"},{local:"transformers.TableQuestionAnsweringPipeline",title:"TableQuestionAnsweringPipeline"},{local:"transformers.TextClassificationPipeline",title:"TextClassificationPipeline"},{local:"transformers.TextGenerationPipeline",title:"TextGenerationPipeline"},{local:"transformers.Text2TextGenerationPipeline",title:"Text2TextGenerationPipeline"},{local:"transformers.TokenClassificationPipeline",title:"TokenClassificationPipeline"},{local:"transformers.TranslationPipeline",title:"TranslationPipeline"},{local:"transformers.ZeroShotClassificationPipeline",title:"ZeroShotClassificationPipeline"}],title:"The task specific pipelines"},{local:"transformers.Pipeline",title:"Parent class: `Pipeline`"}],title:"Pipelines"};function Hq(mo,x,ie){let{fw:$}=x;return mo.$$set=A=>{"fw"in A&&ie(0,$=A.fw)},[$]}class Jq extends Lq{constructor(x){super();Gq(this,x,Hq,Qq,Uq,{fw:0})}}export{Jq as default,Wq as metadata};
