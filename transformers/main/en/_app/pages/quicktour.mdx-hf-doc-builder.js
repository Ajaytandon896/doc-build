import{S as zg,i as xg,s as Pg,e as l,k as f,w as k,t as s,M as Fg,c as i,d as a,m as c,a as p,x as w,h as r,b as h,G as e,g as m,y,q as b,o as T,B as E,v as Mg,L as we}from"../chunks/vendor-hf-doc-builder.js";import{T as jn}from"../chunks/Tip-hf-doc-builder.js";import{Y as qg}from"../chunks/Youtube-hf-doc-builder.js";import{I as Ne}from"../chunks/IconCopyLink-hf-doc-builder.js";import{C as I}from"../chunks/CodeBlock-hf-doc-builder.js";import{D as Cg}from"../chunks/DocNotebookDropdown-hf-doc-builder.js";import{F as cs,M as me}from"../chunks/Markdown-hf-doc-builder.js";function Sg(P){let o,d;return o=new I({props:{code:"pip install torch",highlighted:"pip install torch"}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p:we,i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function Dg(P){let o,d;return o=new me({props:{$$slots:{default:[Sg]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function Og(P){let o,d;return o=new I({props:{code:"pip install tensorflow",highlighted:"pip install tensorflow"}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p:we,i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function Ng(P){let o,d;return o=new me({props:{$$slots:{default:[Og]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function Ig(P){let o,d,n,$,_,v,q,F,g,j,S,N,O,W;return O=new I({props:{code:`from transformers import AutoTokenizer, AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(model_name)
tokenizer = AutoTokenizer.from_pretrained(model_name)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = AutoModelForSequenceClassification.from_pretrained(model_name)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(model_name)`}}),{c(){o=l("p"),d=s("Use "),n=l("a"),$=s("AutoModelForSequenceClassification"),_=s(" and "),v=l("a"),q=s("AutoTokenizer"),F=s(" to load the pretrained model and it\u2019s associated tokenizer (more on an "),g=l("code"),j=s("AutoClass"),S=s(" in the next section):"),N=f(),k(O.$$.fragment),this.h()},l(z){o=i(z,"P",{});var C=p(o);d=r(C,"Use "),n=i(C,"A",{href:!0});var A=p(n);$=r(A,"AutoModelForSequenceClassification"),A.forEach(a),_=r(C," and "),v=i(C,"A",{href:!0});var D=p(v);q=r(D,"AutoTokenizer"),D.forEach(a),F=r(C," to load the pretrained model and it\u2019s associated tokenizer (more on an "),g=i(C,"CODE",{});var G=p(g);j=r(G,"AutoClass"),G.forEach(a),S=r(C," in the next section):"),C.forEach(a),N=c(z),w(O.$$.fragment,z),this.h()},h(){h(n,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModelForSequenceClassification"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoTokenizer")},m(z,C){m(z,o,C),e(o,d),e(o,n),e(n,$),e(o,_),e(o,v),e(v,q),e(o,F),e(o,g),e(g,j),e(o,S),m(z,N,C),y(O,z,C),W=!0},p:we,i(z){W||(b(O.$$.fragment,z),W=!0)},o(z){T(O.$$.fragment,z),W=!1},d(z){z&&a(o),z&&a(N),E(O,z)}}}function Lg(P){let o,d;return o=new me({props:{$$slots:{default:[Ig]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function Hg(P){let o,d,n,$,_,v,q,F,g,j,S,N,O,W;return O=new I({props:{code:`from transformers import AutoTokenizer, TFAutoModelForSequenceClassification

model = TFAutoModelForSequenceClassification.from_pretrained(model_name)
tokenizer = AutoTokenizer.from_pretrained(model_name)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, TFAutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFAutoModelForSequenceClassification.from_pretrained(model_name)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(model_name)`}}),{c(){o=l("p"),d=s("Use "),n=l("a"),$=s("TFAutoModelForSequenceClassification"),_=s(" and "),v=l("a"),q=s("AutoTokenizer"),F=s(" to load the pretrained model and it\u2019s associated tokenizer (more on an "),g=l("code"),j=s("TFAutoClass"),S=s(" in the next section):"),N=f(),k(O.$$.fragment),this.h()},l(z){o=i(z,"P",{});var C=p(o);d=r(C,"Use "),n=i(C,"A",{href:!0});var A=p(n);$=r(A,"TFAutoModelForSequenceClassification"),A.forEach(a),_=r(C," and "),v=i(C,"A",{href:!0});var D=p(v);q=r(D,"AutoTokenizer"),D.forEach(a),F=r(C," to load the pretrained model and it\u2019s associated tokenizer (more on an "),g=i(C,"CODE",{});var G=p(g);j=r(G,"TFAutoClass"),G.forEach(a),S=r(C," in the next section):"),C.forEach(a),N=c(z),w(O.$$.fragment,z),this.h()},h(){h(n,"href","/docs/transformers/main/en/model_doc/auto#transformers.TFAutoModelForSequenceClassification"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoTokenizer")},m(z,C){m(z,o,C),e(o,d),e(o,n),e(n,$),e(o,_),e(o,v),e(v,q),e(o,F),e(o,g),e(g,j),e(o,S),m(z,N,C),y(O,z,C),W=!0},p:we,i(z){W||(b(O.$$.fragment,z),W=!0)},o(z){T(O.$$.fragment,z),W=!1},d(z){z&&a(o),z&&a(N),E(O,z)}}}function Wg(P){let o,d;return o=new me({props:{$$slots:{default:[Hg]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function Rg(P){let o,d;return o=new I({props:{code:`pt_batch = tokenizer(
    ["We are very happy to show you the \u{1F917} Transformers library.", "We hope you don't hate it."],
    padding=True,
    truncation=True,
    max_length=512,
    return_tensors="pt",
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>pt_batch = tokenizer(
<span class="hljs-meta">... </span>    [<span class="hljs-string">&quot;We are very happy to show you the \u{1F917} Transformers library.&quot;</span>, <span class="hljs-string">&quot;We hope you don&#x27;t hate it.&quot;</span>],
<span class="hljs-meta">... </span>    padding=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>    truncation=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>    max_length=<span class="hljs-number">512</span>,
<span class="hljs-meta">... </span>    return_tensors=<span class="hljs-string">&quot;pt&quot;</span>,
<span class="hljs-meta">... </span>)`}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p:we,i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function Yg(P){let o,d;return o=new me({props:{$$slots:{default:[Rg]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function Ug(P){let o,d;return o=new I({props:{code:`tf_batch = tokenizer(
    ["We are very happy to show you the \u{1F917} Transformers library.", "We hope you don't hate it."],
    padding=True,
    truncation=True,
    max_length=512,
    return_tensors="tf",
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>tf_batch = tokenizer(
<span class="hljs-meta">... </span>    [<span class="hljs-string">&quot;We are very happy to show you the \u{1F917} Transformers library.&quot;</span>, <span class="hljs-string">&quot;We hope you don&#x27;t hate it.&quot;</span>],
<span class="hljs-meta">... </span>    padding=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>    truncation=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>    max_length=<span class="hljs-number">512</span>,
<span class="hljs-meta">... </span>    return_tensors=<span class="hljs-string">&quot;tf&quot;</span>,
<span class="hljs-meta">... </span>)`}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p:we,i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function Gg(P){let o,d;return o=new me({props:{$$slots:{default:[Ug]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function Bg(P){let o,d,n,$,_,v,q,F,g,j,S;return{c(){o=l("p"),d=s("Check out the "),n=l("a"),$=s("preprocess"),_=s(" tutorial for more details about tokenization, and how to use an "),v=l("a"),q=s("AutoFeatureExtractor"),F=s(" and "),g=l("a"),j=s("AutoProcessor"),S=s(" to preprocess image, audio, and multimodal inputs."),this.h()},l(N){o=i(N,"P",{});var O=p(o);d=r(O,"Check out the "),n=i(O,"A",{href:!0});var W=p(n);$=r(W,"preprocess"),W.forEach(a),_=r(O," tutorial for more details about tokenization, and how to use an "),v=i(O,"A",{href:!0});var z=p(v);q=r(z,"AutoFeatureExtractor"),z.forEach(a),F=r(O," and "),g=i(O,"A",{href:!0});var C=p(g);j=r(C,"AutoProcessor"),C.forEach(a),S=r(O," to preprocess image, audio, and multimodal inputs."),O.forEach(a),this.h()},h(){h(n,"href","./preprocessing"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoFeatureExtractor"),h(g,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoProcessor")},m(N,O){m(N,o,O),e(o,d),e(o,n),e(n,$),e(o,_),e(o,v),e(v,q),e(o,F),e(o,g),e(g,j),e(o,S)},d(N){N&&a(o)}}}function Qg(P){let o,d,n,$,_,v,q,F;return{c(){o=l("p"),d=s("See the "),n=l("a"),$=s("task summary"),_=s(" for tasks supported by an "),v=l("a"),q=s("AutoModel"),F=s(" class."),this.h()},l(g){o=i(g,"P",{});var j=p(o);d=r(j,"See the "),n=i(j,"A",{href:!0});var S=p(n);$=r(S,"task summary"),S.forEach(a),_=r(j," for tasks supported by an "),v=i(j,"A",{href:!0});var N=p(v);q=r(N,"AutoModel"),N.forEach(a),F=r(j," class."),j.forEach(a),this.h()},h(){h(n,"href","./task_summary"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModel")},m(g,j){m(g,o,j),e(o,d),e(o,n),e(n,$),e(o,_),e(o,v),e(v,q),e(o,F)},d(g){g&&a(o)}}}function Vg(P){let o,d,n,$,_,v,q,F,g,j,S,N,O,W,z,C,A,D,G,R,V,ie,oe,de,B,ne,le,Q,$e,J,ye,ge,K,se,Z,x,L,X;return C=new I({props:{code:`from transformers import AutoModelForSequenceClassification

model_name = "nlptown/bert-base-multilingual-uncased-sentiment"
pt_model = AutoModelForSequenceClassification.from_pretrained(model_name)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model_name = <span class="hljs-string">&quot;nlptown/bert-base-multilingual-uncased-sentiment&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pt_model = AutoModelForSequenceClassification.from_pretrained(model_name)`}}),D=new jn({props:{$$slots:{default:[Qg]},$$scope:{ctx:P}}}),ne=new I({props:{code:"pt_outputs = pt_model(**pt_batch)",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>pt_outputs = pt_model(**pt_batch)'}}),L=new I({props:{code:`from torch import nn

pt_predictions = nn.functional.softmax(pt_outputs.logits, dim=-1)
print(pt_predictions)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn

<span class="hljs-meta">&gt;&gt;&gt; </span>pt_predictions = nn.functional.softmax(pt_outputs.logits, dim=-<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(pt_predictions)
tensor([[<span class="hljs-number">0.0021</span>, <span class="hljs-number">0.0018</span>, <span class="hljs-number">0.0115</span>, <span class="hljs-number">0.2121</span>, <span class="hljs-number">0.7725</span>],
        [<span class="hljs-number">0.2084</span>, <span class="hljs-number">0.1826</span>, <span class="hljs-number">0.1969</span>, <span class="hljs-number">0.1755</span>, <span class="hljs-number">0.2365</span>]], grad_fn=&lt;SoftmaxBackward0&gt;)`}}),{c(){o=l("p"),d=s("\u{1F917} Transformers provides a simple and unified way to load pretrained instances. This means you can load an "),n=l("a"),$=s("AutoModel"),_=s(" like you would load an "),v=l("a"),q=s("AutoTokenizer"),F=s(". The only difference is selecting the correct "),g=l("a"),j=s("AutoModel"),S=s(" for the task. For text (or sequence) classification, you should load "),N=l("a"),O=s("AutoModelForSequenceClassification"),W=s(":"),z=f(),k(C.$$.fragment),A=f(),k(D.$$.fragment),G=f(),R=l("p"),V=s("Now pass your preprocessed batch of inputs directly to the model. You just have to unpack the dictionary by adding "),ie=l("code"),oe=s("**"),de=s(":"),B=f(),k(ne.$$.fragment),le=f(),Q=l("p"),$e=s("The model outputs the final activations in the "),J=l("code"),ye=s("logits"),ge=s(" attribute. Apply the softmax function to the "),K=l("code"),se=s("logits"),Z=s(" to retrieve the probabilities:"),x=f(),k(L.$$.fragment),this.h()},l(M){o=i(M,"P",{});var H=p(o);d=r(H,"\u{1F917} Transformers provides a simple and unified way to load pretrained instances. This means you can load an "),n=i(H,"A",{href:!0});var _e=p(n);$=r(_e,"AutoModel"),_e.forEach(a),_=r(H," like you would load an "),v=i(H,"A",{href:!0});var Ie=p(v);q=r(Ie,"AutoTokenizer"),Ie.forEach(a),F=r(H,". The only difference is selecting the correct "),g=i(H,"A",{href:!0});var ae=p(g);j=r(ae,"AutoModel"),ae.forEach(a),S=r(H," for the task. For text (or sequence) classification, you should load "),N=i(H,"A",{href:!0});var Le=p(N);O=r(Le,"AutoModelForSequenceClassification"),Le.forEach(a),W=r(H,":"),H.forEach(a),z=c(M),w(C.$$.fragment,M),A=c(M),w(D.$$.fragment,M),G=c(M),R=i(M,"P",{});var ee=p(R);V=r(ee,"Now pass your preprocessed batch of inputs directly to the model. You just have to unpack the dictionary by adding "),ie=i(ee,"CODE",{});var us=p(ie);oe=r(us,"**"),us.forEach(a),de=r(ee,":"),ee.forEach(a),B=c(M),w(ne.$$.fragment,M),le=c(M),Q=i(M,"P",{});var he=p(Q);$e=r(he,"The model outputs the final activations in the "),J=i(he,"CODE",{});var ms=p(J);ye=r(ms,"logits"),ms.forEach(a),ge=r(he," attribute. Apply the softmax function to the "),K=i(he,"CODE",{});var ds=p(K);se=r(ds,"logits"),ds.forEach(a),Z=r(he," to retrieve the probabilities:"),he.forEach(a),x=c(M),w(L.$$.fragment,M),this.h()},h(){h(n,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModel"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoTokenizer"),h(g,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModel"),h(N,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModelForSequenceClassification")},m(M,H){m(M,o,H),e(o,d),e(o,n),e(n,$),e(o,_),e(o,v),e(v,q),e(o,F),e(o,g),e(g,j),e(o,S),e(o,N),e(N,O),e(o,W),m(M,z,H),y(C,M,H),m(M,A,H),y(D,M,H),m(M,G,H),m(M,R,H),e(R,V),e(R,ie),e(ie,oe),e(R,de),m(M,B,H),y(ne,M,H),m(M,le,H),m(M,Q,H),e(Q,$e),e(Q,J),e(J,ye),e(Q,ge),e(Q,K),e(K,se),e(Q,Z),m(M,x,H),y(L,M,H),X=!0},p(M,H){const _e={};H&2&&(_e.$$scope={dirty:H,ctx:M}),D.$set(_e)},i(M){X||(b(C.$$.fragment,M),b(D.$$.fragment,M),b(ne.$$.fragment,M),b(L.$$.fragment,M),X=!0)},o(M){T(C.$$.fragment,M),T(D.$$.fragment,M),T(ne.$$.fragment,M),T(L.$$.fragment,M),X=!1},d(M){M&&a(o),M&&a(z),E(C,M),M&&a(A),E(D,M),M&&a(G),M&&a(R),M&&a(B),E(ne,M),M&&a(le),M&&a(Q),M&&a(x),E(L,M)}}}function Kg(P){let o,d;return o=new me({props:{$$slots:{default:[Vg]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function Jg(P){let o,d,n,$,_,v,q,F;return{c(){o=l("p"),d=s("See the "),n=l("a"),$=s("task summary"),_=s(" for tasks supported by an "),v=l("a"),q=s("AutoModel"),F=s(" class."),this.h()},l(g){o=i(g,"P",{});var j=p(o);d=r(j,"See the "),n=i(j,"A",{href:!0});var S=p(n);$=r(S,"task summary"),S.forEach(a),_=r(j," for tasks supported by an "),v=i(j,"A",{href:!0});var N=p(v);q=r(N,"AutoModel"),N.forEach(a),F=r(j," class."),j.forEach(a),this.h()},h(){h(n,"href","./task_summary"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModel")},m(g,j){m(g,o,j),e(o,d),e(o,n),e(n,$),e(o,_),e(o,v),e(v,q),e(o,F)},d(g){g&&a(o)}}}function Zg(P){let o,d,n,$,_,v,q,F,g,j,S,N,O,W,z,C,A,D,G,R,V,ie,oe,de,B,ne,le,Q,$e,J,ye,ge,K,se,Z;return C=new I({props:{code:`from transformers import TFAutoModelForSequenceClassification

model_name = "nlptown/bert-base-multilingual-uncased-sentiment"
tf_model = TFAutoModelForSequenceClassification.from_pretrained(model_name)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model_name = <span class="hljs-string">&quot;nlptown/bert-base-multilingual-uncased-sentiment&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tf_model = TFAutoModelForSequenceClassification.from_pretrained(model_name)`}}),D=new jn({props:{$$slots:{default:[Jg]},$$scope:{ctx:P}}}),oe=new I({props:{code:"tf_outputs = tf_model(tf_batch)",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>tf_outputs = tf_model(tf_batch)'}}),se=new I({props:{code:`import tensorflow as tf

tf_predictions = tf.nn.softmax(tf_outputs.logits, axis=-1)
tf_predictions`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tf_predictions = tf.nn.softmax(tf_outputs.logits, axis=-<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tf_predictions`}}),{c(){o=l("p"),d=s("\u{1F917} Transformers provides a simple and unified way to load pretrained instances. This means you can load an "),n=l("a"),$=s("TFAutoModel"),_=s(" like you would load an "),v=l("a"),q=s("AutoTokenizer"),F=s(". The only difference is selecting the correct "),g=l("a"),j=s("TFAutoModel"),S=s(" for the task. For text (or sequence) classification, you should load "),N=l("a"),O=s("TFAutoModelForSequenceClassification"),W=s(":"),z=f(),k(C.$$.fragment),A=f(),k(D.$$.fragment),G=f(),R=l("p"),V=s("Now pass your preprocessed batch of inputs directly to the model by passing the dictionary keys directly to the tensors:"),ie=f(),k(oe.$$.fragment),de=f(),B=l("p"),ne=s("The model outputs the final activations in the "),le=l("code"),Q=s("logits"),$e=s(" attribute. Apply the softmax function to the "),J=l("code"),ye=s("logits"),ge=s(" to retrieve the probabilities:"),K=f(),k(se.$$.fragment),this.h()},l(x){o=i(x,"P",{});var L=p(o);d=r(L,"\u{1F917} Transformers provides a simple and unified way to load pretrained instances. This means you can load an "),n=i(L,"A",{href:!0});var X=p(n);$=r(X,"TFAutoModel"),X.forEach(a),_=r(L," like you would load an "),v=i(L,"A",{href:!0});var M=p(v);q=r(M,"AutoTokenizer"),M.forEach(a),F=r(L,". The only difference is selecting the correct "),g=i(L,"A",{href:!0});var H=p(g);j=r(H,"TFAutoModel"),H.forEach(a),S=r(L," for the task. For text (or sequence) classification, you should load "),N=i(L,"A",{href:!0});var _e=p(N);O=r(_e,"TFAutoModelForSequenceClassification"),_e.forEach(a),W=r(L,":"),L.forEach(a),z=c(x),w(C.$$.fragment,x),A=c(x),w(D.$$.fragment,x),G=c(x),R=i(x,"P",{});var Ie=p(R);V=r(Ie,"Now pass your preprocessed batch of inputs directly to the model by passing the dictionary keys directly to the tensors:"),Ie.forEach(a),ie=c(x),w(oe.$$.fragment,x),de=c(x),B=i(x,"P",{});var ae=p(B);ne=r(ae,"The model outputs the final activations in the "),le=i(ae,"CODE",{});var Le=p(le);Q=r(Le,"logits"),Le.forEach(a),$e=r(ae," attribute. Apply the softmax function to the "),J=i(ae,"CODE",{});var ee=p(J);ye=r(ee,"logits"),ee.forEach(a),ge=r(ae," to retrieve the probabilities:"),ae.forEach(a),K=c(x),w(se.$$.fragment,x),this.h()},h(){h(n,"href","/docs/transformers/main/en/model_doc/auto#transformers.TFAutoModel"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoTokenizer"),h(g,"href","/docs/transformers/main/en/model_doc/auto#transformers.TFAutoModel"),h(N,"href","/docs/transformers/main/en/model_doc/auto#transformers.TFAutoModelForSequenceClassification")},m(x,L){m(x,o,L),e(o,d),e(o,n),e(n,$),e(o,_),e(o,v),e(v,q),e(o,F),e(o,g),e(g,j),e(o,S),e(o,N),e(N,O),e(o,W),m(x,z,L),y(C,x,L),m(x,A,L),y(D,x,L),m(x,G,L),m(x,R,L),e(R,V),m(x,ie,L),y(oe,x,L),m(x,de,L),m(x,B,L),e(B,ne),e(B,le),e(le,Q),e(B,$e),e(B,J),e(J,ye),e(B,ge),m(x,K,L),y(se,x,L),Z=!0},p(x,L){const X={};L&2&&(X.$$scope={dirty:L,ctx:x}),D.$set(X)},i(x){Z||(b(C.$$.fragment,x),b(D.$$.fragment,x),b(oe.$$.fragment,x),b(se.$$.fragment,x),Z=!0)},o(x){T(C.$$.fragment,x),T(D.$$.fragment,x),T(oe.$$.fragment,x),T(se.$$.fragment,x),Z=!1},d(x){x&&a(o),x&&a(z),E(C,x),x&&a(A),E(D,x),x&&a(G),x&&a(R),x&&a(ie),E(oe,x),x&&a(de),x&&a(B),x&&a(K),E(se,x)}}}function Xg(P){let o,d;return o=new me({props:{$$slots:{default:[Zg]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function e_(P){let o,d,n,$,_;return{c(){o=l("p"),d=s("All \u{1F917} Transformers models (PyTorch or TensorFlow) output the tensors "),n=l("em"),$=s("before"),_=s(` the final activation
function (like softmax) because the final activation function is often fused with the loss. Model outputs are special dataclasses so their attributes are autocompleted in an IDE. The model outputs behave like a tuple or a dictionary (you can index with an integer, a slice or a string) in which case, attributes that are None are ignored.`)},l(v){o=i(v,"P",{});var q=p(o);d=r(q,"All \u{1F917} Transformers models (PyTorch or TensorFlow) output the tensors "),n=i(q,"EM",{});var F=p(n);$=r(F,"before"),F.forEach(a),_=r(q,` the final activation
function (like softmax) because the final activation function is often fused with the loss. Model outputs are special dataclasses so their attributes are autocompleted in an IDE. The model outputs behave like a tuple or a dictionary (you can index with an integer, a slice or a string) in which case, attributes that are None are ignored.`),q.forEach(a)},m(v,q){m(v,o,q),e(o,d),e(o,n),e(n,$),e(o,_)},d(v){v&&a(o)}}}function t_(P){let o,d,n,$,_,v,q,F,g,j,S,N,O,W,z,C;return q=new I({props:{code:`pt_save_directory = "./pt_save_pretrained"
tokenizer.save_pretrained(pt_save_directory)
pt_model.save_pretrained(pt_save_directory)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>pt_save_directory = <span class="hljs-string">&quot;./pt_save_pretrained&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.save_pretrained(pt_save_directory)
<span class="hljs-meta">&gt;&gt;&gt; </span>pt_model.save_pretrained(pt_save_directory)`}}),z=new I({props:{code:'pt_model = AutoModelForSequenceClassification.from_pretrained("./pt_save_pretrained")',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>pt_model = AutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;./pt_save_pretrained&quot;</span>)'}}),{c(){o=l("p"),d=s("Once your model is fine-tuned, you can save it with its tokenizer using "),n=l("a"),$=s("PreTrainedModel.save_pretrained()"),_=s(":"),v=f(),k(q.$$.fragment),F=f(),g=l("p"),j=s("When you are ready to use the model again, reload it with "),S=l("a"),N=s("PreTrainedModel.from_pretrained()"),O=s(":"),W=f(),k(z.$$.fragment),this.h()},l(A){o=i(A,"P",{});var D=p(o);d=r(D,"Once your model is fine-tuned, you can save it with its tokenizer using "),n=i(D,"A",{href:!0});var G=p(n);$=r(G,"PreTrainedModel.save_pretrained()"),G.forEach(a),_=r(D,":"),D.forEach(a),v=c(A),w(q.$$.fragment,A),F=c(A),g=i(A,"P",{});var R=p(g);j=r(R,"When you are ready to use the model again, reload it with "),S=i(R,"A",{href:!0});var V=p(S);N=r(V,"PreTrainedModel.from_pretrained()"),V.forEach(a),O=r(R,":"),R.forEach(a),W=c(A),w(z.$$.fragment,A),this.h()},h(){h(n,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.save_pretrained"),h(S,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained")},m(A,D){m(A,o,D),e(o,d),e(o,n),e(n,$),e(o,_),m(A,v,D),y(q,A,D),m(A,F,D),m(A,g,D),e(g,j),e(g,S),e(S,N),e(g,O),m(A,W,D),y(z,A,D),C=!0},p:we,i(A){C||(b(q.$$.fragment,A),b(z.$$.fragment,A),C=!0)},o(A){T(q.$$.fragment,A),T(z.$$.fragment,A),C=!1},d(A){A&&a(o),A&&a(v),E(q,A),A&&a(F),A&&a(g),A&&a(W),E(z,A)}}}function a_(P){let o,d;return o=new me({props:{$$slots:{default:[t_]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function s_(P){let o,d,n,$,_,v,q,F,g,j,S,N,O,W,z,C;return q=new I({props:{code:`tf_save_directory = "./tf_save_pretrained"
tokenizer.save_pretrained(tf_save_directory)
tf_model.save_pretrained(tf_save_directory)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>tf_save_directory = <span class="hljs-string">&quot;./tf_save_pretrained&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.save_pretrained(tf_save_directory)
<span class="hljs-meta">&gt;&gt;&gt; </span>tf_model.save_pretrained(tf_save_directory)`}}),z=new I({props:{code:'tf_model = TFAutoModelForSequenceClassification.from_pretrained("./tf_save_pretrained")',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>tf_model = TFAutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;./tf_save_pretrained&quot;</span>)'}}),{c(){o=l("p"),d=s("Once your model is fine-tuned, you can save it with its tokenizer using "),n=l("a"),$=s("TFPreTrainedModel.save_pretrained()"),_=s(":"),v=f(),k(q.$$.fragment),F=f(),g=l("p"),j=s("When you are ready to use the model again, reload it with "),S=l("a"),N=s("TFPreTrainedModel.from_pretrained()"),O=s(":"),W=f(),k(z.$$.fragment),this.h()},l(A){o=i(A,"P",{});var D=p(o);d=r(D,"Once your model is fine-tuned, you can save it with its tokenizer using "),n=i(D,"A",{href:!0});var G=p(n);$=r(G,"TFPreTrainedModel.save_pretrained()"),G.forEach(a),_=r(D,":"),D.forEach(a),v=c(A),w(q.$$.fragment,A),F=c(A),g=i(A,"P",{});var R=p(g);j=r(R,"When you are ready to use the model again, reload it with "),S=i(R,"A",{href:!0});var V=p(S);N=r(V,"TFPreTrainedModel.from_pretrained()"),V.forEach(a),O=r(R,":"),R.forEach(a),W=c(A),w(z.$$.fragment,A),this.h()},h(){h(n,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel.save_pretrained"),h(S,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel.from_pretrained")},m(A,D){m(A,o,D),e(o,d),e(o,n),e(n,$),e(o,_),m(A,v,D),y(q,A,D),m(A,F,D),m(A,g,D),e(g,j),e(g,S),e(S,N),e(g,O),m(A,W,D),y(z,A,D),C=!0},p:we,i(A){C||(b(q.$$.fragment,A),b(z.$$.fragment,A),C=!0)},o(A){T(q.$$.fragment,A),T(z.$$.fragment,A),C=!1},d(A){A&&a(o),A&&a(v),E(q,A),A&&a(F),A&&a(g),A&&a(W),E(z,A)}}}function r_(P){let o,d;return o=new me({props:{$$slots:{default:[s_]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function o_(P){let o,d;return o=new I({props:{code:`from transformers import AutoModel

tokenizer = AutoTokenizer.from_pretrained(tf_save_directory)
pt_model = AutoModelForSequenceClassification.from_pretrained(tf_save_directory, from_tf=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModel

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(tf_save_directory)
<span class="hljs-meta">&gt;&gt;&gt; </span>pt_model = AutoModelForSequenceClassification.from_pretrained(tf_save_directory, from_tf=<span class="hljs-literal">True</span>)`}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p:we,i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function n_(P){let o,d;return o=new me({props:{$$slots:{default:[o_]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function l_(P){let o,d;return o=new I({props:{code:`from transformers import TFAutoModel

tokenizer = AutoTokenizer.from_pretrained(pt_save_directory)
tf_model = TFAutoModelForSequenceClassification.from_pretrained(pt_save_directory, from_pt=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModel

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(pt_save_directory)
<span class="hljs-meta">&gt;&gt;&gt; </span>tf_model = TFAutoModelForSequenceClassification.from_pretrained(pt_save_directory, from_pt=<span class="hljs-literal">True</span>)`}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p:we,i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function i_(P){let o,d;return o=new me({props:{$$slots:{default:[l_]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function p_(P){let o,d,n,$,_,v,q,F;return q=new I({props:{code:`from transformers import AutoModel

my_model = AutoModel.from_config(my_config)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModel

<span class="hljs-meta">&gt;&gt;&gt; </span>my_model = AutoModel.from_config(my_config)`}}),{c(){o=l("p"),d=s("Create a model from your custom configuration with "),n=l("a"),$=s("AutoModel.from_config()"),_=s(":"),v=f(),k(q.$$.fragment),this.h()},l(g){o=i(g,"P",{});var j=p(o);d=r(j,"Create a model from your custom configuration with "),n=i(j,"A",{href:!0});var S=p(n);$=r(S,"AutoModel.from_config()"),S.forEach(a),_=r(j,":"),j.forEach(a),v=c(g),w(q.$$.fragment,g),this.h()},h(){h(n,"href","/docs/transformers/main/en/model_doc/auto#transformers.FlaxAutoModelForVision2Seq.from_config")},m(g,j){m(g,o,j),e(o,d),e(o,n),e(n,$),e(o,_),m(g,v,j),y(q,g,j),F=!0},p:we,i(g){F||(b(q.$$.fragment,g),F=!0)},o(g){T(q.$$.fragment,g),F=!1},d(g){g&&a(o),g&&a(v),E(q,g)}}}function f_(P){let o,d;return o=new me({props:{$$slots:{default:[p_]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function c_(P){let o,d,n,$,_,v,q,F;return q=new I({props:{code:`from transformers import TFAutoModel

my_model = TFAutoModel.from_config(my_config)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModel

<span class="hljs-meta">&gt;&gt;&gt; </span>my_model = TFAutoModel.from_config(my_config)`}}),{c(){o=l("p"),d=s("Create a model from your custom configuration with "),n=l("a"),$=s("TFAutoModel.from_config()"),_=s(":"),v=f(),k(q.$$.fragment),this.h()},l(g){o=i(g,"P",{});var j=p(o);d=r(j,"Create a model from your custom configuration with "),n=i(j,"A",{href:!0});var S=p(n);$=r(S,"TFAutoModel.from_config()"),S.forEach(a),_=r(j,":"),j.forEach(a),v=c(g),w(q.$$.fragment,g),this.h()},h(){h(n,"href","/docs/transformers/main/en/model_doc/auto#transformers.FlaxAutoModelForVision2Seq.from_config")},m(g,j){m(g,o,j),e(o,d),e(o,n),e(n,$),e(o,_),m(g,v,j),y(q,g,j),F=!0},p:we,i(g){F||(b(q.$$.fragment,g),F=!0)},o(g){T(q.$$.fragment,g),F=!1},d(g){g&&a(o),g&&a(v),E(q,g)}}}function u_(P){let o,d;return o=new me({props:{$$slots:{default:[c_]},$$scope:{ctx:P}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,$){y(o,n,$),d=!0},p(n,$){const _={};$&2&&(_.$$scope={dirty:$,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function m_(P){let o,d,n,$,_,v,q,F;return{c(){o=l("p"),d=s("For tasks - like translation or summarization - that use a sequence-to-sequence model, use the "),n=l("a"),$=s("Seq2SeqTrainer"),_=s(" and "),v=l("a"),q=s("Seq2SeqTrainingArguments"),F=s(" classes instead."),this.h()},l(g){o=i(g,"P",{});var j=p(o);d=r(j,"For tasks - like translation or summarization - that use a sequence-to-sequence model, use the "),n=i(j,"A",{href:!0});var S=p(n);$=r(S,"Seq2SeqTrainer"),S.forEach(a),_=r(j," and "),v=i(j,"A",{href:!0});var N=p(v);q=r(N,"Seq2SeqTrainingArguments"),N.forEach(a),F=r(j," classes instead."),j.forEach(a),this.h()},h(){h(n,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Seq2SeqTrainer"),h(v,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Seq2SeqTrainingArguments")},m(g,j){m(g,o,j),e(o,d),e(o,n),e(n,$),e(o,_),e(o,v),e(v,q),e(o,F)},d(g){g&&a(o)}}}function d_(P){let o,d,n,$,_,v,q,F,g,j,S,N,O,W,z,C,A,D,G,R,V,ie,oe,de,B,ne,le,Q,$e,J,ye,ge,K,se,Z,x,L,X,M,H,_e,Ie,ae,Le,ee,us,he,ms,ds,hs,Ei,Ai,qn,ut,br,be,Tr,Er,ji,qi,Ar,jr,zi,xi,qr,zr,Pi,Fi,xr,Pr,Mi,Ci,Y,Te,Fr,Si,Di,Mr,Oi,Ni,Cr,Ii,Li,Sr,Hi,Wi,Ee,Dr,Ri,Yi,Or,Ui,Gi,Nr,Bi,Qi,Ir,Vi,Ki,Ae,Lr,Ji,Zi,Hr,Xi,ep,Wr,tp,ap,Rr,sp,rp,je,Yr,op,np,Ur,lp,ip,Gr,pp,fp,Br,cp,up,qe,Qr,mp,dp,Vr,hp,$p,Kr,gp,_p,Jr,vp,kp,ze,Zr,wp,yp,Xr,bp,Tp,eo,Ep,Ap,to,jp,qp,xe,ao,zp,xp,so,Pp,Fp,ro,Mp,Cp,oo,Sp,Dp,Pe,no,Op,Np,lo,Ip,Lp,io,Hp,Wp,po,Rp,Yp,Fe,fo,Up,Gp,co,Bp,Qp,uo,Vp,Kp,mo,Jp,Zp,Me,ho,Xp,ef,$o,tf,af,go,sf,rf,_o,of,nf,Ce,vo,lf,pf,ko,ff,cf,wo,uf,mf,yo,df,hf,Se,bo,$f,gf,To,_f,vf,Eo,kf,wf,Ao,yf,bf,De,jo,Tf,Ef,qo,Af,jf,zo,qf,zf,xo,xf,zn,pe,Pf,$s,Ff,Mf,gs,Cf,Sf,_s,Df,Of,vs,Nf,If,xn,ra,Pn,ve,Lf,ks,Hf,Wf,oa,Rf,Yf,Po,Uf,Gf,Fn,na,Mn,mt,Bf,ws,Qf,Vf,Cn,la,Sn,dt,Kf,ys,Jf,Zf,Dn,ia,On,He,Xf,pa,ec,tc,fa,ac,sc,Nn,ca,In,ht,rc,ua,Fo,oc,nc,Ln,ma,Hn,$t,lc,Mo,ic,pc,Wn,da,Rn,gt,fc,bs,cc,uc,Yn,et,_t,Co,ha,mc,So,dc,Un,fe,hc,Ts,$c,gc,$a,_c,vc,Es,kc,wc,ga,yc,bc,Gn,_a,Bn,vt,Qn,We,Tc,As,Ec,Ac,Do,jc,qc,Vn,va,Kn,Re,zc,js,xc,Pc,qs,Fc,Mc,Jn,tt,kt,Oo,ka,Cc,No,Sc,Zn,wa,Xn,re,Dc,zs,Oc,Nc,xs,Ic,Lc,Ps,Hc,Wc,Fs,Rc,Yc,Io,Uc,Gc,el,Ye,Bc,Lo,Qc,Vc,Ms,Kc,Jc,tl,at,wt,Ho,ya,Zc,Wo,Xc,al,yt,eu,Cs,tu,au,sl,bt,su,Ss,ru,ou,rl,ba,ol,Ds,nu,nl,Ta,ll,Os,lu,il,Tt,Ns,Is,iu,pu,fu,Ls,Hs,cu,uu,pl,Ws,mu,fl,Et,cl,At,ul,st,jt,Ro,Ea,du,Yo,hu,ml,qt,dl,zt,hl,rt,xt,Uo,Aa,$u,Go,gu,$l,Pt,gl,Ue,_u,Bo,vu,ku,Qo,wu,yu,_l,Ft,vl,ot,Mt,Vo,ja,bu,Ko,Tu,kl,Rs,Eu,wl,Ge,Au,Ys,ju,qu,Us,zu,xu,yl,qa,bl,Ct,Tl,St,Pu,Gs,Fu,Mu,El,nt,Dt,Jo,za,Cu,Zo,Su,Al,Be,Du,xa,Xo,Ou,Nu,Bs,Iu,Lu,jl,Ot,Hu,Qs,Wu,Ru,ql,ce,Pa,lt,Yu,Vs,Uu,Gu,Fa,en,Bu,Qu,Vu,Ma,Ku,Ca,Ks,Js,Ju,Zu,Xu,Sa,em,Da,tn,tm,am,Oa,sm,Na,an,rm,om,Ia,nm,La,Ha,lm,sn,im,pm,fm,Wa,zl,Nt,cm,Zs,um,mm,xl,Ra,Pl,It,dm,Xs,hm,$m,Fl,Ya,Ml,Lt,Cl,Qe,gm,er,_m,vm,tr,km,wm,Sl,Ve,ym,ar,bm,Tm,sr,Em,Am,Dl,it,Ht,rn,Ua,jm,on,qm,Ol,te,zm,Ga,nn,xm,Pm,Ba,Fm,Mm,rr,Cm,Sm,ln,Dm,Om,Qa,pn,Nm,Im,Va,fn,Lm,Hm,Nl,Ke,Ka,pt,Wm,or,Rm,Ym,Ja,cn,Um,Gm,Bm,Za,Qm,Xa,un,Vm,Km,es,Jm,ts,as,Zm,nr,Xm,ed,td,ss,Il,lr,mn,rs,dn,ad,sd,os,Ll,ns,ls,ft,rd,hn,od,nd,$n,ld,id,pd,is,Hl,ct,Wt,gn,ps,fd,_n,cd,Wl,ir,ud,Rl;return v=new Ne({}),S=new Cg({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Mixed",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/main/transformers_doc/en/quicktour.ipynb"},{label:"PyTorch",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/main/transformers_doc/en/pytorch/quicktour.ipynb"},{label:"TensorFlow",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/main/transformers_doc/en/tensorflow/quicktour.ipynb"},{label:"Mixed",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/main/transformers_doc/en/quicktour.ipynb"},{label:"PyTorch",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/main/transformers_doc/en/pytorch/quicktour.ipynb"},{label:"TensorFlow",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/main/transformers_doc/en/tensorflow/quicktour.ipynb"}]}}),Q=new I({props:{code:"!pip install transformers datasets",highlighted:"!pip install transformers datasets"}}),K=new cs({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[Ng],pytorch:[Dg]},$$scope:{ctx:P}}}),X=new Ne({}),ae=new qg({props:{id:"tiZFewofSLM"}}),ra=new I({props:{code:`from transformers import pipeline

classifier = pipeline("sentiment-analysis")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

<span class="hljs-meta">&gt;&gt;&gt; </span>classifier = pipeline(<span class="hljs-string">&quot;sentiment-analysis&quot;</span>)`}}),na=new I({props:{code:'classifier("We are very happy to show you the \u{1F917} Transformers library.")',highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>classifier(<span class="hljs-string">&quot;We are very happy to show you the \u{1F917} Transformers library.&quot;</span>)
[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9998</span>}]`}}),la=new I({props:{code:`results = classifier(["We are very happy to show you the \u{1F917} Transformers library.", "We hope you don't hate it."])
for result in results:
    print(f"label: {result['label']}, with score: {round(result['score'], 4)}")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>results = classifier([<span class="hljs-string">&quot;We are very happy to show you the \u{1F917} Transformers library.&quot;</span>, <span class="hljs-string">&quot;We hope you don&#x27;t hate it.&quot;</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;label: <span class="hljs-subst">{result[<span class="hljs-string">&#x27;label&#x27;</span>]}</span>, with score: <span class="hljs-subst">{<span class="hljs-built_in">round</span>(result[<span class="hljs-string">&#x27;score&#x27;</span>], <span class="hljs-number">4</span>)}</span>&quot;</span>)
label: POSITIVE, <span class="hljs-keyword">with</span> score: <span class="hljs-number">0.9998</span>
label: NEGATIVE, <span class="hljs-keyword">with</span> score: <span class="hljs-number">0.5309</span>`}}),ia=new I({props:{code:`import torch
from transformers import pipeline

speech_recognizer = pipeline("automatic-speech-recognition", model="facebook/wav2vec2-base-960h")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

<span class="hljs-meta">&gt;&gt;&gt; </span>speech_recognizer = pipeline(<span class="hljs-string">&quot;automatic-speech-recognition&quot;</span>, model=<span class="hljs-string">&quot;facebook/wav2vec2-base-960h&quot;</span>)`}}),ca=new I({props:{code:`from datasets import load_dataset, Audio

dataset = load_dataset("PolyAI/minds14", name="en-US", split="train")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset, Audio

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;PolyAI/minds14&quot;</span>, name=<span class="hljs-string">&quot;en-US&quot;</span>, split=<span class="hljs-string">&quot;train&quot;</span>)`}}),ma=new I({props:{code:'dataset = dataset.cast_column("audio", Audio(sampling_rate=speech_recognizer.feature_extractor.sampling_rate))',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = dataset.cast_column(<span class="hljs-string">&quot;audio&quot;</span>, Audio(sampling_rate=speech_recognizer.feature_extractor.sampling_rate))'}}),da=new I({props:{code:`result = speech_recognizer(dataset[:4]["audio"])
print([d["text"] for d in result])`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>result = speech_recognizer(dataset[:<span class="hljs-number">4</span>][<span class="hljs-string">&quot;audio&quot;</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>([d[<span class="hljs-string">&quot;text&quot;</span>] <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> result])
[<span class="hljs-string">&#x27;I WOULD LIKE TO SET UP A JOINT ACCOUNT WITH MY PARTNER HOW DO I PROCEED WITH DOING THAT&#x27;</span>, <span class="hljs-string">&quot;FODING HOW I&#x27;D SET UP A JOIN TO HET WITH MY WIFE AND WHERE THE AP MIGHT BE&quot;</span>, <span class="hljs-string">&quot;I I&#x27;D LIKE TOY SET UP A JOINT ACCOUNT WITH MY PARTNER I&#x27;M NOT SEEING THE OPTION TO DO IT ON THE AP SO I CALLED IN TO GET SOME HELP CAN I JUST DO IT OVER THE PHONE WITH YOU AND GIVE YOU THE INFORMATION OR SHOULD I DO IT IN THE AP AND I&#x27;M MISSING SOMETHING UQUETTE HAD PREFERRED TO JUST DO IT OVER THE PHONE OF POSSIBLE THINGS&quot;</span>, <span class="hljs-string">&#x27;HOW DO I THURN A JOIN A COUNT&#x27;</span>]`}}),ha=new Ne({}),_a=new I({props:{code:'model_name = "nlptown/bert-base-multilingual-uncased-sentiment"',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>model_name = <span class="hljs-string">&quot;nlptown/bert-base-multilingual-uncased-sentiment&quot;</span>'}}),vt=new cs({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[Wg],pytorch:[Lg]},$$scope:{ctx:P}}}),va=new I({props:{code:`classifier = pipeline("sentiment-analysis", model=model, tokenizer=tokenizer)
classifier("Nous sommes tr\xE8s heureux de vous pr\xE9senter la biblioth\xE8que \u{1F917} Transformers.")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>classifier = pipeline(<span class="hljs-string">&quot;sentiment-analysis&quot;</span>, model=model, tokenizer=tokenizer)
<span class="hljs-meta">&gt;&gt;&gt; </span>classifier(<span class="hljs-string">&quot;Nous sommes tr\xE8s heureux de vous pr\xE9senter la biblioth\xE8que \u{1F917} Transformers.&quot;</span>)
[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;5 stars&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.7273</span>}]`}}),ka=new Ne({}),wa=new qg({props:{id:"AhChOFRegn4"}}),ya=new Ne({}),ba=new I({props:{code:`from transformers import AutoTokenizer

model_name = "nlptown/bert-base-multilingual-uncased-sentiment"
tokenizer = AutoTokenizer.from_pretrained(model_name)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>model_name = <span class="hljs-string">&quot;nlptown/bert-base-multilingual-uncased-sentiment&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(model_name)`}}),Ta=new I({props:{code:`encoding = tokenizer("We are very happy to show you the \u{1F917} Transformers library.")
print(encoding)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = tokenizer(<span class="hljs-string">&quot;We are very happy to show you the \u{1F917} Transformers library.&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(encoding)
{<span class="hljs-string">&#x27;input_ids&#x27;</span>: [<span class="hljs-number">101</span>, <span class="hljs-number">11312</span>, <span class="hljs-number">10320</span>, <span class="hljs-number">12495</span>, <span class="hljs-number">19308</span>, <span class="hljs-number">10114</span>, <span class="hljs-number">11391</span>, <span class="hljs-number">10855</span>, <span class="hljs-number">10103</span>, <span class="hljs-number">100</span>, <span class="hljs-number">58263</span>, <span class="hljs-number">13299</span>, <span class="hljs-number">119</span>, <span class="hljs-number">102</span>],
 <span class="hljs-string">&#x27;token_type_ids&#x27;</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
 <span class="hljs-string">&#x27;attention_mask&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]}`}}),Et=new cs({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[Gg],pytorch:[Yg]},$$scope:{ctx:P}}}),At=new jn({props:{$$slots:{default:[Bg]},$$scope:{ctx:P}}}),Ea=new Ne({}),qt=new cs({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[Xg],pytorch:[Kg]},$$scope:{ctx:P}}}),zt=new jn({props:{$$slots:{default:[e_]},$$scope:{ctx:P}}}),Aa=new Ne({}),Pt=new cs({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[r_],pytorch:[a_]},$$scope:{ctx:P}}}),Ft=new cs({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[i_],pytorch:[n_]},$$scope:{ctx:P}}}),ja=new Ne({}),qa=new I({props:{code:`from transformers import AutoConfig

my_config = AutoConfig.from_pretrained("distilbert-base-uncased", n_heads=12)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoConfig

<span class="hljs-meta">&gt;&gt;&gt; </span>my_config = AutoConfig.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>, n_heads=<span class="hljs-number">12</span>)`}}),Ct=new cs({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[u_],pytorch:[f_]},$$scope:{ctx:P}}}),za=new Ne({}),Ma=new I({props:{code:`from transformers import AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained("distilbert-base-uncased")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = AutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)`}}),Sa=new I({props:{code:`from transformers import TrainingArguments

training_args = TrainingArguments(
    output_dir="path/to/save/folder/",
    learning_rate=2e-5,
    per_device_train_batch_size=8,
    per_device_eval_batch_size=8,
    num_train_epochs=2,
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

<span class="hljs-meta">&gt;&gt;&gt; </span>training_args = TrainingArguments(
<span class="hljs-meta">... </span>    output_dir=<span class="hljs-string">&quot;path/to/save/folder/&quot;</span>,
<span class="hljs-meta">... </span>    learning_rate=<span class="hljs-number">2e-5</span>,
<span class="hljs-meta">... </span>    per_device_train_batch_size=<span class="hljs-number">8</span>,
<span class="hljs-meta">... </span>    per_device_eval_batch_size=<span class="hljs-number">8</span>,
<span class="hljs-meta">... </span>    num_train_epochs=<span class="hljs-number">2</span>,
<span class="hljs-meta">... </span>)`}}),Oa=new I({props:{code:`from transformers import AutoTokenizer

tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)`}}),Ia=new I({props:{code:`train_dataset = dataset["train"]
eval_dataset = dataset["eval"]`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>train_dataset = dataset[<span class="hljs-string">&quot;train&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>eval_dataset = dataset[<span class="hljs-string">&quot;eval&quot;</span>]`}}),Wa=new I({props:{code:`from transformers import DefaultDataCollator

data_collator = DefaultDataCollator()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DefaultDataCollator

<span class="hljs-meta">&gt;&gt;&gt; </span>data_collator = DefaultDataCollator()`}}),Ra=new I({props:{code:`from transformers import Trainer

trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=dataset["train"],
    eval_dataset=dataset["test"],
    tokenizer=tokenizer,
    data_collator=data_collator,
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Trainer

<span class="hljs-meta">&gt;&gt;&gt; </span>trainer = Trainer(
<span class="hljs-meta">... </span>    model=model,
<span class="hljs-meta">... </span>    args=training_args,
<span class="hljs-meta">... </span>    train_dataset=dataset[<span class="hljs-string">&quot;train&quot;</span>],
<span class="hljs-meta">... </span>    eval_dataset=dataset[<span class="hljs-string">&quot;test&quot;</span>],
<span class="hljs-meta">... </span>    tokenizer=tokenizer,
<span class="hljs-meta">... </span>    data_collator=data_collator,
<span class="hljs-meta">... </span>)`}}),Ya=new I({props:{code:"trainer.train()",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>trainer.train()'}}),Lt=new jn({props:{$$slots:{default:[m_]},$$scope:{ctx:P}}}),Ua=new Ne({}),Za=new I({props:{code:`from transformers import TFAutoModelForSequenceClassification

model = TFAutoModelForSequenceClassification.from_pretrained("distilbert-base-uncased")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFAutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)`}}),es=new I({props:{code:`from transformers import AutoTokenizer

tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)`}}),ss=new I({props:{code:`def tokenize_dataset(dataset):
    return tokenizer(dataset["text"])`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_dataset</span>(<span class="hljs-params">dataset</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> tokenizer(dataset[<span class="hljs-string">&quot;text&quot;</span>])`}}),os=new I({props:{code:"",highlighted:""}}),is=new I({props:{code:`from tensorflow.keras.optimizers import Adam

model.compile(optimizer=Adam(3e-5))
model.fit(dataset)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> tensorflow.keras.optimizers <span class="hljs-keyword">import</span> Adam

<span class="hljs-meta">&gt;&gt;&gt; </span>model.<span class="hljs-built_in">compile</span>(optimizer=Adam(<span class="hljs-number">3e-5</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>model.fit(dataset)`}}),ps=new Ne({}),{c(){o=l("meta"),d=f(),n=l("h1"),$=l("a"),_=l("span"),k(v.$$.fragment),q=f(),F=l("span"),g=s("Quick tour"),j=f(),k(S.$$.fragment),N=f(),O=l("p"),W=s("Get up and running with \u{1F917} Transformers! Whether you\u2019re a developer or an everyday user, this quick tour will help you get started and show you how to use the "),z=l("a"),C=s("pipeline()"),A=s(" for inference, load a pretrained model and preprocessor with an "),D=l("a"),G=s("AutoClass"),R=s(", and quickly train a model with PyTorch or TensorFlow. If you\u2019re a beginner, we recommend checking out our tutorials or "),V=l("a"),ie=s("course"),oe=s(" next for more in-depth explanations of the concepts introduced here."),de=f(),B=l("p"),ne=s("Before you begin, make sure you have all the necessary libraries installed:"),le=f(),k(Q.$$.fragment),$e=f(),J=l("p"),ye=s("You\u2019ll also need to install your preferred machine learning framework:"),ge=f(),k(K.$$.fragment),se=f(),Z=l("h2"),x=l("a"),L=l("span"),k(X.$$.fragment),M=f(),H=l("span"),_e=s("Pipeline"),Ie=f(),k(ae.$$.fragment),Le=f(),ee=l("p"),us=s("The "),he=l("a"),ms=s("pipeline()"),ds=s(" is the easiest way to use a pretrained model for inference. You can use the "),hs=l("a"),Ei=s("pipeline()"),Ai=s(" out-of-the-box for many tasks across different modalities. Take a look at the table below for some supported tasks:"),qn=f(),ut=l("table"),br=l("thead"),be=l("tr"),Tr=l("th"),Er=l("strong"),ji=s("Task"),qi=f(),Ar=l("th"),jr=l("strong"),zi=s("Description"),xi=f(),qr=l("th"),zr=l("strong"),Pi=s("Modality"),Fi=f(),xr=l("th"),Pr=l("strong"),Mi=s("Pipeline identifier"),Ci=f(),Y=l("tbody"),Te=l("tr"),Fr=l("td"),Si=s("Text classification"),Di=f(),Mr=l("td"),Oi=s("assign a label to a given sequence of text"),Ni=f(),Cr=l("td"),Ii=s("NLP"),Li=f(),Sr=l("td"),Hi=s("pipeline(task=\u201Csentiment-analysis\u201D)"),Wi=f(),Ee=l("tr"),Dr=l("td"),Ri=s("Text generation"),Yi=f(),Or=l("td"),Ui=s("generate text that follows a given prompt"),Gi=f(),Nr=l("td"),Bi=s("NLP"),Qi=f(),Ir=l("td"),Vi=s("pipeline(task=\u201Ctext-generation\u201D)"),Ki=f(),Ae=l("tr"),Lr=l("td"),Ji=s("Name entity recognition"),Zi=f(),Hr=l("td"),Xi=s("assign a label to each token in a sequence (people, organization, location, etc.)"),ep=f(),Wr=l("td"),tp=s("NLP"),ap=f(),Rr=l("td"),sp=s("pipeline(task=\u201Cner\u201D)"),rp=f(),je=l("tr"),Yr=l("td"),op=s("Question answering"),np=f(),Ur=l("td"),lp=s("extract an answer from the text given some context and a question"),ip=f(),Gr=l("td"),pp=s("NLP"),fp=f(),Br=l("td"),cp=s("pipeline(task=\u201Cquestion-answering\u201D)"),up=f(),qe=l("tr"),Qr=l("td"),mp=s("Fill-mask"),dp=f(),Vr=l("td"),hp=s("predict the correct masked token in a sequence"),$p=f(),Kr=l("td"),gp=s("NLP"),_p=f(),Jr=l("td"),vp=s("pipeline(task=\u201Cfill-mask\u201D)"),kp=f(),ze=l("tr"),Zr=l("td"),wp=s("Summarization"),yp=f(),Xr=l("td"),bp=s("generate a summary of a sequence of text or document"),Tp=f(),eo=l("td"),Ep=s("NLP"),Ap=f(),to=l("td"),jp=s("pipeline(task=\u201Csummarization\u201D)"),qp=f(),xe=l("tr"),ao=l("td"),zp=s("Translation"),xp=f(),so=l("td"),Pp=s("translate text from one language into another"),Fp=f(),ro=l("td"),Mp=s("NLP"),Cp=f(),oo=l("td"),Sp=s("pipeline(task=\u201Ctranslation\u201D)"),Dp=f(),Pe=l("tr"),no=l("td"),Op=s("Image classification"),Np=f(),lo=l("td"),Ip=s("assign a label to an image"),Lp=f(),io=l("td"),Hp=s("Computer vision"),Wp=f(),po=l("td"),Rp=s("pipeline(task=\u201Cimage-classification\u201D)"),Yp=f(),Fe=l("tr"),fo=l("td"),Up=s("Image segmentation"),Gp=f(),co=l("td"),Bp=s("assign a label to each individual pixel of an image (supports semantic, panoptic, and instance segmentation)"),Qp=f(),uo=l("td"),Vp=s("Computer vision"),Kp=f(),mo=l("td"),Jp=s("pipeline(task=\u201Cimage-segmentation\u201D)"),Zp=f(),Me=l("tr"),ho=l("td"),Xp=s("Object detection"),ef=f(),$o=l("td"),tf=s("predict the bounding boxes and classes of objects in an image"),af=f(),go=l("td"),sf=s("Computer vision"),rf=f(),_o=l("td"),of=s("pipeline(task=\u201Cobject-detection\u201D)"),nf=f(),Ce=l("tr"),vo=l("td"),lf=s("Audio classification"),pf=f(),ko=l("td"),ff=s("assign a label to an audio file"),cf=f(),wo=l("td"),uf=s("Audio"),mf=f(),yo=l("td"),df=s("pipeline(task=\u201Caudio-classification\u201D)"),hf=f(),Se=l("tr"),bo=l("td"),$f=s("Automatic speech recognition"),gf=f(),To=l("td"),_f=s("extract speech from an audio file into text"),vf=f(),Eo=l("td"),kf=s("Audio"),wf=f(),Ao=l("td"),yf=s("pipeline(task=\u201Cautomatic-speech-recognition\u201D)"),bf=f(),De=l("tr"),jo=l("td"),Tf=s("Visual question answering"),Ef=f(),qo=l("td"),Af=s("given an image and a question, correctly answer a question about the image"),jf=f(),zo=l("td"),qf=s("Multimodal"),zf=f(),xo=l("td"),xf=s("pipeline(task=\u201Cvqa\u201D)"),zn=f(),pe=l("p"),Pf=s("Start by creating an instance of "),$s=l("a"),Ff=s("pipeline()"),Mf=s(" and specifying a task you want to use it for. You can use the "),gs=l("a"),Cf=s("pipeline()"),Sf=s(" for any of the previously mentioned tasks, and for a complete list of supported tasks, take a look at the "),_s=l("a"),Df=s("pipeline API reference"),Of=s(". In this guide though, you\u2019ll use the "),vs=l("a"),Nf=s("pipeline()"),If=s(" for sentiment analysis as an example:"),xn=f(),k(ra.$$.fragment),Pn=f(),ve=l("p"),Lf=s("The "),ks=l("a"),Hf=s("pipeline()"),Wf=s(" downloads and caches a default "),oa=l("a"),Rf=s("pretrained model"),Yf=s(" and tokenizer for sentiment analysis. Now you can use the "),Po=l("code"),Uf=s("classifier"),Gf=s(" on your target text:"),Fn=f(),k(na.$$.fragment),Mn=f(),mt=l("p"),Bf=s("If you have more than one input, pass your inputs as a list to the "),ws=l("a"),Qf=s("pipeline()"),Vf=s(" to return a list of dictionaries:"),Cn=f(),k(la.$$.fragment),Sn=f(),dt=l("p"),Kf=s("The "),ys=l("a"),Jf=s("pipeline()"),Zf=s(" can also iterate over an entire dataset for any task you like. For this example, let\u2019s choose automatic speech recognition as our task:"),Dn=f(),k(ia.$$.fragment),On=f(),He=l("p"),Xf=s("Load an audio dataset (see the \u{1F917} Datasets "),pa=l("a"),ec=s("Quick Start"),tc=s(" for more details) you\u2019d like to iterate over. For example, load the "),fa=l("a"),ac=s("MInDS-14"),sc=s(" dataset:"),Nn=f(),k(ca.$$.fragment),In=f(),ht=l("p"),rc=s(`You need to make sure the sampling rate of the dataset matches the sampling
rate `),ua=l("a"),Fo=l("code"),oc=s("facebook/wav2vec2-base-960h"),nc=s(" was trained on:"),Ln=f(),k(ma.$$.fragment),Hn=f(),$t=l("p"),lc=s("The audio files are automatically loaded and resampled when calling the "),Mo=l("code"),ic=s('"audio"'),pc=s(` column.
Extract the raw waveform arrays from the first 4 samples and pass it as a list to the pipeline:`),Wn=f(),k(da.$$.fragment),Rn=f(),gt=l("p"),fc=s("For larger datasets where the inputs are big (like in speech or vision), you\u2019ll want to pass a generator instead of a list to load all the inputs in memory. Take a look at the "),bs=l("a"),cc=s("pipeline API reference"),uc=s(" for more information."),Yn=f(),et=l("h3"),_t=l("a"),Co=l("span"),k(ha.$$.fragment),mc=f(),So=l("span"),dc=s("Use another model and tokenizer in the pipeline"),Un=f(),fe=l("p"),hc=s("The "),Ts=l("a"),$c=s("pipeline()"),gc=s(" can accommodate any model from the "),$a=l("a"),_c=s("Hub"),vc=s(", making it easy to adapt the "),Es=l("a"),kc=s("pipeline()"),wc=s(" for other use-cases. For example, if you\u2019d like a model capable of handling French text, use the tags on the Hub to filter for an appropriate model. The top filtered result returns a multilingual "),ga=l("a"),yc=s("BERT model"),bc=s(" finetuned for sentiment analysis you can use for French text:"),Gn=f(),k(_a.$$.fragment),Bn=f(),k(vt.$$.fragment),Qn=f(),We=l("p"),Tc=s("Specify the model and tokenizer in the "),As=l("a"),Ec=s("pipeline()"),Ac=s(", and now you can apply the "),Do=l("code"),jc=s("classifier"),qc=s(" on French text:"),Vn=f(),k(va.$$.fragment),Kn=f(),Re=l("p"),zc=s("If you can\u2019t find a model for your use-case, you\u2019ll need to finetune a pretrained model on your data. Take a look at our "),js=l("a"),xc=s("finetuning tutorial"),Pc=s(" to learn how. Finally, after you\u2019ve finetuned your pretrained model, please consider "),qs=l("a"),Fc=s("sharing"),Mc=s(" the model with the community on the Hub to democratize machine learning for everyone! \u{1F917}"),Jn=f(),tt=l("h2"),kt=l("a"),Oo=l("span"),k(ka.$$.fragment),Cc=f(),No=l("span"),Sc=s("AutoClass"),Zn=f(),k(wa.$$.fragment),Xn=f(),re=l("p"),Dc=s("Under the hood, the "),zs=l("a"),Oc=s("AutoModelForSequenceClassification"),Nc=s(" and "),xs=l("a"),Ic=s("AutoTokenizer"),Lc=s(" classes work together to power the "),Ps=l("a"),Hc=s("pipeline()"),Wc=s(" you used above. An "),Fs=l("a"),Rc=s("AutoClass"),Yc=s(" is a shortcut that automatically retrieves the architecture of a pretrained model from it\u2019s name or path. You only need to select the appropriate "),Io=l("code"),Uc=s("AutoClass"),Gc=s(" for your task and it\u2019s associated preprocessing class."),el=f(),Ye=l("p"),Bc=s("Let\u2019s return to the example from the previous section and see how you can use the "),Lo=l("code"),Qc=s("AutoClass"),Vc=s(" to replicate the results of the "),Ms=l("a"),Kc=s("pipeline()"),Jc=s("."),tl=f(),at=l("h3"),wt=l("a"),Ho=l("span"),k(ya.$$.fragment),Zc=f(),Wo=l("span"),Xc=s("AutoTokenizer"),al=f(),yt=l("p"),eu=s("A tokenizer is responsible for preprocessing text into an array of numbers as inputs to a model. There are multiple rules that govern the tokenization process, including how to split a word and at what level words should be split (learn more about tokenization in the "),Cs=l("a"),tu=s("tokenizer summary"),au=s("). The most important thing to remember is you need to instantiate a tokenizer with the same model name to ensure you\u2019re using the same tokenization rules a model was pretrained with."),sl=f(),bt=l("p"),su=s("Load a tokenizer with "),Ss=l("a"),ru=s("AutoTokenizer"),ou=s(":"),rl=f(),k(ba.$$.fragment),ol=f(),Ds=l("p"),nu=s("Pass your text to the tokenizer:"),nl=f(),k(Ta.$$.fragment),ll=f(),Os=l("p"),lu=s("The tokenizer returns a dictionary containing:"),il=f(),Tt=l("ul"),Ns=l("li"),Is=l("a"),iu=s("input_ids"),pu=s(": numerical representions of your tokens."),fu=f(),Ls=l("li"),Hs=l("a"),cu=s("atttention_mask"),uu=s(": indicates which tokens should be attended to."),pl=f(),Ws=l("p"),mu=s("A tokenizer can also accept a list of inputs, and pad and truncate the text to return a batch with uniform length:"),fl=f(),k(Et.$$.fragment),cl=f(),k(At.$$.fragment),ul=f(),st=l("h3"),jt=l("a"),Ro=l("span"),k(Ea.$$.fragment),du=f(),Yo=l("span"),hu=s("AutoModel"),ml=f(),k(qt.$$.fragment),dl=f(),k(zt.$$.fragment),hl=f(),rt=l("h3"),xt=l("a"),Uo=l("span"),k(Aa.$$.fragment),$u=f(),Go=l("span"),gu=s("Save a model"),$l=f(),k(Pt.$$.fragment),gl=f(),Ue=l("p"),_u=s("One particularly cool \u{1F917} Transformers feature is the ability to save a model and reload it as either a PyTorch or TensorFlow model. The "),Bo=l("code"),vu=s("from_pt"),ku=s(" or "),Qo=l("code"),wu=s("from_tf"),yu=s(" parameter can convert the model from one framework to the other:"),_l=f(),k(Ft.$$.fragment),vl=f(),ot=l("h2"),Mt=l("a"),Vo=l("span"),k(ja.$$.fragment),bu=f(),Ko=l("span"),Tu=s("Custom model builds"),kl=f(),Rs=l("p"),Eu=s("You can modify the model\u2019s configuration class to change how a model is built. The configuration specifies a model\u2019s attributes, such as the number of hidden layers or attention heads. You start from scratch when you initialize a model from a custom configuration class. The model attributes are randomly initialized, and you\u2019ll need to train the model before you can use it to get meaningful results."),wl=f(),Ge=l("p"),Au=s("Start by importing "),Ys=l("a"),ju=s("AutoConfig"),qu=s(", and then load the pretrained model you want to modify. Within "),Us=l("a"),zu=s("AutoConfig.from_pretrained()"),xu=s(", you can specify the attribute you want to change, such as the number of attention heads:"),yl=f(),k(qa.$$.fragment),bl=f(),k(Ct.$$.fragment),Tl=f(),St=l("p"),Pu=s("Take a look at the "),Gs=l("a"),Fu=s("Create a custom architecture"),Mu=s(" guide for more information about building custom configurations."),El=f(),nt=l("h2"),Dt=l("a"),Jo=l("span"),k(za.$$.fragment),Cu=f(),Zo=l("span"),Su=s("Trainer - a PyTorch optimized training loop"),Al=f(),Be=l("p"),Du=s("All models are a standard "),xa=l("a"),Xo=l("code"),Ou=s("torch.nn.Module"),Nu=s(" so you can use them in any typical training loop. While you can write your own training loop, \u{1F917} Transformers provides a "),Bs=l("a"),Iu=s("Trainer"),Lu=s(" class for PyTorch, which contains the basic training loop and adds additional functionality for features like distributed training, mixed precision, and more."),jl=f(),Ot=l("p"),Hu=s("Depending on your task, you\u2019ll typically pass the following parameters to "),Qs=l("a"),Wu=s("Trainer"),Ru=s(":"),ql=f(),ce=l("ol"),Pa=l("li"),lt=l("p"),Yu=s("A "),Vs=l("a"),Uu=s("PreTrainedModel"),Gu=s(" or a "),Fa=l("a"),en=l("code"),Bu=s("torch.nn.Module"),Qu=s(":"),Vu=f(),k(Ma.$$.fragment),Ku=f(),Ca=l("li"),Ks=l("p"),Js=l("a"),Ju=s("TrainingArguments"),Zu=s(" contains the model hyperparameters you can change like learning rate, batch size, and the number of epochs to train for. The default values are used if you don\u2019t specify any training arguments:"),Xu=f(),k(Sa.$$.fragment),em=f(),Da=l("li"),tn=l("p"),tm=s("A preprocessing class like a tokenizer, feature extractor, or processor:"),am=f(),k(Oa.$$.fragment),sm=f(),Na=l("li"),an=l("p"),rm=s("Your preprocessed train and test datasets:"),om=f(),k(Ia.$$.fragment),nm=f(),La=l("li"),Ha=l("p"),lm=s("A "),sn=l("code"),im=s("DataCollator()"),pm=s(" to create a batch of examples from your dataset:"),fm=f(),k(Wa.$$.fragment),zl=f(),Nt=l("p"),cm=s("Now gather all these classes in "),Zs=l("a"),um=s("Trainer"),mm=s(":"),xl=f(),k(Ra.$$.fragment),Pl=f(),It=l("p"),dm=s("When you\u2019re ready, call "),Xs=l("a"),hm=s("train()"),$m=s(" to start training:"),Fl=f(),k(Ya.$$.fragment),Ml=f(),k(Lt.$$.fragment),Cl=f(),Qe=l("p"),gm=s("You can customize the training loop behavior by subclassing the methods inside "),er=l("a"),_m=s("Trainer"),vm=s(". This allows you to customize features such as the loss function, optimizer, and scheduler. Take a look at the "),tr=l("a"),km=s("Trainer"),wm=s(" reference for which methods can be subclassed."),Sl=f(),Ve=l("p"),ym=s("The other way to customize the training loop is by using "),ar=l("a"),bm=s("Callbacks"),Tm=s(". You can use callbacks to integrate with other libraries and inspect the training loop to report on progress or stop the training early. Callbacks do not modify anything in the training loop itself. To customize something like the loss function, you need to subclass the "),sr=l("a"),Em=s("Trainer"),Am=s(" instead."),Dl=f(),it=l("h2"),Ht=l("a"),rn=l("span"),k(Ua.$$.fragment),jm=f(),on=l("span"),qm=s("Train with TensorFlow"),Ol=f(),te=l("p"),zm=s("All models are a standard "),Ga=l("a"),nn=l("code"),xm=s("tf.keras.Model"),Pm=s(" so they can be trained in TensorFlow with the "),Ba=l("a"),Fm=s("Keras"),Mm=s(" API. \u{1F917} Transformers provides the "),rr=l("a"),Cm=s("prepare_tf_dataset()"),Sm=s(" method to easily load your dataset as a "),ln=l("code"),Dm=s("tf.data.Dataset"),Om=s(" so you can start training right away with Keras\u2019 "),Qa=l("a"),pn=l("code"),Nm=s("compile"),Im=s(" and "),Va=l("a"),fn=l("code"),Lm=s("fit"),Hm=s(" methods."),Nl=f(),Ke=l("ol"),Ka=l("li"),pt=l("p"),Wm=s("You\u2019ll start with a "),or=l("a"),Rm=s("TFPreTrainedModel"),Ym=s(" or a "),Ja=l("a"),cn=l("code"),Um=s("tf.keras.Model"),Gm=s(":"),Bm=f(),k(Za.$$.fragment),Qm=f(),Xa=l("li"),un=l("p"),Vm=s("A preprocessing class like a tokenizer, feature extractor, or processor:"),Km=f(),k(es.$$.fragment),Jm=f(),ts=l("li"),as=l("p"),Zm=s("Tokenize the dataset and pass it and the tokenizer to "),nr=l("a"),Xm=s("prepare_tf_dataset()"),ed=s(". You can also change the batch size and shuffle the dataset here if you\u2019d like:"),td=f(),k(ss.$$.fragment),Il=f(),lr=l("blockquote"),mn=l("blockquote"),rs=l("blockquote"),dn=l("p"),ad=s(`dataset = dataset.map(tokenize_dataset)
tf_dataset = model.prepare_tf_dataset(dataset, batch_size=16, shuffle=True, tokenizer=tokenizer)`),sd=f(),k(os.$$.fragment),Ll=f(),ns=l("ol"),ls=l("li"),ft=l("p"),rd=s("When you\u2019re ready, you can call "),hn=l("code"),od=s("compile"),nd=s(" and "),$n=l("code"),ld=s("fit"),id=s(" to start training:"),pd=f(),k(is.$$.fragment),Hl=f(),ct=l("h2"),Wt=l("a"),gn=l("span"),k(ps.$$.fragment),fd=f(),_n=l("span"),cd=s("What's next?"),Wl=f(),ir=l("p"),ud=s("Now that you\u2019ve completed the \u{1F917} Transformers quick tour, check out our guides and learn how to do more specific things like writing a custom model, fine-tuning a model for a task, and how to train a model with a script. If you\u2019re interested in learning more about \u{1F917} Transformers core concepts, grab a cup of coffee and take a look at our Conceptual Guides!"),this.h()},l(t){const u=Fg('[data-svelte="svelte-1phssyn"]',document.head);o=i(u,"META",{name:!0,content:!0}),u.forEach(a),d=c(t),n=i(t,"H1",{class:!0});var fs=p(n);$=i(fs,"A",{id:!0,class:!0,href:!0});var vn=p($);_=i(vn,"SPAN",{});var kn=p(_);w(v.$$.fragment,kn),kn.forEach(a),vn.forEach(a),q=c(fs),F=i(fs,"SPAN",{});var wn=p(F);g=r(wn,"Quick tour"),wn.forEach(a),fs.forEach(a),j=c(t),w(S.$$.fragment,t),N=c(t),O=i(t,"P",{});var Oe=p(O);W=r(Oe,"Get up and running with \u{1F917} Transformers! Whether you\u2019re a developer or an everyday user, this quick tour will help you get started and show you how to use the "),z=i(Oe,"A",{href:!0});var yn=p(z);C=r(yn,"pipeline()"),yn.forEach(a),A=r(Oe," for inference, load a pretrained model and preprocessor with an "),D=i(Oe,"A",{href:!0});var bn=p(D);G=r(bn,"AutoClass"),bn.forEach(a),R=r(Oe,", and quickly train a model with PyTorch or TensorFlow. If you\u2019re a beginner, we recommend checking out our tutorials or "),V=i(Oe,"A",{href:!0,rel:!0});var Tn=p(V);ie=r(Tn,"course"),Tn.forEach(a),oe=r(Oe," next for more in-depth explanations of the concepts introduced here."),Oe.forEach(a),de=c(t),B=i(t,"P",{});var En=p(B);ne=r(En,"Before you begin, make sure you have all the necessary libraries installed:"),En.forEach(a),le=c(t),w(Q.$$.fragment,t),$e=c(t),J=i(t,"P",{});var An=p(J);ye=r(An,"You\u2019ll also need to install your preferred machine learning framework:"),An.forEach(a),ge=c(t),w(K.$$.fragment,t),se=c(t),Z=i(t,"H2",{class:!0});var Yl=p(Z);x=i(Yl,"A",{id:!0,class:!0,href:!0});var $d=p(x);L=i($d,"SPAN",{});var gd=p(L);w(X.$$.fragment,gd),gd.forEach(a),$d.forEach(a),M=c(Yl),H=i(Yl,"SPAN",{});var _d=p(H);_e=r(_d,"Pipeline"),_d.forEach(a),Yl.forEach(a),Ie=c(t),w(ae.$$.fragment,t),Le=c(t),ee=i(t,"P",{});var pr=p(ee);us=r(pr,"The "),he=i(pr,"A",{href:!0});var vd=p(he);ms=r(vd,"pipeline()"),vd.forEach(a),ds=r(pr," is the easiest way to use a pretrained model for inference. You can use the "),hs=i(pr,"A",{href:!0});var kd=p(hs);Ei=r(kd,"pipeline()"),kd.forEach(a),Ai=r(pr," out-of-the-box for many tasks across different modalities. Take a look at the table below for some supported tasks:"),pr.forEach(a),qn=c(t),ut=i(t,"TABLE",{});var Ul=p(ut);br=i(Ul,"THEAD",{});var wd=p(br);be=i(wd,"TR",{});var Rt=p(be);Tr=i(Rt,"TH",{});var yd=p(Tr);Er=i(yd,"STRONG",{});var bd=p(Er);ji=r(bd,"Task"),bd.forEach(a),yd.forEach(a),qi=c(Rt),Ar=i(Rt,"TH",{});var Td=p(Ar);jr=i(Td,"STRONG",{});var Ed=p(jr);zi=r(Ed,"Description"),Ed.forEach(a),Td.forEach(a),xi=c(Rt),qr=i(Rt,"TH",{});var Ad=p(qr);zr=i(Ad,"STRONG",{});var jd=p(zr);Pi=r(jd,"Modality"),jd.forEach(a),Ad.forEach(a),Fi=c(Rt),xr=i(Rt,"TH",{});var qd=p(xr);Pr=i(qd,"STRONG",{});var zd=p(Pr);Mi=r(zd,"Pipeline identifier"),zd.forEach(a),qd.forEach(a),Rt.forEach(a),wd.forEach(a),Ci=c(Ul),Y=i(Ul,"TBODY",{});var U=p(Y);Te=i(U,"TR",{});var Yt=p(Te);Fr=i(Yt,"TD",{});var xd=p(Fr);Si=r(xd,"Text classification"),xd.forEach(a),Di=c(Yt),Mr=i(Yt,"TD",{});var Pd=p(Mr);Oi=r(Pd,"assign a label to a given sequence of text"),Pd.forEach(a),Ni=c(Yt),Cr=i(Yt,"TD",{});var Fd=p(Cr);Ii=r(Fd,"NLP"),Fd.forEach(a),Li=c(Yt),Sr=i(Yt,"TD",{});var Md=p(Sr);Hi=r(Md,"pipeline(task=\u201Csentiment-analysis\u201D)"),Md.forEach(a),Yt.forEach(a),Wi=c(U),Ee=i(U,"TR",{});var Ut=p(Ee);Dr=i(Ut,"TD",{});var Cd=p(Dr);Ri=r(Cd,"Text generation"),Cd.forEach(a),Yi=c(Ut),Or=i(Ut,"TD",{});var Sd=p(Or);Ui=r(Sd,"generate text that follows a given prompt"),Sd.forEach(a),Gi=c(Ut),Nr=i(Ut,"TD",{});var Dd=p(Nr);Bi=r(Dd,"NLP"),Dd.forEach(a),Qi=c(Ut),Ir=i(Ut,"TD",{});var Od=p(Ir);Vi=r(Od,"pipeline(task=\u201Ctext-generation\u201D)"),Od.forEach(a),Ut.forEach(a),Ki=c(U),Ae=i(U,"TR",{});var Gt=p(Ae);Lr=i(Gt,"TD",{});var Nd=p(Lr);Ji=r(Nd,"Name entity recognition"),Nd.forEach(a),Zi=c(Gt),Hr=i(Gt,"TD",{});var Id=p(Hr);Xi=r(Id,"assign a label to each token in a sequence (people, organization, location, etc.)"),Id.forEach(a),ep=c(Gt),Wr=i(Gt,"TD",{});var Ld=p(Wr);tp=r(Ld,"NLP"),Ld.forEach(a),ap=c(Gt),Rr=i(Gt,"TD",{});var Hd=p(Rr);sp=r(Hd,"pipeline(task=\u201Cner\u201D)"),Hd.forEach(a),Gt.forEach(a),rp=c(U),je=i(U,"TR",{});var Bt=p(je);Yr=i(Bt,"TD",{});var Wd=p(Yr);op=r(Wd,"Question answering"),Wd.forEach(a),np=c(Bt),Ur=i(Bt,"TD",{});var Rd=p(Ur);lp=r(Rd,"extract an answer from the text given some context and a question"),Rd.forEach(a),ip=c(Bt),Gr=i(Bt,"TD",{});var Yd=p(Gr);pp=r(Yd,"NLP"),Yd.forEach(a),fp=c(Bt),Br=i(Bt,"TD",{});var Ud=p(Br);cp=r(Ud,"pipeline(task=\u201Cquestion-answering\u201D)"),Ud.forEach(a),Bt.forEach(a),up=c(U),qe=i(U,"TR",{});var Qt=p(qe);Qr=i(Qt,"TD",{});var Gd=p(Qr);mp=r(Gd,"Fill-mask"),Gd.forEach(a),dp=c(Qt),Vr=i(Qt,"TD",{});var Bd=p(Vr);hp=r(Bd,"predict the correct masked token in a sequence"),Bd.forEach(a),$p=c(Qt),Kr=i(Qt,"TD",{});var Qd=p(Kr);gp=r(Qd,"NLP"),Qd.forEach(a),_p=c(Qt),Jr=i(Qt,"TD",{});var Vd=p(Jr);vp=r(Vd,"pipeline(task=\u201Cfill-mask\u201D)"),Vd.forEach(a),Qt.forEach(a),kp=c(U),ze=i(U,"TR",{});var Vt=p(ze);Zr=i(Vt,"TD",{});var Kd=p(Zr);wp=r(Kd,"Summarization"),Kd.forEach(a),yp=c(Vt),Xr=i(Vt,"TD",{});var Jd=p(Xr);bp=r(Jd,"generate a summary of a sequence of text or document"),Jd.forEach(a),Tp=c(Vt),eo=i(Vt,"TD",{});var Zd=p(eo);Ep=r(Zd,"NLP"),Zd.forEach(a),Ap=c(Vt),to=i(Vt,"TD",{});var Xd=p(to);jp=r(Xd,"pipeline(task=\u201Csummarization\u201D)"),Xd.forEach(a),Vt.forEach(a),qp=c(U),xe=i(U,"TR",{});var Kt=p(xe);ao=i(Kt,"TD",{});var eh=p(ao);zp=r(eh,"Translation"),eh.forEach(a),xp=c(Kt),so=i(Kt,"TD",{});var th=p(so);Pp=r(th,"translate text from one language into another"),th.forEach(a),Fp=c(Kt),ro=i(Kt,"TD",{});var ah=p(ro);Mp=r(ah,"NLP"),ah.forEach(a),Cp=c(Kt),oo=i(Kt,"TD",{});var sh=p(oo);Sp=r(sh,"pipeline(task=\u201Ctranslation\u201D)"),sh.forEach(a),Kt.forEach(a),Dp=c(U),Pe=i(U,"TR",{});var Jt=p(Pe);no=i(Jt,"TD",{});var rh=p(no);Op=r(rh,"Image classification"),rh.forEach(a),Np=c(Jt),lo=i(Jt,"TD",{});var oh=p(lo);Ip=r(oh,"assign a label to an image"),oh.forEach(a),Lp=c(Jt),io=i(Jt,"TD",{});var nh=p(io);Hp=r(nh,"Computer vision"),nh.forEach(a),Wp=c(Jt),po=i(Jt,"TD",{});var lh=p(po);Rp=r(lh,"pipeline(task=\u201Cimage-classification\u201D)"),lh.forEach(a),Jt.forEach(a),Yp=c(U),Fe=i(U,"TR",{});var Zt=p(Fe);fo=i(Zt,"TD",{});var ih=p(fo);Up=r(ih,"Image segmentation"),ih.forEach(a),Gp=c(Zt),co=i(Zt,"TD",{});var ph=p(co);Bp=r(ph,"assign a label to each individual pixel of an image (supports semantic, panoptic, and instance segmentation)"),ph.forEach(a),Qp=c(Zt),uo=i(Zt,"TD",{});var fh=p(uo);Vp=r(fh,"Computer vision"),fh.forEach(a),Kp=c(Zt),mo=i(Zt,"TD",{});var ch=p(mo);Jp=r(ch,"pipeline(task=\u201Cimage-segmentation\u201D)"),ch.forEach(a),Zt.forEach(a),Zp=c(U),Me=i(U,"TR",{});var Xt=p(Me);ho=i(Xt,"TD",{});var uh=p(ho);Xp=r(uh,"Object detection"),uh.forEach(a),ef=c(Xt),$o=i(Xt,"TD",{});var mh=p($o);tf=r(mh,"predict the bounding boxes and classes of objects in an image"),mh.forEach(a),af=c(Xt),go=i(Xt,"TD",{});var dh=p(go);sf=r(dh,"Computer vision"),dh.forEach(a),rf=c(Xt),_o=i(Xt,"TD",{});var hh=p(_o);of=r(hh,"pipeline(task=\u201Cobject-detection\u201D)"),hh.forEach(a),Xt.forEach(a),nf=c(U),Ce=i(U,"TR",{});var ea=p(Ce);vo=i(ea,"TD",{});var $h=p(vo);lf=r($h,"Audio classification"),$h.forEach(a),pf=c(ea),ko=i(ea,"TD",{});var gh=p(ko);ff=r(gh,"assign a label to an audio file"),gh.forEach(a),cf=c(ea),wo=i(ea,"TD",{});var _h=p(wo);uf=r(_h,"Audio"),_h.forEach(a),mf=c(ea),yo=i(ea,"TD",{});var vh=p(yo);df=r(vh,"pipeline(task=\u201Caudio-classification\u201D)"),vh.forEach(a),ea.forEach(a),hf=c(U),Se=i(U,"TR",{});var ta=p(Se);bo=i(ta,"TD",{});var kh=p(bo);$f=r(kh,"Automatic speech recognition"),kh.forEach(a),gf=c(ta),To=i(ta,"TD",{});var wh=p(To);_f=r(wh,"extract speech from an audio file into text"),wh.forEach(a),vf=c(ta),Eo=i(ta,"TD",{});var yh=p(Eo);kf=r(yh,"Audio"),yh.forEach(a),wf=c(ta),Ao=i(ta,"TD",{});var bh=p(Ao);yf=r(bh,"pipeline(task=\u201Cautomatic-speech-recognition\u201D)"),bh.forEach(a),ta.forEach(a),bf=c(U),De=i(U,"TR",{});var aa=p(De);jo=i(aa,"TD",{});var Th=p(jo);Tf=r(Th,"Visual question answering"),Th.forEach(a),Ef=c(aa),qo=i(aa,"TD",{});var Eh=p(qo);Af=r(Eh,"given an image and a question, correctly answer a question about the image"),Eh.forEach(a),jf=c(aa),zo=i(aa,"TD",{});var Ah=p(zo);qf=r(Ah,"Multimodal"),Ah.forEach(a),zf=c(aa),xo=i(aa,"TD",{});var jh=p(xo);xf=r(jh,"pipeline(task=\u201Cvqa\u201D)"),jh.forEach(a),aa.forEach(a),U.forEach(a),Ul.forEach(a),zn=c(t),pe=i(t,"P",{});var Je=p(pe);Pf=r(Je,"Start by creating an instance of "),$s=i(Je,"A",{href:!0});var qh=p($s);Ff=r(qh,"pipeline()"),qh.forEach(a),Mf=r(Je," and specifying a task you want to use it for. You can use the "),gs=i(Je,"A",{href:!0});var zh=p(gs);Cf=r(zh,"pipeline()"),zh.forEach(a),Sf=r(Je," for any of the previously mentioned tasks, and for a complete list of supported tasks, take a look at the "),_s=i(Je,"A",{href:!0});var xh=p(_s);Df=r(xh,"pipeline API reference"),xh.forEach(a),Of=r(Je,". In this guide though, you\u2019ll use the "),vs=i(Je,"A",{href:!0});var Ph=p(vs);Nf=r(Ph,"pipeline()"),Ph.forEach(a),If=r(Je," for sentiment analysis as an example:"),Je.forEach(a),xn=c(t),w(ra.$$.fragment,t),Pn=c(t),ve=i(t,"P",{});var sa=p(ve);Lf=r(sa,"The "),ks=i(sa,"A",{href:!0});var Fh=p(ks);Hf=r(Fh,"pipeline()"),Fh.forEach(a),Wf=r(sa," downloads and caches a default "),oa=i(sa,"A",{href:!0,rel:!0});var Mh=p(oa);Rf=r(Mh,"pretrained model"),Mh.forEach(a),Yf=r(sa," and tokenizer for sentiment analysis. Now you can use the "),Po=i(sa,"CODE",{});var Ch=p(Po);Uf=r(Ch,"classifier"),Ch.forEach(a),Gf=r(sa," on your target text:"),sa.forEach(a),Fn=c(t),w(na.$$.fragment,t),Mn=c(t),mt=i(t,"P",{});var Gl=p(mt);Bf=r(Gl,"If you have more than one input, pass your inputs as a list to the "),ws=i(Gl,"A",{href:!0});var Sh=p(ws);Qf=r(Sh,"pipeline()"),Sh.forEach(a),Vf=r(Gl," to return a list of dictionaries:"),Gl.forEach(a),Cn=c(t),w(la.$$.fragment,t),Sn=c(t),dt=i(t,"P",{});var Bl=p(dt);Kf=r(Bl,"The "),ys=i(Bl,"A",{href:!0});var Dh=p(ys);Jf=r(Dh,"pipeline()"),Dh.forEach(a),Zf=r(Bl," can also iterate over an entire dataset for any task you like. For this example, let\u2019s choose automatic speech recognition as our task:"),Bl.forEach(a),Dn=c(t),w(ia.$$.fragment,t),On=c(t),He=i(t,"P",{});var fr=p(He);Xf=r(fr,"Load an audio dataset (see the \u{1F917} Datasets "),pa=i(fr,"A",{href:!0,rel:!0});var Oh=p(pa);ec=r(Oh,"Quick Start"),Oh.forEach(a),tc=r(fr," for more details) you\u2019d like to iterate over. For example, load the "),fa=i(fr,"A",{href:!0,rel:!0});var Nh=p(fa);ac=r(Nh,"MInDS-14"),Nh.forEach(a),sc=r(fr," dataset:"),fr.forEach(a),Nn=c(t),w(ca.$$.fragment,t),In=c(t),ht=i(t,"P",{});var Ql=p(ht);rc=r(Ql,`You need to make sure the sampling rate of the dataset matches the sampling
rate `),ua=i(Ql,"A",{href:!0,rel:!0});var Ih=p(ua);Fo=i(Ih,"CODE",{});var Lh=p(Fo);oc=r(Lh,"facebook/wav2vec2-base-960h"),Lh.forEach(a),Ih.forEach(a),nc=r(Ql," was trained on:"),Ql.forEach(a),Ln=c(t),w(ma.$$.fragment,t),Hn=c(t),$t=i(t,"P",{});var Vl=p($t);lc=r(Vl,"The audio files are automatically loaded and resampled when calling the "),Mo=i(Vl,"CODE",{});var Hh=p(Mo);ic=r(Hh,'"audio"'),Hh.forEach(a),pc=r(Vl,` column.
Extract the raw waveform arrays from the first 4 samples and pass it as a list to the pipeline:`),Vl.forEach(a),Wn=c(t),w(da.$$.fragment,t),Rn=c(t),gt=i(t,"P",{});var Kl=p(gt);fc=r(Kl,"For larger datasets where the inputs are big (like in speech or vision), you\u2019ll want to pass a generator instead of a list to load all the inputs in memory. Take a look at the "),bs=i(Kl,"A",{href:!0});var Wh=p(bs);cc=r(Wh,"pipeline API reference"),Wh.forEach(a),uc=r(Kl," for more information."),Kl.forEach(a),Yn=c(t),et=i(t,"H3",{class:!0});var Jl=p(et);_t=i(Jl,"A",{id:!0,class:!0,href:!0});var Rh=p(_t);Co=i(Rh,"SPAN",{});var Yh=p(Co);w(ha.$$.fragment,Yh),Yh.forEach(a),Rh.forEach(a),mc=c(Jl),So=i(Jl,"SPAN",{});var Uh=p(So);dc=r(Uh,"Use another model and tokenizer in the pipeline"),Uh.forEach(a),Jl.forEach(a),Un=c(t),fe=i(t,"P",{});var Ze=p(fe);hc=r(Ze,"The "),Ts=i(Ze,"A",{href:!0});var Gh=p(Ts);$c=r(Gh,"pipeline()"),Gh.forEach(a),gc=r(Ze," can accommodate any model from the "),$a=i(Ze,"A",{href:!0,rel:!0});var Bh=p($a);_c=r(Bh,"Hub"),Bh.forEach(a),vc=r(Ze,", making it easy to adapt the "),Es=i(Ze,"A",{href:!0});var Qh=p(Es);kc=r(Qh,"pipeline()"),Qh.forEach(a),wc=r(Ze," for other use-cases. For example, if you\u2019d like a model capable of handling French text, use the tags on the Hub to filter for an appropriate model. The top filtered result returns a multilingual "),ga=i(Ze,"A",{href:!0,rel:!0});var Vh=p(ga);yc=r(Vh,"BERT model"),Vh.forEach(a),bc=r(Ze," finetuned for sentiment analysis you can use for French text:"),Ze.forEach(a),Gn=c(t),w(_a.$$.fragment,t),Bn=c(t),w(vt.$$.fragment,t),Qn=c(t),We=i(t,"P",{});var cr=p(We);Tc=r(cr,"Specify the model and tokenizer in the "),As=i(cr,"A",{href:!0});var Kh=p(As);Ec=r(Kh,"pipeline()"),Kh.forEach(a),Ac=r(cr,", and now you can apply the "),Do=i(cr,"CODE",{});var Jh=p(Do);jc=r(Jh,"classifier"),Jh.forEach(a),qc=r(cr," on French text:"),cr.forEach(a),Vn=c(t),w(va.$$.fragment,t),Kn=c(t),Re=i(t,"P",{});var ur=p(Re);zc=r(ur,"If you can\u2019t find a model for your use-case, you\u2019ll need to finetune a pretrained model on your data. Take a look at our "),js=i(ur,"A",{href:!0});var Zh=p(js);xc=r(Zh,"finetuning tutorial"),Zh.forEach(a),Pc=r(ur," to learn how. Finally, after you\u2019ve finetuned your pretrained model, please consider "),qs=i(ur,"A",{href:!0});var Xh=p(qs);Fc=r(Xh,"sharing"),Xh.forEach(a),Mc=r(ur," the model with the community on the Hub to democratize machine learning for everyone! \u{1F917}"),ur.forEach(a),Jn=c(t),tt=i(t,"H2",{class:!0});var Zl=p(tt);kt=i(Zl,"A",{id:!0,class:!0,href:!0});var e$=p(kt);Oo=i(e$,"SPAN",{});var t$=p(Oo);w(ka.$$.fragment,t$),t$.forEach(a),e$.forEach(a),Cc=c(Zl),No=i(Zl,"SPAN",{});var a$=p(No);Sc=r(a$,"AutoClass"),a$.forEach(a),Zl.forEach(a),Zn=c(t),w(wa.$$.fragment,t),Xn=c(t),re=i(t,"P",{});var ke=p(re);Dc=r(ke,"Under the hood, the "),zs=i(ke,"A",{href:!0});var s$=p(zs);Oc=r(s$,"AutoModelForSequenceClassification"),s$.forEach(a),Nc=r(ke," and "),xs=i(ke,"A",{href:!0});var r$=p(xs);Ic=r(r$,"AutoTokenizer"),r$.forEach(a),Lc=r(ke," classes work together to power the "),Ps=i(ke,"A",{href:!0});var o$=p(Ps);Hc=r(o$,"pipeline()"),o$.forEach(a),Wc=r(ke," you used above. An "),Fs=i(ke,"A",{href:!0});var n$=p(Fs);Rc=r(n$,"AutoClass"),n$.forEach(a),Yc=r(ke," is a shortcut that automatically retrieves the architecture of a pretrained model from it\u2019s name or path. You only need to select the appropriate "),Io=i(ke,"CODE",{});var l$=p(Io);Uc=r(l$,"AutoClass"),l$.forEach(a),Gc=r(ke," for your task and it\u2019s associated preprocessing class."),ke.forEach(a),el=c(t),Ye=i(t,"P",{});var mr=p(Ye);Bc=r(mr,"Let\u2019s return to the example from the previous section and see how you can use the "),Lo=i(mr,"CODE",{});var i$=p(Lo);Qc=r(i$,"AutoClass"),i$.forEach(a),Vc=r(mr," to replicate the results of the "),Ms=i(mr,"A",{href:!0});var p$=p(Ms);Kc=r(p$,"pipeline()"),p$.forEach(a),Jc=r(mr,"."),mr.forEach(a),tl=c(t),at=i(t,"H3",{class:!0});var Xl=p(at);wt=i(Xl,"A",{id:!0,class:!0,href:!0});var f$=p(wt);Ho=i(f$,"SPAN",{});var c$=p(Ho);w(ya.$$.fragment,c$),c$.forEach(a),f$.forEach(a),Zc=c(Xl),Wo=i(Xl,"SPAN",{});var u$=p(Wo);Xc=r(u$,"AutoTokenizer"),u$.forEach(a),Xl.forEach(a),al=c(t),yt=i(t,"P",{});var ei=p(yt);eu=r(ei,"A tokenizer is responsible for preprocessing text into an array of numbers as inputs to a model. There are multiple rules that govern the tokenization process, including how to split a word and at what level words should be split (learn more about tokenization in the "),Cs=i(ei,"A",{href:!0});var m$=p(Cs);tu=r(m$,"tokenizer summary"),m$.forEach(a),au=r(ei,"). The most important thing to remember is you need to instantiate a tokenizer with the same model name to ensure you\u2019re using the same tokenization rules a model was pretrained with."),ei.forEach(a),sl=c(t),bt=i(t,"P",{});var ti=p(bt);su=r(ti,"Load a tokenizer with "),Ss=i(ti,"A",{href:!0});var d$=p(Ss);ru=r(d$,"AutoTokenizer"),d$.forEach(a),ou=r(ti,":"),ti.forEach(a),rl=c(t),w(ba.$$.fragment,t),ol=c(t),Ds=i(t,"P",{});var h$=p(Ds);nu=r(h$,"Pass your text to the tokenizer:"),h$.forEach(a),nl=c(t),w(Ta.$$.fragment,t),ll=c(t),Os=i(t,"P",{});var $$=p(Os);lu=r($$,"The tokenizer returns a dictionary containing:"),$$.forEach(a),il=c(t),Tt=i(t,"UL",{});var ai=p(Tt);Ns=i(ai,"LI",{});var md=p(Ns);Is=i(md,"A",{href:!0});var g$=p(Is);iu=r(g$,"input_ids"),g$.forEach(a),pu=r(md,": numerical representions of your tokens."),md.forEach(a),fu=c(ai),Ls=i(ai,"LI",{});var dd=p(Ls);Hs=i(dd,"A",{href:!0});var _$=p(Hs);cu=r(_$,"atttention_mask"),_$.forEach(a),uu=r(dd,": indicates which tokens should be attended to."),dd.forEach(a),ai.forEach(a),pl=c(t),Ws=i(t,"P",{});var v$=p(Ws);mu=r(v$,"A tokenizer can also accept a list of inputs, and pad and truncate the text to return a batch with uniform length:"),v$.forEach(a),fl=c(t),w(Et.$$.fragment,t),cl=c(t),w(At.$$.fragment,t),ul=c(t),st=i(t,"H3",{class:!0});var si=p(st);jt=i(si,"A",{id:!0,class:!0,href:!0});var k$=p(jt);Ro=i(k$,"SPAN",{});var w$=p(Ro);w(Ea.$$.fragment,w$),w$.forEach(a),k$.forEach(a),du=c(si),Yo=i(si,"SPAN",{});var y$=p(Yo);hu=r(y$,"AutoModel"),y$.forEach(a),si.forEach(a),ml=c(t),w(qt.$$.fragment,t),dl=c(t),w(zt.$$.fragment,t),hl=c(t),rt=i(t,"H3",{class:!0});var ri=p(rt);xt=i(ri,"A",{id:!0,class:!0,href:!0});var b$=p(xt);Uo=i(b$,"SPAN",{});var T$=p(Uo);w(Aa.$$.fragment,T$),T$.forEach(a),b$.forEach(a),$u=c(ri),Go=i(ri,"SPAN",{});var E$=p(Go);gu=r(E$,"Save a model"),E$.forEach(a),ri.forEach(a),$l=c(t),w(Pt.$$.fragment,t),gl=c(t),Ue=i(t,"P",{});var dr=p(Ue);_u=r(dr,"One particularly cool \u{1F917} Transformers feature is the ability to save a model and reload it as either a PyTorch or TensorFlow model. The "),Bo=i(dr,"CODE",{});var A$=p(Bo);vu=r(A$,"from_pt"),A$.forEach(a),ku=r(dr," or "),Qo=i(dr,"CODE",{});var j$=p(Qo);wu=r(j$,"from_tf"),j$.forEach(a),yu=r(dr," parameter can convert the model from one framework to the other:"),dr.forEach(a),_l=c(t),w(Ft.$$.fragment,t),vl=c(t),ot=i(t,"H2",{class:!0});var oi=p(ot);Mt=i(oi,"A",{id:!0,class:!0,href:!0});var q$=p(Mt);Vo=i(q$,"SPAN",{});var z$=p(Vo);w(ja.$$.fragment,z$),z$.forEach(a),q$.forEach(a),bu=c(oi),Ko=i(oi,"SPAN",{});var x$=p(Ko);Tu=r(x$,"Custom model builds"),x$.forEach(a),oi.forEach(a),kl=c(t),Rs=i(t,"P",{});var P$=p(Rs);Eu=r(P$,"You can modify the model\u2019s configuration class to change how a model is built. The configuration specifies a model\u2019s attributes, such as the number of hidden layers or attention heads. You start from scratch when you initialize a model from a custom configuration class. The model attributes are randomly initialized, and you\u2019ll need to train the model before you can use it to get meaningful results."),P$.forEach(a),wl=c(t),Ge=i(t,"P",{});var hr=p(Ge);Au=r(hr,"Start by importing "),Ys=i(hr,"A",{href:!0});var F$=p(Ys);ju=r(F$,"AutoConfig"),F$.forEach(a),qu=r(hr,", and then load the pretrained model you want to modify. Within "),Us=i(hr,"A",{href:!0});var M$=p(Us);zu=r(M$,"AutoConfig.from_pretrained()"),M$.forEach(a),xu=r(hr,", you can specify the attribute you want to change, such as the number of attention heads:"),hr.forEach(a),yl=c(t),w(qa.$$.fragment,t),bl=c(t),w(Ct.$$.fragment,t),Tl=c(t),St=i(t,"P",{});var ni=p(St);Pu=r(ni,"Take a look at the "),Gs=i(ni,"A",{href:!0});var C$=p(Gs);Fu=r(C$,"Create a custom architecture"),C$.forEach(a),Mu=r(ni," guide for more information about building custom configurations."),ni.forEach(a),El=c(t),nt=i(t,"H2",{class:!0});var li=p(nt);Dt=i(li,"A",{id:!0,class:!0,href:!0});var S$=p(Dt);Jo=i(S$,"SPAN",{});var D$=p(Jo);w(za.$$.fragment,D$),D$.forEach(a),S$.forEach(a),Cu=c(li),Zo=i(li,"SPAN",{});var O$=p(Zo);Su=r(O$,"Trainer - a PyTorch optimized training loop"),O$.forEach(a),li.forEach(a),Al=c(t),Be=i(t,"P",{});var $r=p(Be);Du=r($r,"All models are a standard "),xa=i($r,"A",{href:!0,rel:!0});var N$=p(xa);Xo=i(N$,"CODE",{});var I$=p(Xo);Ou=r(I$,"torch.nn.Module"),I$.forEach(a),N$.forEach(a),Nu=r($r," so you can use them in any typical training loop. While you can write your own training loop, \u{1F917} Transformers provides a "),Bs=i($r,"A",{href:!0});var L$=p(Bs);Iu=r(L$,"Trainer"),L$.forEach(a),Lu=r($r," class for PyTorch, which contains the basic training loop and adds additional functionality for features like distributed training, mixed precision, and more."),$r.forEach(a),jl=c(t),Ot=i(t,"P",{});var ii=p(Ot);Hu=r(ii,"Depending on your task, you\u2019ll typically pass the following parameters to "),Qs=i(ii,"A",{href:!0});var H$=p(Qs);Wu=r(H$,"Trainer"),H$.forEach(a),Ru=r(ii,":"),ii.forEach(a),ql=c(t),ce=i(t,"OL",{});var Xe=p(ce);Pa=i(Xe,"LI",{});var pi=p(Pa);lt=i(pi,"P",{});var gr=p(lt);Yu=r(gr,"A "),Vs=i(gr,"A",{href:!0});var W$=p(Vs);Uu=r(W$,"PreTrainedModel"),W$.forEach(a),Gu=r(gr," or a "),Fa=i(gr,"A",{href:!0,rel:!0});var R$=p(Fa);en=i(R$,"CODE",{});var Y$=p(en);Bu=r(Y$,"torch.nn.Module"),Y$.forEach(a),R$.forEach(a),Qu=r(gr,":"),gr.forEach(a),Vu=c(pi),w(Ma.$$.fragment,pi),pi.forEach(a),Ku=c(Xe),Ca=i(Xe,"LI",{});var fi=p(Ca);Ks=i(fi,"P",{});var hd=p(Ks);Js=i(hd,"A",{href:!0});var U$=p(Js);Ju=r(U$,"TrainingArguments"),U$.forEach(a),Zu=r(hd," contains the model hyperparameters you can change like learning rate, batch size, and the number of epochs to train for. The default values are used if you don\u2019t specify any training arguments:"),hd.forEach(a),Xu=c(fi),w(Sa.$$.fragment,fi),fi.forEach(a),em=c(Xe),Da=i(Xe,"LI",{});var ci=p(Da);tn=i(ci,"P",{});var G$=p(tn);tm=r(G$,"A preprocessing class like a tokenizer, feature extractor, or processor:"),G$.forEach(a),am=c(ci),w(Oa.$$.fragment,ci),ci.forEach(a),sm=c(Xe),Na=i(Xe,"LI",{});var ui=p(Na);an=i(ui,"P",{});var B$=p(an);rm=r(B$,"Your preprocessed train and test datasets:"),B$.forEach(a),om=c(ui),w(Ia.$$.fragment,ui),ui.forEach(a),nm=c(Xe),La=i(Xe,"LI",{});var mi=p(La);Ha=i(mi,"P",{});var di=p(Ha);lm=r(di,"A "),sn=i(di,"CODE",{});var Q$=p(sn);im=r(Q$,"DataCollator()"),Q$.forEach(a),pm=r(di," to create a batch of examples from your dataset:"),di.forEach(a),fm=c(mi),w(Wa.$$.fragment,mi),mi.forEach(a),Xe.forEach(a),zl=c(t),Nt=i(t,"P",{});var hi=p(Nt);cm=r(hi,"Now gather all these classes in "),Zs=i(hi,"A",{href:!0});var V$=p(Zs);um=r(V$,"Trainer"),V$.forEach(a),mm=r(hi,":"),hi.forEach(a),xl=c(t),w(Ra.$$.fragment,t),Pl=c(t),It=i(t,"P",{});var $i=p(It);dm=r($i,"When you\u2019re ready, call "),Xs=i($i,"A",{href:!0});var K$=p(Xs);hm=r(K$,"train()"),K$.forEach(a),$m=r($i," to start training:"),$i.forEach(a),Fl=c(t),w(Ya.$$.fragment,t),Ml=c(t),w(Lt.$$.fragment,t),Cl=c(t),Qe=i(t,"P",{});var _r=p(Qe);gm=r(_r,"You can customize the training loop behavior by subclassing the methods inside "),er=i(_r,"A",{href:!0});var J$=p(er);_m=r(J$,"Trainer"),J$.forEach(a),vm=r(_r,". This allows you to customize features such as the loss function, optimizer, and scheduler. Take a look at the "),tr=i(_r,"A",{href:!0});var Z$=p(tr);km=r(Z$,"Trainer"),Z$.forEach(a),wm=r(_r," reference for which methods can be subclassed."),_r.forEach(a),Sl=c(t),Ve=i(t,"P",{});var vr=p(Ve);ym=r(vr,"The other way to customize the training loop is by using "),ar=i(vr,"A",{href:!0});var X$=p(ar);bm=r(X$,"Callbacks"),X$.forEach(a),Tm=r(vr,". You can use callbacks to integrate with other libraries and inspect the training loop to report on progress or stop the training early. Callbacks do not modify anything in the training loop itself. To customize something like the loss function, you need to subclass the "),sr=i(vr,"A",{href:!0});var eg=p(sr);Em=r(eg,"Trainer"),eg.forEach(a),Am=r(vr," instead."),vr.forEach(a),Dl=c(t),it=i(t,"H2",{class:!0});var gi=p(it);Ht=i(gi,"A",{id:!0,class:!0,href:!0});var tg=p(Ht);rn=i(tg,"SPAN",{});var ag=p(rn);w(Ua.$$.fragment,ag),ag.forEach(a),tg.forEach(a),jm=c(gi),on=i(gi,"SPAN",{});var sg=p(on);qm=r(sg,"Train with TensorFlow"),sg.forEach(a),gi.forEach(a),Ol=c(t),te=i(t,"P",{});var ue=p(te);zm=r(ue,"All models are a standard "),Ga=i(ue,"A",{href:!0,rel:!0});var rg=p(Ga);nn=i(rg,"CODE",{});var og=p(nn);xm=r(og,"tf.keras.Model"),og.forEach(a),rg.forEach(a),Pm=r(ue," so they can be trained in TensorFlow with the "),Ba=i(ue,"A",{href:!0,rel:!0});var ng=p(Ba);Fm=r(ng,"Keras"),ng.forEach(a),Mm=r(ue," API. \u{1F917} Transformers provides the "),rr=i(ue,"A",{href:!0});var lg=p(rr);Cm=r(lg,"prepare_tf_dataset()"),lg.forEach(a),Sm=r(ue," method to easily load your dataset as a "),ln=i(ue,"CODE",{});var ig=p(ln);Dm=r(ig,"tf.data.Dataset"),ig.forEach(a),Om=r(ue," so you can start training right away with Keras\u2019 "),Qa=i(ue,"A",{href:!0,rel:!0});var pg=p(Qa);pn=i(pg,"CODE",{});var fg=p(pn);Nm=r(fg,"compile"),fg.forEach(a),pg.forEach(a),Im=r(ue," and "),Va=i(ue,"A",{href:!0,rel:!0});var cg=p(Va);fn=i(cg,"CODE",{});var ug=p(fn);Lm=r(ug,"fit"),ug.forEach(a),cg.forEach(a),Hm=r(ue," methods."),ue.forEach(a),Nl=c(t),Ke=i(t,"OL",{});var kr=p(Ke);Ka=i(kr,"LI",{});var _i=p(Ka);pt=i(_i,"P",{});var wr=p(pt);Wm=r(wr,"You\u2019ll start with a "),or=i(wr,"A",{href:!0});var mg=p(or);Rm=r(mg,"TFPreTrainedModel"),mg.forEach(a),Ym=r(wr," or a "),Ja=i(wr,"A",{href:!0,rel:!0});var dg=p(Ja);cn=i(dg,"CODE",{});var hg=p(cn);Um=r(hg,"tf.keras.Model"),hg.forEach(a),dg.forEach(a),Gm=r(wr,":"),wr.forEach(a),Bm=c(_i),w(Za.$$.fragment,_i),_i.forEach(a),Qm=c(kr),Xa=i(kr,"LI",{});var vi=p(Xa);un=i(vi,"P",{});var $g=p(un);Vm=r($g,"A preprocessing class like a tokenizer, feature extractor, or processor:"),$g.forEach(a),Km=c(vi),w(es.$$.fragment,vi),vi.forEach(a),Jm=c(kr),ts=i(kr,"LI",{});var ki=p(ts);as=i(ki,"P",{});var wi=p(as);Zm=r(wi,"Tokenize the dataset and pass it and the tokenizer to "),nr=i(wi,"A",{href:!0});var gg=p(nr);Xm=r(gg,"prepare_tf_dataset()"),gg.forEach(a),ed=r(wi,". You can also change the batch size and shuffle the dataset here if you\u2019d like:"),wi.forEach(a),td=c(ki),w(ss.$$.fragment,ki),ki.forEach(a),kr.forEach(a),Il=c(t),lr=i(t,"BLOCKQUOTE",{});var _g=p(lr);mn=i(_g,"BLOCKQUOTE",{});var vg=p(mn);rs=i(vg,"BLOCKQUOTE",{});var yi=p(rs);dn=i(yi,"P",{});var kg=p(dn);ad=r(kg,`dataset = dataset.map(tokenize_dataset)
tf_dataset = model.prepare_tf_dataset(dataset, batch_size=16, shuffle=True, tokenizer=tokenizer)`),kg.forEach(a),sd=c(yi),w(os.$$.fragment,yi),yi.forEach(a),vg.forEach(a),_g.forEach(a),Ll=c(t),ns=i(t,"OL",{start:!0});var wg=p(ns);ls=i(wg,"LI",{});var bi=p(ls);ft=i(bi,"P",{});var yr=p(ft);rd=r(yr,"When you\u2019re ready, you can call "),hn=i(yr,"CODE",{});var yg=p(hn);od=r(yg,"compile"),yg.forEach(a),nd=r(yr," and "),$n=i(yr,"CODE",{});var bg=p($n);ld=r(bg,"fit"),bg.forEach(a),id=r(yr," to start training:"),yr.forEach(a),pd=c(bi),w(is.$$.fragment,bi),bi.forEach(a),wg.forEach(a),Hl=c(t),ct=i(t,"H2",{class:!0});var Ti=p(ct);Wt=i(Ti,"A",{id:!0,class:!0,href:!0});var Tg=p(Wt);gn=i(Tg,"SPAN",{});var Eg=p(gn);w(ps.$$.fragment,Eg),Eg.forEach(a),Tg.forEach(a),fd=c(Ti),_n=i(Ti,"SPAN",{});var Ag=p(_n);cd=r(Ag,"What's next?"),Ag.forEach(a),Ti.forEach(a),Wl=c(t),ir=i(t,"P",{});var jg=p(ir);ud=r(jg,"Now that you\u2019ve completed the \u{1F917} Transformers quick tour, check out our guides and learn how to do more specific things like writing a custom model, fine-tuning a model for a task, and how to train a model with a script. If you\u2019re interested in learning more about \u{1F917} Transformers core concepts, grab a cup of coffee and take a look at our Conceptual Guides!"),jg.forEach(a),this.h()},h(){h(o,"name","hf:doc:metadata"),h(o,"content",JSON.stringify(h_)),h($,"id","quick-tour"),h($,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h($,"href","#quick-tour"),h(n,"class","relative group"),h(z,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(D,"href","./model_doc/auto"),h(V,"href","https://huggingface.co/course/chapter1/1"),h(V,"rel","nofollow"),h(x,"id","pipeline"),h(x,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(x,"href","#pipeline"),h(Z,"class","relative group"),h(he,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(hs,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h($s,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(gs,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(_s,"href","./main_classes/pipelines"),h(vs,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(ks,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(oa,"href","https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english"),h(oa,"rel","nofollow"),h(ws,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(ys,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(pa,"href","https://huggingface.co/docs/datasets/quickstart#audio"),h(pa,"rel","nofollow"),h(fa,"href","https://huggingface.co/datasets/PolyAI/minds14"),h(fa,"rel","nofollow"),h(ua,"href","https://huggingface.co/facebook/wav2vec2-base-960h"),h(ua,"rel","nofollow"),h(bs,"href","./main_classes/pipelines"),h(_t,"id","use-another-model-and-tokenizer-in-the-pipeline"),h(_t,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(_t,"href","#use-another-model-and-tokenizer-in-the-pipeline"),h(et,"class","relative group"),h(Ts,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h($a,"href","https://huggingface.co/models"),h($a,"rel","nofollow"),h(Es,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(ga,"href","https://huggingface.co/nlptown/bert-base-multilingual-uncased-sentiment"),h(ga,"rel","nofollow"),h(As,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(js,"href","./training"),h(qs,"href","./model_sharing"),h(kt,"id","autoclass"),h(kt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(kt,"href","#autoclass"),h(tt,"class","relative group"),h(zs,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModelForSequenceClassification"),h(xs,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoTokenizer"),h(Ps,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(Fs,"href","./model_doc/auto"),h(Ms,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(wt,"id","autotokenizer"),h(wt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(wt,"href","#autotokenizer"),h(at,"class","relative group"),h(Cs,"href","./tokenizer_summary"),h(Ss,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoTokenizer"),h(Is,"href","./glossary#input-ids"),h(Hs,"href",".glossary#attention-mask"),h(jt,"id","automodel"),h(jt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(jt,"href","#automodel"),h(st,"class","relative group"),h(xt,"id","save-a-model"),h(xt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(xt,"href","#save-a-model"),h(rt,"class","relative group"),h(Mt,"id","custom-model-builds"),h(Mt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(Mt,"href","#custom-model-builds"),h(ot,"class","relative group"),h(Ys,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoConfig"),h(Us,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoConfig.from_pretrained"),h(Gs,"href","./create_a_model"),h(Dt,"id","trainer-a-pytorch-optimized-training-loop"),h(Dt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(Dt,"href","#trainer-a-pytorch-optimized-training-loop"),h(nt,"class","relative group"),h(xa,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),h(xa,"rel","nofollow"),h(Bs,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer"),h(Qs,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer"),h(Vs,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),h(Fa,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),h(Fa,"rel","nofollow"),h(Js,"href","/docs/transformers/main/en/main_classes/trainer#transformers.TrainingArguments"),h(Zs,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer"),h(Xs,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer.train"),h(er,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer"),h(tr,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer"),h(ar,"href","./main_classes/callbacks"),h(sr,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer"),h(Ht,"id","train-with-tensorflow"),h(Ht,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(Ht,"href","#train-with-tensorflow"),h(it,"class","relative group"),h(Ga,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),h(Ga,"rel","nofollow"),h(Ba,"href","https://keras.io/"),h(Ba,"rel","nofollow"),h(rr,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel.prepare_tf_dataset"),h(Qa,"href","https://keras.io/api/models/model_training_apis/#compile-method"),h(Qa,"rel","nofollow"),h(Va,"href","https://keras.io/api/models/model_training_apis/#fit-method"),h(Va,"rel","nofollow"),h(or,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),h(Ja,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),h(Ja,"rel","nofollow"),h(nr,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel.prepare_tf_dataset"),h(ns,"start","4"),h(Wt,"id","whats-next"),h(Wt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(Wt,"href","#whats-next"),h(ct,"class","relative group")},m(t,u){e(document.head,o),m(t,d,u),m(t,n,u),e(n,$),e($,_),y(v,_,null),e(n,q),e(n,F),e(F,g),m(t,j,u),y(S,t,u),m(t,N,u),m(t,O,u),e(O,W),e(O,z),e(z,C),e(O,A),e(O,D),e(D,G),e(O,R),e(O,V),e(V,ie),e(O,oe),m(t,de,u),m(t,B,u),e(B,ne),m(t,le,u),y(Q,t,u),m(t,$e,u),m(t,J,u),e(J,ye),m(t,ge,u),y(K,t,u),m(t,se,u),m(t,Z,u),e(Z,x),e(x,L),y(X,L,null),e(Z,M),e(Z,H),e(H,_e),m(t,Ie,u),y(ae,t,u),m(t,Le,u),m(t,ee,u),e(ee,us),e(ee,he),e(he,ms),e(ee,ds),e(ee,hs),e(hs,Ei),e(ee,Ai),m(t,qn,u),m(t,ut,u),e(ut,br),e(br,be),e(be,Tr),e(Tr,Er),e(Er,ji),e(be,qi),e(be,Ar),e(Ar,jr),e(jr,zi),e(be,xi),e(be,qr),e(qr,zr),e(zr,Pi),e(be,Fi),e(be,xr),e(xr,Pr),e(Pr,Mi),e(ut,Ci),e(ut,Y),e(Y,Te),e(Te,Fr),e(Fr,Si),e(Te,Di),e(Te,Mr),e(Mr,Oi),e(Te,Ni),e(Te,Cr),e(Cr,Ii),e(Te,Li),e(Te,Sr),e(Sr,Hi),e(Y,Wi),e(Y,Ee),e(Ee,Dr),e(Dr,Ri),e(Ee,Yi),e(Ee,Or),e(Or,Ui),e(Ee,Gi),e(Ee,Nr),e(Nr,Bi),e(Ee,Qi),e(Ee,Ir),e(Ir,Vi),e(Y,Ki),e(Y,Ae),e(Ae,Lr),e(Lr,Ji),e(Ae,Zi),e(Ae,Hr),e(Hr,Xi),e(Ae,ep),e(Ae,Wr),e(Wr,tp),e(Ae,ap),e(Ae,Rr),e(Rr,sp),e(Y,rp),e(Y,je),e(je,Yr),e(Yr,op),e(je,np),e(je,Ur),e(Ur,lp),e(je,ip),e(je,Gr),e(Gr,pp),e(je,fp),e(je,Br),e(Br,cp),e(Y,up),e(Y,qe),e(qe,Qr),e(Qr,mp),e(qe,dp),e(qe,Vr),e(Vr,hp),e(qe,$p),e(qe,Kr),e(Kr,gp),e(qe,_p),e(qe,Jr),e(Jr,vp),e(Y,kp),e(Y,ze),e(ze,Zr),e(Zr,wp),e(ze,yp),e(ze,Xr),e(Xr,bp),e(ze,Tp),e(ze,eo),e(eo,Ep),e(ze,Ap),e(ze,to),e(to,jp),e(Y,qp),e(Y,xe),e(xe,ao),e(ao,zp),e(xe,xp),e(xe,so),e(so,Pp),e(xe,Fp),e(xe,ro),e(ro,Mp),e(xe,Cp),e(xe,oo),e(oo,Sp),e(Y,Dp),e(Y,Pe),e(Pe,no),e(no,Op),e(Pe,Np),e(Pe,lo),e(lo,Ip),e(Pe,Lp),e(Pe,io),e(io,Hp),e(Pe,Wp),e(Pe,po),e(po,Rp),e(Y,Yp),e(Y,Fe),e(Fe,fo),e(fo,Up),e(Fe,Gp),e(Fe,co),e(co,Bp),e(Fe,Qp),e(Fe,uo),e(uo,Vp),e(Fe,Kp),e(Fe,mo),e(mo,Jp),e(Y,Zp),e(Y,Me),e(Me,ho),e(ho,Xp),e(Me,ef),e(Me,$o),e($o,tf),e(Me,af),e(Me,go),e(go,sf),e(Me,rf),e(Me,_o),e(_o,of),e(Y,nf),e(Y,Ce),e(Ce,vo),e(vo,lf),e(Ce,pf),e(Ce,ko),e(ko,ff),e(Ce,cf),e(Ce,wo),e(wo,uf),e(Ce,mf),e(Ce,yo),e(yo,df),e(Y,hf),e(Y,Se),e(Se,bo),e(bo,$f),e(Se,gf),e(Se,To),e(To,_f),e(Se,vf),e(Se,Eo),e(Eo,kf),e(Se,wf),e(Se,Ao),e(Ao,yf),e(Y,bf),e(Y,De),e(De,jo),e(jo,Tf),e(De,Ef),e(De,qo),e(qo,Af),e(De,jf),e(De,zo),e(zo,qf),e(De,zf),e(De,xo),e(xo,xf),m(t,zn,u),m(t,pe,u),e(pe,Pf),e(pe,$s),e($s,Ff),e(pe,Mf),e(pe,gs),e(gs,Cf),e(pe,Sf),e(pe,_s),e(_s,Df),e(pe,Of),e(pe,vs),e(vs,Nf),e(pe,If),m(t,xn,u),y(ra,t,u),m(t,Pn,u),m(t,ve,u),e(ve,Lf),e(ve,ks),e(ks,Hf),e(ve,Wf),e(ve,oa),e(oa,Rf),e(ve,Yf),e(ve,Po),e(Po,Uf),e(ve,Gf),m(t,Fn,u),y(na,t,u),m(t,Mn,u),m(t,mt,u),e(mt,Bf),e(mt,ws),e(ws,Qf),e(mt,Vf),m(t,Cn,u),y(la,t,u),m(t,Sn,u),m(t,dt,u),e(dt,Kf),e(dt,ys),e(ys,Jf),e(dt,Zf),m(t,Dn,u),y(ia,t,u),m(t,On,u),m(t,He,u),e(He,Xf),e(He,pa),e(pa,ec),e(He,tc),e(He,fa),e(fa,ac),e(He,sc),m(t,Nn,u),y(ca,t,u),m(t,In,u),m(t,ht,u),e(ht,rc),e(ht,ua),e(ua,Fo),e(Fo,oc),e(ht,nc),m(t,Ln,u),y(ma,t,u),m(t,Hn,u),m(t,$t,u),e($t,lc),e($t,Mo),e(Mo,ic),e($t,pc),m(t,Wn,u),y(da,t,u),m(t,Rn,u),m(t,gt,u),e(gt,fc),e(gt,bs),e(bs,cc),e(gt,uc),m(t,Yn,u),m(t,et,u),e(et,_t),e(_t,Co),y(ha,Co,null),e(et,mc),e(et,So),e(So,dc),m(t,Un,u),m(t,fe,u),e(fe,hc),e(fe,Ts),e(Ts,$c),e(fe,gc),e(fe,$a),e($a,_c),e(fe,vc),e(fe,Es),e(Es,kc),e(fe,wc),e(fe,ga),e(ga,yc),e(fe,bc),m(t,Gn,u),y(_a,t,u),m(t,Bn,u),y(vt,t,u),m(t,Qn,u),m(t,We,u),e(We,Tc),e(We,As),e(As,Ec),e(We,Ac),e(We,Do),e(Do,jc),e(We,qc),m(t,Vn,u),y(va,t,u),m(t,Kn,u),m(t,Re,u),e(Re,zc),e(Re,js),e(js,xc),e(Re,Pc),e(Re,qs),e(qs,Fc),e(Re,Mc),m(t,Jn,u),m(t,tt,u),e(tt,kt),e(kt,Oo),y(ka,Oo,null),e(tt,Cc),e(tt,No),e(No,Sc),m(t,Zn,u),y(wa,t,u),m(t,Xn,u),m(t,re,u),e(re,Dc),e(re,zs),e(zs,Oc),e(re,Nc),e(re,xs),e(xs,Ic),e(re,Lc),e(re,Ps),e(Ps,Hc),e(re,Wc),e(re,Fs),e(Fs,Rc),e(re,Yc),e(re,Io),e(Io,Uc),e(re,Gc),m(t,el,u),m(t,Ye,u),e(Ye,Bc),e(Ye,Lo),e(Lo,Qc),e(Ye,Vc),e(Ye,Ms),e(Ms,Kc),e(Ye,Jc),m(t,tl,u),m(t,at,u),e(at,wt),e(wt,Ho),y(ya,Ho,null),e(at,Zc),e(at,Wo),e(Wo,Xc),m(t,al,u),m(t,yt,u),e(yt,eu),e(yt,Cs),e(Cs,tu),e(yt,au),m(t,sl,u),m(t,bt,u),e(bt,su),e(bt,Ss),e(Ss,ru),e(bt,ou),m(t,rl,u),y(ba,t,u),m(t,ol,u),m(t,Ds,u),e(Ds,nu),m(t,nl,u),y(Ta,t,u),m(t,ll,u),m(t,Os,u),e(Os,lu),m(t,il,u),m(t,Tt,u),e(Tt,Ns),e(Ns,Is),e(Is,iu),e(Ns,pu),e(Tt,fu),e(Tt,Ls),e(Ls,Hs),e(Hs,cu),e(Ls,uu),m(t,pl,u),m(t,Ws,u),e(Ws,mu),m(t,fl,u),y(Et,t,u),m(t,cl,u),y(At,t,u),m(t,ul,u),m(t,st,u),e(st,jt),e(jt,Ro),y(Ea,Ro,null),e(st,du),e(st,Yo),e(Yo,hu),m(t,ml,u),y(qt,t,u),m(t,dl,u),y(zt,t,u),m(t,hl,u),m(t,rt,u),e(rt,xt),e(xt,Uo),y(Aa,Uo,null),e(rt,$u),e(rt,Go),e(Go,gu),m(t,$l,u),y(Pt,t,u),m(t,gl,u),m(t,Ue,u),e(Ue,_u),e(Ue,Bo),e(Bo,vu),e(Ue,ku),e(Ue,Qo),e(Qo,wu),e(Ue,yu),m(t,_l,u),y(Ft,t,u),m(t,vl,u),m(t,ot,u),e(ot,Mt),e(Mt,Vo),y(ja,Vo,null),e(ot,bu),e(ot,Ko),e(Ko,Tu),m(t,kl,u),m(t,Rs,u),e(Rs,Eu),m(t,wl,u),m(t,Ge,u),e(Ge,Au),e(Ge,Ys),e(Ys,ju),e(Ge,qu),e(Ge,Us),e(Us,zu),e(Ge,xu),m(t,yl,u),y(qa,t,u),m(t,bl,u),y(Ct,t,u),m(t,Tl,u),m(t,St,u),e(St,Pu),e(St,Gs),e(Gs,Fu),e(St,Mu),m(t,El,u),m(t,nt,u),e(nt,Dt),e(Dt,Jo),y(za,Jo,null),e(nt,Cu),e(nt,Zo),e(Zo,Su),m(t,Al,u),m(t,Be,u),e(Be,Du),e(Be,xa),e(xa,Xo),e(Xo,Ou),e(Be,Nu),e(Be,Bs),e(Bs,Iu),e(Be,Lu),m(t,jl,u),m(t,Ot,u),e(Ot,Hu),e(Ot,Qs),e(Qs,Wu),e(Ot,Ru),m(t,ql,u),m(t,ce,u),e(ce,Pa),e(Pa,lt),e(lt,Yu),e(lt,Vs),e(Vs,Uu),e(lt,Gu),e(lt,Fa),e(Fa,en),e(en,Bu),e(lt,Qu),e(Pa,Vu),y(Ma,Pa,null),e(ce,Ku),e(ce,Ca),e(Ca,Ks),e(Ks,Js),e(Js,Ju),e(Ks,Zu),e(Ca,Xu),y(Sa,Ca,null),e(ce,em),e(ce,Da),e(Da,tn),e(tn,tm),e(Da,am),y(Oa,Da,null),e(ce,sm),e(ce,Na),e(Na,an),e(an,rm),e(Na,om),y(Ia,Na,null),e(ce,nm),e(ce,La),e(La,Ha),e(Ha,lm),e(Ha,sn),e(sn,im),e(Ha,pm),e(La,fm),y(Wa,La,null),m(t,zl,u),m(t,Nt,u),e(Nt,cm),e(Nt,Zs),e(Zs,um),e(Nt,mm),m(t,xl,u),y(Ra,t,u),m(t,Pl,u),m(t,It,u),e(It,dm),e(It,Xs),e(Xs,hm),e(It,$m),m(t,Fl,u),y(Ya,t,u),m(t,Ml,u),y(Lt,t,u),m(t,Cl,u),m(t,Qe,u),e(Qe,gm),e(Qe,er),e(er,_m),e(Qe,vm),e(Qe,tr),e(tr,km),e(Qe,wm),m(t,Sl,u),m(t,Ve,u),e(Ve,ym),e(Ve,ar),e(ar,bm),e(Ve,Tm),e(Ve,sr),e(sr,Em),e(Ve,Am),m(t,Dl,u),m(t,it,u),e(it,Ht),e(Ht,rn),y(Ua,rn,null),e(it,jm),e(it,on),e(on,qm),m(t,Ol,u),m(t,te,u),e(te,zm),e(te,Ga),e(Ga,nn),e(nn,xm),e(te,Pm),e(te,Ba),e(Ba,Fm),e(te,Mm),e(te,rr),e(rr,Cm),e(te,Sm),e(te,ln),e(ln,Dm),e(te,Om),e(te,Qa),e(Qa,pn),e(pn,Nm),e(te,Im),e(te,Va),e(Va,fn),e(fn,Lm),e(te,Hm),m(t,Nl,u),m(t,Ke,u),e(Ke,Ka),e(Ka,pt),e(pt,Wm),e(pt,or),e(or,Rm),e(pt,Ym),e(pt,Ja),e(Ja,cn),e(cn,Um),e(pt,Gm),e(Ka,Bm),y(Za,Ka,null),e(Ke,Qm),e(Ke,Xa),e(Xa,un),e(un,Vm),e(Xa,Km),y(es,Xa,null),e(Ke,Jm),e(Ke,ts),e(ts,as),e(as,Zm),e(as,nr),e(nr,Xm),e(as,ed),e(ts,td),y(ss,ts,null),m(t,Il,u),m(t,lr,u),e(lr,mn),e(mn,rs),e(rs,dn),e(dn,ad),e(rs,sd),y(os,rs,null),m(t,Ll,u),m(t,ns,u),e(ns,ls),e(ls,ft),e(ft,rd),e(ft,hn),e(hn,od),e(ft,nd),e(ft,$n),e($n,ld),e(ft,id),e(ls,pd),y(is,ls,null),m(t,Hl,u),m(t,ct,u),e(ct,Wt),e(Wt,gn),y(ps,gn,null),e(ct,fd),e(ct,_n),e(_n,cd),m(t,Wl,u),m(t,ir,u),e(ir,ud),Rl=!0},p(t,[u]){const fs={};u&2&&(fs.$$scope={dirty:u,ctx:t}),K.$set(fs);const vn={};u&2&&(vn.$$scope={dirty:u,ctx:t}),vt.$set(vn);const kn={};u&2&&(kn.$$scope={dirty:u,ctx:t}),Et.$set(kn);const wn={};u&2&&(wn.$$scope={dirty:u,ctx:t}),At.$set(wn);const Oe={};u&2&&(Oe.$$scope={dirty:u,ctx:t}),qt.$set(Oe);const yn={};u&2&&(yn.$$scope={dirty:u,ctx:t}),zt.$set(yn);const bn={};u&2&&(bn.$$scope={dirty:u,ctx:t}),Pt.$set(bn);const Tn={};u&2&&(Tn.$$scope={dirty:u,ctx:t}),Ft.$set(Tn);const En={};u&2&&(En.$$scope={dirty:u,ctx:t}),Ct.$set(En);const An={};u&2&&(An.$$scope={dirty:u,ctx:t}),Lt.$set(An)},i(t){Rl||(b(v.$$.fragment,t),b(S.$$.fragment,t),b(Q.$$.fragment,t),b(K.$$.fragment,t),b(X.$$.fragment,t),b(ae.$$.fragment,t),b(ra.$$.fragment,t),b(na.$$.fragment,t),b(la.$$.fragment,t),b(ia.$$.fragment,t),b(ca.$$.fragment,t),b(ma.$$.fragment,t),b(da.$$.fragment,t),b(ha.$$.fragment,t),b(_a.$$.fragment,t),b(vt.$$.fragment,t),b(va.$$.fragment,t),b(ka.$$.fragment,t),b(wa.$$.fragment,t),b(ya.$$.fragment,t),b(ba.$$.fragment,t),b(Ta.$$.fragment,t),b(Et.$$.fragment,t),b(At.$$.fragment,t),b(Ea.$$.fragment,t),b(qt.$$.fragment,t),b(zt.$$.fragment,t),b(Aa.$$.fragment,t),b(Pt.$$.fragment,t),b(Ft.$$.fragment,t),b(ja.$$.fragment,t),b(qa.$$.fragment,t),b(Ct.$$.fragment,t),b(za.$$.fragment,t),b(Ma.$$.fragment,t),b(Sa.$$.fragment,t),b(Oa.$$.fragment,t),b(Ia.$$.fragment,t),b(Wa.$$.fragment,t),b(Ra.$$.fragment,t),b(Ya.$$.fragment,t),b(Lt.$$.fragment,t),b(Ua.$$.fragment,t),b(Za.$$.fragment,t),b(es.$$.fragment,t),b(ss.$$.fragment,t),b(os.$$.fragment,t),b(is.$$.fragment,t),b(ps.$$.fragment,t),Rl=!0)},o(t){T(v.$$.fragment,t),T(S.$$.fragment,t),T(Q.$$.fragment,t),T(K.$$.fragment,t),T(X.$$.fragment,t),T(ae.$$.fragment,t),T(ra.$$.fragment,t),T(na.$$.fragment,t),T(la.$$.fragment,t),T(ia.$$.fragment,t),T(ca.$$.fragment,t),T(ma.$$.fragment,t),T(da.$$.fragment,t),T(ha.$$.fragment,t),T(_a.$$.fragment,t),T(vt.$$.fragment,t),T(va.$$.fragment,t),T(ka.$$.fragment,t),T(wa.$$.fragment,t),T(ya.$$.fragment,t),T(ba.$$.fragment,t),T(Ta.$$.fragment,t),T(Et.$$.fragment,t),T(At.$$.fragment,t),T(Ea.$$.fragment,t),T(qt.$$.fragment,t),T(zt.$$.fragment,t),T(Aa.$$.fragment,t),T(Pt.$$.fragment,t),T(Ft.$$.fragment,t),T(ja.$$.fragment,t),T(qa.$$.fragment,t),T(Ct.$$.fragment,t),T(za.$$.fragment,t),T(Ma.$$.fragment,t),T(Sa.$$.fragment,t),T(Oa.$$.fragment,t),T(Ia.$$.fragment,t),T(Wa.$$.fragment,t),T(Ra.$$.fragment,t),T(Ya.$$.fragment,t),T(Lt.$$.fragment,t),T(Ua.$$.fragment,t),T(Za.$$.fragment,t),T(es.$$.fragment,t),T(ss.$$.fragment,t),T(os.$$.fragment,t),T(is.$$.fragment,t),T(ps.$$.fragment,t),Rl=!1},d(t){a(o),t&&a(d),t&&a(n),E(v),t&&a(j),E(S,t),t&&a(N),t&&a(O),t&&a(de),t&&a(B),t&&a(le),E(Q,t),t&&a($e),t&&a(J),t&&a(ge),E(K,t),t&&a(se),t&&a(Z),E(X),t&&a(Ie),E(ae,t),t&&a(Le),t&&a(ee),t&&a(qn),t&&a(ut),t&&a(zn),t&&a(pe),t&&a(xn),E(ra,t),t&&a(Pn),t&&a(ve),t&&a(Fn),E(na,t),t&&a(Mn),t&&a(mt),t&&a(Cn),E(la,t),t&&a(Sn),t&&a(dt),t&&a(Dn),E(ia,t),t&&a(On),t&&a(He),t&&a(Nn),E(ca,t),t&&a(In),t&&a(ht),t&&a(Ln),E(ma,t),t&&a(Hn),t&&a($t),t&&a(Wn),E(da,t),t&&a(Rn),t&&a(gt),t&&a(Yn),t&&a(et),E(ha),t&&a(Un),t&&a(fe),t&&a(Gn),E(_a,t),t&&a(Bn),E(vt,t),t&&a(Qn),t&&a(We),t&&a(Vn),E(va,t),t&&a(Kn),t&&a(Re),t&&a(Jn),t&&a(tt),E(ka),t&&a(Zn),E(wa,t),t&&a(Xn),t&&a(re),t&&a(el),t&&a(Ye),t&&a(tl),t&&a(at),E(ya),t&&a(al),t&&a(yt),t&&a(sl),t&&a(bt),t&&a(rl),E(ba,t),t&&a(ol),t&&a(Ds),t&&a(nl),E(Ta,t),t&&a(ll),t&&a(Os),t&&a(il),t&&a(Tt),t&&a(pl),t&&a(Ws),t&&a(fl),E(Et,t),t&&a(cl),E(At,t),t&&a(ul),t&&a(st),E(Ea),t&&a(ml),E(qt,t),t&&a(dl),E(zt,t),t&&a(hl),t&&a(rt),E(Aa),t&&a($l),E(Pt,t),t&&a(gl),t&&a(Ue),t&&a(_l),E(Ft,t),t&&a(vl),t&&a(ot),E(ja),t&&a(kl),t&&a(Rs),t&&a(wl),t&&a(Ge),t&&a(yl),E(qa,t),t&&a(bl),E(Ct,t),t&&a(Tl),t&&a(St),t&&a(El),t&&a(nt),E(za),t&&a(Al),t&&a(Be),t&&a(jl),t&&a(Ot),t&&a(ql),t&&a(ce),E(Ma),E(Sa),E(Oa),E(Ia),E(Wa),t&&a(zl),t&&a(Nt),t&&a(xl),E(Ra,t),t&&a(Pl),t&&a(It),t&&a(Fl),E(Ya,t),t&&a(Ml),E(Lt,t),t&&a(Cl),t&&a(Qe),t&&a(Sl),t&&a(Ve),t&&a(Dl),t&&a(it),E(Ua),t&&a(Ol),t&&a(te),t&&a(Nl),t&&a(Ke),E(Za),E(es),E(ss),t&&a(Il),t&&a(lr),E(os),t&&a(Ll),t&&a(ns),E(is),t&&a(Hl),t&&a(ct),E(ps),t&&a(Wl),t&&a(ir)}}}const h_={local:"quick-tour",sections:[{local:"pipeline",sections:[{local:"use-another-model-and-tokenizer-in-the-pipeline",title:"Use another model and tokenizer in the pipeline"}],title:"Pipeline"},{local:"autoclass",sections:[{local:"autotokenizer",title:"AutoTokenizer"},{local:"automodel",title:"AutoModel"},{local:"save-a-model",title:"Save a model"}],title:"AutoClass"},{local:"custom-model-builds",title:"Custom model builds"},{local:"trainer-a-pytorch-optimized-training-loop",title:"Trainer - a PyTorch optimized training loop"},{local:"train-with-tensorflow",title:"Train with TensorFlow"},{local:"whats-next",title:"What's next?"}],title:"Quick tour"};function $_(P){return Mg(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class T_ extends zg{constructor(o){super();xg(this,o,$_,d_,Pg,{})}}export{T_ as default,h_ as metadata};
