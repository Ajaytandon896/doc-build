import{S as j$,i as q$,s as z$,e as l,k as f,w as k,t as s,M as P$,c as i,d as a,m as c,a as p,x as w,h as r,b as h,G as e,g as u,y,q as b,o as T,B as E,v as x$,L as ye}from"../chunks/vendor-hf-doc-builder.js";import{T as An}from"../chunks/Tip-hf-doc-builder.js";import{Y as A$}from"../chunks/Youtube-hf-doc-builder.js";import{I as Oe}from"../chunks/IconCopyLink-hf-doc-builder.js";import{C as O}from"../chunks/CodeBlock-hf-doc-builder.js";import{D as F$}from"../chunks/DocNotebookDropdown-hf-doc-builder.js";import{F as ms,M as de}from"../chunks/Markdown-hf-doc-builder.js";function M$(x){let o,d;return o=new O({props:{code:"pip install torch",highlighted:"pip install torch"}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p:ye,i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function S$(x){let o,d;return o=new de({props:{$$slots:{default:[M$]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function C$(x){let o,d;return o=new O({props:{code:"pip install tensorflow",highlighted:"pip install tensorflow"}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p:ye,i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function D$(x){let o,d;return o=new de({props:{$$slots:{default:[C$]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function I$(x){let o,d,n,g,_,v,q,F,$,j,C,N,I,W;return I=new O({props:{code:`from transformers import AutoTokenizer, AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(model_name)
tokenizer = AutoTokenizer.from_pretrained(model_name)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = AutoModelForSequenceClassification.from_pretrained(model_name)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(model_name)`}}),{c(){o=l("p"),d=s("Use "),n=l("a"),g=s("AutoModelForSequenceClassification"),_=s(" and "),v=l("a"),q=s("AutoTokenizer"),F=s(" to load the pretrained model and it\u2019s associated tokenizer (more on an "),$=l("code"),j=s("AutoClass"),C=s(" in the next section):"),N=f(),k(I.$$.fragment),this.h()},l(z){o=i(z,"P",{});var S=p(o);d=r(S,"Use "),n=i(S,"A",{href:!0});var A=p(n);g=r(A,"AutoModelForSequenceClassification"),A.forEach(a),_=r(S," and "),v=i(S,"A",{href:!0});var D=p(v);q=r(D,"AutoTokenizer"),D.forEach(a),F=r(S," to load the pretrained model and it\u2019s associated tokenizer (more on an "),$=i(S,"CODE",{});var K=p($);j=r(K,"AutoClass"),K.forEach(a),C=r(S," in the next section):"),S.forEach(a),N=c(z),w(I.$$.fragment,z),this.h()},h(){h(n,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModelForSequenceClassification"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoTokenizer")},m(z,S){u(z,o,S),e(o,d),e(o,n),e(n,g),e(o,_),e(o,v),e(v,q),e(o,F),e(o,$),e($,j),e(o,C),u(z,N,S),y(I,z,S),W=!0},p:ye,i(z){W||(b(I.$$.fragment,z),W=!0)},o(z){T(I.$$.fragment,z),W=!1},d(z){z&&a(o),z&&a(N),E(I,z)}}}function N$(x){let o,d;return o=new de({props:{$$slots:{default:[I$]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function O$(x){let o,d,n,g,_,v,q,F,$,j,C,N,I,W;return I=new O({props:{code:`from transformers import AutoTokenizer, TFAutoModelForSequenceClassification

model = TFAutoModelForSequenceClassification.from_pretrained(model_name)
tokenizer = AutoTokenizer.from_pretrained(model_name)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, TFAutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFAutoModelForSequenceClassification.from_pretrained(model_name)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(model_name)`}}),{c(){o=l("p"),d=s("Use "),n=l("a"),g=s("TFAutoModelForSequenceClassification"),_=s(" and "),v=l("a"),q=s("AutoTokenizer"),F=s(" to load the pretrained model and it\u2019s associated tokenizer (more on an "),$=l("code"),j=s("TFAutoClass"),C=s(" in the next section):"),N=f(),k(I.$$.fragment),this.h()},l(z){o=i(z,"P",{});var S=p(o);d=r(S,"Use "),n=i(S,"A",{href:!0});var A=p(n);g=r(A,"TFAutoModelForSequenceClassification"),A.forEach(a),_=r(S," and "),v=i(S,"A",{href:!0});var D=p(v);q=r(D,"AutoTokenizer"),D.forEach(a),F=r(S," to load the pretrained model and it\u2019s associated tokenizer (more on an "),$=i(S,"CODE",{});var K=p($);j=r(K,"TFAutoClass"),K.forEach(a),C=r(S," in the next section):"),S.forEach(a),N=c(z),w(I.$$.fragment,z),this.h()},h(){h(n,"href","/docs/transformers/main/en/model_doc/auto#transformers.TFAutoModelForSequenceClassification"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoTokenizer")},m(z,S){u(z,o,S),e(o,d),e(o,n),e(n,g),e(o,_),e(o,v),e(v,q),e(o,F),e(o,$),e($,j),e(o,C),u(z,N,S),y(I,z,S),W=!0},p:ye,i(z){W||(b(I.$$.fragment,z),W=!0)},o(z){T(I.$$.fragment,z),W=!1},d(z){z&&a(o),z&&a(N),E(I,z)}}}function H$(x){let o,d;return o=new de({props:{$$slots:{default:[O$]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function L$(x){let o,d;return o=new O({props:{code:`pt_batch = tokenizer(
    ["We are very happy to show you the \u{1F917} Transformers library.", "We hope you don't hate it."],
    padding=True,
    truncation=True,
    max_length=512,
    return_tensors="pt",
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>pt_batch = tokenizer(
<span class="hljs-meta">... </span>    [<span class="hljs-string">&quot;We are very happy to show you the \u{1F917} Transformers library.&quot;</span>, <span class="hljs-string">&quot;We hope you don&#x27;t hate it.&quot;</span>],
<span class="hljs-meta">... </span>    padding=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>    truncation=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>    max_length=<span class="hljs-number">512</span>,
<span class="hljs-meta">... </span>    return_tensors=<span class="hljs-string">&quot;pt&quot;</span>,
<span class="hljs-meta">... </span>)`}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p:ye,i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function W$(x){let o,d;return o=new de({props:{$$slots:{default:[L$]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function R$(x){let o,d;return o=new O({props:{code:`tf_batch = tokenizer(
    ["We are very happy to show you the \u{1F917} Transformers library.", "We hope you don't hate it."],
    padding=True,
    truncation=True,
    max_length=512,
    return_tensors="tf",
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>tf_batch = tokenizer(
<span class="hljs-meta">... </span>    [<span class="hljs-string">&quot;We are very happy to show you the \u{1F917} Transformers library.&quot;</span>, <span class="hljs-string">&quot;We hope you don&#x27;t hate it.&quot;</span>],
<span class="hljs-meta">... </span>    padding=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>    truncation=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>    max_length=<span class="hljs-number">512</span>,
<span class="hljs-meta">... </span>    return_tensors=<span class="hljs-string">&quot;tf&quot;</span>,
<span class="hljs-meta">... </span>)`}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p:ye,i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function Y$(x){let o,d;return o=new de({props:{$$slots:{default:[R$]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function U$(x){let o,d,n,g,_,v,q,F,$,j,C;return{c(){o=l("p"),d=s("Check out the "),n=l("a"),g=s("preprocess"),_=s(" tutorial for more details about tokenization, and how to use an "),v=l("a"),q=s("AutoFeatureExtractor"),F=s(" and "),$=l("a"),j=s("AutoProcessor"),C=s(" to preprocess image, audio, and multimodal inputs."),this.h()},l(N){o=i(N,"P",{});var I=p(o);d=r(I,"Check out the "),n=i(I,"A",{href:!0});var W=p(n);g=r(W,"preprocess"),W.forEach(a),_=r(I," tutorial for more details about tokenization, and how to use an "),v=i(I,"A",{href:!0});var z=p(v);q=r(z,"AutoFeatureExtractor"),z.forEach(a),F=r(I," and "),$=i(I,"A",{href:!0});var S=p($);j=r(S,"AutoProcessor"),S.forEach(a),C=r(I," to preprocess image, audio, and multimodal inputs."),I.forEach(a),this.h()},h(){h(n,"href","./preprocessing"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoFeatureExtractor"),h($,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoProcessor")},m(N,I){u(N,o,I),e(o,d),e(o,n),e(n,g),e(o,_),e(o,v),e(v,q),e(o,F),e(o,$),e($,j),e(o,C)},d(N){N&&a(o)}}}function K$(x){let o,d,n,g,_,v,q,F;return{c(){o=l("p"),d=s("See the "),n=l("a"),g=s("task summary"),_=s(" for tasks supported by an "),v=l("a"),q=s("AutoModel"),F=s(" class."),this.h()},l($){o=i($,"P",{});var j=p(o);d=r(j,"See the "),n=i(j,"A",{href:!0});var C=p(n);g=r(C,"task summary"),C.forEach(a),_=r(j," for tasks supported by an "),v=i(j,"A",{href:!0});var N=p(v);q=r(N,"AutoModel"),N.forEach(a),F=r(j," class."),j.forEach(a),this.h()},h(){h(n,"href","./task_summary"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModel")},m($,j){u($,o,j),e(o,d),e(o,n),e(n,g),e(o,_),e(o,v),e(v,q),e(o,F)},d($){$&&a(o)}}}function G$(x){let o,d,n,g,_,v,q,F,$,j,C,N,I,W,z,S,A,D,K,R,V,ie,oe,he,G,ne,le,B,$e,J,be,_e,Q,se,Z,P,H,X;return S=new O({props:{code:`from transformers import AutoModelForSequenceClassification

model_name = "nlptown/bert-base-multilingual-uncased-sentiment"
pt_model = AutoModelForSequenceClassification.from_pretrained(model_name)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model_name = <span class="hljs-string">&quot;nlptown/bert-base-multilingual-uncased-sentiment&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pt_model = AutoModelForSequenceClassification.from_pretrained(model_name)`}}),D=new An({props:{$$slots:{default:[K$]},$$scope:{ctx:x}}}),ne=new O({props:{code:"pt_outputs = pt_model(**pt_batch)",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>pt_outputs = pt_model(**pt_batch)'}}),H=new O({props:{code:`from torch import nn

pt_predictions = nn.functional.softmax(pt_outputs.logits, dim=-1)
print(pt_predictions)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn

<span class="hljs-meta">&gt;&gt;&gt; </span>pt_predictions = nn.functional.softmax(pt_outputs.logits, dim=-<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(pt_predictions)
tensor([[<span class="hljs-number">0.0021</span>, <span class="hljs-number">0.0018</span>, <span class="hljs-number">0.0115</span>, <span class="hljs-number">0.2121</span>, <span class="hljs-number">0.7725</span>],
        [<span class="hljs-number">0.2084</span>, <span class="hljs-number">0.1826</span>, <span class="hljs-number">0.1969</span>, <span class="hljs-number">0.1755</span>, <span class="hljs-number">0.2365</span>]], grad_fn=&lt;SoftmaxBackward0&gt;)`}}),{c(){o=l("p"),d=s("\u{1F917} Transformers provides a simple and unified way to load pretrained instances. This means you can load an "),n=l("a"),g=s("AutoModel"),_=s(" like you would load an "),v=l("a"),q=s("AutoTokenizer"),F=s(". The only difference is selecting the correct "),$=l("a"),j=s("AutoModel"),C=s(" for the task. For text (or sequence) classification, you should load "),N=l("a"),I=s("AutoModelForSequenceClassification"),W=s(":"),z=f(),k(S.$$.fragment),A=f(),k(D.$$.fragment),K=f(),R=l("p"),V=s("Now pass your preprocessed batch of inputs directly to the model. You just have to unpack the dictionary by adding "),ie=l("code"),oe=s("**"),he=s(":"),G=f(),k(ne.$$.fragment),le=f(),B=l("p"),$e=s("The model outputs the final activations in the "),J=l("code"),be=s("logits"),_e=s(" attribute. Apply the softmax function to the "),Q=l("code"),se=s("logits"),Z=s(" to retrieve the probabilities:"),P=f(),k(H.$$.fragment),this.h()},l(M){o=i(M,"P",{});var L=p(o);d=r(L,"\u{1F917} Transformers provides a simple and unified way to load pretrained instances. This means you can load an "),n=i(L,"A",{href:!0});var ve=p(n);g=r(ve,"AutoModel"),ve.forEach(a),_=r(L," like you would load an "),v=i(L,"A",{href:!0});var He=p(v);q=r(He,"AutoTokenizer"),He.forEach(a),F=r(L,". The only difference is selecting the correct "),$=i(L,"A",{href:!0});var ae=p($);j=r(ae,"AutoModel"),ae.forEach(a),C=r(L," for the task. For text (or sequence) classification, you should load "),N=i(L,"A",{href:!0});var Le=p(N);I=r(Le,"AutoModelForSequenceClassification"),Le.forEach(a),W=r(L,":"),L.forEach(a),z=c(M),w(S.$$.fragment,M),A=c(M),w(D.$$.fragment,M),K=c(M),R=i(M,"P",{});var ee=p(R);V=r(ee,"Now pass your preprocessed batch of inputs directly to the model. You just have to unpack the dictionary by adding "),ie=i(ee,"CODE",{});var us=p(ie);oe=r(us,"**"),us.forEach(a),he=r(ee,":"),ee.forEach(a),G=c(M),w(ne.$$.fragment,M),le=c(M),B=i(M,"P",{});var ge=p(B);$e=r(ge,"The model outputs the final activations in the "),J=i(ge,"CODE",{});var ds=p(J);be=r(ds,"logits"),ds.forEach(a),_e=r(ge," attribute. Apply the softmax function to the "),Q=i(ge,"CODE",{});var hs=p(Q);se=r(hs,"logits"),hs.forEach(a),Z=r(ge," to retrieve the probabilities:"),ge.forEach(a),P=c(M),w(H.$$.fragment,M),this.h()},h(){h(n,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModel"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoTokenizer"),h($,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModel"),h(N,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModelForSequenceClassification")},m(M,L){u(M,o,L),e(o,d),e(o,n),e(n,g),e(o,_),e(o,v),e(v,q),e(o,F),e(o,$),e($,j),e(o,C),e(o,N),e(N,I),e(o,W),u(M,z,L),y(S,M,L),u(M,A,L),y(D,M,L),u(M,K,L),u(M,R,L),e(R,V),e(R,ie),e(ie,oe),e(R,he),u(M,G,L),y(ne,M,L),u(M,le,L),u(M,B,L),e(B,$e),e(B,J),e(J,be),e(B,_e),e(B,Q),e(Q,se),e(B,Z),u(M,P,L),y(H,M,L),X=!0},p(M,L){const ve={};L&2&&(ve.$$scope={dirty:L,ctx:M}),D.$set(ve)},i(M){X||(b(S.$$.fragment,M),b(D.$$.fragment,M),b(ne.$$.fragment,M),b(H.$$.fragment,M),X=!0)},o(M){T(S.$$.fragment,M),T(D.$$.fragment,M),T(ne.$$.fragment,M),T(H.$$.fragment,M),X=!1},d(M){M&&a(o),M&&a(z),E(S,M),M&&a(A),E(D,M),M&&a(K),M&&a(R),M&&a(G),E(ne,M),M&&a(le),M&&a(B),M&&a(P),E(H,M)}}}function B$(x){let o,d;return o=new de({props:{$$slots:{default:[G$]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function V$(x){let o,d,n,g,_,v,q,F;return{c(){o=l("p"),d=s("See the "),n=l("a"),g=s("task summary"),_=s(" for tasks supported by an "),v=l("a"),q=s("AutoModel"),F=s(" class."),this.h()},l($){o=i($,"P",{});var j=p(o);d=r(j,"See the "),n=i(j,"A",{href:!0});var C=p(n);g=r(C,"task summary"),C.forEach(a),_=r(j," for tasks supported by an "),v=i(j,"A",{href:!0});var N=p(v);q=r(N,"AutoModel"),N.forEach(a),F=r(j," class."),j.forEach(a),this.h()},h(){h(n,"href","./task_summary"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModel")},m($,j){u($,o,j),e(o,d),e(o,n),e(n,g),e(o,_),e(o,v),e(v,q),e(o,F)},d($){$&&a(o)}}}function Q$(x){let o,d,n,g,_,v,q,F,$,j,C,N,I,W,z,S,A,D,K,R,V,ie,oe,he,G,ne,le,B,$e,J,be,_e,Q,se,Z;return S=new O({props:{code:`from transformers import TFAutoModelForSequenceClassification

model_name = "nlptown/bert-base-multilingual-uncased-sentiment"
tf_model = TFAutoModelForSequenceClassification.from_pretrained(model_name)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model_name = <span class="hljs-string">&quot;nlptown/bert-base-multilingual-uncased-sentiment&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tf_model = TFAutoModelForSequenceClassification.from_pretrained(model_name)`}}),D=new An({props:{$$slots:{default:[V$]},$$scope:{ctx:x}}}),oe=new O({props:{code:"tf_outputs = tf_model(tf_batch)",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>tf_outputs = tf_model(tf_batch)'}}),se=new O({props:{code:`import tensorflow as tf

tf_predictions = tf.nn.softmax(tf_outputs.logits, axis=-1)
tf_predictions`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tf_predictions = tf.nn.softmax(tf_outputs.logits, axis=-<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tf_predictions`}}),{c(){o=l("p"),d=s("\u{1F917} Transformers provides a simple and unified way to load pretrained instances. This means you can load an "),n=l("a"),g=s("TFAutoModel"),_=s(" like you would load an "),v=l("a"),q=s("AutoTokenizer"),F=s(". The only difference is selecting the correct "),$=l("a"),j=s("TFAutoModel"),C=s(" for the task. For text (or sequence) classification, you should load "),N=l("a"),I=s("TFAutoModelForSequenceClassification"),W=s(":"),z=f(),k(S.$$.fragment),A=f(),k(D.$$.fragment),K=f(),R=l("p"),V=s("Now pass your preprocessed batch of inputs directly to the model by passing the dictionary keys directly to the tensors:"),ie=f(),k(oe.$$.fragment),he=f(),G=l("p"),ne=s("The model outputs the final activations in the "),le=l("code"),B=s("logits"),$e=s(" attribute. Apply the softmax function to the "),J=l("code"),be=s("logits"),_e=s(" to retrieve the probabilities:"),Q=f(),k(se.$$.fragment),this.h()},l(P){o=i(P,"P",{});var H=p(o);d=r(H,"\u{1F917} Transformers provides a simple and unified way to load pretrained instances. This means you can load an "),n=i(H,"A",{href:!0});var X=p(n);g=r(X,"TFAutoModel"),X.forEach(a),_=r(H," like you would load an "),v=i(H,"A",{href:!0});var M=p(v);q=r(M,"AutoTokenizer"),M.forEach(a),F=r(H,". The only difference is selecting the correct "),$=i(H,"A",{href:!0});var L=p($);j=r(L,"TFAutoModel"),L.forEach(a),C=r(H," for the task. For text (or sequence) classification, you should load "),N=i(H,"A",{href:!0});var ve=p(N);I=r(ve,"TFAutoModelForSequenceClassification"),ve.forEach(a),W=r(H,":"),H.forEach(a),z=c(P),w(S.$$.fragment,P),A=c(P),w(D.$$.fragment,P),K=c(P),R=i(P,"P",{});var He=p(R);V=r(He,"Now pass your preprocessed batch of inputs directly to the model by passing the dictionary keys directly to the tensors:"),He.forEach(a),ie=c(P),w(oe.$$.fragment,P),he=c(P),G=i(P,"P",{});var ae=p(G);ne=r(ae,"The model outputs the final activations in the "),le=i(ae,"CODE",{});var Le=p(le);B=r(Le,"logits"),Le.forEach(a),$e=r(ae," attribute. Apply the softmax function to the "),J=i(ae,"CODE",{});var ee=p(J);be=r(ee,"logits"),ee.forEach(a),_e=r(ae," to retrieve the probabilities:"),ae.forEach(a),Q=c(P),w(se.$$.fragment,P),this.h()},h(){h(n,"href","/docs/transformers/main/en/model_doc/auto#transformers.TFAutoModel"),h(v,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoTokenizer"),h($,"href","/docs/transformers/main/en/model_doc/auto#transformers.TFAutoModel"),h(N,"href","/docs/transformers/main/en/model_doc/auto#transformers.TFAutoModelForSequenceClassification")},m(P,H){u(P,o,H),e(o,d),e(o,n),e(n,g),e(o,_),e(o,v),e(v,q),e(o,F),e(o,$),e($,j),e(o,C),e(o,N),e(N,I),e(o,W),u(P,z,H),y(S,P,H),u(P,A,H),y(D,P,H),u(P,K,H),u(P,R,H),e(R,V),u(P,ie,H),y(oe,P,H),u(P,he,H),u(P,G,H),e(G,ne),e(G,le),e(le,B),e(G,$e),e(G,J),e(J,be),e(G,_e),u(P,Q,H),y(se,P,H),Z=!0},p(P,H){const X={};H&2&&(X.$$scope={dirty:H,ctx:P}),D.$set(X)},i(P){Z||(b(S.$$.fragment,P),b(D.$$.fragment,P),b(oe.$$.fragment,P),b(se.$$.fragment,P),Z=!0)},o(P){T(S.$$.fragment,P),T(D.$$.fragment,P),T(oe.$$.fragment,P),T(se.$$.fragment,P),Z=!1},d(P){P&&a(o),P&&a(z),E(S,P),P&&a(A),E(D,P),P&&a(K),P&&a(R),P&&a(ie),E(oe,P),P&&a(he),P&&a(G),P&&a(Q),E(se,P)}}}function J$(x){let o,d;return o=new de({props:{$$slots:{default:[Q$]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function Z$(x){let o,d,n,g,_;return{c(){o=l("p"),d=s("All \u{1F917} Transformers models (PyTorch or TensorFlow) output the tensors "),n=l("em"),g=s("before"),_=s(` the final activation
function (like softmax) because the final activation function is often fused with the loss. Model outputs are special dataclasses so their attributes are autocompleted in an IDE. The model outputs behave like a tuple or a dictionary (you can index with an integer, a slice or a string) in which case, attributes that are None are ignored.`)},l(v){o=i(v,"P",{});var q=p(o);d=r(q,"All \u{1F917} Transformers models (PyTorch or TensorFlow) output the tensors "),n=i(q,"EM",{});var F=p(n);g=r(F,"before"),F.forEach(a),_=r(q,` the final activation
function (like softmax) because the final activation function is often fused with the loss. Model outputs are special dataclasses so their attributes are autocompleted in an IDE. The model outputs behave like a tuple or a dictionary (you can index with an integer, a slice or a string) in which case, attributes that are None are ignored.`),q.forEach(a)},m(v,q){u(v,o,q),e(o,d),e(o,n),e(n,g),e(o,_)},d(v){v&&a(o)}}}function X$(x){let o,d,n,g,_,v,q,F,$,j,C,N,I,W,z,S;return q=new O({props:{code:`pt_save_directory = "./pt_save_pretrained"
tokenizer.save_pretrained(pt_save_directory)
pt_model.save_pretrained(pt_save_directory)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>pt_save_directory = <span class="hljs-string">&quot;./pt_save_pretrained&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.save_pretrained(pt_save_directory)
<span class="hljs-meta">&gt;&gt;&gt; </span>pt_model.save_pretrained(pt_save_directory)`}}),z=new O({props:{code:'pt_model = AutoModelForSequenceClassification.from_pretrained("./pt_save_pretrained")',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>pt_model = AutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;./pt_save_pretrained&quot;</span>)'}}),{c(){o=l("p"),d=s("Once your model is fine-tuned, you can save it with its tokenizer using "),n=l("a"),g=s("PreTrainedModel.save_pretrained()"),_=s(":"),v=f(),k(q.$$.fragment),F=f(),$=l("p"),j=s("When you are ready to use the model again, reload it with "),C=l("a"),N=s("PreTrainedModel.from_pretrained()"),I=s(":"),W=f(),k(z.$$.fragment),this.h()},l(A){o=i(A,"P",{});var D=p(o);d=r(D,"Once your model is fine-tuned, you can save it with its tokenizer using "),n=i(D,"A",{href:!0});var K=p(n);g=r(K,"PreTrainedModel.save_pretrained()"),K.forEach(a),_=r(D,":"),D.forEach(a),v=c(A),w(q.$$.fragment,A),F=c(A),$=i(A,"P",{});var R=p($);j=r(R,"When you are ready to use the model again, reload it with "),C=i(R,"A",{href:!0});var V=p(C);N=r(V,"PreTrainedModel.from_pretrained()"),V.forEach(a),I=r(R,":"),R.forEach(a),W=c(A),w(z.$$.fragment,A),this.h()},h(){h(n,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.save_pretrained"),h(C,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained")},m(A,D){u(A,o,D),e(o,d),e(o,n),e(n,g),e(o,_),u(A,v,D),y(q,A,D),u(A,F,D),u(A,$,D),e($,j),e($,C),e(C,N),e($,I),u(A,W,D),y(z,A,D),S=!0},p:ye,i(A){S||(b(q.$$.fragment,A),b(z.$$.fragment,A),S=!0)},o(A){T(q.$$.fragment,A),T(z.$$.fragment,A),S=!1},d(A){A&&a(o),A&&a(v),E(q,A),A&&a(F),A&&a($),A&&a(W),E(z,A)}}}function e_(x){let o,d;return o=new de({props:{$$slots:{default:[X$]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function t_(x){let o,d,n,g,_,v,q,F,$,j,C,N,I,W,z,S;return q=new O({props:{code:`tf_save_directory = "./tf_save_pretrained"
tokenizer.save_pretrained(tf_save_directory)
tf_model.save_pretrained(tf_save_directory)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>tf_save_directory = <span class="hljs-string">&quot;./tf_save_pretrained&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.save_pretrained(tf_save_directory)
<span class="hljs-meta">&gt;&gt;&gt; </span>tf_model.save_pretrained(tf_save_directory)`}}),z=new O({props:{code:'tf_model = TFAutoModelForSequenceClassification.from_pretrained("./tf_save_pretrained")',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>tf_model = TFAutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;./tf_save_pretrained&quot;</span>)'}}),{c(){o=l("p"),d=s("Once your model is fine-tuned, you can save it with its tokenizer using "),n=l("a"),g=s("TFPreTrainedModel.save_pretrained()"),_=s(":"),v=f(),k(q.$$.fragment),F=f(),$=l("p"),j=s("When you are ready to use the model again, reload it with "),C=l("a"),N=s("TFPreTrainedModel.from_pretrained()"),I=s(":"),W=f(),k(z.$$.fragment),this.h()},l(A){o=i(A,"P",{});var D=p(o);d=r(D,"Once your model is fine-tuned, you can save it with its tokenizer using "),n=i(D,"A",{href:!0});var K=p(n);g=r(K,"TFPreTrainedModel.save_pretrained()"),K.forEach(a),_=r(D,":"),D.forEach(a),v=c(A),w(q.$$.fragment,A),F=c(A),$=i(A,"P",{});var R=p($);j=r(R,"When you are ready to use the model again, reload it with "),C=i(R,"A",{href:!0});var V=p(C);N=r(V,"TFPreTrainedModel.from_pretrained()"),V.forEach(a),I=r(R,":"),R.forEach(a),W=c(A),w(z.$$.fragment,A),this.h()},h(){h(n,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel.save_pretrained"),h(C,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel.from_pretrained")},m(A,D){u(A,o,D),e(o,d),e(o,n),e(n,g),e(o,_),u(A,v,D),y(q,A,D),u(A,F,D),u(A,$,D),e($,j),e($,C),e(C,N),e($,I),u(A,W,D),y(z,A,D),S=!0},p:ye,i(A){S||(b(q.$$.fragment,A),b(z.$$.fragment,A),S=!0)},o(A){T(q.$$.fragment,A),T(z.$$.fragment,A),S=!1},d(A){A&&a(o),A&&a(v),E(q,A),A&&a(F),A&&a($),A&&a(W),E(z,A)}}}function a_(x){let o,d;return o=new de({props:{$$slots:{default:[t_]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function s_(x){let o,d;return o=new O({props:{code:`from transformers import AutoModel

tokenizer = AutoTokenizer.from_pretrained(tf_save_directory)
pt_model = AutoModelForSequenceClassification.from_pretrained(tf_save_directory, from_tf=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModel

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(tf_save_directory)
<span class="hljs-meta">&gt;&gt;&gt; </span>pt_model = AutoModelForSequenceClassification.from_pretrained(tf_save_directory, from_tf=<span class="hljs-literal">True</span>)`}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p:ye,i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function r_(x){let o,d;return o=new de({props:{$$slots:{default:[s_]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function o_(x){let o,d;return o=new O({props:{code:`from transformers import TFAutoModel

tokenizer = AutoTokenizer.from_pretrained(pt_save_directory)
tf_model = TFAutoModelForSequenceClassification.from_pretrained(pt_save_directory, from_pt=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModel

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(pt_save_directory)
<span class="hljs-meta">&gt;&gt;&gt; </span>tf_model = TFAutoModelForSequenceClassification.from_pretrained(pt_save_directory, from_pt=<span class="hljs-literal">True</span>)`}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p:ye,i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function n_(x){let o,d;return o=new de({props:{$$slots:{default:[o_]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function l_(x){let o,d,n,g,_,v,q,F;return q=new O({props:{code:`from transformers import AutoModel

my_model = AutoModel.from_config(my_config)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModel

<span class="hljs-meta">&gt;&gt;&gt; </span>my_model = AutoModel.from_config(my_config)`}}),{c(){o=l("p"),d=s("Create a model from your custom configuration with "),n=l("a"),g=s("AutoModel.from_config()"),_=s(":"),v=f(),k(q.$$.fragment),this.h()},l($){o=i($,"P",{});var j=p(o);d=r(j,"Create a model from your custom configuration with "),n=i(j,"A",{href:!0});var C=p(n);g=r(C,"AutoModel.from_config()"),C.forEach(a),_=r(j,":"),j.forEach(a),v=c($),w(q.$$.fragment,$),this.h()},h(){h(n,"href","/docs/transformers/main/en/model_doc/auto#transformers.FlaxAutoModelForVision2Seq.from_config")},m($,j){u($,o,j),e(o,d),e(o,n),e(n,g),e(o,_),u($,v,j),y(q,$,j),F=!0},p:ye,i($){F||(b(q.$$.fragment,$),F=!0)},o($){T(q.$$.fragment,$),F=!1},d($){$&&a(o),$&&a(v),E(q,$)}}}function i_(x){let o,d;return o=new de({props:{$$slots:{default:[l_]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function p_(x){let o,d,n,g,_,v,q,F;return q=new O({props:{code:`from transformers import TFAutoModel

my_model = TFAutoModel.from_config(my_config)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModel

<span class="hljs-meta">&gt;&gt;&gt; </span>my_model = TFAutoModel.from_config(my_config)`}}),{c(){o=l("p"),d=s("Create a model from your custom configuration with "),n=l("a"),g=s("TFAutoModel.from_config()"),_=s(":"),v=f(),k(q.$$.fragment),this.h()},l($){o=i($,"P",{});var j=p(o);d=r(j,"Create a model from your custom configuration with "),n=i(j,"A",{href:!0});var C=p(n);g=r(C,"TFAutoModel.from_config()"),C.forEach(a),_=r(j,":"),j.forEach(a),v=c($),w(q.$$.fragment,$),this.h()},h(){h(n,"href","/docs/transformers/main/en/model_doc/auto#transformers.FlaxAutoModelForVision2Seq.from_config")},m($,j){u($,o,j),e(o,d),e(o,n),e(n,g),e(o,_),u($,v,j),y(q,$,j),F=!0},p:ye,i($){F||(b(q.$$.fragment,$),F=!0)},o($){T(q.$$.fragment,$),F=!1},d($){$&&a(o),$&&a(v),E(q,$)}}}function f_(x){let o,d;return o=new de({props:{$$slots:{default:[p_]},$$scope:{ctx:x}}}),{c(){k(o.$$.fragment)},l(n){w(o.$$.fragment,n)},m(n,g){y(o,n,g),d=!0},p(n,g){const _={};g&2&&(_.$$scope={dirty:g,ctx:n}),o.$set(_)},i(n){d||(b(o.$$.fragment,n),d=!0)},o(n){T(o.$$.fragment,n),d=!1},d(n){E(o,n)}}}function c_(x){let o,d,n,g,_,v,q,F;return{c(){o=l("p"),d=s("For tasks - like translation or summarization - that use a sequence-to-sequence model, use the "),n=l("a"),g=s("Seq2SeqTrainer"),_=s(" and "),v=l("a"),q=s("Seq2SeqTrainingArguments"),F=s(" classes instead."),this.h()},l($){o=i($,"P",{});var j=p(o);d=r(j,"For tasks - like translation or summarization - that use a sequence-to-sequence model, use the "),n=i(j,"A",{href:!0});var C=p(n);g=r(C,"Seq2SeqTrainer"),C.forEach(a),_=r(j," and "),v=i(j,"A",{href:!0});var N=p(v);q=r(N,"Seq2SeqTrainingArguments"),N.forEach(a),F=r(j," classes instead."),j.forEach(a),this.h()},h(){h(n,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Seq2SeqTrainer"),h(v,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Seq2SeqTrainingArguments")},m($,j){u($,o,j),e(o,d),e(o,n),e(n,g),e(o,_),e(o,v),e(v,q),e(o,F)},d($){$&&a(o)}}}function m_(x){let o,d,n,g,_,v,q,F,$,j,C,N,I,W,z,S,A,D,K,R,V,ie,oe,he,G,ne,le,B,$e,J,be,_e,Q,se,Z,P,H,X,M,L,ve,He,ae,Le,ee,us,ge,ds,hs,gs,wi,yi,jn,dt,br,Te,Tr,Er,bi,Ti,Ar,jr,Ei,Ai,qr,zr,ji,qi,Pr,xr,zi,Pi,Y,Ee,Fr,xi,Fi,Mr,Mi,Si,Sr,Ci,Di,Cr,Ii,Ni,Ae,Dr,Oi,Hi,Ir,Li,Wi,Nr,Ri,Yi,Or,Ui,Ki,je,Hr,Gi,Bi,Lr,Vi,Qi,Wr,Ji,Zi,Rr,Xi,ep,qe,Yr,tp,ap,Ur,sp,rp,Kr,op,np,Gr,lp,ip,ze,Br,pp,fp,Vr,cp,mp,Qr,up,dp,Jr,hp,gp,Pe,Zr,$p,_p,Xr,vp,kp,eo,wp,yp,to,bp,Tp,xe,ao,Ep,Ap,so,jp,qp,ro,zp,Pp,oo,xp,Fp,Fe,no,Mp,Sp,lo,Cp,Dp,io,Ip,Np,po,Op,Hp,Me,fo,Lp,Wp,co,Rp,Yp,mo,Up,Kp,uo,Gp,Bp,Se,ho,Vp,Qp,go,Jp,Zp,$o,Xp,ef,_o,tf,af,Ce,vo,sf,rf,ko,of,nf,wo,lf,pf,yo,ff,cf,De,bo,mf,uf,To,df,hf,Eo,gf,$f,Ao,_f,vf,Ie,jo,kf,wf,qo,yf,bf,zo,Tf,Ef,Po,Af,qn,pe,jf,$s,qf,zf,_s,Pf,xf,vs,Ff,Mf,ks,Sf,Cf,zn,na,Pn,ke,Df,ws,If,Nf,la,Of,Hf,xo,Lf,Wf,xn,ia,Fn,ht,Rf,ys,Yf,Uf,Mn,pa,Sn,gt,Kf,bs,Gf,Bf,Cn,fa,Dn,We,Vf,ca,Qf,Jf,ma,Zf,Xf,In,ua,Nn,$t,ec,da,Fo,tc,ac,On,ha,Hn,_t,sc,Mo,rc,oc,Ln,ga,Wn,vt,nc,Ts,lc,ic,Rn,tt,kt,So,$a,pc,Co,fc,Yn,fe,cc,Es,mc,uc,_a,dc,hc,As,gc,$c,va,_c,vc,Un,ka,Kn,wt,Gn,Re,kc,js,wc,yc,Do,bc,Tc,Bn,wa,Vn,Ye,Ec,qs,Ac,jc,zs,qc,zc,Qn,at,yt,Io,ya,Pc,No,xc,Jn,ba,Zn,re,Fc,Ps,Mc,Sc,xs,Cc,Dc,Fs,Ic,Nc,Ms,Oc,Hc,Oo,Lc,Wc,Xn,Ue,Rc,Ho,Yc,Uc,Ss,Kc,Gc,el,st,bt,Lo,Ta,Bc,Wo,Vc,tl,Tt,Qc,Cs,Jc,Zc,al,Et,Xc,Ds,em,tm,sl,Ea,rl,Is,am,ol,Aa,nl,Ns,sm,ll,At,Os,Hs,rm,om,nm,Ls,Ws,lm,im,il,Rs,pm,pl,jt,fl,qt,cl,rt,zt,Ro,ja,fm,Yo,cm,ml,Pt,ul,xt,dl,ot,Ft,Uo,qa,mm,Ko,um,hl,Mt,gl,Ke,dm,Go,hm,gm,Bo,$m,_m,$l,St,_l,nt,Ct,Vo,za,vm,Qo,km,vl,Ys,wm,kl,Ge,ym,Us,bm,Tm,Ks,Em,Am,wl,Pa,yl,Dt,bl,It,jm,Gs,qm,zm,Tl,lt,Nt,Jo,xa,Pm,Zo,xm,El,Be,Fm,Fa,Xo,Mm,Sm,Bs,Cm,Dm,Al,Ot,Im,Vs,Nm,Om,jl,ce,Ma,it,Hm,Qs,Lm,Wm,Sa,en,Rm,Ym,Um,Ca,Km,Da,Js,Zs,Gm,Bm,Vm,Ia,Qm,Na,tn,Jm,Zm,Oa,Xm,Ha,an,eu,tu,La,au,Wa,Ra,su,sn,ru,ou,nu,Ya,ql,Ht,lu,Xs,iu,pu,zl,Ua,Pl,Lt,fu,er,cu,mu,xl,Ka,Fl,Wt,Ml,Ve,uu,tr,du,hu,ar,gu,$u,Sl,Qe,_u,sr,vu,ku,rr,wu,yu,Cl,pt,Rt,rn,Ga,bu,on,Tu,Dl,te,Eu,Ba,nn,Au,ju,Va,qu,zu,or,Pu,xu,ln,Fu,Mu,Qa,pn,Su,Cu,Ja,fn,Du,Iu,Il,me,Za,ft,Nu,nr,Ou,Hu,Xa,cn,Lu,Wu,Ru,es,Yu,ts,mn,Uu,Ku,as,Gu,ss,un,Bu,Vu,rs,Qu,os,ct,Ju,ns,Zu,Xu,lr,ed,td,ad,ls,sd,is,mt,rd,dn,od,nd,hn,ld,id,pd,ps,Nl,ut,Yt,gn,fs,fd,$n,cd,Ol,ir,md,Hl;return v=new Oe({}),C=new F$({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Mixed",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/main/transformers_doc/en/quicktour.ipynb"},{label:"PyTorch",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/main/transformers_doc/en/pytorch/quicktour.ipynb"},{label:"TensorFlow",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/main/transformers_doc/en/tensorflow/quicktour.ipynb"},{label:"Mixed",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/main/transformers_doc/en/quicktour.ipynb"},{label:"PyTorch",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/main/transformers_doc/en/pytorch/quicktour.ipynb"},{label:"TensorFlow",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/main/transformers_doc/en/tensorflow/quicktour.ipynb"}]}}),B=new O({props:{code:"!pip install transformers datasets",highlighted:"!pip install transformers datasets"}}),Q=new ms({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[D$],pytorch:[S$]},$$scope:{ctx:x}}}),X=new Oe({}),ae=new A$({props:{id:"tiZFewofSLM"}}),na=new O({props:{code:`from transformers import pipeline

classifier = pipeline("sentiment-analysis")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

<span class="hljs-meta">&gt;&gt;&gt; </span>classifier = pipeline(<span class="hljs-string">&quot;sentiment-analysis&quot;</span>)`}}),ia=new O({props:{code:'classifier("We are very happy to show you the \u{1F917} Transformers library.")',highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>classifier(<span class="hljs-string">&quot;We are very happy to show you the \u{1F917} Transformers library.&quot;</span>)
[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9998</span>}]`}}),pa=new O({props:{code:`results = classifier(["We are very happy to show you the \u{1F917} Transformers library.", "We hope you don't hate it."])
for result in results:
    print(f"label: {result['label']}, with score: {round(result['score'], 4)}")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>results = classifier([<span class="hljs-string">&quot;We are very happy to show you the \u{1F917} Transformers library.&quot;</span>, <span class="hljs-string">&quot;We hope you don&#x27;t hate it.&quot;</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;label: <span class="hljs-subst">{result[<span class="hljs-string">&#x27;label&#x27;</span>]}</span>, with score: <span class="hljs-subst">{<span class="hljs-built_in">round</span>(result[<span class="hljs-string">&#x27;score&#x27;</span>], <span class="hljs-number">4</span>)}</span>&quot;</span>)
label: POSITIVE, <span class="hljs-keyword">with</span> score: <span class="hljs-number">0.9998</span>
label: NEGATIVE, <span class="hljs-keyword">with</span> score: <span class="hljs-number">0.5309</span>`}}),fa=new O({props:{code:`import torch
from transformers import pipeline

speech_recognizer = pipeline("automatic-speech-recognition", model="facebook/wav2vec2-base-960h")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

<span class="hljs-meta">&gt;&gt;&gt; </span>speech_recognizer = pipeline(<span class="hljs-string">&quot;automatic-speech-recognition&quot;</span>, model=<span class="hljs-string">&quot;facebook/wav2vec2-base-960h&quot;</span>)`}}),ua=new O({props:{code:`from datasets import load_dataset, Audio

dataset = load_dataset("PolyAI/minds14", name="en-US", split="train")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset, Audio

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;PolyAI/minds14&quot;</span>, name=<span class="hljs-string">&quot;en-US&quot;</span>, split=<span class="hljs-string">&quot;train&quot;</span>)`}}),ha=new O({props:{code:'dataset = dataset.cast_column("audio", Audio(sampling_rate=speech_recognizer.feature_extractor.sampling_rate))',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = dataset.cast_column(<span class="hljs-string">&quot;audio&quot;</span>, Audio(sampling_rate=speech_recognizer.feature_extractor.sampling_rate))'}}),ga=new O({props:{code:`result = speech_recognizer(dataset[:4]["audio"])
print([d["text"] for d in result])`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>result = speech_recognizer(dataset[:<span class="hljs-number">4</span>][<span class="hljs-string">&quot;audio&quot;</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>([d[<span class="hljs-string">&quot;text&quot;</span>] <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> result])
[<span class="hljs-string">&#x27;I WOULD LIKE TO SET UP A JOINT ACCOUNT WITH MY PARTNER HOW DO I PROCEED WITH DOING THAT&#x27;</span>, <span class="hljs-string">&quot;FODING HOW I&#x27;D SET UP A JOIN TO HET WITH MY WIFE AND WHERE THE AP MIGHT BE&quot;</span>, <span class="hljs-string">&quot;I I&#x27;D LIKE TOY SET UP A JOINT ACCOUNT WITH MY PARTNER I&#x27;M NOT SEEING THE OPTION TO DO IT ON THE AP SO I CALLED IN TO GET SOME HELP CAN I JUST DO IT OVER THE PHONE WITH YOU AND GIVE YOU THE INFORMATION OR SHOULD I DO IT IN THE AP AND I&#x27;M MISSING SOMETHING UQUETTE HAD PREFERRED TO JUST DO IT OVER THE PHONE OF POSSIBLE THINGS&quot;</span>, <span class="hljs-string">&#x27;HOW DO I THURN A JOIN A COUNT&#x27;</span>]`}}),$a=new Oe({}),ka=new O({props:{code:'model_name = "nlptown/bert-base-multilingual-uncased-sentiment"',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>model_name = <span class="hljs-string">&quot;nlptown/bert-base-multilingual-uncased-sentiment&quot;</span>'}}),wt=new ms({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[H$],pytorch:[N$]},$$scope:{ctx:x}}}),wa=new O({props:{code:`classifier = pipeline("sentiment-analysis", model=model, tokenizer=tokenizer)
classifier("Nous sommes tr\xE8s heureux de vous pr\xE9senter la biblioth\xE8que \u{1F917} Transformers.")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>classifier = pipeline(<span class="hljs-string">&quot;sentiment-analysis&quot;</span>, model=model, tokenizer=tokenizer)
<span class="hljs-meta">&gt;&gt;&gt; </span>classifier(<span class="hljs-string">&quot;Nous sommes tr\xE8s heureux de vous pr\xE9senter la biblioth\xE8que \u{1F917} Transformers.&quot;</span>)
[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;5 stars&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.7273</span>}]`}}),ya=new Oe({}),ba=new A$({props:{id:"AhChOFRegn4"}}),Ta=new Oe({}),Ea=new O({props:{code:`from transformers import AutoTokenizer

model_name = "nlptown/bert-base-multilingual-uncased-sentiment"
tokenizer = AutoTokenizer.from_pretrained(model_name)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>model_name = <span class="hljs-string">&quot;nlptown/bert-base-multilingual-uncased-sentiment&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(model_name)`}}),Aa=new O({props:{code:`encoding = tokenizer("We are very happy to show you the \u{1F917} Transformers library.")
print(encoding)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = tokenizer(<span class="hljs-string">&quot;We are very happy to show you the \u{1F917} Transformers library.&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(encoding)
{<span class="hljs-string">&#x27;input_ids&#x27;</span>: [<span class="hljs-number">101</span>, <span class="hljs-number">11312</span>, <span class="hljs-number">10320</span>, <span class="hljs-number">12495</span>, <span class="hljs-number">19308</span>, <span class="hljs-number">10114</span>, <span class="hljs-number">11391</span>, <span class="hljs-number">10855</span>, <span class="hljs-number">10103</span>, <span class="hljs-number">100</span>, <span class="hljs-number">58263</span>, <span class="hljs-number">13299</span>, <span class="hljs-number">119</span>, <span class="hljs-number">102</span>],
 <span class="hljs-string">&#x27;token_type_ids&#x27;</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
 <span class="hljs-string">&#x27;attention_mask&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]}`}}),jt=new ms({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[Y$],pytorch:[W$]},$$scope:{ctx:x}}}),qt=new An({props:{$$slots:{default:[U$]},$$scope:{ctx:x}}}),ja=new Oe({}),Pt=new ms({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[J$],pytorch:[B$]},$$scope:{ctx:x}}}),xt=new An({props:{$$slots:{default:[Z$]},$$scope:{ctx:x}}}),qa=new Oe({}),Mt=new ms({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[a_],pytorch:[e_]},$$scope:{ctx:x}}}),St=new ms({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[n_],pytorch:[r_]},$$scope:{ctx:x}}}),za=new Oe({}),Pa=new O({props:{code:`from transformers import AutoConfig

my_config = AutoConfig.from_pretrained("distilbert-base-uncased", n_heads=12)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoConfig

<span class="hljs-meta">&gt;&gt;&gt; </span>my_config = AutoConfig.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>, n_heads=<span class="hljs-number">12</span>)`}}),Dt=new ms({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[f_],pytorch:[i_]},$$scope:{ctx:x}}}),xa=new Oe({}),Ca=new O({props:{code:`from transformers import AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained("distilbert-base-uncased")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = AutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)`}}),Ia=new O({props:{code:`from transformers import TrainingArguments

training_args = TrainingArguments(
    output_dir="path/to/save/folder/",
    learning_rate=2e-5,
    per_device_train_batch_size=8,
    per_device_eval_batch_size=8,
    num_train_epochs=2,
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

<span class="hljs-meta">&gt;&gt;&gt; </span>training_args = TrainingArguments(
<span class="hljs-meta">... </span>    output_dir=<span class="hljs-string">&quot;path/to/save/folder/&quot;</span>,
<span class="hljs-meta">... </span>    learning_rate=<span class="hljs-number">2e-5</span>,
<span class="hljs-meta">... </span>    per_device_train_batch_size=<span class="hljs-number">8</span>,
<span class="hljs-meta">... </span>    per_device_eval_batch_size=<span class="hljs-number">8</span>,
<span class="hljs-meta">... </span>    num_train_epochs=<span class="hljs-number">2</span>,
<span class="hljs-meta">... </span>)`}}),Oa=new O({props:{code:`from transformers import AutoTokenizer

tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)`}}),La=new O({props:{code:`train_dataset = dataset["train"]  # doctest: +SKIP
eval_dataset = dataset["eval"]  # doctest: +SKIP`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>train_dataset = dataset[<span class="hljs-string">&quot;train&quot;</span>]  <span class="hljs-comment"># doctest: +SKIP</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>eval_dataset = dataset[<span class="hljs-string">&quot;eval&quot;</span>]  <span class="hljs-comment"># doctest: +SKIP</span>`}}),Ya=new O({props:{code:`from transformers import DefaultDataCollator

data_collator = DefaultDataCollator()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DefaultDataCollator

<span class="hljs-meta">&gt;&gt;&gt; </span>data_collator = DefaultDataCollator()`}}),Ua=new O({props:{code:`from transformers import Trainer

trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=dataset["train"],
    eval_dataset=dataset["test"],
    tokenizer=tokenizer,
    data_collator=data_collator,
)  # doctest: +SKIP`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Trainer

<span class="hljs-meta">&gt;&gt;&gt; </span>trainer = Trainer(
<span class="hljs-meta">... </span>    model=model,
<span class="hljs-meta">... </span>    args=training_args,
<span class="hljs-meta">... </span>    train_dataset=dataset[<span class="hljs-string">&quot;train&quot;</span>],
<span class="hljs-meta">... </span>    eval_dataset=dataset[<span class="hljs-string">&quot;test&quot;</span>],
<span class="hljs-meta">... </span>    tokenizer=tokenizer,
<span class="hljs-meta">... </span>    data_collator=data_collator,
<span class="hljs-meta">... </span>)  <span class="hljs-comment"># doctest: +SKIP</span>`}}),Ka=new O({props:{code:"trainer.train()",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>trainer.train()'}}),Wt=new An({props:{$$slots:{default:[c_]},$$scope:{ctx:x}}}),Ga=new Oe({}),es=new O({props:{code:`from transformers import TFAutoModelForSequenceClassification

model = TFAutoModelForSequenceClassification.from_pretrained("distilbert-base-uncased")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFAutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)`}}),as=new O({props:{code:`from transformers import AutoTokenizer

tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)`}}),rs=new O({props:{code:`def tokenize_dataset(dataset):
    return tokenizer(dataset["text"])  # doctest: +SKIP`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_dataset</span>(<span class="hljs-params">dataset</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> tokenizer(dataset[<span class="hljs-string">&quot;text&quot;</span>])  <span class="hljs-comment"># doctest: +SKIP</span>`}}),ls=new O({props:{code:`dataset = dataset.map(tokenize_dataset)  # doctest: +SKIP
tf_dataset = model.prepare_tf_dataset(
    dataset, batch_size=16, shuffle=True, tokenizer=tokenizer
)  # doctest: +SKIP`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = dataset.<span class="hljs-built_in">map</span>(tokenize_dataset)  <span class="hljs-comment"># doctest: +SKIP</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tf_dataset = model.prepare_tf_dataset(
<span class="hljs-meta">... </span>    dataset, batch_size=<span class="hljs-number">16</span>, shuffle=<span class="hljs-literal">True</span>, tokenizer=tokenizer
<span class="hljs-meta">... </span>)  <span class="hljs-comment"># doctest: +SKIP</span>`}}),ps=new O({props:{code:`from tensorflow.keras.optimizers import Adam

model.compile(optimizer=Adam(3e-5))
model.fit(dataset)  # doctest: +SKIP`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> tensorflow.keras.optimizers <span class="hljs-keyword">import</span> Adam

<span class="hljs-meta">&gt;&gt;&gt; </span>model.<span class="hljs-built_in">compile</span>(optimizer=Adam(<span class="hljs-number">3e-5</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>model.fit(dataset)  <span class="hljs-comment"># doctest: +SKIP</span>`}}),fs=new Oe({}),{c(){o=l("meta"),d=f(),n=l("h1"),g=l("a"),_=l("span"),k(v.$$.fragment),q=f(),F=l("span"),$=s("Quick tour"),j=f(),k(C.$$.fragment),N=f(),I=l("p"),W=s("Get up and running with \u{1F917} Transformers! Whether you\u2019re a developer or an everyday user, this quick tour will help you get started and show you how to use the "),z=l("a"),S=s("pipeline()"),A=s(" for inference, load a pretrained model and preprocessor with an "),D=l("a"),K=s("AutoClass"),R=s(", and quickly train a model with PyTorch or TensorFlow. If you\u2019re a beginner, we recommend checking out our tutorials or "),V=l("a"),ie=s("course"),oe=s(" next for more in-depth explanations of the concepts introduced here."),he=f(),G=l("p"),ne=s("Before you begin, make sure you have all the necessary libraries installed:"),le=f(),k(B.$$.fragment),$e=f(),J=l("p"),be=s("You\u2019ll also need to install your preferred machine learning framework:"),_e=f(),k(Q.$$.fragment),se=f(),Z=l("h2"),P=l("a"),H=l("span"),k(X.$$.fragment),M=f(),L=l("span"),ve=s("Pipeline"),He=f(),k(ae.$$.fragment),Le=f(),ee=l("p"),us=s("The "),ge=l("a"),ds=s("pipeline()"),hs=s(" is the easiest way to use a pretrained model for inference. You can use the "),gs=l("a"),wi=s("pipeline()"),yi=s(" out-of-the-box for many tasks across different modalities. Take a look at the table below for some supported tasks:"),jn=f(),dt=l("table"),br=l("thead"),Te=l("tr"),Tr=l("th"),Er=l("strong"),bi=s("Task"),Ti=f(),Ar=l("th"),jr=l("strong"),Ei=s("Description"),Ai=f(),qr=l("th"),zr=l("strong"),ji=s("Modality"),qi=f(),Pr=l("th"),xr=l("strong"),zi=s("Pipeline identifier"),Pi=f(),Y=l("tbody"),Ee=l("tr"),Fr=l("td"),xi=s("Text classification"),Fi=f(),Mr=l("td"),Mi=s("assign a label to a given sequence of text"),Si=f(),Sr=l("td"),Ci=s("NLP"),Di=f(),Cr=l("td"),Ii=s("pipeline(task=\u201Csentiment-analysis\u201D)"),Ni=f(),Ae=l("tr"),Dr=l("td"),Oi=s("Text generation"),Hi=f(),Ir=l("td"),Li=s("generate text that follows a given prompt"),Wi=f(),Nr=l("td"),Ri=s("NLP"),Yi=f(),Or=l("td"),Ui=s("pipeline(task=\u201Ctext-generation\u201D)"),Ki=f(),je=l("tr"),Hr=l("td"),Gi=s("Name entity recognition"),Bi=f(),Lr=l("td"),Vi=s("assign a label to each token in a sequence (people, organization, location, etc.)"),Qi=f(),Wr=l("td"),Ji=s("NLP"),Zi=f(),Rr=l("td"),Xi=s("pipeline(task=\u201Cner\u201D)"),ep=f(),qe=l("tr"),Yr=l("td"),tp=s("Question answering"),ap=f(),Ur=l("td"),sp=s("extract an answer from the text given some context and a question"),rp=f(),Kr=l("td"),op=s("NLP"),np=f(),Gr=l("td"),lp=s("pipeline(task=\u201Cquestion-answering\u201D)"),ip=f(),ze=l("tr"),Br=l("td"),pp=s("Fill-mask"),fp=f(),Vr=l("td"),cp=s("predict the correct masked token in a sequence"),mp=f(),Qr=l("td"),up=s("NLP"),dp=f(),Jr=l("td"),hp=s("pipeline(task=\u201Cfill-mask\u201D)"),gp=f(),Pe=l("tr"),Zr=l("td"),$p=s("Summarization"),_p=f(),Xr=l("td"),vp=s("generate a summary of a sequence of text or document"),kp=f(),eo=l("td"),wp=s("NLP"),yp=f(),to=l("td"),bp=s("pipeline(task=\u201Csummarization\u201D)"),Tp=f(),xe=l("tr"),ao=l("td"),Ep=s("Translation"),Ap=f(),so=l("td"),jp=s("translate text from one language into another"),qp=f(),ro=l("td"),zp=s("NLP"),Pp=f(),oo=l("td"),xp=s("pipeline(task=\u201Ctranslation\u201D)"),Fp=f(),Fe=l("tr"),no=l("td"),Mp=s("Image classification"),Sp=f(),lo=l("td"),Cp=s("assign a label to an image"),Dp=f(),io=l("td"),Ip=s("Computer vision"),Np=f(),po=l("td"),Op=s("pipeline(task=\u201Cimage-classification\u201D)"),Hp=f(),Me=l("tr"),fo=l("td"),Lp=s("Image segmentation"),Wp=f(),co=l("td"),Rp=s("assign a label to each individual pixel of an image (supports semantic, panoptic, and instance segmentation)"),Yp=f(),mo=l("td"),Up=s("Computer vision"),Kp=f(),uo=l("td"),Gp=s("pipeline(task=\u201Cimage-segmentation\u201D)"),Bp=f(),Se=l("tr"),ho=l("td"),Vp=s("Object detection"),Qp=f(),go=l("td"),Jp=s("predict the bounding boxes and classes of objects in an image"),Zp=f(),$o=l("td"),Xp=s("Computer vision"),ef=f(),_o=l("td"),tf=s("pipeline(task=\u201Cobject-detection\u201D)"),af=f(),Ce=l("tr"),vo=l("td"),sf=s("Audio classification"),rf=f(),ko=l("td"),of=s("assign a label to an audio file"),nf=f(),wo=l("td"),lf=s("Audio"),pf=f(),yo=l("td"),ff=s("pipeline(task=\u201Caudio-classification\u201D)"),cf=f(),De=l("tr"),bo=l("td"),mf=s("Automatic speech recognition"),uf=f(),To=l("td"),df=s("extract speech from an audio file into text"),hf=f(),Eo=l("td"),gf=s("Audio"),$f=f(),Ao=l("td"),_f=s("pipeline(task=\u201Cautomatic-speech-recognition\u201D)"),vf=f(),Ie=l("tr"),jo=l("td"),kf=s("Visual question answering"),wf=f(),qo=l("td"),yf=s("given an image and a question, correctly answer a question about the image"),bf=f(),zo=l("td"),Tf=s("Multimodal"),Ef=f(),Po=l("td"),Af=s("pipeline(task=\u201Cvqa\u201D)"),qn=f(),pe=l("p"),jf=s("Start by creating an instance of "),$s=l("a"),qf=s("pipeline()"),zf=s(" and specifying a task you want to use it for. You can use the "),_s=l("a"),Pf=s("pipeline()"),xf=s(" for any of the previously mentioned tasks, and for a complete list of supported tasks, take a look at the "),vs=l("a"),Ff=s("pipeline API reference"),Mf=s(". In this guide though, you\u2019ll use the "),ks=l("a"),Sf=s("pipeline()"),Cf=s(" for sentiment analysis as an example:"),zn=f(),k(na.$$.fragment),Pn=f(),ke=l("p"),Df=s("The "),ws=l("a"),If=s("pipeline()"),Nf=s(" downloads and caches a default "),la=l("a"),Of=s("pretrained model"),Hf=s(" and tokenizer for sentiment analysis. Now you can use the "),xo=l("code"),Lf=s("classifier"),Wf=s(" on your target text:"),xn=f(),k(ia.$$.fragment),Fn=f(),ht=l("p"),Rf=s("If you have more than one input, pass your inputs as a list to the "),ys=l("a"),Yf=s("pipeline()"),Uf=s(" to return a list of dictionaries:"),Mn=f(),k(pa.$$.fragment),Sn=f(),gt=l("p"),Kf=s("The "),bs=l("a"),Gf=s("pipeline()"),Bf=s(" can also iterate over an entire dataset for any task you like. For this example, let\u2019s choose automatic speech recognition as our task:"),Cn=f(),k(fa.$$.fragment),Dn=f(),We=l("p"),Vf=s("Load an audio dataset (see the \u{1F917} Datasets "),ca=l("a"),Qf=s("Quick Start"),Jf=s(" for more details) you\u2019d like to iterate over. For example, load the "),ma=l("a"),Zf=s("MInDS-14"),Xf=s(" dataset:"),In=f(),k(ua.$$.fragment),Nn=f(),$t=l("p"),ec=s(`You need to make sure the sampling rate of the dataset matches the sampling
rate `),da=l("a"),Fo=l("code"),tc=s("facebook/wav2vec2-base-960h"),ac=s(" was trained on:"),On=f(),k(ha.$$.fragment),Hn=f(),_t=l("p"),sc=s("The audio files are automatically loaded and resampled when calling the "),Mo=l("code"),rc=s('"audio"'),oc=s(` column.
Extract the raw waveform arrays from the first 4 samples and pass it as a list to the pipeline:`),Ln=f(),k(ga.$$.fragment),Wn=f(),vt=l("p"),nc=s("For larger datasets where the inputs are big (like in speech or vision), you\u2019ll want to pass a generator instead of a list to load all the inputs in memory. Take a look at the "),Ts=l("a"),lc=s("pipeline API reference"),ic=s(" for more information."),Rn=f(),tt=l("h3"),kt=l("a"),So=l("span"),k($a.$$.fragment),pc=f(),Co=l("span"),fc=s("Use another model and tokenizer in the pipeline"),Yn=f(),fe=l("p"),cc=s("The "),Es=l("a"),mc=s("pipeline()"),uc=s(" can accommodate any model from the "),_a=l("a"),dc=s("Hub"),hc=s(", making it easy to adapt the "),As=l("a"),gc=s("pipeline()"),$c=s(" for other use-cases. For example, if you\u2019d like a model capable of handling French text, use the tags on the Hub to filter for an appropriate model. The top filtered result returns a multilingual "),va=l("a"),_c=s("BERT model"),vc=s(" finetuned for sentiment analysis you can use for French text:"),Un=f(),k(ka.$$.fragment),Kn=f(),k(wt.$$.fragment),Gn=f(),Re=l("p"),kc=s("Specify the model and tokenizer in the "),js=l("a"),wc=s("pipeline()"),yc=s(", and now you can apply the "),Do=l("code"),bc=s("classifier"),Tc=s(" on French text:"),Bn=f(),k(wa.$$.fragment),Vn=f(),Ye=l("p"),Ec=s("If you can\u2019t find a model for your use-case, you\u2019ll need to finetune a pretrained model on your data. Take a look at our "),qs=l("a"),Ac=s("finetuning tutorial"),jc=s(" to learn how. Finally, after you\u2019ve finetuned your pretrained model, please consider "),zs=l("a"),qc=s("sharing"),zc=s(" the model with the community on the Hub to democratize machine learning for everyone! \u{1F917}"),Qn=f(),at=l("h2"),yt=l("a"),Io=l("span"),k(ya.$$.fragment),Pc=f(),No=l("span"),xc=s("AutoClass"),Jn=f(),k(ba.$$.fragment),Zn=f(),re=l("p"),Fc=s("Under the hood, the "),Ps=l("a"),Mc=s("AutoModelForSequenceClassification"),Sc=s(" and "),xs=l("a"),Cc=s("AutoTokenizer"),Dc=s(" classes work together to power the "),Fs=l("a"),Ic=s("pipeline()"),Nc=s(" you used above. An "),Ms=l("a"),Oc=s("AutoClass"),Hc=s(" is a shortcut that automatically retrieves the architecture of a pretrained model from it\u2019s name or path. You only need to select the appropriate "),Oo=l("code"),Lc=s("AutoClass"),Wc=s(" for your task and it\u2019s associated preprocessing class."),Xn=f(),Ue=l("p"),Rc=s("Let\u2019s return to the example from the previous section and see how you can use the "),Ho=l("code"),Yc=s("AutoClass"),Uc=s(" to replicate the results of the "),Ss=l("a"),Kc=s("pipeline()"),Gc=s("."),el=f(),st=l("h3"),bt=l("a"),Lo=l("span"),k(Ta.$$.fragment),Bc=f(),Wo=l("span"),Vc=s("AutoTokenizer"),tl=f(),Tt=l("p"),Qc=s("A tokenizer is responsible for preprocessing text into an array of numbers as inputs to a model. There are multiple rules that govern the tokenization process, including how to split a word and at what level words should be split (learn more about tokenization in the "),Cs=l("a"),Jc=s("tokenizer summary"),Zc=s("). The most important thing to remember is you need to instantiate a tokenizer with the same model name to ensure you\u2019re using the same tokenization rules a model was pretrained with."),al=f(),Et=l("p"),Xc=s("Load a tokenizer with "),Ds=l("a"),em=s("AutoTokenizer"),tm=s(":"),sl=f(),k(Ea.$$.fragment),rl=f(),Is=l("p"),am=s("Pass your text to the tokenizer:"),ol=f(),k(Aa.$$.fragment),nl=f(),Ns=l("p"),sm=s("The tokenizer returns a dictionary containing:"),ll=f(),At=l("ul"),Os=l("li"),Hs=l("a"),rm=s("input_ids"),om=s(": numerical representions of your tokens."),nm=f(),Ls=l("li"),Ws=l("a"),lm=s("atttention_mask"),im=s(": indicates which tokens should be attended to."),il=f(),Rs=l("p"),pm=s("A tokenizer can also accept a list of inputs, and pad and truncate the text to return a batch with uniform length:"),pl=f(),k(jt.$$.fragment),fl=f(),k(qt.$$.fragment),cl=f(),rt=l("h3"),zt=l("a"),Ro=l("span"),k(ja.$$.fragment),fm=f(),Yo=l("span"),cm=s("AutoModel"),ml=f(),k(Pt.$$.fragment),ul=f(),k(xt.$$.fragment),dl=f(),ot=l("h3"),Ft=l("a"),Uo=l("span"),k(qa.$$.fragment),mm=f(),Ko=l("span"),um=s("Save a model"),hl=f(),k(Mt.$$.fragment),gl=f(),Ke=l("p"),dm=s("One particularly cool \u{1F917} Transformers feature is the ability to save a model and reload it as either a PyTorch or TensorFlow model. The "),Go=l("code"),hm=s("from_pt"),gm=s(" or "),Bo=l("code"),$m=s("from_tf"),_m=s(" parameter can convert the model from one framework to the other:"),$l=f(),k(St.$$.fragment),_l=f(),nt=l("h2"),Ct=l("a"),Vo=l("span"),k(za.$$.fragment),vm=f(),Qo=l("span"),km=s("Custom model builds"),vl=f(),Ys=l("p"),wm=s("You can modify the model\u2019s configuration class to change how a model is built. The configuration specifies a model\u2019s attributes, such as the number of hidden layers or attention heads. You start from scratch when you initialize a model from a custom configuration class. The model attributes are randomly initialized, and you\u2019ll need to train the model before you can use it to get meaningful results."),kl=f(),Ge=l("p"),ym=s("Start by importing "),Us=l("a"),bm=s("AutoConfig"),Tm=s(", and then load the pretrained model you want to modify. Within "),Ks=l("a"),Em=s("AutoConfig.from_pretrained()"),Am=s(", you can specify the attribute you want to change, such as the number of attention heads:"),wl=f(),k(Pa.$$.fragment),yl=f(),k(Dt.$$.fragment),bl=f(),It=l("p"),jm=s("Take a look at the "),Gs=l("a"),qm=s("Create a custom architecture"),zm=s(" guide for more information about building custom configurations."),Tl=f(),lt=l("h2"),Nt=l("a"),Jo=l("span"),k(xa.$$.fragment),Pm=f(),Zo=l("span"),xm=s("Trainer - a PyTorch optimized training loop"),El=f(),Be=l("p"),Fm=s("All models are a standard "),Fa=l("a"),Xo=l("code"),Mm=s("torch.nn.Module"),Sm=s(" so you can use them in any typical training loop. While you can write your own training loop, \u{1F917} Transformers provides a "),Bs=l("a"),Cm=s("Trainer"),Dm=s(" class for PyTorch, which contains the basic training loop and adds additional functionality for features like distributed training, mixed precision, and more."),Al=f(),Ot=l("p"),Im=s("Depending on your task, you\u2019ll typically pass the following parameters to "),Vs=l("a"),Nm=s("Trainer"),Om=s(":"),jl=f(),ce=l("ol"),Ma=l("li"),it=l("p"),Hm=s("A "),Qs=l("a"),Lm=s("PreTrainedModel"),Wm=s(" or a "),Sa=l("a"),en=l("code"),Rm=s("torch.nn.Module"),Ym=s(":"),Um=f(),k(Ca.$$.fragment),Km=f(),Da=l("li"),Js=l("p"),Zs=l("a"),Gm=s("TrainingArguments"),Bm=s(" contains the model hyperparameters you can change like learning rate, batch size, and the number of epochs to train for. The default values are used if you don\u2019t specify any training arguments:"),Vm=f(),k(Ia.$$.fragment),Qm=f(),Na=l("li"),tn=l("p"),Jm=s("A preprocessing class like a tokenizer, feature extractor, or processor:"),Zm=f(),k(Oa.$$.fragment),Xm=f(),Ha=l("li"),an=l("p"),eu=s("Your preprocessed train and test datasets:"),tu=f(),k(La.$$.fragment),au=f(),Wa=l("li"),Ra=l("p"),su=s("A "),sn=l("code"),ru=s("DataCollator()"),ou=s(" to create a batch of examples from your dataset:"),nu=f(),k(Ya.$$.fragment),ql=f(),Ht=l("p"),lu=s("Now gather all these classes in "),Xs=l("a"),iu=s("Trainer"),pu=s(":"),zl=f(),k(Ua.$$.fragment),Pl=f(),Lt=l("p"),fu=s("When you\u2019re ready, call "),er=l("a"),cu=s("train()"),mu=s(" to start training:"),xl=f(),k(Ka.$$.fragment),Fl=f(),k(Wt.$$.fragment),Ml=f(),Ve=l("p"),uu=s("You can customize the training loop behavior by subclassing the methods inside "),tr=l("a"),du=s("Trainer"),hu=s(". This allows you to customize features such as the loss function, optimizer, and scheduler. Take a look at the "),ar=l("a"),gu=s("Trainer"),$u=s(" reference for which methods can be subclassed."),Sl=f(),Qe=l("p"),_u=s("The other way to customize the training loop is by using "),sr=l("a"),vu=s("Callbacks"),ku=s(". You can use callbacks to integrate with other libraries and inspect the training loop to report on progress or stop the training early. Callbacks do not modify anything in the training loop itself. To customize something like the loss function, you need to subclass the "),rr=l("a"),wu=s("Trainer"),yu=s(" instead."),Cl=f(),pt=l("h2"),Rt=l("a"),rn=l("span"),k(Ga.$$.fragment),bu=f(),on=l("span"),Tu=s("Train with TensorFlow"),Dl=f(),te=l("p"),Eu=s("All models are a standard "),Ba=l("a"),nn=l("code"),Au=s("tf.keras.Model"),ju=s(" so they can be trained in TensorFlow with the "),Va=l("a"),qu=s("Keras"),zu=s(" API. \u{1F917} Transformers provides the "),or=l("a"),Pu=s("prepare_tf_dataset()"),xu=s(" method to easily load your dataset as a "),ln=l("code"),Fu=s("tf.data.Dataset"),Mu=s(" so you can start training right away with Keras\u2019 "),Qa=l("a"),pn=l("code"),Su=s("compile"),Cu=s(" and "),Ja=l("a"),fn=l("code"),Du=s("fit"),Iu=s(" methods."),Il=f(),me=l("ol"),Za=l("li"),ft=l("p"),Nu=s("You\u2019ll start with a "),nr=l("a"),Ou=s("TFPreTrainedModel"),Hu=s(" or a "),Xa=l("a"),cn=l("code"),Lu=s("tf.keras.Model"),Wu=s(":"),Ru=f(),k(es.$$.fragment),Yu=f(),ts=l("li"),mn=l("p"),Uu=s("A preprocessing class like a tokenizer, feature extractor, or processor:"),Ku=f(),k(as.$$.fragment),Gu=f(),ss=l("li"),un=l("p"),Bu=s("Create a function to tokenize the dataset:"),Vu=f(),k(rs.$$.fragment),Qu=f(),os=l("li"),ct=l("p"),Ju=s("Apply the tokenizer over the entire dataset with "),ns=l("a"),Zu=s("map"),Xu=s(" and then pass the dataset and tokenizer to "),lr=l("a"),ed=s("prepare_tf_dataset()"),td=s(". You can also change the batch size and shuffle the dataset here if you\u2019d like:"),ad=f(),k(ls.$$.fragment),sd=f(),is=l("li"),mt=l("p"),rd=s("When you\u2019re ready, you can call "),dn=l("code"),od=s("compile"),nd=s(" and "),hn=l("code"),ld=s("fit"),id=s(" to start training:"),pd=f(),k(ps.$$.fragment),Nl=f(),ut=l("h2"),Yt=l("a"),gn=l("span"),k(fs.$$.fragment),fd=f(),$n=l("span"),cd=s("What's next?"),Ol=f(),ir=l("p"),md=s("Now that you\u2019ve completed the \u{1F917} Transformers quick tour, check out our guides and learn how to do more specific things like writing a custom model, fine-tuning a model for a task, and how to train a model with a script. If you\u2019re interested in learning more about \u{1F917} Transformers core concepts, grab a cup of coffee and take a look at our Conceptual Guides!"),this.h()},l(t){const m=P$('[data-svelte="svelte-1phssyn"]',document.head);o=i(m,"META",{name:!0,content:!0}),m.forEach(a),d=c(t),n=i(t,"H1",{class:!0});var cs=p(n);g=i(cs,"A",{id:!0,class:!0,href:!0});var _n=p(g);_=i(_n,"SPAN",{});var vn=p(_);w(v.$$.fragment,vn),vn.forEach(a),_n.forEach(a),q=c(cs),F=i(cs,"SPAN",{});var kn=p(F);$=r(kn,"Quick tour"),kn.forEach(a),cs.forEach(a),j=c(t),w(C.$$.fragment,t),N=c(t),I=i(t,"P",{});var Ne=p(I);W=r(Ne,"Get up and running with \u{1F917} Transformers! Whether you\u2019re a developer or an everyday user, this quick tour will help you get started and show you how to use the "),z=i(Ne,"A",{href:!0});var wn=p(z);S=r(wn,"pipeline()"),wn.forEach(a),A=r(Ne," for inference, load a pretrained model and preprocessor with an "),D=i(Ne,"A",{href:!0});var yn=p(D);K=r(yn,"AutoClass"),yn.forEach(a),R=r(Ne,", and quickly train a model with PyTorch or TensorFlow. If you\u2019re a beginner, we recommend checking out our tutorials or "),V=i(Ne,"A",{href:!0,rel:!0});var bn=p(V);ie=r(bn,"course"),bn.forEach(a),oe=r(Ne," next for more in-depth explanations of the concepts introduced here."),Ne.forEach(a),he=c(t),G=i(t,"P",{});var Tn=p(G);ne=r(Tn,"Before you begin, make sure you have all the necessary libraries installed:"),Tn.forEach(a),le=c(t),w(B.$$.fragment,t),$e=c(t),J=i(t,"P",{});var En=p(J);be=r(En,"You\u2019ll also need to install your preferred machine learning framework:"),En.forEach(a),_e=c(t),w(Q.$$.fragment,t),se=c(t),Z=i(t,"H2",{class:!0});var Ll=p(Z);P=i(Ll,"A",{id:!0,class:!0,href:!0});var gd=p(P);H=i(gd,"SPAN",{});var $d=p(H);w(X.$$.fragment,$d),$d.forEach(a),gd.forEach(a),M=c(Ll),L=i(Ll,"SPAN",{});var _d=p(L);ve=r(_d,"Pipeline"),_d.forEach(a),Ll.forEach(a),He=c(t),w(ae.$$.fragment,t),Le=c(t),ee=i(t,"P",{});var pr=p(ee);us=r(pr,"The "),ge=i(pr,"A",{href:!0});var vd=p(ge);ds=r(vd,"pipeline()"),vd.forEach(a),hs=r(pr," is the easiest way to use a pretrained model for inference. You can use the "),gs=i(pr,"A",{href:!0});var kd=p(gs);wi=r(kd,"pipeline()"),kd.forEach(a),yi=r(pr," out-of-the-box for many tasks across different modalities. Take a look at the table below for some supported tasks:"),pr.forEach(a),jn=c(t),dt=i(t,"TABLE",{});var Wl=p(dt);br=i(Wl,"THEAD",{});var wd=p(br);Te=i(wd,"TR",{});var Ut=p(Te);Tr=i(Ut,"TH",{});var yd=p(Tr);Er=i(yd,"STRONG",{});var bd=p(Er);bi=r(bd,"Task"),bd.forEach(a),yd.forEach(a),Ti=c(Ut),Ar=i(Ut,"TH",{});var Td=p(Ar);jr=i(Td,"STRONG",{});var Ed=p(jr);Ei=r(Ed,"Description"),Ed.forEach(a),Td.forEach(a),Ai=c(Ut),qr=i(Ut,"TH",{});var Ad=p(qr);zr=i(Ad,"STRONG",{});var jd=p(zr);ji=r(jd,"Modality"),jd.forEach(a),Ad.forEach(a),qi=c(Ut),Pr=i(Ut,"TH",{});var qd=p(Pr);xr=i(qd,"STRONG",{});var zd=p(xr);zi=r(zd,"Pipeline identifier"),zd.forEach(a),qd.forEach(a),Ut.forEach(a),wd.forEach(a),Pi=c(Wl),Y=i(Wl,"TBODY",{});var U=p(Y);Ee=i(U,"TR",{});var Kt=p(Ee);Fr=i(Kt,"TD",{});var Pd=p(Fr);xi=r(Pd,"Text classification"),Pd.forEach(a),Fi=c(Kt),Mr=i(Kt,"TD",{});var xd=p(Mr);Mi=r(xd,"assign a label to a given sequence of text"),xd.forEach(a),Si=c(Kt),Sr=i(Kt,"TD",{});var Fd=p(Sr);Ci=r(Fd,"NLP"),Fd.forEach(a),Di=c(Kt),Cr=i(Kt,"TD",{});var Md=p(Cr);Ii=r(Md,"pipeline(task=\u201Csentiment-analysis\u201D)"),Md.forEach(a),Kt.forEach(a),Ni=c(U),Ae=i(U,"TR",{});var Gt=p(Ae);Dr=i(Gt,"TD",{});var Sd=p(Dr);Oi=r(Sd,"Text generation"),Sd.forEach(a),Hi=c(Gt),Ir=i(Gt,"TD",{});var Cd=p(Ir);Li=r(Cd,"generate text that follows a given prompt"),Cd.forEach(a),Wi=c(Gt),Nr=i(Gt,"TD",{});var Dd=p(Nr);Ri=r(Dd,"NLP"),Dd.forEach(a),Yi=c(Gt),Or=i(Gt,"TD",{});var Id=p(Or);Ui=r(Id,"pipeline(task=\u201Ctext-generation\u201D)"),Id.forEach(a),Gt.forEach(a),Ki=c(U),je=i(U,"TR",{});var Bt=p(je);Hr=i(Bt,"TD",{});var Nd=p(Hr);Gi=r(Nd,"Name entity recognition"),Nd.forEach(a),Bi=c(Bt),Lr=i(Bt,"TD",{});var Od=p(Lr);Vi=r(Od,"assign a label to each token in a sequence (people, organization, location, etc.)"),Od.forEach(a),Qi=c(Bt),Wr=i(Bt,"TD",{});var Hd=p(Wr);Ji=r(Hd,"NLP"),Hd.forEach(a),Zi=c(Bt),Rr=i(Bt,"TD",{});var Ld=p(Rr);Xi=r(Ld,"pipeline(task=\u201Cner\u201D)"),Ld.forEach(a),Bt.forEach(a),ep=c(U),qe=i(U,"TR",{});var Vt=p(qe);Yr=i(Vt,"TD",{});var Wd=p(Yr);tp=r(Wd,"Question answering"),Wd.forEach(a),ap=c(Vt),Ur=i(Vt,"TD",{});var Rd=p(Ur);sp=r(Rd,"extract an answer from the text given some context and a question"),Rd.forEach(a),rp=c(Vt),Kr=i(Vt,"TD",{});var Yd=p(Kr);op=r(Yd,"NLP"),Yd.forEach(a),np=c(Vt),Gr=i(Vt,"TD",{});var Ud=p(Gr);lp=r(Ud,"pipeline(task=\u201Cquestion-answering\u201D)"),Ud.forEach(a),Vt.forEach(a),ip=c(U),ze=i(U,"TR",{});var Qt=p(ze);Br=i(Qt,"TD",{});var Kd=p(Br);pp=r(Kd,"Fill-mask"),Kd.forEach(a),fp=c(Qt),Vr=i(Qt,"TD",{});var Gd=p(Vr);cp=r(Gd,"predict the correct masked token in a sequence"),Gd.forEach(a),mp=c(Qt),Qr=i(Qt,"TD",{});var Bd=p(Qr);up=r(Bd,"NLP"),Bd.forEach(a),dp=c(Qt),Jr=i(Qt,"TD",{});var Vd=p(Jr);hp=r(Vd,"pipeline(task=\u201Cfill-mask\u201D)"),Vd.forEach(a),Qt.forEach(a),gp=c(U),Pe=i(U,"TR",{});var Jt=p(Pe);Zr=i(Jt,"TD",{});var Qd=p(Zr);$p=r(Qd,"Summarization"),Qd.forEach(a),_p=c(Jt),Xr=i(Jt,"TD",{});var Jd=p(Xr);vp=r(Jd,"generate a summary of a sequence of text or document"),Jd.forEach(a),kp=c(Jt),eo=i(Jt,"TD",{});var Zd=p(eo);wp=r(Zd,"NLP"),Zd.forEach(a),yp=c(Jt),to=i(Jt,"TD",{});var Xd=p(to);bp=r(Xd,"pipeline(task=\u201Csummarization\u201D)"),Xd.forEach(a),Jt.forEach(a),Tp=c(U),xe=i(U,"TR",{});var Zt=p(xe);ao=i(Zt,"TD",{});var eh=p(ao);Ep=r(eh,"Translation"),eh.forEach(a),Ap=c(Zt),so=i(Zt,"TD",{});var th=p(so);jp=r(th,"translate text from one language into another"),th.forEach(a),qp=c(Zt),ro=i(Zt,"TD",{});var ah=p(ro);zp=r(ah,"NLP"),ah.forEach(a),Pp=c(Zt),oo=i(Zt,"TD",{});var sh=p(oo);xp=r(sh,"pipeline(task=\u201Ctranslation\u201D)"),sh.forEach(a),Zt.forEach(a),Fp=c(U),Fe=i(U,"TR",{});var Xt=p(Fe);no=i(Xt,"TD",{});var rh=p(no);Mp=r(rh,"Image classification"),rh.forEach(a),Sp=c(Xt),lo=i(Xt,"TD",{});var oh=p(lo);Cp=r(oh,"assign a label to an image"),oh.forEach(a),Dp=c(Xt),io=i(Xt,"TD",{});var nh=p(io);Ip=r(nh,"Computer vision"),nh.forEach(a),Np=c(Xt),po=i(Xt,"TD",{});var lh=p(po);Op=r(lh,"pipeline(task=\u201Cimage-classification\u201D)"),lh.forEach(a),Xt.forEach(a),Hp=c(U),Me=i(U,"TR",{});var ea=p(Me);fo=i(ea,"TD",{});var ih=p(fo);Lp=r(ih,"Image segmentation"),ih.forEach(a),Wp=c(ea),co=i(ea,"TD",{});var ph=p(co);Rp=r(ph,"assign a label to each individual pixel of an image (supports semantic, panoptic, and instance segmentation)"),ph.forEach(a),Yp=c(ea),mo=i(ea,"TD",{});var fh=p(mo);Up=r(fh,"Computer vision"),fh.forEach(a),Kp=c(ea),uo=i(ea,"TD",{});var ch=p(uo);Gp=r(ch,"pipeline(task=\u201Cimage-segmentation\u201D)"),ch.forEach(a),ea.forEach(a),Bp=c(U),Se=i(U,"TR",{});var ta=p(Se);ho=i(ta,"TD",{});var mh=p(ho);Vp=r(mh,"Object detection"),mh.forEach(a),Qp=c(ta),go=i(ta,"TD",{});var uh=p(go);Jp=r(uh,"predict the bounding boxes and classes of objects in an image"),uh.forEach(a),Zp=c(ta),$o=i(ta,"TD",{});var dh=p($o);Xp=r(dh,"Computer vision"),dh.forEach(a),ef=c(ta),_o=i(ta,"TD",{});var hh=p(_o);tf=r(hh,"pipeline(task=\u201Cobject-detection\u201D)"),hh.forEach(a),ta.forEach(a),af=c(U),Ce=i(U,"TR",{});var aa=p(Ce);vo=i(aa,"TD",{});var gh=p(vo);sf=r(gh,"Audio classification"),gh.forEach(a),rf=c(aa),ko=i(aa,"TD",{});var $h=p(ko);of=r($h,"assign a label to an audio file"),$h.forEach(a),nf=c(aa),wo=i(aa,"TD",{});var _h=p(wo);lf=r(_h,"Audio"),_h.forEach(a),pf=c(aa),yo=i(aa,"TD",{});var vh=p(yo);ff=r(vh,"pipeline(task=\u201Caudio-classification\u201D)"),vh.forEach(a),aa.forEach(a),cf=c(U),De=i(U,"TR",{});var sa=p(De);bo=i(sa,"TD",{});var kh=p(bo);mf=r(kh,"Automatic speech recognition"),kh.forEach(a),uf=c(sa),To=i(sa,"TD",{});var wh=p(To);df=r(wh,"extract speech from an audio file into text"),wh.forEach(a),hf=c(sa),Eo=i(sa,"TD",{});var yh=p(Eo);gf=r(yh,"Audio"),yh.forEach(a),$f=c(sa),Ao=i(sa,"TD",{});var bh=p(Ao);_f=r(bh,"pipeline(task=\u201Cautomatic-speech-recognition\u201D)"),bh.forEach(a),sa.forEach(a),vf=c(U),Ie=i(U,"TR",{});var ra=p(Ie);jo=i(ra,"TD",{});var Th=p(jo);kf=r(Th,"Visual question answering"),Th.forEach(a),wf=c(ra),qo=i(ra,"TD",{});var Eh=p(qo);yf=r(Eh,"given an image and a question, correctly answer a question about the image"),Eh.forEach(a),bf=c(ra),zo=i(ra,"TD",{});var Ah=p(zo);Tf=r(Ah,"Multimodal"),Ah.forEach(a),Ef=c(ra),Po=i(ra,"TD",{});var jh=p(Po);Af=r(jh,"pipeline(task=\u201Cvqa\u201D)"),jh.forEach(a),ra.forEach(a),U.forEach(a),Wl.forEach(a),qn=c(t),pe=i(t,"P",{});var Je=p(pe);jf=r(Je,"Start by creating an instance of "),$s=i(Je,"A",{href:!0});var qh=p($s);qf=r(qh,"pipeline()"),qh.forEach(a),zf=r(Je," and specifying a task you want to use it for. You can use the "),_s=i(Je,"A",{href:!0});var zh=p(_s);Pf=r(zh,"pipeline()"),zh.forEach(a),xf=r(Je," for any of the previously mentioned tasks, and for a complete list of supported tasks, take a look at the "),vs=i(Je,"A",{href:!0});var Ph=p(vs);Ff=r(Ph,"pipeline API reference"),Ph.forEach(a),Mf=r(Je,". In this guide though, you\u2019ll use the "),ks=i(Je,"A",{href:!0});var xh=p(ks);Sf=r(xh,"pipeline()"),xh.forEach(a),Cf=r(Je," for sentiment analysis as an example:"),Je.forEach(a),zn=c(t),w(na.$$.fragment,t),Pn=c(t),ke=i(t,"P",{});var oa=p(ke);Df=r(oa,"The "),ws=i(oa,"A",{href:!0});var Fh=p(ws);If=r(Fh,"pipeline()"),Fh.forEach(a),Nf=r(oa," downloads and caches a default "),la=i(oa,"A",{href:!0,rel:!0});var Mh=p(la);Of=r(Mh,"pretrained model"),Mh.forEach(a),Hf=r(oa," and tokenizer for sentiment analysis. Now you can use the "),xo=i(oa,"CODE",{});var Sh=p(xo);Lf=r(Sh,"classifier"),Sh.forEach(a),Wf=r(oa," on your target text:"),oa.forEach(a),xn=c(t),w(ia.$$.fragment,t),Fn=c(t),ht=i(t,"P",{});var Rl=p(ht);Rf=r(Rl,"If you have more than one input, pass your inputs as a list to the "),ys=i(Rl,"A",{href:!0});var Ch=p(ys);Yf=r(Ch,"pipeline()"),Ch.forEach(a),Uf=r(Rl," to return a list of dictionaries:"),Rl.forEach(a),Mn=c(t),w(pa.$$.fragment,t),Sn=c(t),gt=i(t,"P",{});var Yl=p(gt);Kf=r(Yl,"The "),bs=i(Yl,"A",{href:!0});var Dh=p(bs);Gf=r(Dh,"pipeline()"),Dh.forEach(a),Bf=r(Yl," can also iterate over an entire dataset for any task you like. For this example, let\u2019s choose automatic speech recognition as our task:"),Yl.forEach(a),Cn=c(t),w(fa.$$.fragment,t),Dn=c(t),We=i(t,"P",{});var fr=p(We);Vf=r(fr,"Load an audio dataset (see the \u{1F917} Datasets "),ca=i(fr,"A",{href:!0,rel:!0});var Ih=p(ca);Qf=r(Ih,"Quick Start"),Ih.forEach(a),Jf=r(fr," for more details) you\u2019d like to iterate over. For example, load the "),ma=i(fr,"A",{href:!0,rel:!0});var Nh=p(ma);Zf=r(Nh,"MInDS-14"),Nh.forEach(a),Xf=r(fr," dataset:"),fr.forEach(a),In=c(t),w(ua.$$.fragment,t),Nn=c(t),$t=i(t,"P",{});var Ul=p($t);ec=r(Ul,`You need to make sure the sampling rate of the dataset matches the sampling
rate `),da=i(Ul,"A",{href:!0,rel:!0});var Oh=p(da);Fo=i(Oh,"CODE",{});var Hh=p(Fo);tc=r(Hh,"facebook/wav2vec2-base-960h"),Hh.forEach(a),Oh.forEach(a),ac=r(Ul," was trained on:"),Ul.forEach(a),On=c(t),w(ha.$$.fragment,t),Hn=c(t),_t=i(t,"P",{});var Kl=p(_t);sc=r(Kl,"The audio files are automatically loaded and resampled when calling the "),Mo=i(Kl,"CODE",{});var Lh=p(Mo);rc=r(Lh,'"audio"'),Lh.forEach(a),oc=r(Kl,` column.
Extract the raw waveform arrays from the first 4 samples and pass it as a list to the pipeline:`),Kl.forEach(a),Ln=c(t),w(ga.$$.fragment,t),Wn=c(t),vt=i(t,"P",{});var Gl=p(vt);nc=r(Gl,"For larger datasets where the inputs are big (like in speech or vision), you\u2019ll want to pass a generator instead of a list to load all the inputs in memory. Take a look at the "),Ts=i(Gl,"A",{href:!0});var Wh=p(Ts);lc=r(Wh,"pipeline API reference"),Wh.forEach(a),ic=r(Gl," for more information."),Gl.forEach(a),Rn=c(t),tt=i(t,"H3",{class:!0});var Bl=p(tt);kt=i(Bl,"A",{id:!0,class:!0,href:!0});var Rh=p(kt);So=i(Rh,"SPAN",{});var Yh=p(So);w($a.$$.fragment,Yh),Yh.forEach(a),Rh.forEach(a),pc=c(Bl),Co=i(Bl,"SPAN",{});var Uh=p(Co);fc=r(Uh,"Use another model and tokenizer in the pipeline"),Uh.forEach(a),Bl.forEach(a),Yn=c(t),fe=i(t,"P",{});var Ze=p(fe);cc=r(Ze,"The "),Es=i(Ze,"A",{href:!0});var Kh=p(Es);mc=r(Kh,"pipeline()"),Kh.forEach(a),uc=r(Ze," can accommodate any model from the "),_a=i(Ze,"A",{href:!0,rel:!0});var Gh=p(_a);dc=r(Gh,"Hub"),Gh.forEach(a),hc=r(Ze,", making it easy to adapt the "),As=i(Ze,"A",{href:!0});var Bh=p(As);gc=r(Bh,"pipeline()"),Bh.forEach(a),$c=r(Ze," for other use-cases. For example, if you\u2019d like a model capable of handling French text, use the tags on the Hub to filter for an appropriate model. The top filtered result returns a multilingual "),va=i(Ze,"A",{href:!0,rel:!0});var Vh=p(va);_c=r(Vh,"BERT model"),Vh.forEach(a),vc=r(Ze," finetuned for sentiment analysis you can use for French text:"),Ze.forEach(a),Un=c(t),w(ka.$$.fragment,t),Kn=c(t),w(wt.$$.fragment,t),Gn=c(t),Re=i(t,"P",{});var cr=p(Re);kc=r(cr,"Specify the model and tokenizer in the "),js=i(cr,"A",{href:!0});var Qh=p(js);wc=r(Qh,"pipeline()"),Qh.forEach(a),yc=r(cr,", and now you can apply the "),Do=i(cr,"CODE",{});var Jh=p(Do);bc=r(Jh,"classifier"),Jh.forEach(a),Tc=r(cr," on French text:"),cr.forEach(a),Bn=c(t),w(wa.$$.fragment,t),Vn=c(t),Ye=i(t,"P",{});var mr=p(Ye);Ec=r(mr,"If you can\u2019t find a model for your use-case, you\u2019ll need to finetune a pretrained model on your data. Take a look at our "),qs=i(mr,"A",{href:!0});var Zh=p(qs);Ac=r(Zh,"finetuning tutorial"),Zh.forEach(a),jc=r(mr," to learn how. Finally, after you\u2019ve finetuned your pretrained model, please consider "),zs=i(mr,"A",{href:!0});var Xh=p(zs);qc=r(Xh,"sharing"),Xh.forEach(a),zc=r(mr," the model with the community on the Hub to democratize machine learning for everyone! \u{1F917}"),mr.forEach(a),Qn=c(t),at=i(t,"H2",{class:!0});var Vl=p(at);yt=i(Vl,"A",{id:!0,class:!0,href:!0});var eg=p(yt);Io=i(eg,"SPAN",{});var tg=p(Io);w(ya.$$.fragment,tg),tg.forEach(a),eg.forEach(a),Pc=c(Vl),No=i(Vl,"SPAN",{});var ag=p(No);xc=r(ag,"AutoClass"),ag.forEach(a),Vl.forEach(a),Jn=c(t),w(ba.$$.fragment,t),Zn=c(t),re=i(t,"P",{});var we=p(re);Fc=r(we,"Under the hood, the "),Ps=i(we,"A",{href:!0});var sg=p(Ps);Mc=r(sg,"AutoModelForSequenceClassification"),sg.forEach(a),Sc=r(we," and "),xs=i(we,"A",{href:!0});var rg=p(xs);Cc=r(rg,"AutoTokenizer"),rg.forEach(a),Dc=r(we," classes work together to power the "),Fs=i(we,"A",{href:!0});var og=p(Fs);Ic=r(og,"pipeline()"),og.forEach(a),Nc=r(we," you used above. An "),Ms=i(we,"A",{href:!0});var ng=p(Ms);Oc=r(ng,"AutoClass"),ng.forEach(a),Hc=r(we," is a shortcut that automatically retrieves the architecture of a pretrained model from it\u2019s name or path. You only need to select the appropriate "),Oo=i(we,"CODE",{});var lg=p(Oo);Lc=r(lg,"AutoClass"),lg.forEach(a),Wc=r(we," for your task and it\u2019s associated preprocessing class."),we.forEach(a),Xn=c(t),Ue=i(t,"P",{});var ur=p(Ue);Rc=r(ur,"Let\u2019s return to the example from the previous section and see how you can use the "),Ho=i(ur,"CODE",{});var ig=p(Ho);Yc=r(ig,"AutoClass"),ig.forEach(a),Uc=r(ur," to replicate the results of the "),Ss=i(ur,"A",{href:!0});var pg=p(Ss);Kc=r(pg,"pipeline()"),pg.forEach(a),Gc=r(ur,"."),ur.forEach(a),el=c(t),st=i(t,"H3",{class:!0});var Ql=p(st);bt=i(Ql,"A",{id:!0,class:!0,href:!0});var fg=p(bt);Lo=i(fg,"SPAN",{});var cg=p(Lo);w(Ta.$$.fragment,cg),cg.forEach(a),fg.forEach(a),Bc=c(Ql),Wo=i(Ql,"SPAN",{});var mg=p(Wo);Vc=r(mg,"AutoTokenizer"),mg.forEach(a),Ql.forEach(a),tl=c(t),Tt=i(t,"P",{});var Jl=p(Tt);Qc=r(Jl,"A tokenizer is responsible for preprocessing text into an array of numbers as inputs to a model. There are multiple rules that govern the tokenization process, including how to split a word and at what level words should be split (learn more about tokenization in the "),Cs=i(Jl,"A",{href:!0});var ug=p(Cs);Jc=r(ug,"tokenizer summary"),ug.forEach(a),Zc=r(Jl,"). The most important thing to remember is you need to instantiate a tokenizer with the same model name to ensure you\u2019re using the same tokenization rules a model was pretrained with."),Jl.forEach(a),al=c(t),Et=i(t,"P",{});var Zl=p(Et);Xc=r(Zl,"Load a tokenizer with "),Ds=i(Zl,"A",{href:!0});var dg=p(Ds);em=r(dg,"AutoTokenizer"),dg.forEach(a),tm=r(Zl,":"),Zl.forEach(a),sl=c(t),w(Ea.$$.fragment,t),rl=c(t),Is=i(t,"P",{});var hg=p(Is);am=r(hg,"Pass your text to the tokenizer:"),hg.forEach(a),ol=c(t),w(Aa.$$.fragment,t),nl=c(t),Ns=i(t,"P",{});var gg=p(Ns);sm=r(gg,"The tokenizer returns a dictionary containing:"),gg.forEach(a),ll=c(t),At=i(t,"UL",{});var Xl=p(At);Os=i(Xl,"LI",{});var ud=p(Os);Hs=i(ud,"A",{href:!0});var $g=p(Hs);rm=r($g,"input_ids"),$g.forEach(a),om=r(ud,": numerical representions of your tokens."),ud.forEach(a),nm=c(Xl),Ls=i(Xl,"LI",{});var dd=p(Ls);Ws=i(dd,"A",{href:!0});var _g=p(Ws);lm=r(_g,"atttention_mask"),_g.forEach(a),im=r(dd,": indicates which tokens should be attended to."),dd.forEach(a),Xl.forEach(a),il=c(t),Rs=i(t,"P",{});var vg=p(Rs);pm=r(vg,"A tokenizer can also accept a list of inputs, and pad and truncate the text to return a batch with uniform length:"),vg.forEach(a),pl=c(t),w(jt.$$.fragment,t),fl=c(t),w(qt.$$.fragment,t),cl=c(t),rt=i(t,"H3",{class:!0});var ei=p(rt);zt=i(ei,"A",{id:!0,class:!0,href:!0});var kg=p(zt);Ro=i(kg,"SPAN",{});var wg=p(Ro);w(ja.$$.fragment,wg),wg.forEach(a),kg.forEach(a),fm=c(ei),Yo=i(ei,"SPAN",{});var yg=p(Yo);cm=r(yg,"AutoModel"),yg.forEach(a),ei.forEach(a),ml=c(t),w(Pt.$$.fragment,t),ul=c(t),w(xt.$$.fragment,t),dl=c(t),ot=i(t,"H3",{class:!0});var ti=p(ot);Ft=i(ti,"A",{id:!0,class:!0,href:!0});var bg=p(Ft);Uo=i(bg,"SPAN",{});var Tg=p(Uo);w(qa.$$.fragment,Tg),Tg.forEach(a),bg.forEach(a),mm=c(ti),Ko=i(ti,"SPAN",{});var Eg=p(Ko);um=r(Eg,"Save a model"),Eg.forEach(a),ti.forEach(a),hl=c(t),w(Mt.$$.fragment,t),gl=c(t),Ke=i(t,"P",{});var dr=p(Ke);dm=r(dr,"One particularly cool \u{1F917} Transformers feature is the ability to save a model and reload it as either a PyTorch or TensorFlow model. The "),Go=i(dr,"CODE",{});var Ag=p(Go);hm=r(Ag,"from_pt"),Ag.forEach(a),gm=r(dr," or "),Bo=i(dr,"CODE",{});var jg=p(Bo);$m=r(jg,"from_tf"),jg.forEach(a),_m=r(dr," parameter can convert the model from one framework to the other:"),dr.forEach(a),$l=c(t),w(St.$$.fragment,t),_l=c(t),nt=i(t,"H2",{class:!0});var ai=p(nt);Ct=i(ai,"A",{id:!0,class:!0,href:!0});var qg=p(Ct);Vo=i(qg,"SPAN",{});var zg=p(Vo);w(za.$$.fragment,zg),zg.forEach(a),qg.forEach(a),vm=c(ai),Qo=i(ai,"SPAN",{});var Pg=p(Qo);km=r(Pg,"Custom model builds"),Pg.forEach(a),ai.forEach(a),vl=c(t),Ys=i(t,"P",{});var xg=p(Ys);wm=r(xg,"You can modify the model\u2019s configuration class to change how a model is built. The configuration specifies a model\u2019s attributes, such as the number of hidden layers or attention heads. You start from scratch when you initialize a model from a custom configuration class. The model attributes are randomly initialized, and you\u2019ll need to train the model before you can use it to get meaningful results."),xg.forEach(a),kl=c(t),Ge=i(t,"P",{});var hr=p(Ge);ym=r(hr,"Start by importing "),Us=i(hr,"A",{href:!0});var Fg=p(Us);bm=r(Fg,"AutoConfig"),Fg.forEach(a),Tm=r(hr,", and then load the pretrained model you want to modify. Within "),Ks=i(hr,"A",{href:!0});var Mg=p(Ks);Em=r(Mg,"AutoConfig.from_pretrained()"),Mg.forEach(a),Am=r(hr,", you can specify the attribute you want to change, such as the number of attention heads:"),hr.forEach(a),wl=c(t),w(Pa.$$.fragment,t),yl=c(t),w(Dt.$$.fragment,t),bl=c(t),It=i(t,"P",{});var si=p(It);jm=r(si,"Take a look at the "),Gs=i(si,"A",{href:!0});var Sg=p(Gs);qm=r(Sg,"Create a custom architecture"),Sg.forEach(a),zm=r(si," guide for more information about building custom configurations."),si.forEach(a),Tl=c(t),lt=i(t,"H2",{class:!0});var ri=p(lt);Nt=i(ri,"A",{id:!0,class:!0,href:!0});var Cg=p(Nt);Jo=i(Cg,"SPAN",{});var Dg=p(Jo);w(xa.$$.fragment,Dg),Dg.forEach(a),Cg.forEach(a),Pm=c(ri),Zo=i(ri,"SPAN",{});var Ig=p(Zo);xm=r(Ig,"Trainer - a PyTorch optimized training loop"),Ig.forEach(a),ri.forEach(a),El=c(t),Be=i(t,"P",{});var gr=p(Be);Fm=r(gr,"All models are a standard "),Fa=i(gr,"A",{href:!0,rel:!0});var Ng=p(Fa);Xo=i(Ng,"CODE",{});var Og=p(Xo);Mm=r(Og,"torch.nn.Module"),Og.forEach(a),Ng.forEach(a),Sm=r(gr," so you can use them in any typical training loop. While you can write your own training loop, \u{1F917} Transformers provides a "),Bs=i(gr,"A",{href:!0});var Hg=p(Bs);Cm=r(Hg,"Trainer"),Hg.forEach(a),Dm=r(gr," class for PyTorch, which contains the basic training loop and adds additional functionality for features like distributed training, mixed precision, and more."),gr.forEach(a),Al=c(t),Ot=i(t,"P",{});var oi=p(Ot);Im=r(oi,"Depending on your task, you\u2019ll typically pass the following parameters to "),Vs=i(oi,"A",{href:!0});var Lg=p(Vs);Nm=r(Lg,"Trainer"),Lg.forEach(a),Om=r(oi,":"),oi.forEach(a),jl=c(t),ce=i(t,"OL",{});var Xe=p(ce);Ma=i(Xe,"LI",{});var ni=p(Ma);it=i(ni,"P",{});var $r=p(it);Hm=r($r,"A "),Qs=i($r,"A",{href:!0});var Wg=p(Qs);Lm=r(Wg,"PreTrainedModel"),Wg.forEach(a),Wm=r($r," or a "),Sa=i($r,"A",{href:!0,rel:!0});var Rg=p(Sa);en=i(Rg,"CODE",{});var Yg=p(en);Rm=r(Yg,"torch.nn.Module"),Yg.forEach(a),Rg.forEach(a),Ym=r($r,":"),$r.forEach(a),Um=c(ni),w(Ca.$$.fragment,ni),ni.forEach(a),Km=c(Xe),Da=i(Xe,"LI",{});var li=p(Da);Js=i(li,"P",{});var hd=p(Js);Zs=i(hd,"A",{href:!0});var Ug=p(Zs);Gm=r(Ug,"TrainingArguments"),Ug.forEach(a),Bm=r(hd," contains the model hyperparameters you can change like learning rate, batch size, and the number of epochs to train for. The default values are used if you don\u2019t specify any training arguments:"),hd.forEach(a),Vm=c(li),w(Ia.$$.fragment,li),li.forEach(a),Qm=c(Xe),Na=i(Xe,"LI",{});var ii=p(Na);tn=i(ii,"P",{});var Kg=p(tn);Jm=r(Kg,"A preprocessing class like a tokenizer, feature extractor, or processor:"),Kg.forEach(a),Zm=c(ii),w(Oa.$$.fragment,ii),ii.forEach(a),Xm=c(Xe),Ha=i(Xe,"LI",{});var pi=p(Ha);an=i(pi,"P",{});var Gg=p(an);eu=r(Gg,"Your preprocessed train and test datasets:"),Gg.forEach(a),tu=c(pi),w(La.$$.fragment,pi),pi.forEach(a),au=c(Xe),Wa=i(Xe,"LI",{});var fi=p(Wa);Ra=i(fi,"P",{});var ci=p(Ra);su=r(ci,"A "),sn=i(ci,"CODE",{});var Bg=p(sn);ru=r(Bg,"DataCollator()"),Bg.forEach(a),ou=r(ci," to create a batch of examples from your dataset:"),ci.forEach(a),nu=c(fi),w(Ya.$$.fragment,fi),fi.forEach(a),Xe.forEach(a),ql=c(t),Ht=i(t,"P",{});var mi=p(Ht);lu=r(mi,"Now gather all these classes in "),Xs=i(mi,"A",{href:!0});var Vg=p(Xs);iu=r(Vg,"Trainer"),Vg.forEach(a),pu=r(mi,":"),mi.forEach(a),zl=c(t),w(Ua.$$.fragment,t),Pl=c(t),Lt=i(t,"P",{});var ui=p(Lt);fu=r(ui,"When you\u2019re ready, call "),er=i(ui,"A",{href:!0});var Qg=p(er);cu=r(Qg,"train()"),Qg.forEach(a),mu=r(ui," to start training:"),ui.forEach(a),xl=c(t),w(Ka.$$.fragment,t),Fl=c(t),w(Wt.$$.fragment,t),Ml=c(t),Ve=i(t,"P",{});var _r=p(Ve);uu=r(_r,"You can customize the training loop behavior by subclassing the methods inside "),tr=i(_r,"A",{href:!0});var Jg=p(tr);du=r(Jg,"Trainer"),Jg.forEach(a),hu=r(_r,". This allows you to customize features such as the loss function, optimizer, and scheduler. Take a look at the "),ar=i(_r,"A",{href:!0});var Zg=p(ar);gu=r(Zg,"Trainer"),Zg.forEach(a),$u=r(_r," reference for which methods can be subclassed."),_r.forEach(a),Sl=c(t),Qe=i(t,"P",{});var vr=p(Qe);_u=r(vr,"The other way to customize the training loop is by using "),sr=i(vr,"A",{href:!0});var Xg=p(sr);vu=r(Xg,"Callbacks"),Xg.forEach(a),ku=r(vr,". You can use callbacks to integrate with other libraries and inspect the training loop to report on progress or stop the training early. Callbacks do not modify anything in the training loop itself. To customize something like the loss function, you need to subclass the "),rr=i(vr,"A",{href:!0});var e$=p(rr);wu=r(e$,"Trainer"),e$.forEach(a),yu=r(vr," instead."),vr.forEach(a),Cl=c(t),pt=i(t,"H2",{class:!0});var di=p(pt);Rt=i(di,"A",{id:!0,class:!0,href:!0});var t$=p(Rt);rn=i(t$,"SPAN",{});var a$=p(rn);w(Ga.$$.fragment,a$),a$.forEach(a),t$.forEach(a),bu=c(di),on=i(di,"SPAN",{});var s$=p(on);Tu=r(s$,"Train with TensorFlow"),s$.forEach(a),di.forEach(a),Dl=c(t),te=i(t,"P",{});var ue=p(te);Eu=r(ue,"All models are a standard "),Ba=i(ue,"A",{href:!0,rel:!0});var r$=p(Ba);nn=i(r$,"CODE",{});var o$=p(nn);Au=r(o$,"tf.keras.Model"),o$.forEach(a),r$.forEach(a),ju=r(ue," so they can be trained in TensorFlow with the "),Va=i(ue,"A",{href:!0,rel:!0});var n$=p(Va);qu=r(n$,"Keras"),n$.forEach(a),zu=r(ue," API. \u{1F917} Transformers provides the "),or=i(ue,"A",{href:!0});var l$=p(or);Pu=r(l$,"prepare_tf_dataset()"),l$.forEach(a),xu=r(ue," method to easily load your dataset as a "),ln=i(ue,"CODE",{});var i$=p(ln);Fu=r(i$,"tf.data.Dataset"),i$.forEach(a),Mu=r(ue," so you can start training right away with Keras\u2019 "),Qa=i(ue,"A",{href:!0,rel:!0});var p$=p(Qa);pn=i(p$,"CODE",{});var f$=p(pn);Su=r(f$,"compile"),f$.forEach(a),p$.forEach(a),Cu=r(ue," and "),Ja=i(ue,"A",{href:!0,rel:!0});var c$=p(Ja);fn=i(c$,"CODE",{});var m$=p(fn);Du=r(m$,"fit"),m$.forEach(a),c$.forEach(a),Iu=r(ue," methods."),ue.forEach(a),Il=c(t),me=i(t,"OL",{});var et=p(me);Za=i(et,"LI",{});var hi=p(Za);ft=i(hi,"P",{});var kr=p(ft);Nu=r(kr,"You\u2019ll start with a "),nr=i(kr,"A",{href:!0});var u$=p(nr);Ou=r(u$,"TFPreTrainedModel"),u$.forEach(a),Hu=r(kr," or a "),Xa=i(kr,"A",{href:!0,rel:!0});var d$=p(Xa);cn=i(d$,"CODE",{});var h$=p(cn);Lu=r(h$,"tf.keras.Model"),h$.forEach(a),d$.forEach(a),Wu=r(kr,":"),kr.forEach(a),Ru=c(hi),w(es.$$.fragment,hi),hi.forEach(a),Yu=c(et),ts=i(et,"LI",{});var gi=p(ts);mn=i(gi,"P",{});var g$=p(mn);Uu=r(g$,"A preprocessing class like a tokenizer, feature extractor, or processor:"),g$.forEach(a),Ku=c(gi),w(as.$$.fragment,gi),gi.forEach(a),Gu=c(et),ss=i(et,"LI",{});var $i=p(ss);un=i($i,"P",{});var $$=p(un);Bu=r($$,"Create a function to tokenize the dataset:"),$$.forEach(a),Vu=c($i),w(rs.$$.fragment,$i),$i.forEach(a),Qu=c(et),os=i(et,"LI",{});var _i=p(os);ct=i(_i,"P",{});var wr=p(ct);Ju=r(wr,"Apply the tokenizer over the entire dataset with "),ns=i(wr,"A",{href:!0,rel:!0});var _$=p(ns);Zu=r(_$,"map"),_$.forEach(a),Xu=r(wr," and then pass the dataset and tokenizer to "),lr=i(wr,"A",{href:!0});var v$=p(lr);ed=r(v$,"prepare_tf_dataset()"),v$.forEach(a),td=r(wr,". You can also change the batch size and shuffle the dataset here if you\u2019d like:"),wr.forEach(a),ad=c(_i),w(ls.$$.fragment,_i),_i.forEach(a),sd=c(et),is=i(et,"LI",{});var vi=p(is);mt=i(vi,"P",{});var yr=p(mt);rd=r(yr,"When you\u2019re ready, you can call "),dn=i(yr,"CODE",{});var k$=p(dn);od=r(k$,"compile"),k$.forEach(a),nd=r(yr," and "),hn=i(yr,"CODE",{});var w$=p(hn);ld=r(w$,"fit"),w$.forEach(a),id=r(yr," to start training:"),yr.forEach(a),pd=c(vi),w(ps.$$.fragment,vi),vi.forEach(a),et.forEach(a),Nl=c(t),ut=i(t,"H2",{class:!0});var ki=p(ut);Yt=i(ki,"A",{id:!0,class:!0,href:!0});var y$=p(Yt);gn=i(y$,"SPAN",{});var b$=p(gn);w(fs.$$.fragment,b$),b$.forEach(a),y$.forEach(a),fd=c(ki),$n=i(ki,"SPAN",{});var T$=p($n);cd=r(T$,"What's next?"),T$.forEach(a),ki.forEach(a),Ol=c(t),ir=i(t,"P",{});var E$=p(ir);md=r(E$,"Now that you\u2019ve completed the \u{1F917} Transformers quick tour, check out our guides and learn how to do more specific things like writing a custom model, fine-tuning a model for a task, and how to train a model with a script. If you\u2019re interested in learning more about \u{1F917} Transformers core concepts, grab a cup of coffee and take a look at our Conceptual Guides!"),E$.forEach(a),this.h()},h(){h(o,"name","hf:doc:metadata"),h(o,"content",JSON.stringify(u_)),h(g,"id","quick-tour"),h(g,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(g,"href","#quick-tour"),h(n,"class","relative group"),h(z,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(D,"href","./model_doc/auto"),h(V,"href","https://huggingface.co/course/chapter1/1"),h(V,"rel","nofollow"),h(P,"id","pipeline"),h(P,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(P,"href","#pipeline"),h(Z,"class","relative group"),h(ge,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(gs,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h($s,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(_s,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(vs,"href","./main_classes/pipelines"),h(ks,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(ws,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(la,"href","https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english"),h(la,"rel","nofollow"),h(ys,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(bs,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(ca,"href","https://huggingface.co/docs/datasets/quickstart#audio"),h(ca,"rel","nofollow"),h(ma,"href","https://huggingface.co/datasets/PolyAI/minds14"),h(ma,"rel","nofollow"),h(da,"href","https://huggingface.co/facebook/wav2vec2-base-960h"),h(da,"rel","nofollow"),h(Ts,"href","./main_classes/pipelines"),h(kt,"id","use-another-model-and-tokenizer-in-the-pipeline"),h(kt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(kt,"href","#use-another-model-and-tokenizer-in-the-pipeline"),h(tt,"class","relative group"),h(Es,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(_a,"href","https://huggingface.co/models"),h(_a,"rel","nofollow"),h(As,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(va,"href","https://huggingface.co/nlptown/bert-base-multilingual-uncased-sentiment"),h(va,"rel","nofollow"),h(js,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(qs,"href","./training"),h(zs,"href","./model_sharing"),h(yt,"id","autoclass"),h(yt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(yt,"href","#autoclass"),h(at,"class","relative group"),h(Ps,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoModelForSequenceClassification"),h(xs,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoTokenizer"),h(Fs,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(Ms,"href","./model_doc/auto"),h(Ss,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),h(bt,"id","autotokenizer"),h(bt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(bt,"href","#autotokenizer"),h(st,"class","relative group"),h(Cs,"href","./tokenizer_summary"),h(Ds,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoTokenizer"),h(Hs,"href","./glossary#input-ids"),h(Ws,"href",".glossary#attention-mask"),h(zt,"id","automodel"),h(zt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(zt,"href","#automodel"),h(rt,"class","relative group"),h(Ft,"id","save-a-model"),h(Ft,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(Ft,"href","#save-a-model"),h(ot,"class","relative group"),h(Ct,"id","custom-model-builds"),h(Ct,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(Ct,"href","#custom-model-builds"),h(nt,"class","relative group"),h(Us,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoConfig"),h(Ks,"href","/docs/transformers/main/en/model_doc/auto#transformers.AutoConfig.from_pretrained"),h(Gs,"href","./create_a_model"),h(Nt,"id","trainer-a-pytorch-optimized-training-loop"),h(Nt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(Nt,"href","#trainer-a-pytorch-optimized-training-loop"),h(lt,"class","relative group"),h(Fa,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),h(Fa,"rel","nofollow"),h(Bs,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer"),h(Vs,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer"),h(Qs,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),h(Sa,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),h(Sa,"rel","nofollow"),h(Zs,"href","/docs/transformers/main/en/main_classes/trainer#transformers.TrainingArguments"),h(Xs,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer"),h(er,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer.train"),h(tr,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer"),h(ar,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer"),h(sr,"href","./main_classes/callbacks"),h(rr,"href","/docs/transformers/main/en/main_classes/trainer#transformers.Trainer"),h(Rt,"id","train-with-tensorflow"),h(Rt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(Rt,"href","#train-with-tensorflow"),h(pt,"class","relative group"),h(Ba,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),h(Ba,"rel","nofollow"),h(Va,"href","https://keras.io/"),h(Va,"rel","nofollow"),h(or,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel.prepare_tf_dataset"),h(Qa,"href","https://keras.io/api/models/model_training_apis/#compile-method"),h(Qa,"rel","nofollow"),h(Ja,"href","https://keras.io/api/models/model_training_apis/#fit-method"),h(Ja,"rel","nofollow"),h(nr,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),h(Xa,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),h(Xa,"rel","nofollow"),h(ns,"href","https://huggingface.co/docs/datasets/main/en/package_reference/main_classes#datasets.Dataset.map"),h(ns,"rel","nofollow"),h(lr,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel.prepare_tf_dataset"),h(Yt,"id","whats-next"),h(Yt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(Yt,"href","#whats-next"),h(ut,"class","relative group")},m(t,m){e(document.head,o),u(t,d,m),u(t,n,m),e(n,g),e(g,_),y(v,_,null),e(n,q),e(n,F),e(F,$),u(t,j,m),y(C,t,m),u(t,N,m),u(t,I,m),e(I,W),e(I,z),e(z,S),e(I,A),e(I,D),e(D,K),e(I,R),e(I,V),e(V,ie),e(I,oe),u(t,he,m),u(t,G,m),e(G,ne),u(t,le,m),y(B,t,m),u(t,$e,m),u(t,J,m),e(J,be),u(t,_e,m),y(Q,t,m),u(t,se,m),u(t,Z,m),e(Z,P),e(P,H),y(X,H,null),e(Z,M),e(Z,L),e(L,ve),u(t,He,m),y(ae,t,m),u(t,Le,m),u(t,ee,m),e(ee,us),e(ee,ge),e(ge,ds),e(ee,hs),e(ee,gs),e(gs,wi),e(ee,yi),u(t,jn,m),u(t,dt,m),e(dt,br),e(br,Te),e(Te,Tr),e(Tr,Er),e(Er,bi),e(Te,Ti),e(Te,Ar),e(Ar,jr),e(jr,Ei),e(Te,Ai),e(Te,qr),e(qr,zr),e(zr,ji),e(Te,qi),e(Te,Pr),e(Pr,xr),e(xr,zi),e(dt,Pi),e(dt,Y),e(Y,Ee),e(Ee,Fr),e(Fr,xi),e(Ee,Fi),e(Ee,Mr),e(Mr,Mi),e(Ee,Si),e(Ee,Sr),e(Sr,Ci),e(Ee,Di),e(Ee,Cr),e(Cr,Ii),e(Y,Ni),e(Y,Ae),e(Ae,Dr),e(Dr,Oi),e(Ae,Hi),e(Ae,Ir),e(Ir,Li),e(Ae,Wi),e(Ae,Nr),e(Nr,Ri),e(Ae,Yi),e(Ae,Or),e(Or,Ui),e(Y,Ki),e(Y,je),e(je,Hr),e(Hr,Gi),e(je,Bi),e(je,Lr),e(Lr,Vi),e(je,Qi),e(je,Wr),e(Wr,Ji),e(je,Zi),e(je,Rr),e(Rr,Xi),e(Y,ep),e(Y,qe),e(qe,Yr),e(Yr,tp),e(qe,ap),e(qe,Ur),e(Ur,sp),e(qe,rp),e(qe,Kr),e(Kr,op),e(qe,np),e(qe,Gr),e(Gr,lp),e(Y,ip),e(Y,ze),e(ze,Br),e(Br,pp),e(ze,fp),e(ze,Vr),e(Vr,cp),e(ze,mp),e(ze,Qr),e(Qr,up),e(ze,dp),e(ze,Jr),e(Jr,hp),e(Y,gp),e(Y,Pe),e(Pe,Zr),e(Zr,$p),e(Pe,_p),e(Pe,Xr),e(Xr,vp),e(Pe,kp),e(Pe,eo),e(eo,wp),e(Pe,yp),e(Pe,to),e(to,bp),e(Y,Tp),e(Y,xe),e(xe,ao),e(ao,Ep),e(xe,Ap),e(xe,so),e(so,jp),e(xe,qp),e(xe,ro),e(ro,zp),e(xe,Pp),e(xe,oo),e(oo,xp),e(Y,Fp),e(Y,Fe),e(Fe,no),e(no,Mp),e(Fe,Sp),e(Fe,lo),e(lo,Cp),e(Fe,Dp),e(Fe,io),e(io,Ip),e(Fe,Np),e(Fe,po),e(po,Op),e(Y,Hp),e(Y,Me),e(Me,fo),e(fo,Lp),e(Me,Wp),e(Me,co),e(co,Rp),e(Me,Yp),e(Me,mo),e(mo,Up),e(Me,Kp),e(Me,uo),e(uo,Gp),e(Y,Bp),e(Y,Se),e(Se,ho),e(ho,Vp),e(Se,Qp),e(Se,go),e(go,Jp),e(Se,Zp),e(Se,$o),e($o,Xp),e(Se,ef),e(Se,_o),e(_o,tf),e(Y,af),e(Y,Ce),e(Ce,vo),e(vo,sf),e(Ce,rf),e(Ce,ko),e(ko,of),e(Ce,nf),e(Ce,wo),e(wo,lf),e(Ce,pf),e(Ce,yo),e(yo,ff),e(Y,cf),e(Y,De),e(De,bo),e(bo,mf),e(De,uf),e(De,To),e(To,df),e(De,hf),e(De,Eo),e(Eo,gf),e(De,$f),e(De,Ao),e(Ao,_f),e(Y,vf),e(Y,Ie),e(Ie,jo),e(jo,kf),e(Ie,wf),e(Ie,qo),e(qo,yf),e(Ie,bf),e(Ie,zo),e(zo,Tf),e(Ie,Ef),e(Ie,Po),e(Po,Af),u(t,qn,m),u(t,pe,m),e(pe,jf),e(pe,$s),e($s,qf),e(pe,zf),e(pe,_s),e(_s,Pf),e(pe,xf),e(pe,vs),e(vs,Ff),e(pe,Mf),e(pe,ks),e(ks,Sf),e(pe,Cf),u(t,zn,m),y(na,t,m),u(t,Pn,m),u(t,ke,m),e(ke,Df),e(ke,ws),e(ws,If),e(ke,Nf),e(ke,la),e(la,Of),e(ke,Hf),e(ke,xo),e(xo,Lf),e(ke,Wf),u(t,xn,m),y(ia,t,m),u(t,Fn,m),u(t,ht,m),e(ht,Rf),e(ht,ys),e(ys,Yf),e(ht,Uf),u(t,Mn,m),y(pa,t,m),u(t,Sn,m),u(t,gt,m),e(gt,Kf),e(gt,bs),e(bs,Gf),e(gt,Bf),u(t,Cn,m),y(fa,t,m),u(t,Dn,m),u(t,We,m),e(We,Vf),e(We,ca),e(ca,Qf),e(We,Jf),e(We,ma),e(ma,Zf),e(We,Xf),u(t,In,m),y(ua,t,m),u(t,Nn,m),u(t,$t,m),e($t,ec),e($t,da),e(da,Fo),e(Fo,tc),e($t,ac),u(t,On,m),y(ha,t,m),u(t,Hn,m),u(t,_t,m),e(_t,sc),e(_t,Mo),e(Mo,rc),e(_t,oc),u(t,Ln,m),y(ga,t,m),u(t,Wn,m),u(t,vt,m),e(vt,nc),e(vt,Ts),e(Ts,lc),e(vt,ic),u(t,Rn,m),u(t,tt,m),e(tt,kt),e(kt,So),y($a,So,null),e(tt,pc),e(tt,Co),e(Co,fc),u(t,Yn,m),u(t,fe,m),e(fe,cc),e(fe,Es),e(Es,mc),e(fe,uc),e(fe,_a),e(_a,dc),e(fe,hc),e(fe,As),e(As,gc),e(fe,$c),e(fe,va),e(va,_c),e(fe,vc),u(t,Un,m),y(ka,t,m),u(t,Kn,m),y(wt,t,m),u(t,Gn,m),u(t,Re,m),e(Re,kc),e(Re,js),e(js,wc),e(Re,yc),e(Re,Do),e(Do,bc),e(Re,Tc),u(t,Bn,m),y(wa,t,m),u(t,Vn,m),u(t,Ye,m),e(Ye,Ec),e(Ye,qs),e(qs,Ac),e(Ye,jc),e(Ye,zs),e(zs,qc),e(Ye,zc),u(t,Qn,m),u(t,at,m),e(at,yt),e(yt,Io),y(ya,Io,null),e(at,Pc),e(at,No),e(No,xc),u(t,Jn,m),y(ba,t,m),u(t,Zn,m),u(t,re,m),e(re,Fc),e(re,Ps),e(Ps,Mc),e(re,Sc),e(re,xs),e(xs,Cc),e(re,Dc),e(re,Fs),e(Fs,Ic),e(re,Nc),e(re,Ms),e(Ms,Oc),e(re,Hc),e(re,Oo),e(Oo,Lc),e(re,Wc),u(t,Xn,m),u(t,Ue,m),e(Ue,Rc),e(Ue,Ho),e(Ho,Yc),e(Ue,Uc),e(Ue,Ss),e(Ss,Kc),e(Ue,Gc),u(t,el,m),u(t,st,m),e(st,bt),e(bt,Lo),y(Ta,Lo,null),e(st,Bc),e(st,Wo),e(Wo,Vc),u(t,tl,m),u(t,Tt,m),e(Tt,Qc),e(Tt,Cs),e(Cs,Jc),e(Tt,Zc),u(t,al,m),u(t,Et,m),e(Et,Xc),e(Et,Ds),e(Ds,em),e(Et,tm),u(t,sl,m),y(Ea,t,m),u(t,rl,m),u(t,Is,m),e(Is,am),u(t,ol,m),y(Aa,t,m),u(t,nl,m),u(t,Ns,m),e(Ns,sm),u(t,ll,m),u(t,At,m),e(At,Os),e(Os,Hs),e(Hs,rm),e(Os,om),e(At,nm),e(At,Ls),e(Ls,Ws),e(Ws,lm),e(Ls,im),u(t,il,m),u(t,Rs,m),e(Rs,pm),u(t,pl,m),y(jt,t,m),u(t,fl,m),y(qt,t,m),u(t,cl,m),u(t,rt,m),e(rt,zt),e(zt,Ro),y(ja,Ro,null),e(rt,fm),e(rt,Yo),e(Yo,cm),u(t,ml,m),y(Pt,t,m),u(t,ul,m),y(xt,t,m),u(t,dl,m),u(t,ot,m),e(ot,Ft),e(Ft,Uo),y(qa,Uo,null),e(ot,mm),e(ot,Ko),e(Ko,um),u(t,hl,m),y(Mt,t,m),u(t,gl,m),u(t,Ke,m),e(Ke,dm),e(Ke,Go),e(Go,hm),e(Ke,gm),e(Ke,Bo),e(Bo,$m),e(Ke,_m),u(t,$l,m),y(St,t,m),u(t,_l,m),u(t,nt,m),e(nt,Ct),e(Ct,Vo),y(za,Vo,null),e(nt,vm),e(nt,Qo),e(Qo,km),u(t,vl,m),u(t,Ys,m),e(Ys,wm),u(t,kl,m),u(t,Ge,m),e(Ge,ym),e(Ge,Us),e(Us,bm),e(Ge,Tm),e(Ge,Ks),e(Ks,Em),e(Ge,Am),u(t,wl,m),y(Pa,t,m),u(t,yl,m),y(Dt,t,m),u(t,bl,m),u(t,It,m),e(It,jm),e(It,Gs),e(Gs,qm),e(It,zm),u(t,Tl,m),u(t,lt,m),e(lt,Nt),e(Nt,Jo),y(xa,Jo,null),e(lt,Pm),e(lt,Zo),e(Zo,xm),u(t,El,m),u(t,Be,m),e(Be,Fm),e(Be,Fa),e(Fa,Xo),e(Xo,Mm),e(Be,Sm),e(Be,Bs),e(Bs,Cm),e(Be,Dm),u(t,Al,m),u(t,Ot,m),e(Ot,Im),e(Ot,Vs),e(Vs,Nm),e(Ot,Om),u(t,jl,m),u(t,ce,m),e(ce,Ma),e(Ma,it),e(it,Hm),e(it,Qs),e(Qs,Lm),e(it,Wm),e(it,Sa),e(Sa,en),e(en,Rm),e(it,Ym),e(Ma,Um),y(Ca,Ma,null),e(ce,Km),e(ce,Da),e(Da,Js),e(Js,Zs),e(Zs,Gm),e(Js,Bm),e(Da,Vm),y(Ia,Da,null),e(ce,Qm),e(ce,Na),e(Na,tn),e(tn,Jm),e(Na,Zm),y(Oa,Na,null),e(ce,Xm),e(ce,Ha),e(Ha,an),e(an,eu),e(Ha,tu),y(La,Ha,null),e(ce,au),e(ce,Wa),e(Wa,Ra),e(Ra,su),e(Ra,sn),e(sn,ru),e(Ra,ou),e(Wa,nu),y(Ya,Wa,null),u(t,ql,m),u(t,Ht,m),e(Ht,lu),e(Ht,Xs),e(Xs,iu),e(Ht,pu),u(t,zl,m),y(Ua,t,m),u(t,Pl,m),u(t,Lt,m),e(Lt,fu),e(Lt,er),e(er,cu),e(Lt,mu),u(t,xl,m),y(Ka,t,m),u(t,Fl,m),y(Wt,t,m),u(t,Ml,m),u(t,Ve,m),e(Ve,uu),e(Ve,tr),e(tr,du),e(Ve,hu),e(Ve,ar),e(ar,gu),e(Ve,$u),u(t,Sl,m),u(t,Qe,m),e(Qe,_u),e(Qe,sr),e(sr,vu),e(Qe,ku),e(Qe,rr),e(rr,wu),e(Qe,yu),u(t,Cl,m),u(t,pt,m),e(pt,Rt),e(Rt,rn),y(Ga,rn,null),e(pt,bu),e(pt,on),e(on,Tu),u(t,Dl,m),u(t,te,m),e(te,Eu),e(te,Ba),e(Ba,nn),e(nn,Au),e(te,ju),e(te,Va),e(Va,qu),e(te,zu),e(te,or),e(or,Pu),e(te,xu),e(te,ln),e(ln,Fu),e(te,Mu),e(te,Qa),e(Qa,pn),e(pn,Su),e(te,Cu),e(te,Ja),e(Ja,fn),e(fn,Du),e(te,Iu),u(t,Il,m),u(t,me,m),e(me,Za),e(Za,ft),e(ft,Nu),e(ft,nr),e(nr,Ou),e(ft,Hu),e(ft,Xa),e(Xa,cn),e(cn,Lu),e(ft,Wu),e(Za,Ru),y(es,Za,null),e(me,Yu),e(me,ts),e(ts,mn),e(mn,Uu),e(ts,Ku),y(as,ts,null),e(me,Gu),e(me,ss),e(ss,un),e(un,Bu),e(ss,Vu),y(rs,ss,null),e(me,Qu),e(me,os),e(os,ct),e(ct,Ju),e(ct,ns),e(ns,Zu),e(ct,Xu),e(ct,lr),e(lr,ed),e(ct,td),e(os,ad),y(ls,os,null),e(me,sd),e(me,is),e(is,mt),e(mt,rd),e(mt,dn),e(dn,od),e(mt,nd),e(mt,hn),e(hn,ld),e(mt,id),e(is,pd),y(ps,is,null),u(t,Nl,m),u(t,ut,m),e(ut,Yt),e(Yt,gn),y(fs,gn,null),e(ut,fd),e(ut,$n),e($n,cd),u(t,Ol,m),u(t,ir,m),e(ir,md),Hl=!0},p(t,[m]){const cs={};m&2&&(cs.$$scope={dirty:m,ctx:t}),Q.$set(cs);const _n={};m&2&&(_n.$$scope={dirty:m,ctx:t}),wt.$set(_n);const vn={};m&2&&(vn.$$scope={dirty:m,ctx:t}),jt.$set(vn);const kn={};m&2&&(kn.$$scope={dirty:m,ctx:t}),qt.$set(kn);const Ne={};m&2&&(Ne.$$scope={dirty:m,ctx:t}),Pt.$set(Ne);const wn={};m&2&&(wn.$$scope={dirty:m,ctx:t}),xt.$set(wn);const yn={};m&2&&(yn.$$scope={dirty:m,ctx:t}),Mt.$set(yn);const bn={};m&2&&(bn.$$scope={dirty:m,ctx:t}),St.$set(bn);const Tn={};m&2&&(Tn.$$scope={dirty:m,ctx:t}),Dt.$set(Tn);const En={};m&2&&(En.$$scope={dirty:m,ctx:t}),Wt.$set(En)},i(t){Hl||(b(v.$$.fragment,t),b(C.$$.fragment,t),b(B.$$.fragment,t),b(Q.$$.fragment,t),b(X.$$.fragment,t),b(ae.$$.fragment,t),b(na.$$.fragment,t),b(ia.$$.fragment,t),b(pa.$$.fragment,t),b(fa.$$.fragment,t),b(ua.$$.fragment,t),b(ha.$$.fragment,t),b(ga.$$.fragment,t),b($a.$$.fragment,t),b(ka.$$.fragment,t),b(wt.$$.fragment,t),b(wa.$$.fragment,t),b(ya.$$.fragment,t),b(ba.$$.fragment,t),b(Ta.$$.fragment,t),b(Ea.$$.fragment,t),b(Aa.$$.fragment,t),b(jt.$$.fragment,t),b(qt.$$.fragment,t),b(ja.$$.fragment,t),b(Pt.$$.fragment,t),b(xt.$$.fragment,t),b(qa.$$.fragment,t),b(Mt.$$.fragment,t),b(St.$$.fragment,t),b(za.$$.fragment,t),b(Pa.$$.fragment,t),b(Dt.$$.fragment,t),b(xa.$$.fragment,t),b(Ca.$$.fragment,t),b(Ia.$$.fragment,t),b(Oa.$$.fragment,t),b(La.$$.fragment,t),b(Ya.$$.fragment,t),b(Ua.$$.fragment,t),b(Ka.$$.fragment,t),b(Wt.$$.fragment,t),b(Ga.$$.fragment,t),b(es.$$.fragment,t),b(as.$$.fragment,t),b(rs.$$.fragment,t),b(ls.$$.fragment,t),b(ps.$$.fragment,t),b(fs.$$.fragment,t),Hl=!0)},o(t){T(v.$$.fragment,t),T(C.$$.fragment,t),T(B.$$.fragment,t),T(Q.$$.fragment,t),T(X.$$.fragment,t),T(ae.$$.fragment,t),T(na.$$.fragment,t),T(ia.$$.fragment,t),T(pa.$$.fragment,t),T(fa.$$.fragment,t),T(ua.$$.fragment,t),T(ha.$$.fragment,t),T(ga.$$.fragment,t),T($a.$$.fragment,t),T(ka.$$.fragment,t),T(wt.$$.fragment,t),T(wa.$$.fragment,t),T(ya.$$.fragment,t),T(ba.$$.fragment,t),T(Ta.$$.fragment,t),T(Ea.$$.fragment,t),T(Aa.$$.fragment,t),T(jt.$$.fragment,t),T(qt.$$.fragment,t),T(ja.$$.fragment,t),T(Pt.$$.fragment,t),T(xt.$$.fragment,t),T(qa.$$.fragment,t),T(Mt.$$.fragment,t),T(St.$$.fragment,t),T(za.$$.fragment,t),T(Pa.$$.fragment,t),T(Dt.$$.fragment,t),T(xa.$$.fragment,t),T(Ca.$$.fragment,t),T(Ia.$$.fragment,t),T(Oa.$$.fragment,t),T(La.$$.fragment,t),T(Ya.$$.fragment,t),T(Ua.$$.fragment,t),T(Ka.$$.fragment,t),T(Wt.$$.fragment,t),T(Ga.$$.fragment,t),T(es.$$.fragment,t),T(as.$$.fragment,t),T(rs.$$.fragment,t),T(ls.$$.fragment,t),T(ps.$$.fragment,t),T(fs.$$.fragment,t),Hl=!1},d(t){a(o),t&&a(d),t&&a(n),E(v),t&&a(j),E(C,t),t&&a(N),t&&a(I),t&&a(he),t&&a(G),t&&a(le),E(B,t),t&&a($e),t&&a(J),t&&a(_e),E(Q,t),t&&a(se),t&&a(Z),E(X),t&&a(He),E(ae,t),t&&a(Le),t&&a(ee),t&&a(jn),t&&a(dt),t&&a(qn),t&&a(pe),t&&a(zn),E(na,t),t&&a(Pn),t&&a(ke),t&&a(xn),E(ia,t),t&&a(Fn),t&&a(ht),t&&a(Mn),E(pa,t),t&&a(Sn),t&&a(gt),t&&a(Cn),E(fa,t),t&&a(Dn),t&&a(We),t&&a(In),E(ua,t),t&&a(Nn),t&&a($t),t&&a(On),E(ha,t),t&&a(Hn),t&&a(_t),t&&a(Ln),E(ga,t),t&&a(Wn),t&&a(vt),t&&a(Rn),t&&a(tt),E($a),t&&a(Yn),t&&a(fe),t&&a(Un),E(ka,t),t&&a(Kn),E(wt,t),t&&a(Gn),t&&a(Re),t&&a(Bn),E(wa,t),t&&a(Vn),t&&a(Ye),t&&a(Qn),t&&a(at),E(ya),t&&a(Jn),E(ba,t),t&&a(Zn),t&&a(re),t&&a(Xn),t&&a(Ue),t&&a(el),t&&a(st),E(Ta),t&&a(tl),t&&a(Tt),t&&a(al),t&&a(Et),t&&a(sl),E(Ea,t),t&&a(rl),t&&a(Is),t&&a(ol),E(Aa,t),t&&a(nl),t&&a(Ns),t&&a(ll),t&&a(At),t&&a(il),t&&a(Rs),t&&a(pl),E(jt,t),t&&a(fl),E(qt,t),t&&a(cl),t&&a(rt),E(ja),t&&a(ml),E(Pt,t),t&&a(ul),E(xt,t),t&&a(dl),t&&a(ot),E(qa),t&&a(hl),E(Mt,t),t&&a(gl),t&&a(Ke),t&&a($l),E(St,t),t&&a(_l),t&&a(nt),E(za),t&&a(vl),t&&a(Ys),t&&a(kl),t&&a(Ge),t&&a(wl),E(Pa,t),t&&a(yl),E(Dt,t),t&&a(bl),t&&a(It),t&&a(Tl),t&&a(lt),E(xa),t&&a(El),t&&a(Be),t&&a(Al),t&&a(Ot),t&&a(jl),t&&a(ce),E(Ca),E(Ia),E(Oa),E(La),E(Ya),t&&a(ql),t&&a(Ht),t&&a(zl),E(Ua,t),t&&a(Pl),t&&a(Lt),t&&a(xl),E(Ka,t),t&&a(Fl),E(Wt,t),t&&a(Ml),t&&a(Ve),t&&a(Sl),t&&a(Qe),t&&a(Cl),t&&a(pt),E(Ga),t&&a(Dl),t&&a(te),t&&a(Il),t&&a(me),E(es),E(as),E(rs),E(ls),E(ps),t&&a(Nl),t&&a(ut),E(fs),t&&a(Ol),t&&a(ir)}}}const u_={local:"quick-tour",sections:[{local:"pipeline",sections:[{local:"use-another-model-and-tokenizer-in-the-pipeline",title:"Use another model and tokenizer in the pipeline"}],title:"Pipeline"},{local:"autoclass",sections:[{local:"autotokenizer",title:"AutoTokenizer"},{local:"automodel",title:"AutoModel"},{local:"save-a-model",title:"Save a model"}],title:"AutoClass"},{local:"custom-model-builds",title:"Custom model builds"},{local:"trainer-a-pytorch-optimized-training-loop",title:"Trainer - a PyTorch optimized training loop"},{local:"train-with-tensorflow",title:"Train with TensorFlow"},{local:"whats-next",title:"What's next?"}],title:"Quick tour"};function d_(x){return x$(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class y_ extends j${constructor(o){super();q$(this,o,d_,m_,z$,{})}}export{y_ as default,u_ as metadata};
