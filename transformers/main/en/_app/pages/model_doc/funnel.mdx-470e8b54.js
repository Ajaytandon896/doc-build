import{S as W2,i as B2,s as Q2,e as r,k as l,w as F,t,M as U2,c as a,d as n,m as d,a as i,x as v,h as o,b as c,F as e,g as h,y as b,q as y,o as w,B as $,v as R2}from"../../chunks/vendor-6b77c823.js";import{T as qe}from"../../chunks/Tip-39098574.js";import{D as X}from"../../chunks/Docstring-1088f2fb.js";import{C as be}from"../../chunks/CodeBlock-3a8b25a8.js";import{I as Ce}from"../../chunks/IconCopyLink-7a11ce68.js";function V2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function H2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function Y2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function K2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function G2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function Z2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function X2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function J2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function e$(H){let u,z,g,_,k,T,f,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,me,W,ee,ae,Q,fe,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),me=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),fe=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),f=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);me=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);fe=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,f),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,me),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,fe),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function n$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function t$(H){let u,z,g,_,k,T,f,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,me,W,ee,ae,Q,fe,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),me=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),fe=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),f=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);me=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);fe=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,f),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,me),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,fe),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function o$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function s$(H){let u,z,g,_,k,T,f,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,me,W,ee,ae,Q,fe,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),me=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),fe=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),f=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);me=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);fe=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,f),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,me),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,fe),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function r$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function a$(H){let u,z,g,_,k,T,f,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,me,W,ee,ae,Q,fe,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),me=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),fe=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),f=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);me=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);fe=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,f),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,me),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,fe),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function i$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function l$(H){let u,z,g,_,k,T,f,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,me,W,ee,ae,Q,fe,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),me=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),fe=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),f=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);me=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);fe=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,f),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,me),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,fe),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function d$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function c$(H){let u,z,g,_,k,T,f,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,me,W,ee,ae,Q,fe,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),me=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),fe=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),f=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);me=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);fe=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,f),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,me),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,fe),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function p$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function u$(H){let u,z,g,_,k,T,f,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,me,W,ee,ae,Q,fe,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),me=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),fe=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),f=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);me=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);fe=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,f),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,me),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,fe),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function h$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function m$(H){let u,z,g,_,k,T,f,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,me,W,ee,ae,Q,fe,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),me=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),fe=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),f=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);me=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);fe=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,f),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,me),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,fe),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function f$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var f=i(u);z=o(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(f,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(n)},m(T,f){h(T,u,f),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function g$(H){let u,z,g,_,k,T,f,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,me,W,ee,ae,Q,fe,I,O,re,U,ge,p,E,Z,Te,ye,D,ke,we,$e,j,R,Ee,Fe,V,Me,ve,_e,ze,oi,Yu,Ku,Oc,In,Gu,No,Zu,Xu,So,Ju,eh,Dc,Zn,Wt,Fl,Io,nh,vl,th,Ac,Nn,Wo,oh,Sn,sh,si,rh,ah,ri,ih,lh,Bo,dh,ch,ph,Xn,uh,ai,hh,mh,ii,fh,gh,Nc,Jn,Bt,bl,Qo,_h,yl,Th,Sc,xe,Uo,kh,wl,Fh,vh,Qt,li,bh,yh,di,wh,$h,Eh,Ro,Mh,ci,zh,qh,Ph,Wn,Vo,Ch,$l,xh,jh,Ho,pi,Lh,El,Oh,Dh,ui,Ah,Ml,Nh,Sh,Ut,Yo,Ih,Ko,Wh,zl,Bh,Qh,Uh,bn,Go,Rh,ql,Vh,Hh,Zo,Yh,et,Kh,Pl,Gh,Zh,Cl,Xh,Jh,em,hi,Xo,Ic,nt,Rt,xl,Jo,nm,jl,tm,Wc,sn,es,om,ns,sm,Ll,rm,am,im,Vt,mi,lm,dm,fi,cm,pm,um,ts,hm,gi,mm,fm,gm,yn,os,_m,Ol,Tm,km,ss,Fm,tt,vm,Dl,bm,ym,Al,wm,$m,Bc,ot,Ht,Nl,rs,Em,Sl,Mm,Qc,st,as,zm,is,qm,_i,Pm,Cm,Uc,rt,ls,xm,ds,jm,Ti,Lm,Om,Rc,at,Yt,Il,cs,Dm,Wl,Am,Vc,Qe,ps,Nm,Bl,Sm,Im,us,Wm,hs,Bm,Qm,Um,ms,Rm,ki,Vm,Hm,Ym,fs,Km,gs,Gm,Zm,Xm,rn,_s,Jm,it,ef,Fi,nf,tf,Ql,of,sf,rf,Kt,af,Ul,lf,df,Ts,Hc,lt,Gt,Rl,ks,cf,Vl,pf,Yc,Ue,Fs,uf,Hl,hf,mf,vs,ff,bs,gf,_f,Tf,ys,kf,vi,Ff,vf,bf,ws,yf,$s,wf,$f,Ef,an,Es,Mf,dt,zf,bi,qf,Pf,Yl,Cf,xf,jf,Zt,Lf,Kl,Of,Df,Ms,Kc,ct,Xt,Gl,zs,Af,Zl,Nf,Gc,pt,qs,Sf,ln,Ps,If,ut,Wf,yi,Bf,Qf,Xl,Uf,Rf,Vf,Jt,Hf,Jl,Yf,Kf,Cs,Zc,ht,eo,ed,xs,Gf,nd,Zf,Xc,Re,js,Xf,Ls,Jf,td,eg,ng,tg,Os,og,Ds,sg,rg,ag,As,ig,wi,lg,dg,cg,Ns,pg,Ss,ug,hg,mg,Ge,Is,fg,mt,gg,$i,_g,Tg,od,kg,Fg,vg,no,bg,sd,yg,wg,Ws,$g,Bs,Jc,ft,to,rd,Qs,Eg,ad,Mg,ep,Ve,Us,zg,id,qg,Pg,Rs,Cg,Vs,xg,jg,Lg,Hs,Og,Ei,Dg,Ag,Ng,Ys,Sg,Ks,Ig,Wg,Bg,Pe,Gs,Qg,gt,Ug,Mi,Rg,Vg,ld,Hg,Yg,Kg,oo,Gg,dd,Zg,Xg,Zs,Jg,Xs,e_,cd,n_,t_,Js,o_,er,np,_t,so,pd,nr,s_,ud,r_,tp,He,tr,a_,hd,i_,l_,or,d_,sr,c_,p_,u_,rr,h_,zi,m_,f_,g_,ar,__,ir,T_,k_,F_,dn,lr,v_,Tt,b_,qi,y_,w_,md,$_,E_,M_,ro,z_,fd,q_,P_,dr,op,kt,ao,gd,cr,C_,_d,x_,sp,Ye,pr,j_,Td,L_,O_,ur,D_,hr,A_,N_,S_,mr,I_,Pi,W_,B_,Q_,fr,U_,gr,R_,V_,H_,Ze,_r,Y_,Ft,K_,Ci,G_,Z_,kd,X_,J_,eT,io,nT,Fd,tT,oT,Tr,sT,kr,rp,vt,lo,vd,Fr,rT,bd,aT,ap,Ke,vr,iT,bt,lT,yd,dT,cT,wd,pT,uT,hT,br,mT,yr,fT,gT,_T,wr,TT,xi,kT,FT,vT,$r,bT,Er,yT,wT,$T,Xe,Mr,ET,yt,MT,ji,zT,qT,$d,PT,CT,xT,co,jT,Ed,LT,OT,zr,DT,qr,ip,wt,po,Md,Pr,AT,zd,NT,lp,Le,Cr,ST,qd,IT,WT,xr,BT,jr,QT,UT,RT,Lr,VT,Li,HT,YT,KT,Or,GT,Dr,ZT,XT,JT,uo,ek,cn,Ar,nk,$t,tk,Oi,ok,sk,Pd,rk,ak,ik,ho,lk,Cd,dk,ck,Nr,dp,Et,mo,xd,Sr,pk,jd,uk,cp,Oe,Ir,hk,Ld,mk,fk,Wr,gk,Br,_k,Tk,kk,Qr,Fk,Di,vk,bk,yk,Ur,wk,Rr,$k,Ek,Mk,fo,zk,pn,Vr,qk,Mt,Pk,Ai,Ck,xk,Od,jk,Lk,Ok,go,Dk,Dd,Ak,Nk,Hr,pp,zt,_o,Ad,Yr,Sk,Nd,Ik,up,De,Kr,Wk,Sd,Bk,Qk,Gr,Uk,Zr,Rk,Vk,Hk,Xr,Yk,Ni,Kk,Gk,Zk,Jr,Xk,ea,Jk,eF,nF,To,tF,un,na,oF,qt,sF,Si,rF,aF,Id,iF,lF,dF,ko,cF,Wd,pF,uF,ta,hp,Pt,Fo,Bd,oa,hF,Qd,mF,mp,Ae,sa,fF,ra,gF,Ud,_F,TF,kF,aa,FF,ia,vF,bF,yF,la,wF,Ii,$F,EF,MF,da,zF,ca,qF,PF,CF,vo,xF,Je,pa,jF,Ct,LF,Wi,OF,DF,Rd,AF,NF,SF,bo,IF,Vd,WF,BF,ua,QF,ha,fp,xt,yo,Hd,ma,UF,Yd,RF,gp,Ne,fa,VF,Kd,HF,YF,ga,KF,_a,GF,ZF,XF,Ta,JF,Bi,ev,nv,tv,ka,ov,Fa,sv,rv,av,wo,iv,en,va,lv,jt,dv,Qi,cv,pv,Gd,uv,hv,mv,$o,fv,Zd,gv,_v,ba,Tv,ya,_p,Lt,Eo,Xd,wa,kv,Jd,Fv,Tp,Se,$a,vv,ec,bv,yv,Ea,wv,Ma,$v,Ev,Mv,za,zv,Ui,qv,Pv,Cv,qa,xv,Pa,jv,Lv,Ov,Mo,Dv,hn,Ca,Av,Ot,Nv,Ri,Sv,Iv,nc,Wv,Bv,Qv,zo,Uv,tc,Rv,Vv,xa,kp,Dt,qo,oc,ja,Hv,sc,Yv,Fp,Ie,La,Kv,rc,Gv,Zv,Oa,Xv,Da,Jv,eb,nb,Aa,tb,Vi,ob,sb,rb,Na,ab,Sa,ib,lb,db,Po,cb,nn,Ia,pb,At,ub,Hi,hb,mb,ac,fb,gb,_b,Co,Tb,ic,kb,Fb,Wa,vb,Ba,vp,Nt,xo,lc,Qa,bb,dc,yb,bp,We,Ua,wb,St,$b,cc,Eb,Mb,pc,zb,qb,Pb,Ra,Cb,Va,xb,jb,Lb,Ha,Ob,Yi,Db,Ab,Nb,Ya,Sb,Ka,Ib,Wb,Bb,jo,Qb,tn,Ga,Ub,It,Rb,Ki,Vb,Hb,uc,Yb,Kb,Gb,Lo,Zb,hc,Xb,Jb,Za,ey,Xa,yp;return T=new Ce({}),ne=new Ce({}),Io=new Ce({}),Wo=new X({props:{name:"class transformers.FunnelConfig",anchor:"transformers.FunnelConfig",parameters:[{name:"vocab_size",val:" = 30522"},{name:"block_sizes",val:" = [4, 4, 4]"},{name:"block_repeats",val:" = None"},{name:"num_decoder_layers",val:" = 2"},{name:"d_model",val:" = 768"},{name:"n_head",val:" = 12"},{name:"d_head",val:" = 64"},{name:"d_inner",val:" = 3072"},{name:"hidden_act",val:" = 'gelu_new'"},{name:"hidden_dropout",val:" = 0.1"},{name:"attention_dropout",val:" = 0.1"},{name:"activation_dropout",val:" = 0.0"},{name:"max_position_embeddings",val:" = 512"},{name:"type_vocab_size",val:" = 3"},{name:"initializer_range",val:" = 0.1"},{name:"initializer_std",val:" = None"},{name:"layer_norm_eps",val:" = 1e-09"},{name:"pooling_type",val:" = 'mean'"},{name:"attention_type",val:" = 'relative_shift'"},{name:"separate_cls",val:" = True"},{name:"truncate_seq",val:" = True"},{name:"pool_q_only",val:" = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FunnelConfig.vocab_size",description:`<strong>vocab_size</strong> (<code>int</code>, <em>optional</em>, defaults to 30522) &#x2014;
Vocabulary size of the Funnel transformer. Defines the number of different tokens that can be represented
by the <code>inputs_ids</code> passed when calling <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelModel">FunnelModel</a> or <a href="/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelModel">TFFunnelModel</a>.`,name:"vocab_size"},{anchor:"transformers.FunnelConfig.block_sizes",description:`<strong>block_sizes</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[4, 4, 4]</code>) &#x2014;
The sizes of the blocks used in the model.`,name:"block_sizes"},{anchor:"transformers.FunnelConfig.block_repeats",description:`<strong>block_repeats</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
If passed along, each layer of each block is repeated the number of times indicated.`,name:"block_repeats"},{anchor:"transformers.FunnelConfig.num_decoder_layers",description:`<strong>num_decoder_layers</strong> (<code>int</code>, <em>optional</em>, defaults to 2) &#x2014;
The number of layers in the decoder (when not using the base model).`,name:"num_decoder_layers"},{anchor:"transformers.FunnelConfig.d_model",description:`<strong>d_model</strong> (<code>int</code>, <em>optional</em>, defaults to 768) &#x2014;
Dimensionality of the model&#x2019;s hidden states.`,name:"d_model"},{anchor:"transformers.FunnelConfig.n_head",description:`<strong>n_head</strong> (<code>int</code>, <em>optional</em>, defaults to 12) &#x2014;
Number of attention heads for each attention layer in the Transformer encoder.`,name:"n_head"},{anchor:"transformers.FunnelConfig.d_head",description:`<strong>d_head</strong> (<code>int</code>, <em>optional</em>, defaults to 64) &#x2014;
Dimensionality of the model&#x2019;s heads.`,name:"d_head"},{anchor:"transformers.FunnelConfig.d_inner",description:`<strong>d_inner</strong> (<code>int</code>, <em>optional</em>, defaults to 3072) &#x2014;
Inner dimension in the feed-forward blocks.`,name:"d_inner"},{anchor:"transformers.FunnelConfig.hidden_act",description:`<strong>hidden_act</strong> (<code>str</code> or <code>callable</code>, <em>optional</em>, defaults to <code>&quot;gelu_new&quot;</code>) &#x2014;
The non-linear activation function (function or string) in the encoder and pooler. If string, <code>&quot;gelu&quot;</code>,
<code>&quot;relu&quot;</code>, <code>&quot;silu&quot;</code> and <code>&quot;gelu_new&quot;</code> are supported.`,name:"hidden_act"},{anchor:"transformers.FunnelConfig.hidden_dropout",description:`<strong>hidden_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.`,name:"hidden_dropout"},{anchor:"transformers.FunnelConfig.attention_dropout",description:`<strong>attention_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probability for the attention probabilities.`,name:"attention_dropout"},{anchor:"transformers.FunnelConfig.activation_dropout",description:`<strong>activation_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The dropout probability used between the two layers of the feed-forward blocks.`,name:"activation_dropout"},{anchor:"transformers.FunnelConfig.max_position_embeddings",description:`<strong>max_position_embeddings</strong> (<code>int</code>, <em>optional</em>, defaults to 512) &#x2014;
The maximum sequence length that this model might ever be used with. Typically set this to something large
just in case (e.g., 512 or 1024 or 2048).`,name:"max_position_embeddings"},{anchor:"transformers.FunnelConfig.type_vocab_size",description:`<strong>type_vocab_size</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
The vocabulary size of the <code>token_type_ids</code> passed when calling <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelModel">FunnelModel</a> or <a href="/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelModel">TFFunnelModel</a>.`,name:"type_vocab_size"},{anchor:"transformers.FunnelConfig.initializer_range",description:`<strong>initializer_range</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The upper bound of the <em>uniform initializer</em> for initializing all weight matrices in attention layers.`,name:"initializer_range"},{anchor:"transformers.FunnelConfig.initializer_std",description:`<strong>initializer_std</strong> (<code>float</code>, <em>optional</em>) &#x2014;
The standard deviation of the <em>normal initializer</em> for initializing the embedding matrix and the weight of
linear layers. Will default to 1 for the embedding matrix and the value given by Xavier initialization for
linear layers.`,name:"initializer_std"},{anchor:"transformers.FunnelConfig.layer_norm_eps",description:`<strong>layer_norm_eps</strong> (<code>float</code>, <em>optional</em>, defaults to 1e-9) &#x2014;
The epsilon used by the layer normalization layers.`,name:"layer_norm_eps"},{anchor:"transformers.FunnelConfig.pooling_type",description:`<strong>pooling_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;mean&quot;</code>) &#x2014;
Possible values are <code>&quot;mean&quot;</code> or <code>&quot;max&quot;</code>. The way pooling is performed at the beginning of each block.`,name:"pooling_type"},{anchor:"transformers.FunnelConfig.attention_type",description:`<strong>attention_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;relative_shift&quot;</code>) &#x2014;
Possible values are <code>&quot;relative_shift&quot;</code> or <code>&quot;factorized&quot;</code>. The former is faster on CPU/GPU while the latter
is faster on TPU.`,name:"attention_type"},{anchor:"transformers.FunnelConfig.separate_cls",description:`<strong>separate_cls</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to separate the cls token when applying pooling.`,name:"separate_cls"},{anchor:"transformers.FunnelConfig.truncate_seq",description:`<strong>truncate_seq</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
When using <code>separate_cls</code>, whether or not to truncate the last token when pooling, to avoid getting a
sequence length that is not a multiple of 2.`,name:"truncate_seq"},{anchor:"transformers.FunnelConfig.pool_q_only",description:`<strong>pool_q_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to apply the pooling only to the query or to query, key and values for the attention layers.`,name:"pool_q_only"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/configuration_funnel.py#L37"}}),Qo=new Ce({}),Uo=new X({props:{name:"class transformers.FunnelTokenizer",anchor:"transformers.FunnelTokenizer",parameters:[{name:"vocab_file",val:""},{name:"do_lower_case",val:" = True"},{name:"do_basic_tokenize",val:" = True"},{name:"never_split",val:" = None"},{name:"unk_token",val:" = '<unk>'"},{name:"sep_token",val:" = '<sep>'"},{name:"pad_token",val:" = '<pad>'"},{name:"cls_token",val:" = '<cls>'"},{name:"mask_token",val:" = '<mask>'"},{name:"bos_token",val:" = '<s>'"},{name:"eos_token",val:" = '</s>'"},{name:"tokenize_chinese_chars",val:" = True"},{name:"strip_accents",val:" = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/tokenization_funnel.py#L58"}}),Vo=new X({props:{name:"build_inputs_with_special_tokens",anchor:"transformers.FunnelTokenizer.build_inputs_with_special_tokens",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],parametersDescription:[{anchor:"transformers.FunnelTokenizer.build_inputs_with_special_tokens.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs to which the special tokens will be added.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizer.build_inputs_with_special_tokens.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/bert/tokenization_bert.py#L248",returnDescription:`
<p>List of <a href="../glossary#input-ids">input IDs</a> with the appropriate special tokens.</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Yo=new X({props:{name:"get_special_tokens_mask",anchor:"transformers.FunnelTokenizer.get_special_tokens_mask",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"},{name:"already_has_special_tokens",val:": bool = False"}],parametersDescription:[{anchor:"transformers.FunnelTokenizer.get_special_tokens_mask.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizer.get_special_tokens_mask.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"},{anchor:"transformers.FunnelTokenizer.get_special_tokens_mask.already_has_special_tokens",description:`<strong>already_has_special_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the token list is already formatted with special tokens for the model.`,name:"already_has_special_tokens"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/bert/tokenization_bert.py#L273",returnDescription:`
<p>A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Go=new X({props:{name:"create_token_type_ids_from_sequences",anchor:"transformers.FunnelTokenizer.create_token_type_ids_from_sequences",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],parametersDescription:[{anchor:"transformers.FunnelTokenizer.create_token_type_ids_from_sequences.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizer.create_token_type_ids_from_sequences.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/tokenization_funnel.py#L108",returnDescription:`
<p>List of <a href="../glossary#token-type-ids">token type IDs</a> according to the given sequence(s).</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Zo=new be({props:{code:`2 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1
| first sequence    | second sequence |`,highlighted:`2<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1 1
| first sequence    | second sequence |`}}),Xo=new X({props:{name:"save_vocabulary",anchor:"transformers.FunnelTokenizer.save_vocabulary",parameters:[{name:"save_directory",val:": str"},{name:"filename_prefix",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/bert/tokenization_bert.py#L330"}}),Jo=new Ce({}),es=new X({props:{name:"class transformers.FunnelTokenizerFast",anchor:"transformers.FunnelTokenizerFast",parameters:[{name:"vocab_file",val:" = None"},{name:"tokenizer_file",val:" = None"},{name:"do_lower_case",val:" = True"},{name:"unk_token",val:" = '<unk>'"},{name:"sep_token",val:" = '<sep>'"},{name:"pad_token",val:" = '<pad>'"},{name:"cls_token",val:" = '<cls>'"},{name:"mask_token",val:" = '<mask>'"},{name:"bos_token",val:" = '<s>'"},{name:"eos_token",val:" = '</s>'"},{name:"clean_text",val:" = True"},{name:"tokenize_chinese_chars",val:" = True"},{name:"strip_accents",val:" = None"},{name:"wordpieces_prefix",val:" = '##'"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/tokenization_funnel_fast.py#L71"}}),os=new X({props:{name:"create_token_type_ids_from_sequences",anchor:"transformers.FunnelTokenizerFast.create_token_type_ids_from_sequences",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],parametersDescription:[{anchor:"transformers.FunnelTokenizerFast.create_token_type_ids_from_sequences.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizerFast.create_token_type_ids_from_sequences.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/tokenization_funnel_fast.py#L124",returnDescription:`
<p>List of <a href="../glossary#token-type-ids">token type IDs</a> according to the given sequence(s).</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),ss=new be({props:{code:`2 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1
| first sequence    | second sequence |`,highlighted:`2<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1 1
| first sequence    | second sequence |`}}),rs=new Ce({}),as=new X({props:{name:"class transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput",anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput",parameters:[{name:"loss",val:": typing.Optional[torch.FloatTensor] = None"},{name:"logits",val:": FloatTensor = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"}],parametersDescription:[{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.loss",description:`<strong>loss</strong> (<em>optional</em>, returned when <code>labels</code> is provided, <code>torch.FloatTensor</code> of shape <code>(1,)</code>) &#x2014;
Total loss of the ELECTRA-style objective.`,name:"loss"},{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.logits",description:`<strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Prediction scores of the head (scores for each token before SoftMax).`,name:"logits"},{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.`,name:"hidden_states"},{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.`,name:"attentions"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L834"}}),ls=new X({props:{name:"class transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput",anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput",parameters:[{name:"logits",val:": Tensor = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[tensorflow.python.framework.ops.Tensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[tensorflow.python.framework.ops.Tensor]] = None"}],parametersDescription:[{anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput.logits",description:`<strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Prediction scores of the head (scores for each token before SoftMax).`,name:"logits"},{anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.`,name:"hidden_states"},{anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.`,name:"attentions"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L978"}}),cs=new Ce({}),ps=new X({props:{name:"class transformers.FunnelBaseModel",anchor:"transformers.FunnelBaseModel",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelBaseModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L927"}}),_s=new X({props:{name:"forward",anchor:"transformers.FunnelBaseModel.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"position_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"head_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelBaseModel.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelBaseModel.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelBaseModel.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelBaseModel.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelBaseModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelBaseModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelBaseModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L943",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Kt=new qe({props:{$$slots:{default:[V2]},$$scope:{ctx:H}}}),Ts=new be({props:{code:`from transformers import FunnelTokenizer, FunnelBaseModel
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelBaseModel.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelBaseModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelBaseModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),ks=new Ce({}),Fs=new X({props:{name:"class transformers.FunnelModel",anchor:"transformers.FunnelModel",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1004"}}),Es=new X({props:{name:"forward",anchor:"transformers.FunnelModel.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelModel.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelModel.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelModel.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelModel.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1021",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Zt=new qe({props:{$$slots:{default:[H2]},$$scope:{ctx:H}}}),Ms=new be({props:{code:`from transformers import FunnelTokenizer, FunnelModel
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelModel.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),zs=new Ce({}),qs=new X({props:{name:"class transformers.FunnelForPreTraining",anchor:"transformers.FunnelForPreTraining",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1112"}}),Ps=new X({props:{name:"forward",anchor:"transformers.FunnelForPreTraining.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelForPreTraining.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForPreTraining.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForPreTraining.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForPreTraining.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForPreTraining.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForPreTraining.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForPreTraining.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForPreTraining.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the ELECTRA-style loss. Input should be a sequence of tokens (see <code>input_ids</code>
docstring) Indices should be in <code>[0, 1]</code>:</p>
<ul>
<li>0 indicates the token is an original token,</li>
<li>1 indicates the token was replaced.</li>
</ul>`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1121",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<em>optional</em>, returned when <code>labels</code> is provided, <code>torch.FloatTensor</code> of shape <code>(1,)</code>) \u2014 Total loss of the ELECTRA-style objective.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Prediction scores of the head (scores for each token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Jt=new qe({props:{$$slots:{default:[Y2]},$$scope:{ctx:H}}}),Cs=new be({props:{code:`from transformers import FunnelTokenizer, FunnelForPreTraining
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForPreTraining.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
logits = model(**inputs).logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForPreTraining
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForPreTraining.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits`}}),xs=new Ce({}),js=new X({props:{name:"class transformers.FunnelForMaskedLM",anchor:"transformers.FunnelForMaskedLM",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelForMaskedLM.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1195"}}),Is=new X({props:{name:"forward",anchor:"transformers.FunnelForMaskedLM.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelForMaskedLM.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForMaskedLM.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForMaskedLM.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForMaskedLM.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForMaskedLM.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForMaskedLM.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForMaskedLM.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForMaskedLM.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the masked language modeling loss. Indices should be in <code>[-100, 0, ..., config.vocab_size]</code> (see <code>input_ids</code> docstring) Tokens with indices set to <code>-100</code> are ignored (masked), the
loss is only computed for the tokens with labels in <code>[0, ..., config.vocab_size]</code>`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1211",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.MaskedLMOutput"
>transformers.modeling_outputs.MaskedLMOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Masked language modeling (MLM) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.vocab_size)</code>) \u2014 Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.MaskedLMOutput"
>transformers.modeling_outputs.MaskedLMOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),no=new qe({props:{$$slots:{default:[K2]},$$scope:{ctx:H}}}),Ws=new be({props:{code:`from transformers import FunnelTokenizer, FunnelForMaskedLM
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForMaskedLM.from_pretrained("funnel-transformer/small")

inputs = tokenizer("The capital of France is <mask>.", return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

# retrieve index of <mask>
mask_token_index = (inputs.input_ids == tokenizer.mask_token_id)[0].nonzero(as_tuple=True)[0]

predicted_token_id = logits[0, mask_token_index].argmax(axis=-1)
tokenizer.decode(predicted_token_id)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForMaskedLM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;The capital of France is &lt;mask&gt;.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># retrieve index of &lt;mask&gt;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>mask_token_index = (inputs.input_ids == tokenizer.mask_token_id)[<span class="hljs-number">0</span>].nonzero(as_tuple=<span class="hljs-literal">True</span>)[<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_id = logits[<span class="hljs-number">0</span>, mask_token_index].argmax(axis=-<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predicted_token_id)
`}}),Bs=new be({props:{code:`labels = tokenizer("The capital of France is Paris.", return_tensors="pt")["input_ids"]
# mask labels of non-<mask> tokens
labels = torch.where(inputs.input_ids == tokenizer.mask_token_id, labels, -100)

outputs = model(**inputs, labels=labels)
round(outputs.loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tokenizer(<span class="hljs-string">&quot;The capital of France is Paris.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)[<span class="hljs-string">&quot;input_ids&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># mask labels of non-&lt;mask&gt; tokens</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.where(inputs.input_ids == tokenizer.mask_token_id, labels, -<span class="hljs-number">100</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, labels=labels)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(outputs.loss.item(), <span class="hljs-number">2</span>)
`}}),Qs=new Ce({}),Us=new X({props:{name:"class transformers.FunnelForSequenceClassification",anchor:"transformers.FunnelForSequenceClassification",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelForSequenceClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1275"}}),Gs=new X({props:{name:"forward",anchor:"transformers.FunnelForSequenceClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelForSequenceClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForSequenceClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForSequenceClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForSequenceClassification.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForSequenceClassification.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForSequenceClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForSequenceClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForSequenceClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the sequence classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels == 1</code> a regression loss is computed (Mean-Square loss), If
<code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1286",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.SequenceClassifierOutput"
>transformers.modeling_outputs.SequenceClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.SequenceClassifierOutput"
>transformers.modeling_outputs.SequenceClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),oo=new qe({props:{$$slots:{default:[G2]},$$scope:{ctx:H}}}),Zs=new be({props:{code:`import torch
from transformers import FunnelTokenizer, FunnelForSequenceClassification

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

predicted_class_id = logits.argmax().item()
model.config.id2label[predicted_class_id]
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_id = logits.argmax().item()
<span class="hljs-meta">&gt;&gt;&gt; </span>model.config.id2label[predicted_class_id]
`}}),Xs=new be({props:{code:`# To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`
num_labels = len(model.config.id2label)
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", num_labels=num_labels)

labels = torch.tensor(1)
loss = model(**inputs, labels=labels).loss
round(loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, num_labels=num_labels)

<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.tensor(<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
`}}),Js=new be({props:{code:`import torch
from transformers import FunnelTokenizer, FunnelForSequenceClassification

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", problem_type="multi_label_classification")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

predicted_class_id = logits.argmax().item()
model.config.id2label[predicted_class_id]
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, problem_type=<span class="hljs-string">&quot;multi_label_classification&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_id = logits.argmax().item()
<span class="hljs-meta">&gt;&gt;&gt; </span>model.config.id2label[predicted_class_id]
`}}),er=new be({props:{code:`# To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`
num_labels = len(model.config.id2label)
model = FunnelForSequenceClassification.from_pretrained(
    "funnel-transformer/small-base", num_labels=num_labels, problem_type="multi_label_classification"
)

labels = torch.nn.functional.one_hot(torch.tensor([predicted_class_id]), num_classes=num_labels).to(
    torch.float
)
loss = model(**inputs, labels=labels).loss
loss.backward()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, num_labels=num_labels, problem_type=<span class="hljs-string">&quot;multi_label_classification&quot;</span>
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.nn.functional.one_hot(torch.tensor([predicted_class_id]), num_classes=num_labels).to(
<span class="hljs-meta">... </span>    torch.<span class="hljs-built_in">float</span>
<span class="hljs-meta">... </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span>loss.backward()`}}),nr=new Ce({}),tr=new X({props:{name:"class transformers.FunnelForMultipleChoice",anchor:"transformers.FunnelForMultipleChoice",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelForMultipleChoice.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1368"}}),lr=new X({props:{name:"forward",anchor:"transformers.FunnelForMultipleChoice.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelForMultipleChoice.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForMultipleChoice.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForMultipleChoice.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForMultipleChoice.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForMultipleChoice.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForMultipleChoice.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForMultipleChoice.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForMultipleChoice.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the multiple choice classification loss. Indices should be in <code>[0, ..., num_choices-1]</code> where <code>num_choices</code> is the size of the second dimension of the input tensors. (See
<code>input_ids</code> above)`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1377",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.MultipleChoiceModelOutput"
>transformers.modeling_outputs.MultipleChoiceModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <em>(1,)</em>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices)</code>) \u2014 <em>num_choices</em> is the second dimension of the input tensors. (see <em>input_ids</em> above).</p>
<p>Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.MultipleChoiceModelOutput"
>transformers.modeling_outputs.MultipleChoiceModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),ro=new qe({props:{$$slots:{default:[Z2]},$$scope:{ctx:H}}}),dr=new be({props:{code:`from transformers import FunnelTokenizer, FunnelForMultipleChoice
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelForMultipleChoice.from_pretrained("funnel-transformer/small-base")

prompt = "In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced."
choice0 = "It is eaten with a fork and a knife."
choice1 = "It is eaten while held in the hand."
labels = torch.tensor(0).unsqueeze(0)  # choice0 is correct (according to Wikipedia ;)), batch size 1

encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors="pt", padding=True)
outputs = model(**{k: v.unsqueeze(0) for k, v in encoding.items()}, labels=labels)  # batch size is 1

# the linear classifier still needs to be trained
loss = outputs.loss
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForMultipleChoice
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForMultipleChoice.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>prompt = <span class="hljs-string">&quot;In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice0 = <span class="hljs-string">&quot;It is eaten with a fork and a knife.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice1 = <span class="hljs-string">&quot;It is eaten while held in the hand.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.tensor(<span class="hljs-number">0</span>).unsqueeze(<span class="hljs-number">0</span>)  <span class="hljs-comment"># choice0 is correct (according to Wikipedia ;)), batch size 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors=<span class="hljs-string">&quot;pt&quot;</span>, padding=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**{k: v.unsqueeze(<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> encoding.items()}, labels=labels)  <span class="hljs-comment"># batch size is 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the linear classifier still needs to be trained</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),cr=new Ce({}),pr=new X({props:{name:"class transformers.FunnelForTokenClassification",anchor:"transformers.FunnelForTokenClassification",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelForTokenClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1452"}}),_r=new X({props:{name:"forward",anchor:"transformers.FunnelForTokenClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelForTokenClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForTokenClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForTokenClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForTokenClassification.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForTokenClassification.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForTokenClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForTokenClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForTokenClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the token classification loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>.`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1464",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.TokenClassifierOutput"
>transformers.modeling_outputs.TokenClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided)  \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.num_labels)</code>) \u2014 Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.TokenClassifierOutput"
>transformers.modeling_outputs.TokenClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),io=new qe({props:{$$slots:{default:[X2]},$$scope:{ctx:H}}}),Tr=new be({props:{code:`from transformers import FunnelTokenizer, FunnelForTokenClassification
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForTokenClassification.from_pretrained("funnel-transformer/small")

inputs = tokenizer(
    "HuggingFace is a company based in Paris and New York", add_special_tokens=False, return_tensors="pt"
)

with torch.no_grad():
    logits = model(**inputs).logits

predicted_token_class_ids = logits.argmax(-1)

# Note that tokens are classified rather then input words which means that
# there might be more predicted token classes than words.
# Multiple token classes might account for the same word
predicted_tokens_classes = [model.config.id2label[t.item()] for t in predicted_token_class_ids[0]]
predicted_tokens_classes
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;HuggingFace is a company based in Paris and New York&quot;</span>, add_special_tokens=<span class="hljs-literal">False</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_class_ids = logits.argmax(-<span class="hljs-number">1</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Note that tokens are classified rather then input words which means that</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># there might be more predicted token classes than words.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Multiple token classes might account for the same word</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes = [model.config.id2label[t.item()] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> predicted_token_class_ids[<span class="hljs-number">0</span>]]
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes
`}}),kr=new be({props:{code:`labels = predicted_token_class_ids
loss = model(**inputs, labels=labels).loss
round(loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = predicted_token_class_ids
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
`}}),Fr=new Ce({}),vr=new X({props:{name:"class transformers.FunnelForQuestionAnswering",anchor:"transformers.FunnelForQuestionAnswering",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelForQuestionAnswering.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1526"}}),Mr=new X({props:{name:"forward",anchor:"transformers.FunnelForQuestionAnswering.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"start_positions",val:": typing.Optional[torch.Tensor] = None"},{name:"end_positions",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelForQuestionAnswering.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForQuestionAnswering.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForQuestionAnswering.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForQuestionAnswering.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForQuestionAnswering.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForQuestionAnswering.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForQuestionAnswering.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForQuestionAnswering.forward.start_positions",description:`<strong>start_positions</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the start of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"start_positions"},{anchor:"transformers.FunnelForQuestionAnswering.forward.end_positions",description:`<strong>end_positions</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the end of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"end_positions"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1537",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.QuestionAnsweringModelOutput"
>transformers.modeling_outputs.QuestionAnsweringModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.</p>
</li>
<li>
<p><strong>start_logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-start scores (before SoftMax).</p>
</li>
<li>
<p><strong>end_logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-end scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.QuestionAnsweringModelOutput"
>transformers.modeling_outputs.QuestionAnsweringModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),co=new qe({props:{$$slots:{default:[J2]},$$scope:{ctx:H}}}),zr=new be({props:{code:`from transformers import FunnelTokenizer, FunnelForQuestionAnswering
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForQuestionAnswering.from_pretrained("funnel-transformer/small")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"

inputs = tokenizer(question, text, return_tensors="pt")
with torch.no_grad():
    outputs = model(**inputs)

answer_start_index = outputs.start_logits.argmax()
answer_end_index = outputs.end_logits.argmax()

predict_answer_tokens = inputs.input_ids[0, answer_start_index : answer_end_index + 1]
tokenizer.decode(predict_answer_tokens)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>answer_start_index = outputs.start_logits.argmax()
<span class="hljs-meta">&gt;&gt;&gt; </span>answer_end_index = outputs.end_logits.argmax()

<span class="hljs-meta">&gt;&gt;&gt; </span>predict_answer_tokens = inputs.input_ids[<span class="hljs-number">0</span>, answer_start_index : answer_end_index + <span class="hljs-number">1</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predict_answer_tokens)
`}}),qr=new be({props:{code:`# target is "nice puppet"
target_start_index = torch.tensor([14])
target_end_index = torch.tensor([15])

outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
loss = outputs.loss
round(loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># target is &quot;nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>target_start_index = torch.tensor([<span class="hljs-number">14</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>target_end_index = torch.tensor([<span class="hljs-number">15</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
`}}),Pr=new Ce({}),Cr=new X({props:{name:"class transformers.TFFunnelBaseModel",anchor:"transformers.TFFunnelBaseModel",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelBaseModel.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1095"}}),uo=new qe({props:{$$slots:{default:[e$]},$$scope:{ctx:H}}}),Ar=new X({props:{name:"call",anchor:"transformers.TFFunnelBaseModel.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelBaseModel.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelBaseModel.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelBaseModel.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelBaseModel.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelBaseModel.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelBaseModel.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelBaseModel.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelBaseModel.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1100",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),ho=new qe({props:{$$slots:{default:[n$]},$$scope:{ctx:H}}}),Nr=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelBaseModel
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = TFFunnelBaseModel.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
outputs = model(inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelBaseModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelBaseModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),Sr=new Ce({}),Ir=new X({props:{name:"class transformers.TFFunnelModel",anchor:"transformers.TFFunnelModel",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelModel.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1142"}}),fo=new qe({props:{$$slots:{default:[t$]},$$scope:{ctx:H}}}),Vr=new X({props:{name:"call",anchor:"transformers.TFFunnelModel.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelModel.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelModel.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelModel.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelModel.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelModel.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelModel.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelModel.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelModel.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1147",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),go=new qe({props:{$$slots:{default:[o$]},$$scope:{ctx:H}}}),Hr=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelModel
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelModel.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
outputs = model(inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),Yr=new Ce({}),Kr=new X({props:{name:"class transformers.TFFunnelForPreTraining",anchor:"transformers.TFFunnelForPreTraining",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForPreTraining.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1192"}}),To=new qe({props:{$$slots:{default:[s$]},$$scope:{ctx:H}}}),na=new X({props:{name:"call",anchor:"transformers.TFFunnelForPreTraining.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"training",val:": bool = False"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForPreTraining.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForPreTraining.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForPreTraining.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForPreTraining.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForPreTraining.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForPreTraining.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForPreTraining.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForPreTraining.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1199",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Prediction scores of the head (scores for each token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),ko=new qe({props:{$$slots:{default:[r$]},$$scope:{ctx:H}}}),ta=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelForPreTraining
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForPreTraining.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
logits = model(inputs).logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForPreTraining
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForPreTraining.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(inputs).logits`}}),oa=new Ce({}),sa=new X({props:{name:"class transformers.TFFunnelForMaskedLM",anchor:"transformers.TFFunnelForMaskedLM",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForMaskedLM.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1259"}}),vo=new qe({props:{$$slots:{default:[a$]},$$scope:{ctx:H}}}),pa=new X({props:{name:"call",anchor:"transformers.TFFunnelForMaskedLM.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelForMaskedLM.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForMaskedLM.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForMaskedLM.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForMaskedLM.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForMaskedLM.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForMaskedLM.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForMaskedLM.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForMaskedLM.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForMaskedLM.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the masked language modeling loss. Indices should be in <code>[-100, 0, ..., config.vocab_size]</code> (see <code>input_ids</code> docstring) Tokens with indices set to <code>-100</code> are ignored (masked), the
loss is only computed for the tokens with labels in <code>[0, ..., config.vocab_size]</code>`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1273",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFMaskedLMOutput"
>transformers.modeling_tf_outputs.TFMaskedLMOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(n,)</code>, <em>optional</em>, where n is the number of non-masked labels, returned when <code>labels</code> is provided) \u2014 Masked language modeling (MLM) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, config.vocab_size)</code>) \u2014 Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFMaskedLMOutput"
>transformers.modeling_tf_outputs.TFMaskedLMOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),bo=new qe({props:{$$slots:{default:[i$]},$$scope:{ctx:H}}}),ua=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelForMaskedLM
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForMaskedLM.from_pretrained("funnel-transformer/small")

inputs = tokenizer("The capital of France is [MASK].", return_tensors="tf")
logits = model(**inputs).logits

# retrieve index of [MASK]
mask_token_index = tf.where((inputs.input_ids == tokenizer.mask_token_id)[0])
selected_logits = tf.gather_nd(logits[0], indices=mask_token_index)

predicted_token_id = tf.math.argmax(selected_logits, axis=-1)
tokenizer.decode(predicted_token_id)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForMaskedLM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;The capital of France is [MASK].&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># retrieve index of [MASK]</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>mask_token_index = tf.where((inputs.input_ids == tokenizer.mask_token_id)[<span class="hljs-number">0</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>selected_logits = tf.gather_nd(logits[<span class="hljs-number">0</span>], indices=mask_token_index)

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_id = tf.math.argmax(selected_logits, axis=-<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predicted_token_id)
`}}),ha=new be({props:{code:`labels = tokenizer("The capital of France is Paris.", return_tensors="tf")["input_ids"]
# mask labels of non-[MASK] tokens
labels = tf.where(inputs.input_ids == tokenizer.mask_token_id, labels, -100)

outputs = model(**inputs, labels=labels)
round(float(outputs.loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tokenizer(<span class="hljs-string">&quot;The capital of France is Paris.&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)[<span class="hljs-string">&quot;input_ids&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># mask labels of non-[MASK] tokens</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tf.where(inputs.input_ids == tokenizer.mask_token_id, labels, -<span class="hljs-number">100</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, labels=labels)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(outputs.loss), <span class="hljs-number">2</span>)
`}}),ma=new Ce({}),fa=new X({props:{name:"class transformers.TFFunnelForSequenceClassification",anchor:"transformers.TFFunnelForSequenceClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForSequenceClassification.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1340"}}),wo=new qe({props:{$$slots:{default:[l$]},$$scope:{ctx:H}}}),va=new X({props:{name:"call",anchor:"transformers.TFFunnelForSequenceClassification.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelForSequenceClassification.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForSequenceClassification.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForSequenceClassification.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForSequenceClassification.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForSequenceClassification.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForSequenceClassification.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForSequenceClassification.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForSequenceClassification.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForSequenceClassification.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the sequence classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels == 1</code> a regression loss is computed (Mean-Square loss), If
<code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1348",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFSequenceClassifierOutput"
>transformers.modeling_tf_outputs.TFSequenceClassifierOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, )</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFSequenceClassifierOutput"
>transformers.modeling_tf_outputs.TFSequenceClassifierOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),$o=new qe({props:{$$slots:{default:[d$]},$$scope:{ctx:H}}}),ba=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelForSequenceClassification
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = TFFunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")

logits = model(**inputs).logits

predicted_class_id = int(tf.math.argmax(logits, axis=-1)[0])
model.config.id2label[predicted_class_id]
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForSequenceClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_id = <span class="hljs-built_in">int</span>(tf.math.argmax(logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>model.config.id2label[predicted_class_id]
`}}),ya=new be({props:{code:`# To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`
num_labels = len(model.config.id2label)
model = TFFunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", num_labels=num_labels)

labels = tf.constant(1)
loss = model(**inputs, labels=labels).loss
round(float(loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, num_labels=num_labels)

<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tf.constant(<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(loss), <span class="hljs-number">2</span>)
`}}),wa=new Ce({}),$a=new X({props:{name:"class transformers.TFFunnelForMultipleChoice",anchor:"transformers.TFFunnelForMultipleChoice",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForMultipleChoice.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1416"}}),Mo=new qe({props:{$$slots:{default:[c$]},$$scope:{ctx:H}}}),Ca=new X({props:{name:"call",anchor:"transformers.TFFunnelForMultipleChoice.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelForMultipleChoice.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForMultipleChoice.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForMultipleChoice.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForMultipleChoice.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForMultipleChoice.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForMultipleChoice.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForMultipleChoice.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForMultipleChoice.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForMultipleChoice.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the multiple choice classification loss. Indices should be in <code>[0, ..., num_choices]</code>
where <code>num_choices</code> is the size of the second dimension of the input tensors. (See <code>input_ids</code> above)`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1433",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput"
>transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <em>(batch_size, )</em>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, num_choices)</code>) \u2014 <em>num_choices</em> is the second dimension of the input tensors. (see <em>input_ids</em> above).</p>
<p>Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput"
>transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),zo=new qe({props:{$$slots:{default:[p$]},$$scope:{ctx:H}}}),xa=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelForMultipleChoice
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = TFFunnelForMultipleChoice.from_pretrained("funnel-transformer/small-base")

prompt = "In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced."
choice0 = "It is eaten with a fork and a knife."
choice1 = "It is eaten while held in the hand."

encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors="tf", padding=True)
inputs = {k: tf.expand_dims(v, 0) for k, v in encoding.items()}
outputs = model(inputs)  # batch size is 1

# the linear classifier still needs to be trained
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForMultipleChoice
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForMultipleChoice.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>prompt = <span class="hljs-string">&quot;In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice0 = <span class="hljs-string">&quot;It is eaten with a fork and a knife.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice1 = <span class="hljs-string">&quot;It is eaten while held in the hand.&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors=<span class="hljs-string">&quot;tf&quot;</span>, padding=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = {k: tf.expand_dims(v, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> encoding.items()}
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)  <span class="hljs-comment"># batch size is 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the linear classifier still needs to be trained</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),ja=new Ce({}),La=new X({props:{name:"class transformers.TFFunnelForTokenClassification",anchor:"transformers.TFFunnelForTokenClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForTokenClassification.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1532"}}),Po=new qe({props:{$$slots:{default:[u$]},$$scope:{ctx:H}}}),Ia=new X({props:{name:"call",anchor:"transformers.TFFunnelForTokenClassification.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelForTokenClassification.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForTokenClassification.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForTokenClassification.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForTokenClassification.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForTokenClassification.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForTokenClassification.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForTokenClassification.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForTokenClassification.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForTokenClassification.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the token classification loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>.`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1543",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFTokenClassifierOutput"
>transformers.modeling_tf_outputs.TFTokenClassifierOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(n,)</code>, <em>optional</em>, where n is the number of unmasked labels, returned when <code>labels</code> is provided)  \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, config.num_labels)</code>) \u2014 Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFTokenClassifierOutput"
>transformers.modeling_tf_outputs.TFTokenClassifierOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),Co=new qe({props:{$$slots:{default:[h$]},$$scope:{ctx:H}}}),Wa=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelForTokenClassification
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForTokenClassification.from_pretrained("funnel-transformer/small")

inputs = tokenizer(
    "HuggingFace is a company based in Paris and New York", add_special_tokens=False, return_tensors="tf"
)

logits = model(**inputs).logits
predicted_token_class_ids = tf.math.argmax(logits, axis=-1)

# Note that tokens are classified rather then input words which means that
# there might be more predicted token classes than words.
# Multiple token classes might account for the same word
predicted_tokens_classes = [model.config.id2label[t] for t in predicted_token_class_ids[0].numpy().tolist()]
predicted_tokens_classes
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;HuggingFace is a company based in Paris and New York&quot;</span>, add_special_tokens=<span class="hljs-literal">False</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_class_ids = tf.math.argmax(logits, axis=-<span class="hljs-number">1</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Note that tokens are classified rather then input words which means that</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># there might be more predicted token classes than words.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Multiple token classes might account for the same word</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes = [model.config.id2label[t] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> predicted_token_class_ids[<span class="hljs-number">0</span>].numpy().tolist()]
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes
`}}),Ba=new be({props:{code:`labels = predicted_token_class_ids
loss = tf.math.reduce_mean(model(**inputs, labels=labels).loss)
round(float(loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = predicted_token_class_ids
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = tf.math.reduce_mean(model(**inputs, labels=labels).loss)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(loss), <span class="hljs-number">2</span>)
`}}),Qa=new Ce({}),Ua=new X({props:{name:"class transformers.TFFunnelForQuestionAnswering",anchor:"transformers.TFFunnelForQuestionAnswering",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForQuestionAnswering.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1610"}}),jo=new qe({props:{$$slots:{default:[m$]},$$scope:{ctx:H}}}),Ga=new X({props:{name:"call",anchor:"transformers.TFFunnelForQuestionAnswering.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"start_positions",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"end_positions",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelForQuestionAnswering.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.start_positions",description:`<strong>start_positions</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the start of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"start_positions"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.end_positions",description:`<strong>end_positions</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the end of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"end_positions"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1620",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput"
>transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, )</code>, <em>optional</em>, returned when <code>start_positions</code> and <code>end_positions</code> are provided) \u2014 Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.</p>
</li>
<li>
<p><strong>start_logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-start scores (before SoftMax).</p>
</li>
<li>
<p><strong>end_logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-end scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput"
>transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),Lo=new qe({props:{$$slots:{default:[f$]},$$scope:{ctx:H}}}),Za=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelForQuestionAnswering
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForQuestionAnswering.from_pretrained("funnel-transformer/small")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"

inputs = tokenizer(question, text, return_tensors="tf")
outputs = model(**inputs)

answer_start_index = int(tf.math.argmax(outputs.start_logits, axis=-1)[0])
answer_end_index = int(tf.math.argmax(outputs.end_logits, axis=-1)[0])

predict_answer_tokens = inputs.input_ids[0, answer_start_index : answer_end_index + 1]
tokenizer.decode(predict_answer_tokens)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>answer_start_index = <span class="hljs-built_in">int</span>(tf.math.argmax(outputs.start_logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>answer_end_index = <span class="hljs-built_in">int</span>(tf.math.argmax(outputs.end_logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>predict_answer_tokens = inputs.input_ids[<span class="hljs-number">0</span>, answer_start_index : answer_end_index + <span class="hljs-number">1</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predict_answer_tokens)
`}}),Xa=new be({props:{code:`# target is "nice puppet"
target_start_index = tf.constant([14])
target_end_index = tf.constant([15])

outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
loss = tf.math.reduce_mean(outputs.loss)
round(float(loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># target is &quot;nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>target_start_index = tf.constant([<span class="hljs-number">14</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>target_end_index = tf.constant([<span class="hljs-number">15</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = tf.math.reduce_mean(outputs.loss)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(loss), <span class="hljs-number">2</span>)
`}}),{c(){u=r("meta"),z=l(),g=r("h1"),_=r("a"),k=r("span"),F(T.$$.fragment),f=l(),M=r("span"),ce=t("Funnel Transformer"),K=l(),q=r("h2"),J=r("a"),A=r("span"),F(ne.$$.fragment),pe=l(),N=r("span"),ue=t("Overview"),ie=l(),Y=r("p"),L=t("The Funnel Transformer model was proposed in the paper "),te=r("a"),G=t(`Funnel-Transformer: Filtering out Sequential Redundancy for
Efficient Language Processing`),P=t(`. It is a bidirectional transformer model, like
BERT, but with a pooling operation after each block of layers, a bit like in traditional convolutional neural networks
(CNN) in computer vision.`),x=l(),oe=r("p"),B=t("The abstract from the paper is the following:"),le=l(),se=r("p"),S=r("em"),he=t(`With the success of language pretraining, it is highly desirable to develop more efficient architectures of good
scalability that can exploit the abundant unlabeled data at a lower cost. To improve the efficiency, we examine the
much-overlooked redundancy in maintaining a full-length token-level presentation, especially for tasks that only
require a single-vector presentation of the sequence. With this intuition, we propose Funnel-Transformer which
gradually compresses the sequence of hidden states to a shorter one and hence reduces the computation cost. More
importantly, by re-investing the saved FLOPs from length reduction in constructing a deeper or wider model, we further
improve the model capacity. In addition, to perform token-level predictions as required by common pretraining
objectives, Funnel-Transformer is able to recover a deep representation for each token from the reduced hidden sequence
via a decoder. Empirically, with comparable or fewer FLOPs, Funnel-Transformer outperforms the standard Transformer on
a wide variety of sequence-level prediction tasks, including text classification, language understanding, and reading
comprehension.`),de=l(),C=r("p"),me=t("Tips:"),W=l(),ee=r("ul"),ae=r("li"),Q=t(`Since Funnel Transformer uses pooling, the sequence length of the hidden states changes after each block of layers.
The base model therefore has a final sequence length that is a quarter of the original one. This model can be used
directly for tasks that just require a sentence summary (like sequence classification or multiple choice). For other
tasks, the full model is used; this full model has a decoder that upsamples the final hidden states to the same
sequence length as the input.`),fe=l(),I=r("li"),O=t(`The Funnel Transformer checkpoints are all available with a full version and a base version. The first ones should be
used for `),re=r("a"),U=t("FunnelModel"),ge=t(", "),p=r("a"),E=t("FunnelForPreTraining"),Z=t(`,
`),Te=r("a"),ye=t("FunnelForMaskedLM"),D=t(", "),ke=r("a"),we=t("FunnelForTokenClassification"),$e=t(` and
class:`),j=r("em"),R=t("~transformers.FunnelForQuestionAnswering"),Ee=t(`. The second ones should be used for
`),Fe=r("a"),V=t("FunnelBaseModel"),Me=t(", "),ve=r("a"),_e=t("FunnelForSequenceClassification"),ze=t(` and
`),oi=r("a"),Yu=t("FunnelForMultipleChoice"),Ku=t("."),Oc=l(),In=r("p"),Gu=t("This model was contributed by "),No=r("a"),Zu=t("sgugger"),Xu=t(". The original code can be found "),So=r("a"),Ju=t("here"),eh=t("."),Dc=l(),Zn=r("h2"),Wt=r("a"),Fl=r("span"),F(Io.$$.fragment),nh=l(),vl=r("span"),th=t("FunnelConfig"),Ac=l(),Nn=r("div"),F(Wo.$$.fragment),oh=l(),Sn=r("p"),sh=t("This is the configuration class to store the configuration of a "),si=r("a"),rh=t("FunnelModel"),ah=t(" or a "),ri=r("a"),ih=t("TFBertModel"),lh=t(`. It is used to
instantiate a Funnel Transformer model according to the specified arguments, defining the model architecture.
Instantiating a configuration with the defaults will yield a similar configuration to that of the Funnel
Transformer `),Bo=r("a"),dh=t("funnel-transformer/small"),ch=t(" architecture."),ph=l(),Xn=r("p"),uh=t("Configuration objects inherit from "),ai=r("a"),hh=t("PretrainedConfig"),mh=t(` and can be used to control the model outputs. Read the
documentation from `),ii=r("a"),fh=t("PretrainedConfig"),gh=t(" for more information."),Nc=l(),Jn=r("h2"),Bt=r("a"),bl=r("span"),F(Qo.$$.fragment),_h=l(),yl=r("span"),Th=t("FunnelTokenizer"),Sc=l(),xe=r("div"),F(Uo.$$.fragment),kh=l(),wl=r("p"),Fh=t("Construct a Funnel Transformer tokenizer."),vh=l(),Qt=r("p"),li=r("a"),bh=t("FunnelTokenizer"),yh=t(" is identical to "),di=r("a"),wh=t("BertTokenizer"),$h=t(` and runs end-to-end tokenization: punctuation splitting and
wordpiece.`),Eh=l(),Ro=r("p"),Mh=t("Refer to superclass "),ci=r("a"),zh=t("BertTokenizer"),qh=t(" for usage examples and documentation concerning parameters."),Ph=l(),Wn=r("div"),F(Vo.$$.fragment),Ch=l(),$l=r("p"),xh=t(`Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and
adding special tokens. A BERT sequence has the following format:`),jh=l(),Ho=r("ul"),pi=r("li"),Lh=t("single sequence: "),El=r("code"),Oh=t("[CLS] X [SEP]"),Dh=l(),ui=r("li"),Ah=t("pair of sequences: "),Ml=r("code"),Nh=t("[CLS] A [SEP] B [SEP]"),Sh=l(),Ut=r("div"),F(Yo.$$.fragment),Ih=l(),Ko=r("p"),Wh=t(`Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding
special tokens using the tokenizer `),zl=r("code"),Bh=t("prepare_for_model"),Qh=t(" method."),Uh=l(),bn=r("div"),F(Go.$$.fragment),Rh=l(),ql=r("p"),Vh=t(`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),Hh=l(),F(Zo.$$.fragment),Yh=l(),et=r("p"),Kh=t("If "),Pl=r("code"),Gh=t("token_ids_1"),Zh=t(" is "),Cl=r("code"),Xh=t("None"),Jh=t(", this method only returns the first portion of the mask (0s)."),em=l(),hi=r("div"),F(Xo.$$.fragment),Ic=l(),nt=r("h2"),Rt=r("a"),xl=r("span"),F(Jo.$$.fragment),nm=l(),jl=r("span"),tm=t("FunnelTokenizerFast"),Wc=l(),sn=r("div"),F(es.$$.fragment),om=l(),ns=r("p"),sm=t("Construct a \u201Cfast\u201D Funnel Transformer tokenizer (backed by HuggingFace\u2019s "),Ll=r("em"),rm=t("tokenizers"),am=t(" library)."),im=l(),Vt=r("p"),mi=r("a"),lm=t("FunnelTokenizerFast"),dm=t(" is identical to "),fi=r("a"),cm=t("BertTokenizerFast"),pm=t(` and runs end-to-end tokenization: punctuation
splitting and wordpiece.`),um=l(),ts=r("p"),hm=t("Refer to superclass "),gi=r("a"),mm=t("BertTokenizerFast"),fm=t(" for usage examples and documentation concerning parameters."),gm=l(),yn=r("div"),F(os.$$.fragment),_m=l(),Ol=r("p"),Tm=t(`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),km=l(),F(ss.$$.fragment),Fm=l(),tt=r("p"),vm=t("If "),Dl=r("code"),bm=t("token_ids_1"),ym=t(" is "),Al=r("code"),wm=t("None"),$m=t(", this method only returns the first portion of the mask (0s)."),Bc=l(),ot=r("h2"),Ht=r("a"),Nl=r("span"),F(rs.$$.fragment),Em=l(),Sl=r("span"),Mm=t("Funnel specific outputs"),Qc=l(),st=r("div"),F(as.$$.fragment),zm=l(),is=r("p"),qm=t("Output type of "),_i=r("a"),Pm=t("FunnelForPreTraining"),Cm=t("."),Uc=l(),rt=r("div"),F(ls.$$.fragment),xm=l(),ds=r("p"),jm=t("Output type of "),Ti=r("a"),Lm=t("FunnelForPreTraining"),Om=t("."),Rc=l(),at=r("h2"),Yt=r("a"),Il=r("span"),F(cs.$$.fragment),Dm=l(),Wl=r("span"),Am=t("FunnelBaseModel"),Vc=l(),Qe=r("div"),F(ps.$$.fragment),Nm=l(),Bl=r("p"),Sm=t(`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),Im=l(),us=r("p"),Wm=t("The Funnel Transformer model was proposed in "),hs=r("a"),Bm=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Qm=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Um=l(),ms=r("p"),Rm=t("This model inherits from "),ki=r("a"),Vm=t("PreTrainedModel"),Hm=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Ym=l(),fs=r("p"),Km=t("This model is also a PyTorch "),gs=r("a"),Gm=t("torch.nn.Module"),Zm=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Xm=l(),rn=r("div"),F(_s.$$.fragment),Jm=l(),it=r("p"),ef=t("The "),Fi=r("a"),nf=t("FunnelBaseModel"),tf=t(" forward method, overrides the "),Ql=r("code"),of=t("__call__"),sf=t(" special method."),rf=l(),F(Kt.$$.fragment),af=l(),Ul=r("p"),lf=t("Example:"),df=l(),F(Ts.$$.fragment),Hc=l(),lt=r("h2"),Gt=r("a"),Rl=r("span"),F(ks.$$.fragment),cf=l(),Vl=r("span"),pf=t("FunnelModel"),Yc=l(),Ue=r("div"),F(Fs.$$.fragment),uf=l(),Hl=r("p"),hf=t("The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),mf=l(),vs=r("p"),ff=t("The Funnel Transformer model was proposed in "),bs=r("a"),gf=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),_f=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Tf=l(),ys=r("p"),kf=t("This model inherits from "),vi=r("a"),Ff=t("PreTrainedModel"),vf=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),bf=l(),ws=r("p"),yf=t("This model is also a PyTorch "),$s=r("a"),wf=t("torch.nn.Module"),$f=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Ef=l(),an=r("div"),F(Es.$$.fragment),Mf=l(),dt=r("p"),zf=t("The "),bi=r("a"),qf=t("FunnelModel"),Pf=t(" forward method, overrides the "),Yl=r("code"),Cf=t("__call__"),xf=t(" special method."),jf=l(),F(Zt.$$.fragment),Lf=l(),Kl=r("p"),Of=t("Example:"),Df=l(),F(Ms.$$.fragment),Kc=l(),ct=r("h2"),Xt=r("a"),Gl=r("span"),F(zs.$$.fragment),Af=l(),Zl=r("span"),Nf=t("FunnelModelForPreTraining"),Gc=l(),pt=r("div"),F(qs.$$.fragment),Sf=l(),ln=r("div"),F(Ps.$$.fragment),If=l(),ut=r("p"),Wf=t("The "),yi=r("a"),Bf=t("FunnelForPreTraining"),Qf=t(" forward method, overrides the "),Xl=r("code"),Uf=t("__call__"),Rf=t(" special method."),Vf=l(),F(Jt.$$.fragment),Hf=l(),Jl=r("p"),Yf=t("Examples:"),Kf=l(),F(Cs.$$.fragment),Zc=l(),ht=r("h2"),eo=r("a"),ed=r("span"),F(xs.$$.fragment),Gf=l(),nd=r("span"),Zf=t("FunnelForMaskedLM"),Xc=l(),Re=r("div"),F(js.$$.fragment),Xf=l(),Ls=r("p"),Jf=t("Funnel Transformer Model with a "),td=r("code"),eg=t("language modeling"),ng=t(" head on top."),tg=l(),Os=r("p"),og=t("The Funnel Transformer model was proposed in "),Ds=r("a"),sg=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),rg=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),ag=l(),As=r("p"),ig=t("This model inherits from "),wi=r("a"),lg=t("PreTrainedModel"),dg=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),cg=l(),Ns=r("p"),pg=t("This model is also a PyTorch "),Ss=r("a"),ug=t("torch.nn.Module"),hg=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),mg=l(),Ge=r("div"),F(Is.$$.fragment),fg=l(),mt=r("p"),gg=t("The "),$i=r("a"),_g=t("FunnelForMaskedLM"),Tg=t(" forward method, overrides the "),od=r("code"),kg=t("__call__"),Fg=t(" special method."),vg=l(),F(no.$$.fragment),bg=l(),sd=r("p"),yg=t("Example:"),wg=l(),F(Ws.$$.fragment),$g=l(),F(Bs.$$.fragment),Jc=l(),ft=r("h2"),to=r("a"),rd=r("span"),F(Qs.$$.fragment),Eg=l(),ad=r("span"),Mg=t("FunnelForSequenceClassification"),ep=l(),Ve=r("div"),F(Us.$$.fragment),zg=l(),id=r("p"),qg=t(`Funnel Transformer Model with a sequence classification/regression head on top (two linear layer on top of the
first timestep of the last hidden state) e.g. for GLUE tasks.`),Pg=l(),Rs=r("p"),Cg=t("The Funnel Transformer model was proposed in "),Vs=r("a"),xg=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),jg=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Lg=l(),Hs=r("p"),Og=t("This model inherits from "),Ei=r("a"),Dg=t("PreTrainedModel"),Ag=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Ng=l(),Ys=r("p"),Sg=t("This model is also a PyTorch "),Ks=r("a"),Ig=t("torch.nn.Module"),Wg=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Bg=l(),Pe=r("div"),F(Gs.$$.fragment),Qg=l(),gt=r("p"),Ug=t("The "),Mi=r("a"),Rg=t("FunnelForSequenceClassification"),Vg=t(" forward method, overrides the "),ld=r("code"),Hg=t("__call__"),Yg=t(" special method."),Kg=l(),F(oo.$$.fragment),Gg=l(),dd=r("p"),Zg=t("Example of single-label classification:"),Xg=l(),F(Zs.$$.fragment),Jg=l(),F(Xs.$$.fragment),e_=l(),cd=r("p"),n_=t("Example of multi-label classification:"),t_=l(),F(Js.$$.fragment),o_=l(),F(er.$$.fragment),np=l(),_t=r("h2"),so=r("a"),pd=r("span"),F(nr.$$.fragment),s_=l(),ud=r("span"),r_=t("FunnelForMultipleChoice"),tp=l(),He=r("div"),F(tr.$$.fragment),a_=l(),hd=r("p"),i_=t(`Funnel Transformer Model with a multiple choice classification head on top (two linear layer on top of the first
timestep of the last hidden state, and a softmax) e.g. for RocStories/SWAG tasks.`),l_=l(),or=r("p"),d_=t("The Funnel Transformer model was proposed in "),sr=r("a"),c_=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),p_=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),u_=l(),rr=r("p"),h_=t("This model inherits from "),zi=r("a"),m_=t("PreTrainedModel"),f_=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),g_=l(),ar=r("p"),__=t("This model is also a PyTorch "),ir=r("a"),T_=t("torch.nn.Module"),k_=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),F_=l(),dn=r("div"),F(lr.$$.fragment),v_=l(),Tt=r("p"),b_=t("The "),qi=r("a"),y_=t("FunnelForMultipleChoice"),w_=t(" forward method, overrides the "),md=r("code"),$_=t("__call__"),E_=t(" special method."),M_=l(),F(ro.$$.fragment),z_=l(),fd=r("p"),q_=t("Example:"),P_=l(),F(dr.$$.fragment),op=l(),kt=r("h2"),ao=r("a"),gd=r("span"),F(cr.$$.fragment),C_=l(),_d=r("span"),x_=t("FunnelForTokenClassification"),sp=l(),Ye=r("div"),F(pr.$$.fragment),j_=l(),Td=r("p"),L_=t(`Funnel Transformer Model with a token classification head on top (a linear layer on top of the hidden-states
output) e.g. for Named-Entity-Recognition (NER) tasks.`),O_=l(),ur=r("p"),D_=t("The Funnel Transformer model was proposed in "),hr=r("a"),A_=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),N_=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),S_=l(),mr=r("p"),I_=t("This model inherits from "),Pi=r("a"),W_=t("PreTrainedModel"),B_=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Q_=l(),fr=r("p"),U_=t("This model is also a PyTorch "),gr=r("a"),R_=t("torch.nn.Module"),V_=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),H_=l(),Ze=r("div"),F(_r.$$.fragment),Y_=l(),Ft=r("p"),K_=t("The "),Ci=r("a"),G_=t("FunnelForTokenClassification"),Z_=t(" forward method, overrides the "),kd=r("code"),X_=t("__call__"),J_=t(" special method."),eT=l(),F(io.$$.fragment),nT=l(),Fd=r("p"),tT=t("Example:"),oT=l(),F(Tr.$$.fragment),sT=l(),F(kr.$$.fragment),rp=l(),vt=r("h2"),lo=r("a"),vd=r("span"),F(Fr.$$.fragment),rT=l(),bd=r("span"),aT=t("FunnelForQuestionAnswering"),ap=l(),Ke=r("div"),F(vr.$$.fragment),iT=l(),bt=r("p"),lT=t(`Funnel Transformer Model with a span classification head on top for extractive question-answering tasks like SQuAD
(a linear layer on top of the hidden-states output to compute `),yd=r("code"),dT=t("span start logits"),cT=t(" and "),wd=r("code"),pT=t("span end logits"),uT=t(")."),hT=l(),br=r("p"),mT=t("The Funnel Transformer model was proposed in "),yr=r("a"),fT=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),gT=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),_T=l(),wr=r("p"),TT=t("This model inherits from "),xi=r("a"),kT=t("PreTrainedModel"),FT=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),vT=l(),$r=r("p"),bT=t("This model is also a PyTorch "),Er=r("a"),yT=t("torch.nn.Module"),wT=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),$T=l(),Xe=r("div"),F(Mr.$$.fragment),ET=l(),yt=r("p"),MT=t("The "),ji=r("a"),zT=t("FunnelForQuestionAnswering"),qT=t(" forward method, overrides the "),$d=r("code"),PT=t("__call__"),CT=t(" special method."),xT=l(),F(co.$$.fragment),jT=l(),Ed=r("p"),LT=t("Example:"),OT=l(),F(zr.$$.fragment),DT=l(),F(qr.$$.fragment),ip=l(),wt=r("h2"),po=r("a"),Md=r("span"),F(Pr.$$.fragment),AT=l(),zd=r("span"),NT=t("TFFunnelBaseModel"),lp=l(),Le=r("div"),F(Cr.$$.fragment),ST=l(),qd=r("p"),IT=t(`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),WT=l(),xr=r("p"),BT=t("The Funnel Transformer model was proposed in "),jr=r("a"),QT=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),UT=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),RT=l(),Lr=r("p"),VT=t("This model inherits from "),Li=r("a"),HT=t("TFPreTrainedModel"),YT=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),KT=l(),Or=r("p"),GT=t("This model is also a "),Dr=r("a"),ZT=t("tf.keras.Model"),XT=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),JT=l(),F(uo.$$.fragment),ek=l(),cn=r("div"),F(Ar.$$.fragment),nk=l(),$t=r("p"),tk=t("The "),Oi=r("a"),ok=t("TFFunnelBaseModel"),sk=t(" forward method, overrides the "),Pd=r("code"),rk=t("__call__"),ak=t(" special method."),ik=l(),F(ho.$$.fragment),lk=l(),Cd=r("p"),dk=t("Example:"),ck=l(),F(Nr.$$.fragment),dp=l(),Et=r("h2"),mo=r("a"),xd=r("span"),F(Sr.$$.fragment),pk=l(),jd=r("span"),uk=t("TFFunnelModel"),cp=l(),Oe=r("div"),F(Ir.$$.fragment),hk=l(),Ld=r("p"),mk=t("The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),fk=l(),Wr=r("p"),gk=t("The Funnel Transformer model was proposed in "),Br=r("a"),_k=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Tk=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),kk=l(),Qr=r("p"),Fk=t("This model inherits from "),Di=r("a"),vk=t("TFPreTrainedModel"),bk=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),yk=l(),Ur=r("p"),wk=t("This model is also a "),Rr=r("a"),$k=t("tf.keras.Model"),Ek=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Mk=l(),F(fo.$$.fragment),zk=l(),pn=r("div"),F(Vr.$$.fragment),qk=l(),Mt=r("p"),Pk=t("The "),Ai=r("a"),Ck=t("TFFunnelModel"),xk=t(" forward method, overrides the "),Od=r("code"),jk=t("__call__"),Lk=t(" special method."),Ok=l(),F(go.$$.fragment),Dk=l(),Dd=r("p"),Ak=t("Example:"),Nk=l(),F(Hr.$$.fragment),pp=l(),zt=r("h2"),_o=r("a"),Ad=r("span"),F(Yr.$$.fragment),Sk=l(),Nd=r("span"),Ik=t("TFFunnelModelForPreTraining"),up=l(),De=r("div"),F(Kr.$$.fragment),Wk=l(),Sd=r("p"),Bk=t("Funnel model with a binary classification head on top as used during pretraining for identifying generated tokens."),Qk=l(),Gr=r("p"),Uk=t("The Funnel Transformer model was proposed in "),Zr=r("a"),Rk=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Vk=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Hk=l(),Xr=r("p"),Yk=t("This model inherits from "),Ni=r("a"),Kk=t("TFPreTrainedModel"),Gk=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Zk=l(),Jr=r("p"),Xk=t("This model is also a "),ea=r("a"),Jk=t("tf.keras.Model"),eF=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),nF=l(),F(To.$$.fragment),tF=l(),un=r("div"),F(na.$$.fragment),oF=l(),qt=r("p"),sF=t("The "),Si=r("a"),rF=t("TFFunnelForPreTraining"),aF=t(" forward method, overrides the "),Id=r("code"),iF=t("__call__"),lF=t(" special method."),dF=l(),F(ko.$$.fragment),cF=l(),Wd=r("p"),pF=t("Examples:"),uF=l(),F(ta.$$.fragment),hp=l(),Pt=r("h2"),Fo=r("a"),Bd=r("span"),F(oa.$$.fragment),hF=l(),Qd=r("span"),mF=t("TFFunnelForMaskedLM"),mp=l(),Ae=r("div"),F(sa.$$.fragment),fF=l(),ra=r("p"),gF=t("Funnel Model with a "),Ud=r("code"),_F=t("language modeling"),TF=t(" head on top."),kF=l(),aa=r("p"),FF=t("The Funnel Transformer model was proposed in "),ia=r("a"),vF=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),bF=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),yF=l(),la=r("p"),wF=t("This model inherits from "),Ii=r("a"),$F=t("TFPreTrainedModel"),EF=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),MF=l(),da=r("p"),zF=t("This model is also a "),ca=r("a"),qF=t("tf.keras.Model"),PF=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),CF=l(),F(vo.$$.fragment),xF=l(),Je=r("div"),F(pa.$$.fragment),jF=l(),Ct=r("p"),LF=t("The "),Wi=r("a"),OF=t("TFFunnelForMaskedLM"),DF=t(" forward method, overrides the "),Rd=r("code"),AF=t("__call__"),NF=t(" special method."),SF=l(),F(bo.$$.fragment),IF=l(),Vd=r("p"),WF=t("Example:"),BF=l(),F(ua.$$.fragment),QF=l(),F(ha.$$.fragment),fp=l(),xt=r("h2"),yo=r("a"),Hd=r("span"),F(ma.$$.fragment),UF=l(),Yd=r("span"),RF=t("TFFunnelForSequenceClassification"),gp=l(),Ne=r("div"),F(fa.$$.fragment),VF=l(),Kd=r("p"),HF=t(`Funnel Model transformer with a sequence classification/regression head on top (a linear layer on top of the pooled
output) e.g. for GLUE tasks.`),YF=l(),ga=r("p"),KF=t("The Funnel Transformer model was proposed in "),_a=r("a"),GF=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),ZF=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),XF=l(),Ta=r("p"),JF=t("This model inherits from "),Bi=r("a"),ev=t("TFPreTrainedModel"),nv=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),tv=l(),ka=r("p"),ov=t("This model is also a "),Fa=r("a"),sv=t("tf.keras.Model"),rv=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),av=l(),F(wo.$$.fragment),iv=l(),en=r("div"),F(va.$$.fragment),lv=l(),jt=r("p"),dv=t("The "),Qi=r("a"),cv=t("TFFunnelForSequenceClassification"),pv=t(" forward method, overrides the "),Gd=r("code"),uv=t("__call__"),hv=t(" special method."),mv=l(),F($o.$$.fragment),fv=l(),Zd=r("p"),gv=t("Example:"),_v=l(),F(ba.$$.fragment),Tv=l(),F(ya.$$.fragment),_p=l(),Lt=r("h2"),Eo=r("a"),Xd=r("span"),F(wa.$$.fragment),kv=l(),Jd=r("span"),Fv=t("TFFunnelForMultipleChoice"),Tp=l(),Se=r("div"),F($a.$$.fragment),vv=l(),ec=r("p"),bv=t(`Funnel Model with a multiple choice classification head on top (a linear layer on top of the pooled output and a
softmax) e.g. for RocStories/SWAG tasks.`),yv=l(),Ea=r("p"),wv=t("The Funnel Transformer model was proposed in "),Ma=r("a"),$v=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Ev=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Mv=l(),za=r("p"),zv=t("This model inherits from "),Ui=r("a"),qv=t("TFPreTrainedModel"),Pv=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Cv=l(),qa=r("p"),xv=t("This model is also a "),Pa=r("a"),jv=t("tf.keras.Model"),Lv=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Ov=l(),F(Mo.$$.fragment),Dv=l(),hn=r("div"),F(Ca.$$.fragment),Av=l(),Ot=r("p"),Nv=t("The "),Ri=r("a"),Sv=t("TFFunnelForMultipleChoice"),Iv=t(" forward method, overrides the "),nc=r("code"),Wv=t("__call__"),Bv=t(" special method."),Qv=l(),F(zo.$$.fragment),Uv=l(),tc=r("p"),Rv=t("Example:"),Vv=l(),F(xa.$$.fragment),kp=l(),Dt=r("h2"),qo=r("a"),oc=r("span"),F(ja.$$.fragment),Hv=l(),sc=r("span"),Yv=t("TFFunnelForTokenClassification"),Fp=l(),Ie=r("div"),F(La.$$.fragment),Kv=l(),rc=r("p"),Gv=t(`Funnel Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g. for
Named-Entity-Recognition (NER) tasks.`),Zv=l(),Oa=r("p"),Xv=t("The Funnel Transformer model was proposed in "),Da=r("a"),Jv=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),eb=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),nb=l(),Aa=r("p"),tb=t("This model inherits from "),Vi=r("a"),ob=t("TFPreTrainedModel"),sb=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),rb=l(),Na=r("p"),ab=t("This model is also a "),Sa=r("a"),ib=t("tf.keras.Model"),lb=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),db=l(),F(Po.$$.fragment),cb=l(),nn=r("div"),F(Ia.$$.fragment),pb=l(),At=r("p"),ub=t("The "),Hi=r("a"),hb=t("TFFunnelForTokenClassification"),mb=t(" forward method, overrides the "),ac=r("code"),fb=t("__call__"),gb=t(" special method."),_b=l(),F(Co.$$.fragment),Tb=l(),ic=r("p"),kb=t("Example:"),Fb=l(),F(Wa.$$.fragment),vb=l(),F(Ba.$$.fragment),vp=l(),Nt=r("h2"),xo=r("a"),lc=r("span"),F(Qa.$$.fragment),bb=l(),dc=r("span"),yb=t("TFFunnelForQuestionAnswering"),bp=l(),We=r("div"),F(Ua.$$.fragment),wb=l(),St=r("p"),$b=t(`Funnel Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear
layers on top of the hidden-states output to compute `),cc=r("code"),Eb=t("span start logits"),Mb=t(" and "),pc=r("code"),zb=t("span end logits"),qb=t(")."),Pb=l(),Ra=r("p"),Cb=t("The Funnel Transformer model was proposed in "),Va=r("a"),xb=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),jb=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Lb=l(),Ha=r("p"),Ob=t("This model inherits from "),Yi=r("a"),Db=t("TFPreTrainedModel"),Ab=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Nb=l(),Ya=r("p"),Sb=t("This model is also a "),Ka=r("a"),Ib=t("tf.keras.Model"),Wb=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Bb=l(),F(jo.$$.fragment),Qb=l(),tn=r("div"),F(Ga.$$.fragment),Ub=l(),It=r("p"),Rb=t("The "),Ki=r("a"),Vb=t("TFFunnelForQuestionAnswering"),Hb=t(" forward method, overrides the "),uc=r("code"),Yb=t("__call__"),Kb=t(" special method."),Gb=l(),F(Lo.$$.fragment),Zb=l(),hc=r("p"),Xb=t("Example:"),Jb=l(),F(Za.$$.fragment),ey=l(),F(Xa.$$.fragment),this.h()},l(s){const m=U2('[data-svelte="svelte-1phssyn"]',document.head);u=a(m,"META",{name:!0,content:!0}),m.forEach(n),z=d(s),g=a(s,"H1",{class:!0});var Ja=i(g);_=a(Ja,"A",{id:!0,class:!0,href:!0});var mc=i(_);k=a(mc,"SPAN",{});var fc=i(k);v(T.$$.fragment,fc),fc.forEach(n),mc.forEach(n),f=d(Ja),M=a(Ja,"SPAN",{});var gc=i(M);ce=o(gc,"Funnel Transformer"),gc.forEach(n),Ja.forEach(n),K=d(s),q=a(s,"H2",{class:!0});var ei=i(q);J=a(ei,"A",{id:!0,class:!0,href:!0});var _c=i(J);A=a(_c,"SPAN",{});var Tc=i(A);v(ne.$$.fragment,Tc),Tc.forEach(n),_c.forEach(n),pe=d(ei),N=a(ei,"SPAN",{});var kc=i(N);ue=o(kc,"Overview"),kc.forEach(n),ei.forEach(n),ie=d(s),Y=a(s,"P",{});var ni=i(Y);L=o(ni,"The Funnel Transformer model was proposed in the paper "),te=a(ni,"A",{href:!0,rel:!0});var Fc=i(te);G=o(Fc,`Funnel-Transformer: Filtering out Sequential Redundancy for
Efficient Language Processing`),Fc.forEach(n),P=o(ni,`. It is a bidirectional transformer model, like
BERT, but with a pooling operation after each block of layers, a bit like in traditional convolutional neural networks
(CNN) in computer vision.`),ni.forEach(n),x=d(s),oe=a(s,"P",{});var vc=i(oe);B=o(vc,"The abstract from the paper is the following:"),vc.forEach(n),le=d(s),se=a(s,"P",{});var bc=i(se);S=a(bc,"EM",{});var yc=i(S);he=o(yc,`With the success of language pretraining, it is highly desirable to develop more efficient architectures of good
scalability that can exploit the abundant unlabeled data at a lower cost. To improve the efficiency, we examine the
much-overlooked redundancy in maintaining a full-length token-level presentation, especially for tasks that only
require a single-vector presentation of the sequence. With this intuition, we propose Funnel-Transformer which
gradually compresses the sequence of hidden states to a shorter one and hence reduces the computation cost. More
importantly, by re-investing the saved FLOPs from length reduction in constructing a deeper or wider model, we further
improve the model capacity. In addition, to perform token-level predictions as required by common pretraining
objectives, Funnel-Transformer is able to recover a deep representation for each token from the reduced hidden sequence
via a decoder. Empirically, with comparable or fewer FLOPs, Funnel-Transformer outperforms the standard Transformer on
a wide variety of sequence-level prediction tasks, including text classification, language understanding, and reading
comprehension.`),yc.forEach(n),bc.forEach(n),de=d(s),C=a(s,"P",{});var wc=i(C);me=o(wc,"Tips:"),wc.forEach(n),W=d(s),ee=a(s,"UL",{});var ti=i(ee);ae=a(ti,"LI",{});var $c=i(ae);Q=o($c,`Since Funnel Transformer uses pooling, the sequence length of the hidden states changes after each block of layers.
The base model therefore has a final sequence length that is a quarter of the original one. This model can be used
directly for tasks that just require a sentence summary (like sequence classification or multiple choice). For other
tasks, the full model is used; this full model has a decoder that upsamples the final hidden states to the same
sequence length as the input.`),$c.forEach(n),fe=d(ti),I=a(ti,"LI",{});var je=i(I);O=o(je,`The Funnel Transformer checkpoints are all available with a full version and a base version. The first ones should be
used for `),re=a(je,"A",{href:!0});var Ec=i(re);U=o(Ec,"FunnelModel"),Ec.forEach(n),ge=o(je,", "),p=a(je,"A",{href:!0});var Mc=i(p);E=o(Mc,"FunnelForPreTraining"),Mc.forEach(n),Z=o(je,`,
`),Te=a(je,"A",{href:!0});var zc=i(Te);ye=o(zc,"FunnelForMaskedLM"),zc.forEach(n),D=o(je,", "),ke=a(je,"A",{href:!0});var qc=i(ke);we=o(qc,"FunnelForTokenClassification"),qc.forEach(n),$e=o(je,` and
class:`),j=a(je,"EM",{});var Pc=i(j);R=o(Pc,"~transformers.FunnelForQuestionAnswering"),Pc.forEach(n),Ee=o(je,`. The second ones should be used for
`),Fe=a(je,"A",{href:!0});var Cc=i(Fe);V=o(Cc,"FunnelBaseModel"),Cc.forEach(n),Me=o(je,", "),ve=a(je,"A",{href:!0});var xc=i(ve);_e=o(xc,"FunnelForSequenceClassification"),xc.forEach(n),ze=o(je,` and
`),oi=a(je,"A",{href:!0});var oy=i(oi);Yu=o(oy,"FunnelForMultipleChoice"),oy.forEach(n),Ku=o(je,"."),je.forEach(n),ti.forEach(n),Oc=d(s),In=a(s,"P",{});var Gi=i(In);Gu=o(Gi,"This model was contributed by "),No=a(Gi,"A",{href:!0,rel:!0});var sy=i(No);Zu=o(sy,"sgugger"),sy.forEach(n),Xu=o(Gi,". The original code can be found "),So=a(Gi,"A",{href:!0,rel:!0});var ry=i(So);Ju=o(ry,"here"),ry.forEach(n),eh=o(Gi,"."),Gi.forEach(n),Dc=d(s),Zn=a(s,"H2",{class:!0});var wp=i(Zn);Wt=a(wp,"A",{id:!0,class:!0,href:!0});var ay=i(Wt);Fl=a(ay,"SPAN",{});var iy=i(Fl);v(Io.$$.fragment,iy),iy.forEach(n),ay.forEach(n),nh=d(wp),vl=a(wp,"SPAN",{});var ly=i(vl);th=o(ly,"FunnelConfig"),ly.forEach(n),wp.forEach(n),Ac=d(s),Nn=a(s,"DIV",{class:!0});var Zi=i(Nn);v(Wo.$$.fragment,Zi),oh=d(Zi),Sn=a(Zi,"P",{});var Oo=i(Sn);sh=o(Oo,"This is the configuration class to store the configuration of a "),si=a(Oo,"A",{href:!0});var dy=i(si);rh=o(dy,"FunnelModel"),dy.forEach(n),ah=o(Oo," or a "),ri=a(Oo,"A",{href:!0});var cy=i(ri);ih=o(cy,"TFBertModel"),cy.forEach(n),lh=o(Oo,`. It is used to
instantiate a Funnel Transformer model according to the specified arguments, defining the model architecture.
Instantiating a configuration with the defaults will yield a similar configuration to that of the Funnel
Transformer `),Bo=a(Oo,"A",{href:!0,rel:!0});var py=i(Bo);dh=o(py,"funnel-transformer/small"),py.forEach(n),ch=o(Oo," architecture."),Oo.forEach(n),ph=d(Zi),Xn=a(Zi,"P",{});var Xi=i(Xn);uh=o(Xi,"Configuration objects inherit from "),ai=a(Xi,"A",{href:!0});var uy=i(ai);hh=o(uy,"PretrainedConfig"),uy.forEach(n),mh=o(Xi,` and can be used to control the model outputs. Read the
documentation from `),ii=a(Xi,"A",{href:!0});var hy=i(ii);fh=o(hy,"PretrainedConfig"),hy.forEach(n),gh=o(Xi," for more information."),Xi.forEach(n),Zi.forEach(n),Nc=d(s),Jn=a(s,"H2",{class:!0});var $p=i(Jn);Bt=a($p,"A",{id:!0,class:!0,href:!0});var my=i(Bt);bl=a(my,"SPAN",{});var fy=i(bl);v(Qo.$$.fragment,fy),fy.forEach(n),my.forEach(n),_h=d($p),yl=a($p,"SPAN",{});var gy=i(yl);Th=o(gy,"FunnelTokenizer"),gy.forEach(n),$p.forEach(n),Sc=d(s),xe=a(s,"DIV",{class:!0});var on=i(xe);v(Uo.$$.fragment,on),kh=d(on),wl=a(on,"P",{});var _y=i(wl);Fh=o(_y,"Construct a Funnel Transformer tokenizer."),_y.forEach(n),vh=d(on),Qt=a(on,"P",{});var jc=i(Qt);li=a(jc,"A",{href:!0});var Ty=i(li);bh=o(Ty,"FunnelTokenizer"),Ty.forEach(n),yh=o(jc," is identical to "),di=a(jc,"A",{href:!0});var ky=i(di);wh=o(ky,"BertTokenizer"),ky.forEach(n),$h=o(jc,` and runs end-to-end tokenization: punctuation splitting and
wordpiece.`),jc.forEach(n),Eh=d(on),Ro=a(on,"P",{});var Ep=i(Ro);Mh=o(Ep,"Refer to superclass "),ci=a(Ep,"A",{href:!0});var Fy=i(ci);zh=o(Fy,"BertTokenizer"),Fy.forEach(n),qh=o(Ep," for usage examples and documentation concerning parameters."),Ep.forEach(n),Ph=d(on),Wn=a(on,"DIV",{class:!0});var Ji=i(Wn);v(Vo.$$.fragment,Ji),Ch=d(Ji),$l=a(Ji,"P",{});var vy=i($l);xh=o(vy,`Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and
adding special tokens. A BERT sequence has the following format:`),vy.forEach(n),jh=d(Ji),Ho=a(Ji,"UL",{});var Mp=i(Ho);pi=a(Mp,"LI",{});var ny=i(pi);Lh=o(ny,"single sequence: "),El=a(ny,"CODE",{});var by=i(El);Oh=o(by,"[CLS] X [SEP]"),by.forEach(n),ny.forEach(n),Dh=d(Mp),ui=a(Mp,"LI",{});var ty=i(ui);Ah=o(ty,"pair of sequences: "),Ml=a(ty,"CODE",{});var yy=i(Ml);Nh=o(yy,"[CLS] A [SEP] B [SEP]"),yy.forEach(n),ty.forEach(n),Mp.forEach(n),Ji.forEach(n),Sh=d(on),Ut=a(on,"DIV",{class:!0});var zp=i(Ut);v(Yo.$$.fragment,zp),Ih=d(zp),Ko=a(zp,"P",{});var qp=i(Ko);Wh=o(qp,`Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding
special tokens using the tokenizer `),zl=a(qp,"CODE",{});var wy=i(zl);Bh=o(wy,"prepare_for_model"),wy.forEach(n),Qh=o(qp," method."),qp.forEach(n),zp.forEach(n),Uh=d(on),bn=a(on,"DIV",{class:!0});var Do=i(bn);v(Go.$$.fragment,Do),Rh=d(Do),ql=a(Do,"P",{});var $y=i(ql);Vh=o($y,`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),$y.forEach(n),Hh=d(Do),v(Zo.$$.fragment,Do),Yh=d(Do),et=a(Do,"P",{});var el=i(et);Kh=o(el,"If "),Pl=a(el,"CODE",{});var Ey=i(Pl);Gh=o(Ey,"token_ids_1"),Ey.forEach(n),Zh=o(el," is "),Cl=a(el,"CODE",{});var My=i(Cl);Xh=o(My,"None"),My.forEach(n),Jh=o(el,", this method only returns the first portion of the mask (0s)."),el.forEach(n),Do.forEach(n),em=d(on),hi=a(on,"DIV",{class:!0});var zy=i(hi);v(Xo.$$.fragment,zy),zy.forEach(n),on.forEach(n),Ic=d(s),nt=a(s,"H2",{class:!0});var Pp=i(nt);Rt=a(Pp,"A",{id:!0,class:!0,href:!0});var qy=i(Rt);xl=a(qy,"SPAN",{});var Py=i(xl);v(Jo.$$.fragment,Py),Py.forEach(n),qy.forEach(n),nm=d(Pp),jl=a(Pp,"SPAN",{});var Cy=i(jl);tm=o(Cy,"FunnelTokenizerFast"),Cy.forEach(n),Pp.forEach(n),Wc=d(s),sn=a(s,"DIV",{class:!0});var Bn=i(sn);v(es.$$.fragment,Bn),om=d(Bn),ns=a(Bn,"P",{});var Cp=i(ns);sm=o(Cp,"Construct a \u201Cfast\u201D Funnel Transformer tokenizer (backed by HuggingFace\u2019s "),Ll=a(Cp,"EM",{});var xy=i(Ll);rm=o(xy,"tokenizers"),xy.forEach(n),am=o(Cp," library)."),Cp.forEach(n),im=d(Bn),Vt=a(Bn,"P",{});var Lc=i(Vt);mi=a(Lc,"A",{href:!0});var jy=i(mi);lm=o(jy,"FunnelTokenizerFast"),jy.forEach(n),dm=o(Lc," is identical to "),fi=a(Lc,"A",{href:!0});var Ly=i(fi);cm=o(Ly,"BertTokenizerFast"),Ly.forEach(n),pm=o(Lc,` and runs end-to-end tokenization: punctuation
splitting and wordpiece.`),Lc.forEach(n),um=d(Bn),ts=a(Bn,"P",{});var xp=i(ts);hm=o(xp,"Refer to superclass "),gi=a(xp,"A",{href:!0});var Oy=i(gi);mm=o(Oy,"BertTokenizerFast"),Oy.forEach(n),fm=o(xp," for usage examples and documentation concerning parameters."),xp.forEach(n),gm=d(Bn),yn=a(Bn,"DIV",{class:!0});var Ao=i(yn);v(os.$$.fragment,Ao),_m=d(Ao),Ol=a(Ao,"P",{});var Dy=i(Ol);Tm=o(Dy,`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),Dy.forEach(n),km=d(Ao),v(ss.$$.fragment,Ao),Fm=d(Ao),tt=a(Ao,"P",{});var nl=i(tt);vm=o(nl,"If "),Dl=a(nl,"CODE",{});var Ay=i(Dl);bm=o(Ay,"token_ids_1"),Ay.forEach(n),ym=o(nl," is "),Al=a(nl,"CODE",{});var Ny=i(Al);wm=o(Ny,"None"),Ny.forEach(n),$m=o(nl,", this method only returns the first portion of the mask (0s)."),nl.forEach(n),Ao.forEach(n),Bn.forEach(n),Bc=d(s),ot=a(s,"H2",{class:!0});var jp=i(ot);Ht=a(jp,"A",{id:!0,class:!0,href:!0});var Sy=i(Ht);Nl=a(Sy,"SPAN",{});var Iy=i(Nl);v(rs.$$.fragment,Iy),Iy.forEach(n),Sy.forEach(n),Em=d(jp),Sl=a(jp,"SPAN",{});var Wy=i(Sl);Mm=o(Wy,"Funnel specific outputs"),Wy.forEach(n),jp.forEach(n),Qc=d(s),st=a(s,"DIV",{class:!0});var Lp=i(st);v(as.$$.fragment,Lp),zm=d(Lp),is=a(Lp,"P",{});var Op=i(is);qm=o(Op,"Output type of "),_i=a(Op,"A",{href:!0});var By=i(_i);Pm=o(By,"FunnelForPreTraining"),By.forEach(n),Cm=o(Op,"."),Op.forEach(n),Lp.forEach(n),Uc=d(s),rt=a(s,"DIV",{class:!0});var Dp=i(rt);v(ls.$$.fragment,Dp),xm=d(Dp),ds=a(Dp,"P",{});var Ap=i(ds);jm=o(Ap,"Output type of "),Ti=a(Ap,"A",{href:!0});var Qy=i(Ti);Lm=o(Qy,"FunnelForPreTraining"),Qy.forEach(n),Om=o(Ap,"."),Ap.forEach(n),Dp.forEach(n),Rc=d(s),at=a(s,"H2",{class:!0});var Np=i(at);Yt=a(Np,"A",{id:!0,class:!0,href:!0});var Uy=i(Yt);Il=a(Uy,"SPAN",{});var Ry=i(Il);v(cs.$$.fragment,Ry),Ry.forEach(n),Uy.forEach(n),Dm=d(Np),Wl=a(Np,"SPAN",{});var Vy=i(Wl);Am=o(Vy,"FunnelBaseModel"),Vy.forEach(n),Np.forEach(n),Vc=d(s),Qe=a(s,"DIV",{class:!0});var wn=i(Qe);v(ps.$$.fragment,wn),Nm=d(wn),Bl=a(wn,"P",{});var Hy=i(Bl);Sm=o(Hy,`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),Hy.forEach(n),Im=d(wn),us=a(wn,"P",{});var Sp=i(us);Wm=o(Sp,"The Funnel Transformer model was proposed in "),hs=a(Sp,"A",{href:!0,rel:!0});var Yy=i(hs);Bm=o(Yy,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Yy.forEach(n),Qm=o(Sp," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Sp.forEach(n),Um=d(wn),ms=a(wn,"P",{});var Ip=i(ms);Rm=o(Ip,"This model inherits from "),ki=a(Ip,"A",{href:!0});var Ky=i(ki);Vm=o(Ky,"PreTrainedModel"),Ky.forEach(n),Hm=o(Ip,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Ip.forEach(n),Ym=d(wn),fs=a(wn,"P",{});var Wp=i(fs);Km=o(Wp,"This model is also a PyTorch "),gs=a(Wp,"A",{href:!0,rel:!0});var Gy=i(gs);Gm=o(Gy,"torch.nn.Module"),Gy.forEach(n),Zm=o(Wp,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Wp.forEach(n),Xm=d(wn),rn=a(wn,"DIV",{class:!0});var Qn=i(rn);v(_s.$$.fragment,Qn),Jm=d(Qn),it=a(Qn,"P",{});var tl=i(it);ef=o(tl,"The "),Fi=a(tl,"A",{href:!0});var Zy=i(Fi);nf=o(Zy,"FunnelBaseModel"),Zy.forEach(n),tf=o(tl," forward method, overrides the "),Ql=a(tl,"CODE",{});var Xy=i(Ql);of=o(Xy,"__call__"),Xy.forEach(n),sf=o(tl," special method."),tl.forEach(n),rf=d(Qn),v(Kt.$$.fragment,Qn),af=d(Qn),Ul=a(Qn,"P",{});var Jy=i(Ul);lf=o(Jy,"Example:"),Jy.forEach(n),df=d(Qn),v(Ts.$$.fragment,Qn),Qn.forEach(n),wn.forEach(n),Hc=d(s),lt=a(s,"H2",{class:!0});var Bp=i(lt);Gt=a(Bp,"A",{id:!0,class:!0,href:!0});var ew=i(Gt);Rl=a(ew,"SPAN",{});var nw=i(Rl);v(ks.$$.fragment,nw),nw.forEach(n),ew.forEach(n),cf=d(Bp),Vl=a(Bp,"SPAN",{});var tw=i(Vl);pf=o(tw,"FunnelModel"),tw.forEach(n),Bp.forEach(n),Yc=d(s),Ue=a(s,"DIV",{class:!0});var $n=i(Ue);v(Fs.$$.fragment,$n),uf=d($n),Hl=a($n,"P",{});var ow=i(Hl);hf=o(ow,"The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),ow.forEach(n),mf=d($n),vs=a($n,"P",{});var Qp=i(vs);ff=o(Qp,"The Funnel Transformer model was proposed in "),bs=a(Qp,"A",{href:!0,rel:!0});var sw=i(bs);gf=o(sw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),sw.forEach(n),_f=o(Qp," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Qp.forEach(n),Tf=d($n),ys=a($n,"P",{});var Up=i(ys);kf=o(Up,"This model inherits from "),vi=a(Up,"A",{href:!0});var rw=i(vi);Ff=o(rw,"PreTrainedModel"),rw.forEach(n),vf=o(Up,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Up.forEach(n),bf=d($n),ws=a($n,"P",{});var Rp=i(ws);yf=o(Rp,"This model is also a PyTorch "),$s=a(Rp,"A",{href:!0,rel:!0});var aw=i($s);wf=o(aw,"torch.nn.Module"),aw.forEach(n),$f=o(Rp,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Rp.forEach(n),Ef=d($n),an=a($n,"DIV",{class:!0});var Un=i(an);v(Es.$$.fragment,Un),Mf=d(Un),dt=a(Un,"P",{});var ol=i(dt);zf=o(ol,"The "),bi=a(ol,"A",{href:!0});var iw=i(bi);qf=o(iw,"FunnelModel"),iw.forEach(n),Pf=o(ol," forward method, overrides the "),Yl=a(ol,"CODE",{});var lw=i(Yl);Cf=o(lw,"__call__"),lw.forEach(n),xf=o(ol," special method."),ol.forEach(n),jf=d(Un),v(Zt.$$.fragment,Un),Lf=d(Un),Kl=a(Un,"P",{});var dw=i(Kl);Of=o(dw,"Example:"),dw.forEach(n),Df=d(Un),v(Ms.$$.fragment,Un),Un.forEach(n),$n.forEach(n),Kc=d(s),ct=a(s,"H2",{class:!0});var Vp=i(ct);Xt=a(Vp,"A",{id:!0,class:!0,href:!0});var cw=i(Xt);Gl=a(cw,"SPAN",{});var pw=i(Gl);v(zs.$$.fragment,pw),pw.forEach(n),cw.forEach(n),Af=d(Vp),Zl=a(Vp,"SPAN",{});var uw=i(Zl);Nf=o(uw,"FunnelModelForPreTraining"),uw.forEach(n),Vp.forEach(n),Gc=d(s),pt=a(s,"DIV",{class:!0});var Hp=i(pt);v(qs.$$.fragment,Hp),Sf=d(Hp),ln=a(Hp,"DIV",{class:!0});var Rn=i(ln);v(Ps.$$.fragment,Rn),If=d(Rn),ut=a(Rn,"P",{});var sl=i(ut);Wf=o(sl,"The "),yi=a(sl,"A",{href:!0});var hw=i(yi);Bf=o(hw,"FunnelForPreTraining"),hw.forEach(n),Qf=o(sl," forward method, overrides the "),Xl=a(sl,"CODE",{});var mw=i(Xl);Uf=o(mw,"__call__"),mw.forEach(n),Rf=o(sl," special method."),sl.forEach(n),Vf=d(Rn),v(Jt.$$.fragment,Rn),Hf=d(Rn),Jl=a(Rn,"P",{});var fw=i(Jl);Yf=o(fw,"Examples:"),fw.forEach(n),Kf=d(Rn),v(Cs.$$.fragment,Rn),Rn.forEach(n),Hp.forEach(n),Zc=d(s),ht=a(s,"H2",{class:!0});var Yp=i(ht);eo=a(Yp,"A",{id:!0,class:!0,href:!0});var gw=i(eo);ed=a(gw,"SPAN",{});var _w=i(ed);v(xs.$$.fragment,_w),_w.forEach(n),gw.forEach(n),Gf=d(Yp),nd=a(Yp,"SPAN",{});var Tw=i(nd);Zf=o(Tw,"FunnelForMaskedLM"),Tw.forEach(n),Yp.forEach(n),Xc=d(s),Re=a(s,"DIV",{class:!0});var En=i(Re);v(js.$$.fragment,En),Xf=d(En),Ls=a(En,"P",{});var Kp=i(Ls);Jf=o(Kp,"Funnel Transformer Model with a "),td=a(Kp,"CODE",{});var kw=i(td);eg=o(kw,"language modeling"),kw.forEach(n),ng=o(Kp," head on top."),Kp.forEach(n),tg=d(En),Os=a(En,"P",{});var Gp=i(Os);og=o(Gp,"The Funnel Transformer model was proposed in "),Ds=a(Gp,"A",{href:!0,rel:!0});var Fw=i(Ds);sg=o(Fw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Fw.forEach(n),rg=o(Gp," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Gp.forEach(n),ag=d(En),As=a(En,"P",{});var Zp=i(As);ig=o(Zp,"This model inherits from "),wi=a(Zp,"A",{href:!0});var vw=i(wi);lg=o(vw,"PreTrainedModel"),vw.forEach(n),dg=o(Zp,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Zp.forEach(n),cg=d(En),Ns=a(En,"P",{});var Xp=i(Ns);pg=o(Xp,"This model is also a PyTorch "),Ss=a(Xp,"A",{href:!0,rel:!0});var bw=i(Ss);ug=o(bw,"torch.nn.Module"),bw.forEach(n),hg=o(Xp,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Xp.forEach(n),mg=d(En),Ge=a(En,"DIV",{class:!0});var Mn=i(Ge);v(Is.$$.fragment,Mn),fg=d(Mn),mt=a(Mn,"P",{});var rl=i(mt);gg=o(rl,"The "),$i=a(rl,"A",{href:!0});var yw=i($i);_g=o(yw,"FunnelForMaskedLM"),yw.forEach(n),Tg=o(rl," forward method, overrides the "),od=a(rl,"CODE",{});var ww=i(od);kg=o(ww,"__call__"),ww.forEach(n),Fg=o(rl," special method."),rl.forEach(n),vg=d(Mn),v(no.$$.fragment,Mn),bg=d(Mn),sd=a(Mn,"P",{});var $w=i(sd);yg=o($w,"Example:"),$w.forEach(n),wg=d(Mn),v(Ws.$$.fragment,Mn),$g=d(Mn),v(Bs.$$.fragment,Mn),Mn.forEach(n),En.forEach(n),Jc=d(s),ft=a(s,"H2",{class:!0});var Jp=i(ft);to=a(Jp,"A",{id:!0,class:!0,href:!0});var Ew=i(to);rd=a(Ew,"SPAN",{});var Mw=i(rd);v(Qs.$$.fragment,Mw),Mw.forEach(n),Ew.forEach(n),Eg=d(Jp),ad=a(Jp,"SPAN",{});var zw=i(ad);Mg=o(zw,"FunnelForSequenceClassification"),zw.forEach(n),Jp.forEach(n),ep=d(s),Ve=a(s,"DIV",{class:!0});var zn=i(Ve);v(Us.$$.fragment,zn),zg=d(zn),id=a(zn,"P",{});var qw=i(id);qg=o(qw,`Funnel Transformer Model with a sequence classification/regression head on top (two linear layer on top of the
first timestep of the last hidden state) e.g. for GLUE tasks.`),qw.forEach(n),Pg=d(zn),Rs=a(zn,"P",{});var eu=i(Rs);Cg=o(eu,"The Funnel Transformer model was proposed in "),Vs=a(eu,"A",{href:!0,rel:!0});var Pw=i(Vs);xg=o(Pw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Pw.forEach(n),jg=o(eu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),eu.forEach(n),Lg=d(zn),Hs=a(zn,"P",{});var nu=i(Hs);Og=o(nu,"This model inherits from "),Ei=a(nu,"A",{href:!0});var Cw=i(Ei);Dg=o(Cw,"PreTrainedModel"),Cw.forEach(n),Ag=o(nu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),nu.forEach(n),Ng=d(zn),Ys=a(zn,"P",{});var tu=i(Ys);Sg=o(tu,"This model is also a PyTorch "),Ks=a(tu,"A",{href:!0,rel:!0});var xw=i(Ks);Ig=o(xw,"torch.nn.Module"),xw.forEach(n),Wg=o(tu,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),tu.forEach(n),Bg=d(zn),Pe=a(zn,"DIV",{class:!0});var Be=i(Pe);v(Gs.$$.fragment,Be),Qg=d(Be),gt=a(Be,"P",{});var al=i(gt);Ug=o(al,"The "),Mi=a(al,"A",{href:!0});var jw=i(Mi);Rg=o(jw,"FunnelForSequenceClassification"),jw.forEach(n),Vg=o(al," forward method, overrides the "),ld=a(al,"CODE",{});var Lw=i(ld);Hg=o(Lw,"__call__"),Lw.forEach(n),Yg=o(al," special method."),al.forEach(n),Kg=d(Be),v(oo.$$.fragment,Be),Gg=d(Be),dd=a(Be,"P",{});var Ow=i(dd);Zg=o(Ow,"Example of single-label classification:"),Ow.forEach(n),Xg=d(Be),v(Zs.$$.fragment,Be),Jg=d(Be),v(Xs.$$.fragment,Be),e_=d(Be),cd=a(Be,"P",{});var Dw=i(cd);n_=o(Dw,"Example of multi-label classification:"),Dw.forEach(n),t_=d(Be),v(Js.$$.fragment,Be),o_=d(Be),v(er.$$.fragment,Be),Be.forEach(n),zn.forEach(n),np=d(s),_t=a(s,"H2",{class:!0});var ou=i(_t);so=a(ou,"A",{id:!0,class:!0,href:!0});var Aw=i(so);pd=a(Aw,"SPAN",{});var Nw=i(pd);v(nr.$$.fragment,Nw),Nw.forEach(n),Aw.forEach(n),s_=d(ou),ud=a(ou,"SPAN",{});var Sw=i(ud);r_=o(Sw,"FunnelForMultipleChoice"),Sw.forEach(n),ou.forEach(n),tp=d(s),He=a(s,"DIV",{class:!0});var qn=i(He);v(tr.$$.fragment,qn),a_=d(qn),hd=a(qn,"P",{});var Iw=i(hd);i_=o(Iw,`Funnel Transformer Model with a multiple choice classification head on top (two linear layer on top of the first
timestep of the last hidden state, and a softmax) e.g. for RocStories/SWAG tasks.`),Iw.forEach(n),l_=d(qn),or=a(qn,"P",{});var su=i(or);d_=o(su,"The Funnel Transformer model was proposed in "),sr=a(su,"A",{href:!0,rel:!0});var Ww=i(sr);c_=o(Ww,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Ww.forEach(n),p_=o(su," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),su.forEach(n),u_=d(qn),rr=a(qn,"P",{});var ru=i(rr);h_=o(ru,"This model inherits from "),zi=a(ru,"A",{href:!0});var Bw=i(zi);m_=o(Bw,"PreTrainedModel"),Bw.forEach(n),f_=o(ru,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),ru.forEach(n),g_=d(qn),ar=a(qn,"P",{});var au=i(ar);__=o(au,"This model is also a PyTorch "),ir=a(au,"A",{href:!0,rel:!0});var Qw=i(ir);T_=o(Qw,"torch.nn.Module"),Qw.forEach(n),k_=o(au,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),au.forEach(n),F_=d(qn),dn=a(qn,"DIV",{class:!0});var Vn=i(dn);v(lr.$$.fragment,Vn),v_=d(Vn),Tt=a(Vn,"P",{});var il=i(Tt);b_=o(il,"The "),qi=a(il,"A",{href:!0});var Uw=i(qi);y_=o(Uw,"FunnelForMultipleChoice"),Uw.forEach(n),w_=o(il," forward method, overrides the "),md=a(il,"CODE",{});var Rw=i(md);$_=o(Rw,"__call__"),Rw.forEach(n),E_=o(il," special method."),il.forEach(n),M_=d(Vn),v(ro.$$.fragment,Vn),z_=d(Vn),fd=a(Vn,"P",{});var Vw=i(fd);q_=o(Vw,"Example:"),Vw.forEach(n),P_=d(Vn),v(dr.$$.fragment,Vn),Vn.forEach(n),qn.forEach(n),op=d(s),kt=a(s,"H2",{class:!0});var iu=i(kt);ao=a(iu,"A",{id:!0,class:!0,href:!0});var Hw=i(ao);gd=a(Hw,"SPAN",{});var Yw=i(gd);v(cr.$$.fragment,Yw),Yw.forEach(n),Hw.forEach(n),C_=d(iu),_d=a(iu,"SPAN",{});var Kw=i(_d);x_=o(Kw,"FunnelForTokenClassification"),Kw.forEach(n),iu.forEach(n),sp=d(s),Ye=a(s,"DIV",{class:!0});var Pn=i(Ye);v(pr.$$.fragment,Pn),j_=d(Pn),Td=a(Pn,"P",{});var Gw=i(Td);L_=o(Gw,`Funnel Transformer Model with a token classification head on top (a linear layer on top of the hidden-states
output) e.g. for Named-Entity-Recognition (NER) tasks.`),Gw.forEach(n),O_=d(Pn),ur=a(Pn,"P",{});var lu=i(ur);D_=o(lu,"The Funnel Transformer model was proposed in "),hr=a(lu,"A",{href:!0,rel:!0});var Zw=i(hr);A_=o(Zw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Zw.forEach(n),N_=o(lu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),lu.forEach(n),S_=d(Pn),mr=a(Pn,"P",{});var du=i(mr);I_=o(du,"This model inherits from "),Pi=a(du,"A",{href:!0});var Xw=i(Pi);W_=o(Xw,"PreTrainedModel"),Xw.forEach(n),B_=o(du,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),du.forEach(n),Q_=d(Pn),fr=a(Pn,"P",{});var cu=i(fr);U_=o(cu,"This model is also a PyTorch "),gr=a(cu,"A",{href:!0,rel:!0});var Jw=i(gr);R_=o(Jw,"torch.nn.Module"),Jw.forEach(n),V_=o(cu,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),cu.forEach(n),H_=d(Pn),Ze=a(Pn,"DIV",{class:!0});var Cn=i(Ze);v(_r.$$.fragment,Cn),Y_=d(Cn),Ft=a(Cn,"P",{});var ll=i(Ft);K_=o(ll,"The "),Ci=a(ll,"A",{href:!0});var e1=i(Ci);G_=o(e1,"FunnelForTokenClassification"),e1.forEach(n),Z_=o(ll," forward method, overrides the "),kd=a(ll,"CODE",{});var n1=i(kd);X_=o(n1,"__call__"),n1.forEach(n),J_=o(ll," special method."),ll.forEach(n),eT=d(Cn),v(io.$$.fragment,Cn),nT=d(Cn),Fd=a(Cn,"P",{});var t1=i(Fd);tT=o(t1,"Example:"),t1.forEach(n),oT=d(Cn),v(Tr.$$.fragment,Cn),sT=d(Cn),v(kr.$$.fragment,Cn),Cn.forEach(n),Pn.forEach(n),rp=d(s),vt=a(s,"H2",{class:!0});var pu=i(vt);lo=a(pu,"A",{id:!0,class:!0,href:!0});var o1=i(lo);vd=a(o1,"SPAN",{});var s1=i(vd);v(Fr.$$.fragment,s1),s1.forEach(n),o1.forEach(n),rT=d(pu),bd=a(pu,"SPAN",{});var r1=i(bd);aT=o(r1,"FunnelForQuestionAnswering"),r1.forEach(n),pu.forEach(n),ap=d(s),Ke=a(s,"DIV",{class:!0});var xn=i(Ke);v(vr.$$.fragment,xn),iT=d(xn),bt=a(xn,"P",{});var dl=i(bt);lT=o(dl,`Funnel Transformer Model with a span classification head on top for extractive question-answering tasks like SQuAD
(a linear layer on top of the hidden-states output to compute `),yd=a(dl,"CODE",{});var a1=i(yd);dT=o(a1,"span start logits"),a1.forEach(n),cT=o(dl," and "),wd=a(dl,"CODE",{});var i1=i(wd);pT=o(i1,"span end logits"),i1.forEach(n),uT=o(dl,")."),dl.forEach(n),hT=d(xn),br=a(xn,"P",{});var uu=i(br);mT=o(uu,"The Funnel Transformer model was proposed in "),yr=a(uu,"A",{href:!0,rel:!0});var l1=i(yr);fT=o(l1,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),l1.forEach(n),gT=o(uu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),uu.forEach(n),_T=d(xn),wr=a(xn,"P",{});var hu=i(wr);TT=o(hu,"This model inherits from "),xi=a(hu,"A",{href:!0});var d1=i(xi);kT=o(d1,"PreTrainedModel"),d1.forEach(n),FT=o(hu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),hu.forEach(n),vT=d(xn),$r=a(xn,"P",{});var mu=i($r);bT=o(mu,"This model is also a PyTorch "),Er=a(mu,"A",{href:!0,rel:!0});var c1=i(Er);yT=o(c1,"torch.nn.Module"),c1.forEach(n),wT=o(mu,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),mu.forEach(n),$T=d(xn),Xe=a(xn,"DIV",{class:!0});var jn=i(Xe);v(Mr.$$.fragment,jn),ET=d(jn),yt=a(jn,"P",{});var cl=i(yt);MT=o(cl,"The "),ji=a(cl,"A",{href:!0});var p1=i(ji);zT=o(p1,"FunnelForQuestionAnswering"),p1.forEach(n),qT=o(cl," forward method, overrides the "),$d=a(cl,"CODE",{});var u1=i($d);PT=o(u1,"__call__"),u1.forEach(n),CT=o(cl," special method."),cl.forEach(n),xT=d(jn),v(co.$$.fragment,jn),jT=d(jn),Ed=a(jn,"P",{});var h1=i(Ed);LT=o(h1,"Example:"),h1.forEach(n),OT=d(jn),v(zr.$$.fragment,jn),DT=d(jn),v(qr.$$.fragment,jn),jn.forEach(n),xn.forEach(n),ip=d(s),wt=a(s,"H2",{class:!0});var fu=i(wt);po=a(fu,"A",{id:!0,class:!0,href:!0});var m1=i(po);Md=a(m1,"SPAN",{});var f1=i(Md);v(Pr.$$.fragment,f1),f1.forEach(n),m1.forEach(n),AT=d(fu),zd=a(fu,"SPAN",{});var g1=i(zd);NT=o(g1,"TFFunnelBaseModel"),g1.forEach(n),fu.forEach(n),lp=d(s),Le=a(s,"DIV",{class:!0});var mn=i(Le);v(Cr.$$.fragment,mn),ST=d(mn),qd=a(mn,"P",{});var _1=i(qd);IT=o(_1,`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),_1.forEach(n),WT=d(mn),xr=a(mn,"P",{});var gu=i(xr);BT=o(gu,"The Funnel Transformer model was proposed in "),jr=a(gu,"A",{href:!0,rel:!0});var T1=i(jr);QT=o(T1,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),T1.forEach(n),UT=o(gu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),gu.forEach(n),RT=d(mn),Lr=a(mn,"P",{});var _u=i(Lr);VT=o(_u,"This model inherits from "),Li=a(_u,"A",{href:!0});var k1=i(Li);HT=o(k1,"TFPreTrainedModel"),k1.forEach(n),YT=o(_u,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),_u.forEach(n),KT=d(mn),Or=a(mn,"P",{});var Tu=i(Or);GT=o(Tu,"This model is also a "),Dr=a(Tu,"A",{href:!0,rel:!0});var F1=i(Dr);ZT=o(F1,"tf.keras.Model"),F1.forEach(n),XT=o(Tu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Tu.forEach(n),JT=d(mn),v(uo.$$.fragment,mn),ek=d(mn),cn=a(mn,"DIV",{class:!0});var Hn=i(cn);v(Ar.$$.fragment,Hn),nk=d(Hn),$t=a(Hn,"P",{});var pl=i($t);tk=o(pl,"The "),Oi=a(pl,"A",{href:!0});var v1=i(Oi);ok=o(v1,"TFFunnelBaseModel"),v1.forEach(n),sk=o(pl," forward method, overrides the "),Pd=a(pl,"CODE",{});var b1=i(Pd);rk=o(b1,"__call__"),b1.forEach(n),ak=o(pl," special method."),pl.forEach(n),ik=d(Hn),v(ho.$$.fragment,Hn),lk=d(Hn),Cd=a(Hn,"P",{});var y1=i(Cd);dk=o(y1,"Example:"),y1.forEach(n),ck=d(Hn),v(Nr.$$.fragment,Hn),Hn.forEach(n),mn.forEach(n),dp=d(s),Et=a(s,"H2",{class:!0});var ku=i(Et);mo=a(ku,"A",{id:!0,class:!0,href:!0});var w1=i(mo);xd=a(w1,"SPAN",{});var $1=i(xd);v(Sr.$$.fragment,$1),$1.forEach(n),w1.forEach(n),pk=d(ku),jd=a(ku,"SPAN",{});var E1=i(jd);uk=o(E1,"TFFunnelModel"),E1.forEach(n),ku.forEach(n),cp=d(s),Oe=a(s,"DIV",{class:!0});var fn=i(Oe);v(Ir.$$.fragment,fn),hk=d(fn),Ld=a(fn,"P",{});var M1=i(Ld);mk=o(M1,"The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),M1.forEach(n),fk=d(fn),Wr=a(fn,"P",{});var Fu=i(Wr);gk=o(Fu,"The Funnel Transformer model was proposed in "),Br=a(Fu,"A",{href:!0,rel:!0});var z1=i(Br);_k=o(z1,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),z1.forEach(n),Tk=o(Fu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Fu.forEach(n),kk=d(fn),Qr=a(fn,"P",{});var vu=i(Qr);Fk=o(vu,"This model inherits from "),Di=a(vu,"A",{href:!0});var q1=i(Di);vk=o(q1,"TFPreTrainedModel"),q1.forEach(n),bk=o(vu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),vu.forEach(n),yk=d(fn),Ur=a(fn,"P",{});var bu=i(Ur);wk=o(bu,"This model is also a "),Rr=a(bu,"A",{href:!0,rel:!0});var P1=i(Rr);$k=o(P1,"tf.keras.Model"),P1.forEach(n),Ek=o(bu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),bu.forEach(n),Mk=d(fn),v(fo.$$.fragment,fn),zk=d(fn),pn=a(fn,"DIV",{class:!0});var Yn=i(pn);v(Vr.$$.fragment,Yn),qk=d(Yn),Mt=a(Yn,"P",{});var ul=i(Mt);Pk=o(ul,"The "),Ai=a(ul,"A",{href:!0});var C1=i(Ai);Ck=o(C1,"TFFunnelModel"),C1.forEach(n),xk=o(ul," forward method, overrides the "),Od=a(ul,"CODE",{});var x1=i(Od);jk=o(x1,"__call__"),x1.forEach(n),Lk=o(ul," special method."),ul.forEach(n),Ok=d(Yn),v(go.$$.fragment,Yn),Dk=d(Yn),Dd=a(Yn,"P",{});var j1=i(Dd);Ak=o(j1,"Example:"),j1.forEach(n),Nk=d(Yn),v(Hr.$$.fragment,Yn),Yn.forEach(n),fn.forEach(n),pp=d(s),zt=a(s,"H2",{class:!0});var yu=i(zt);_o=a(yu,"A",{id:!0,class:!0,href:!0});var L1=i(_o);Ad=a(L1,"SPAN",{});var O1=i(Ad);v(Yr.$$.fragment,O1),O1.forEach(n),L1.forEach(n),Sk=d(yu),Nd=a(yu,"SPAN",{});var D1=i(Nd);Ik=o(D1,"TFFunnelModelForPreTraining"),D1.forEach(n),yu.forEach(n),up=d(s),De=a(s,"DIV",{class:!0});var gn=i(De);v(Kr.$$.fragment,gn),Wk=d(gn),Sd=a(gn,"P",{});var A1=i(Sd);Bk=o(A1,"Funnel model with a binary classification head on top as used during pretraining for identifying generated tokens."),A1.forEach(n),Qk=d(gn),Gr=a(gn,"P",{});var wu=i(Gr);Uk=o(wu,"The Funnel Transformer model was proposed in "),Zr=a(wu,"A",{href:!0,rel:!0});var N1=i(Zr);Rk=o(N1,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),N1.forEach(n),Vk=o(wu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),wu.forEach(n),Hk=d(gn),Xr=a(gn,"P",{});var $u=i(Xr);Yk=o($u,"This model inherits from "),Ni=a($u,"A",{href:!0});var S1=i(Ni);Kk=o(S1,"TFPreTrainedModel"),S1.forEach(n),Gk=o($u,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),$u.forEach(n),Zk=d(gn),Jr=a(gn,"P",{});var Eu=i(Jr);Xk=o(Eu,"This model is also a "),ea=a(Eu,"A",{href:!0,rel:!0});var I1=i(ea);Jk=o(I1,"tf.keras.Model"),I1.forEach(n),eF=o(Eu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Eu.forEach(n),nF=d(gn),v(To.$$.fragment,gn),tF=d(gn),un=a(gn,"DIV",{class:!0});var Kn=i(un);v(na.$$.fragment,Kn),oF=d(Kn),qt=a(Kn,"P",{});var hl=i(qt);sF=o(hl,"The "),Si=a(hl,"A",{href:!0});var W1=i(Si);rF=o(W1,"TFFunnelForPreTraining"),W1.forEach(n),aF=o(hl," forward method, overrides the "),Id=a(hl,"CODE",{});var B1=i(Id);iF=o(B1,"__call__"),B1.forEach(n),lF=o(hl," special method."),hl.forEach(n),dF=d(Kn),v(ko.$$.fragment,Kn),cF=d(Kn),Wd=a(Kn,"P",{});var Q1=i(Wd);pF=o(Q1,"Examples:"),Q1.forEach(n),uF=d(Kn),v(ta.$$.fragment,Kn),Kn.forEach(n),gn.forEach(n),hp=d(s),Pt=a(s,"H2",{class:!0});var Mu=i(Pt);Fo=a(Mu,"A",{id:!0,class:!0,href:!0});var U1=i(Fo);Bd=a(U1,"SPAN",{});var R1=i(Bd);v(oa.$$.fragment,R1),R1.forEach(n),U1.forEach(n),hF=d(Mu),Qd=a(Mu,"SPAN",{});var V1=i(Qd);mF=o(V1,"TFFunnelForMaskedLM"),V1.forEach(n),Mu.forEach(n),mp=d(s),Ae=a(s,"DIV",{class:!0});var _n=i(Ae);v(sa.$$.fragment,_n),fF=d(_n),ra=a(_n,"P",{});var zu=i(ra);gF=o(zu,"Funnel Model with a "),Ud=a(zu,"CODE",{});var H1=i(Ud);_F=o(H1,"language modeling"),H1.forEach(n),TF=o(zu," head on top."),zu.forEach(n),kF=d(_n),aa=a(_n,"P",{});var qu=i(aa);FF=o(qu,"The Funnel Transformer model was proposed in "),ia=a(qu,"A",{href:!0,rel:!0});var Y1=i(ia);vF=o(Y1,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Y1.forEach(n),bF=o(qu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),qu.forEach(n),yF=d(_n),la=a(_n,"P",{});var Pu=i(la);wF=o(Pu,"This model inherits from "),Ii=a(Pu,"A",{href:!0});var K1=i(Ii);$F=o(K1,"TFPreTrainedModel"),K1.forEach(n),EF=o(Pu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Pu.forEach(n),MF=d(_n),da=a(_n,"P",{});var Cu=i(da);zF=o(Cu,"This model is also a "),ca=a(Cu,"A",{href:!0,rel:!0});var G1=i(ca);qF=o(G1,"tf.keras.Model"),G1.forEach(n),PF=o(Cu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Cu.forEach(n),CF=d(_n),v(vo.$$.fragment,_n),xF=d(_n),Je=a(_n,"DIV",{class:!0});var Ln=i(Je);v(pa.$$.fragment,Ln),jF=d(Ln),Ct=a(Ln,"P",{});var ml=i(Ct);LF=o(ml,"The "),Wi=a(ml,"A",{href:!0});var Z1=i(Wi);OF=o(Z1,"TFFunnelForMaskedLM"),Z1.forEach(n),DF=o(ml," forward method, overrides the "),Rd=a(ml,"CODE",{});var X1=i(Rd);AF=o(X1,"__call__"),X1.forEach(n),NF=o(ml," special method."),ml.forEach(n),SF=d(Ln),v(bo.$$.fragment,Ln),IF=d(Ln),Vd=a(Ln,"P",{});var J1=i(Vd);WF=o(J1,"Example:"),J1.forEach(n),BF=d(Ln),v(ua.$$.fragment,Ln),QF=d(Ln),v(ha.$$.fragment,Ln),Ln.forEach(n),_n.forEach(n),fp=d(s),xt=a(s,"H2",{class:!0});var xu=i(xt);yo=a(xu,"A",{id:!0,class:!0,href:!0});var e2=i(yo);Hd=a(e2,"SPAN",{});var n2=i(Hd);v(ma.$$.fragment,n2),n2.forEach(n),e2.forEach(n),UF=d(xu),Yd=a(xu,"SPAN",{});var t2=i(Yd);RF=o(t2,"TFFunnelForSequenceClassification"),t2.forEach(n),xu.forEach(n),gp=d(s),Ne=a(s,"DIV",{class:!0});var Tn=i(Ne);v(fa.$$.fragment,Tn),VF=d(Tn),Kd=a(Tn,"P",{});var o2=i(Kd);HF=o(o2,`Funnel Model transformer with a sequence classification/regression head on top (a linear layer on top of the pooled
output) e.g. for GLUE tasks.`),o2.forEach(n),YF=d(Tn),ga=a(Tn,"P",{});var ju=i(ga);KF=o(ju,"The Funnel Transformer model was proposed in "),_a=a(ju,"A",{href:!0,rel:!0});var s2=i(_a);GF=o(s2,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),s2.forEach(n),ZF=o(ju," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),ju.forEach(n),XF=d(Tn),Ta=a(Tn,"P",{});var Lu=i(Ta);JF=o(Lu,"This model inherits from "),Bi=a(Lu,"A",{href:!0});var r2=i(Bi);ev=o(r2,"TFPreTrainedModel"),r2.forEach(n),nv=o(Lu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Lu.forEach(n),tv=d(Tn),ka=a(Tn,"P",{});var Ou=i(ka);ov=o(Ou,"This model is also a "),Fa=a(Ou,"A",{href:!0,rel:!0});var a2=i(Fa);sv=o(a2,"tf.keras.Model"),a2.forEach(n),rv=o(Ou,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Ou.forEach(n),av=d(Tn),v(wo.$$.fragment,Tn),iv=d(Tn),en=a(Tn,"DIV",{class:!0});var On=i(en);v(va.$$.fragment,On),lv=d(On),jt=a(On,"P",{});var fl=i(jt);dv=o(fl,"The "),Qi=a(fl,"A",{href:!0});var i2=i(Qi);cv=o(i2,"TFFunnelForSequenceClassification"),i2.forEach(n),pv=o(fl," forward method, overrides the "),Gd=a(fl,"CODE",{});var l2=i(Gd);uv=o(l2,"__call__"),l2.forEach(n),hv=o(fl," special method."),fl.forEach(n),mv=d(On),v($o.$$.fragment,On),fv=d(On),Zd=a(On,"P",{});var d2=i(Zd);gv=o(d2,"Example:"),d2.forEach(n),_v=d(On),v(ba.$$.fragment,On),Tv=d(On),v(ya.$$.fragment,On),On.forEach(n),Tn.forEach(n),_p=d(s),Lt=a(s,"H2",{class:!0});var Du=i(Lt);Eo=a(Du,"A",{id:!0,class:!0,href:!0});var c2=i(Eo);Xd=a(c2,"SPAN",{});var p2=i(Xd);v(wa.$$.fragment,p2),p2.forEach(n),c2.forEach(n),kv=d(Du),Jd=a(Du,"SPAN",{});var u2=i(Jd);Fv=o(u2,"TFFunnelForMultipleChoice"),u2.forEach(n),Du.forEach(n),Tp=d(s),Se=a(s,"DIV",{class:!0});var kn=i(Se);v($a.$$.fragment,kn),vv=d(kn),ec=a(kn,"P",{});var h2=i(ec);bv=o(h2,`Funnel Model with a multiple choice classification head on top (a linear layer on top of the pooled output and a
softmax) e.g. for RocStories/SWAG tasks.`),h2.forEach(n),yv=d(kn),Ea=a(kn,"P",{});var Au=i(Ea);wv=o(Au,"The Funnel Transformer model was proposed in "),Ma=a(Au,"A",{href:!0,rel:!0});var m2=i(Ma);$v=o(m2,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),m2.forEach(n),Ev=o(Au," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Au.forEach(n),Mv=d(kn),za=a(kn,"P",{});var Nu=i(za);zv=o(Nu,"This model inherits from "),Ui=a(Nu,"A",{href:!0});var f2=i(Ui);qv=o(f2,"TFPreTrainedModel"),f2.forEach(n),Pv=o(Nu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Nu.forEach(n),Cv=d(kn),qa=a(kn,"P",{});var Su=i(qa);xv=o(Su,"This model is also a "),Pa=a(Su,"A",{href:!0,rel:!0});var g2=i(Pa);jv=o(g2,"tf.keras.Model"),g2.forEach(n),Lv=o(Su,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Su.forEach(n),Ov=d(kn),v(Mo.$$.fragment,kn),Dv=d(kn),hn=a(kn,"DIV",{class:!0});var Gn=i(hn);v(Ca.$$.fragment,Gn),Av=d(Gn),Ot=a(Gn,"P",{});var gl=i(Ot);Nv=o(gl,"The "),Ri=a(gl,"A",{href:!0});var _2=i(Ri);Sv=o(_2,"TFFunnelForMultipleChoice"),_2.forEach(n),Iv=o(gl," forward method, overrides the "),nc=a(gl,"CODE",{});var T2=i(nc);Wv=o(T2,"__call__"),T2.forEach(n),Bv=o(gl," special method."),gl.forEach(n),Qv=d(Gn),v(zo.$$.fragment,Gn),Uv=d(Gn),tc=a(Gn,"P",{});var k2=i(tc);Rv=o(k2,"Example:"),k2.forEach(n),Vv=d(Gn),v(xa.$$.fragment,Gn),Gn.forEach(n),kn.forEach(n),kp=d(s),Dt=a(s,"H2",{class:!0});var Iu=i(Dt);qo=a(Iu,"A",{id:!0,class:!0,href:!0});var F2=i(qo);oc=a(F2,"SPAN",{});var v2=i(oc);v(ja.$$.fragment,v2),v2.forEach(n),F2.forEach(n),Hv=d(Iu),sc=a(Iu,"SPAN",{});var b2=i(sc);Yv=o(b2,"TFFunnelForTokenClassification"),b2.forEach(n),Iu.forEach(n),Fp=d(s),Ie=a(s,"DIV",{class:!0});var Fn=i(Ie);v(La.$$.fragment,Fn),Kv=d(Fn),rc=a(Fn,"P",{});var y2=i(rc);Gv=o(y2,`Funnel Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g. for
Named-Entity-Recognition (NER) tasks.`),y2.forEach(n),Zv=d(Fn),Oa=a(Fn,"P",{});var Wu=i(Oa);Xv=o(Wu,"The Funnel Transformer model was proposed in "),Da=a(Wu,"A",{href:!0,rel:!0});var w2=i(Da);Jv=o(w2,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),w2.forEach(n),eb=o(Wu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Wu.forEach(n),nb=d(Fn),Aa=a(Fn,"P",{});var Bu=i(Aa);tb=o(Bu,"This model inherits from "),Vi=a(Bu,"A",{href:!0});var $2=i(Vi);ob=o($2,"TFPreTrainedModel"),$2.forEach(n),sb=o(Bu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Bu.forEach(n),rb=d(Fn),Na=a(Fn,"P",{});var Qu=i(Na);ab=o(Qu,"This model is also a "),Sa=a(Qu,"A",{href:!0,rel:!0});var E2=i(Sa);ib=o(E2,"tf.keras.Model"),E2.forEach(n),lb=o(Qu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Qu.forEach(n),db=d(Fn),v(Po.$$.fragment,Fn),cb=d(Fn),nn=a(Fn,"DIV",{class:!0});var Dn=i(nn);v(Ia.$$.fragment,Dn),pb=d(Dn),At=a(Dn,"P",{});var _l=i(At);ub=o(_l,"The "),Hi=a(_l,"A",{href:!0});var M2=i(Hi);hb=o(M2,"TFFunnelForTokenClassification"),M2.forEach(n),mb=o(_l," forward method, overrides the "),ac=a(_l,"CODE",{});var z2=i(ac);fb=o(z2,"__call__"),z2.forEach(n),gb=o(_l," special method."),_l.forEach(n),_b=d(Dn),v(Co.$$.fragment,Dn),Tb=d(Dn),ic=a(Dn,"P",{});var q2=i(ic);kb=o(q2,"Example:"),q2.forEach(n),Fb=d(Dn),v(Wa.$$.fragment,Dn),vb=d(Dn),v(Ba.$$.fragment,Dn),Dn.forEach(n),Fn.forEach(n),vp=d(s),Nt=a(s,"H2",{class:!0});var Uu=i(Nt);xo=a(Uu,"A",{id:!0,class:!0,href:!0});var P2=i(xo);lc=a(P2,"SPAN",{});var C2=i(lc);v(Qa.$$.fragment,C2),C2.forEach(n),P2.forEach(n),bb=d(Uu),dc=a(Uu,"SPAN",{});var x2=i(dc);yb=o(x2,"TFFunnelForQuestionAnswering"),x2.forEach(n),Uu.forEach(n),bp=d(s),We=a(s,"DIV",{class:!0});var vn=i(We);v(Ua.$$.fragment,vn),wb=d(vn),St=a(vn,"P",{});var Tl=i(St);$b=o(Tl,`Funnel Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear
layers on top of the hidden-states output to compute `),cc=a(Tl,"CODE",{});var j2=i(cc);Eb=o(j2,"span start logits"),j2.forEach(n),Mb=o(Tl," and "),pc=a(Tl,"CODE",{});var L2=i(pc);zb=o(L2,"span end logits"),L2.forEach(n),qb=o(Tl,")."),Tl.forEach(n),Pb=d(vn),Ra=a(vn,"P",{});var Ru=i(Ra);Cb=o(Ru,"The Funnel Transformer model was proposed in "),Va=a(Ru,"A",{href:!0,rel:!0});var O2=i(Va);xb=o(O2,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),O2.forEach(n),jb=o(Ru," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Ru.forEach(n),Lb=d(vn),Ha=a(vn,"P",{});var Vu=i(Ha);Ob=o(Vu,"This model inherits from "),Yi=a(Vu,"A",{href:!0});var D2=i(Yi);Db=o(D2,"TFPreTrainedModel"),D2.forEach(n),Ab=o(Vu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Vu.forEach(n),Nb=d(vn),Ya=a(vn,"P",{});var Hu=i(Ya);Sb=o(Hu,"This model is also a "),Ka=a(Hu,"A",{href:!0,rel:!0});var A2=i(Ka);Ib=o(A2,"tf.keras.Model"),A2.forEach(n),Wb=o(Hu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Hu.forEach(n),Bb=d(vn),v(jo.$$.fragment,vn),Qb=d(vn),tn=a(vn,"DIV",{class:!0});var An=i(tn);v(Ga.$$.fragment,An),Ub=d(An),It=a(An,"P",{});var kl=i(It);Rb=o(kl,"The "),Ki=a(kl,"A",{href:!0});var N2=i(Ki);Vb=o(N2,"TFFunnelForQuestionAnswering"),N2.forEach(n),Hb=o(kl," forward method, overrides the "),uc=a(kl,"CODE",{});var S2=i(uc);Yb=o(S2,"__call__"),S2.forEach(n),Kb=o(kl," special method."),kl.forEach(n),Gb=d(An),v(Lo.$$.fragment,An),Zb=d(An),hc=a(An,"P",{});var I2=i(hc);Xb=o(I2,"Example:"),I2.forEach(n),Jb=d(An),v(Za.$$.fragment,An),ey=d(An),v(Xa.$$.fragment,An),An.forEach(n),vn.forEach(n),this.h()},h(){c(u,"name","hf:doc:metadata"),c(u,"content",JSON.stringify(_$)),c(_,"id","funnel-transformer"),c(_,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(_,"href","#funnel-transformer"),c(g,"class","relative group"),c(J,"id","overview"),c(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(J,"href","#overview"),c(q,"class","relative group"),c(te,"href","https://arxiv.org/abs/2006.03236"),c(te,"rel","nofollow"),c(re,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelModel"),c(p,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(Te,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForMaskedLM"),c(ke,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForTokenClassification"),c(Fe,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelBaseModel"),c(ve,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForSequenceClassification"),c(oi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForMultipleChoice"),c(No,"href","https://huggingface.co/sgugger"),c(No,"rel","nofollow"),c(So,"href","https://github.com/laiguokun/Funnel-Transformer"),c(So,"rel","nofollow"),c(Wt,"id","transformers.FunnelConfig"),c(Wt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Wt,"href","#transformers.FunnelConfig"),c(Zn,"class","relative group"),c(si,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelModel"),c(ri,"href","/docs/transformers/main/en/model_doc/bert#transformers.TFBertModel"),c(Bo,"href","https://huggingface.co/funnel-transformer/small"),c(Bo,"rel","nofollow"),c(ai,"href","/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig"),c(ii,"href","/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig"),c(Nn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Bt,"id","transformers.FunnelTokenizer"),c(Bt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Bt,"href","#transformers.FunnelTokenizer"),c(Jn,"class","relative group"),c(li,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer"),c(di,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer"),c(ci,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer"),c(Wn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ut,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(bn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(hi,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(xe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Rt,"id","transformers.FunnelTokenizerFast"),c(Rt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Rt,"href","#transformers.FunnelTokenizerFast"),c(nt,"class","relative group"),c(mi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizerFast"),c(fi,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizerFast"),c(gi,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizerFast"),c(yn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(sn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ht,"id","transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"),c(Ht,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Ht,"href","#transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"),c(ot,"class","relative group"),c(_i,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(st,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ti,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(rt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Yt,"id","transformers.FunnelBaseModel"),c(Yt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Yt,"href","#transformers.FunnelBaseModel"),c(at,"class","relative group"),c(hs,"href","https://arxiv.org/abs/2006.03236"),c(hs,"rel","nofollow"),c(ki,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c(gs,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(gs,"rel","nofollow"),c(Fi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelBaseModel"),c(rn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Qe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Gt,"id","transformers.FunnelModel"),c(Gt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Gt,"href","#transformers.FunnelModel"),c(lt,"class","relative group"),c(bs,"href","https://arxiv.org/abs/2006.03236"),c(bs,"rel","nofollow"),c(vi,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c($s,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c($s,"rel","nofollow"),c(bi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelModel"),c(an,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Xt,"id","transformers.FunnelForPreTraining"),c(Xt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Xt,"href","#transformers.FunnelForPreTraining"),c(ct,"class","relative group"),c(yi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(ln,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(pt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(eo,"id","transformers.FunnelForMaskedLM"),c(eo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(eo,"href","#transformers.FunnelForMaskedLM"),c(ht,"class","relative group"),c(Ds,"href","https://arxiv.org/abs/2006.03236"),c(Ds,"rel","nofollow"),c(wi,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c(Ss,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Ss,"rel","nofollow"),c($i,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForMaskedLM"),c(Ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(to,"id","transformers.FunnelForSequenceClassification"),c(to,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(to,"href","#transformers.FunnelForSequenceClassification"),c(ft,"class","relative group"),c(Vs,"href","https://arxiv.org/abs/2006.03236"),c(Vs,"rel","nofollow"),c(Ei,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c(Ks,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Ks,"rel","nofollow"),c(Mi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForSequenceClassification"),c(Pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(so,"id","transformers.FunnelForMultipleChoice"),c(so,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(so,"href","#transformers.FunnelForMultipleChoice"),c(_t,"class","relative group"),c(sr,"href","https://arxiv.org/abs/2006.03236"),c(sr,"rel","nofollow"),c(zi,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c(ir,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(ir,"rel","nofollow"),c(qi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForMultipleChoice"),c(dn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(He,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(ao,"id","transformers.FunnelForTokenClassification"),c(ao,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ao,"href","#transformers.FunnelForTokenClassification"),c(kt,"class","relative group"),c(hr,"href","https://arxiv.org/abs/2006.03236"),c(hr,"rel","nofollow"),c(Pi,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c(gr,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(gr,"rel","nofollow"),c(Ci,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForTokenClassification"),c(Ze,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ye,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(lo,"id","transformers.FunnelForQuestionAnswering"),c(lo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(lo,"href","#transformers.FunnelForQuestionAnswering"),c(vt,"class","relative group"),c(yr,"href","https://arxiv.org/abs/2006.03236"),c(yr,"rel","nofollow"),c(xi,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c(Er,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Er,"rel","nofollow"),c(ji,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForQuestionAnswering"),c(Xe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ke,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(po,"id","transformers.TFFunnelBaseModel"),c(po,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(po,"href","#transformers.TFFunnelBaseModel"),c(wt,"class","relative group"),c(jr,"href","https://arxiv.org/abs/2006.03236"),c(jr,"rel","nofollow"),c(Li,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(Dr,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Dr,"rel","nofollow"),c(Oi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelBaseModel"),c(cn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(mo,"id","transformers.TFFunnelModel"),c(mo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(mo,"href","#transformers.TFFunnelModel"),c(Et,"class","relative group"),c(Br,"href","https://arxiv.org/abs/2006.03236"),c(Br,"rel","nofollow"),c(Di,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(Rr,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Rr,"rel","nofollow"),c(Ai,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelModel"),c(pn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(_o,"id","transformers.TFFunnelForPreTraining"),c(_o,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(_o,"href","#transformers.TFFunnelForPreTraining"),c(zt,"class","relative group"),c(Zr,"href","https://arxiv.org/abs/2006.03236"),c(Zr,"rel","nofollow"),c(Ni,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(ea,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(ea,"rel","nofollow"),c(Si,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelForPreTraining"),c(un,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(De,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Fo,"id","transformers.TFFunnelForMaskedLM"),c(Fo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Fo,"href","#transformers.TFFunnelForMaskedLM"),c(Pt,"class","relative group"),c(ia,"href","https://arxiv.org/abs/2006.03236"),c(ia,"rel","nofollow"),c(Ii,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(ca,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(ca,"rel","nofollow"),c(Wi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelForMaskedLM"),c(Je,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(yo,"id","transformers.TFFunnelForSequenceClassification"),c(yo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(yo,"href","#transformers.TFFunnelForSequenceClassification"),c(xt,"class","relative group"),c(_a,"href","https://arxiv.org/abs/2006.03236"),c(_a,"rel","nofollow"),c(Bi,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(Fa,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Fa,"rel","nofollow"),c(Qi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelForSequenceClassification"),c(en,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Eo,"id","transformers.TFFunnelForMultipleChoice"),c(Eo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Eo,"href","#transformers.TFFunnelForMultipleChoice"),c(Lt,"class","relative group"),c(Ma,"href","https://arxiv.org/abs/2006.03236"),c(Ma,"rel","nofollow"),c(Ui,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(Pa,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Pa,"rel","nofollow"),c(Ri,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelForMultipleChoice"),c(hn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(qo,"id","transformers.TFFunnelForTokenClassification"),c(qo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(qo,"href","#transformers.TFFunnelForTokenClassification"),c(Dt,"class","relative group"),c(Da,"href","https://arxiv.org/abs/2006.03236"),c(Da,"rel","nofollow"),c(Vi,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(Sa,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Sa,"rel","nofollow"),c(Hi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelForTokenClassification"),c(nn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(xo,"id","transformers.TFFunnelForQuestionAnswering"),c(xo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(xo,"href","#transformers.TFFunnelForQuestionAnswering"),c(Nt,"class","relative group"),c(Va,"href","https://arxiv.org/abs/2006.03236"),c(Va,"rel","nofollow"),c(Yi,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(Ka,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Ka,"rel","nofollow"),c(Ki,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelForQuestionAnswering"),c(tn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(We,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(s,m){e(document.head,u),h(s,z,m),h(s,g,m),e(g,_),e(_,k),b(T,k,null),e(g,f),e(g,M),e(M,ce),h(s,K,m),h(s,q,m),e(q,J),e(J,A),b(ne,A,null),e(q,pe),e(q,N),e(N,ue),h(s,ie,m),h(s,Y,m),e(Y,L),e(Y,te),e(te,G),e(Y,P),h(s,x,m),h(s,oe,m),e(oe,B),h(s,le,m),h(s,se,m),e(se,S),e(S,he),h(s,de,m),h(s,C,m),e(C,me),h(s,W,m),h(s,ee,m),e(ee,ae),e(ae,Q),e(ee,fe),e(ee,I),e(I,O),e(I,re),e(re,U),e(I,ge),e(I,p),e(p,E),e(I,Z),e(I,Te),e(Te,ye),e(I,D),e(I,ke),e(ke,we),e(I,$e),e(I,j),e(j,R),e(I,Ee),e(I,Fe),e(Fe,V),e(I,Me),e(I,ve),e(ve,_e),e(I,ze),e(I,oi),e(oi,Yu),e(I,Ku),h(s,Oc,m),h(s,In,m),e(In,Gu),e(In,No),e(No,Zu),e(In,Xu),e(In,So),e(So,Ju),e(In,eh),h(s,Dc,m),h(s,Zn,m),e(Zn,Wt),e(Wt,Fl),b(Io,Fl,null),e(Zn,nh),e(Zn,vl),e(vl,th),h(s,Ac,m),h(s,Nn,m),b(Wo,Nn,null),e(Nn,oh),e(Nn,Sn),e(Sn,sh),e(Sn,si),e(si,rh),e(Sn,ah),e(Sn,ri),e(ri,ih),e(Sn,lh),e(Sn,Bo),e(Bo,dh),e(Sn,ch),e(Nn,ph),e(Nn,Xn),e(Xn,uh),e(Xn,ai),e(ai,hh),e(Xn,mh),e(Xn,ii),e(ii,fh),e(Xn,gh),h(s,Nc,m),h(s,Jn,m),e(Jn,Bt),e(Bt,bl),b(Qo,bl,null),e(Jn,_h),e(Jn,yl),e(yl,Th),h(s,Sc,m),h(s,xe,m),b(Uo,xe,null),e(xe,kh),e(xe,wl),e(wl,Fh),e(xe,vh),e(xe,Qt),e(Qt,li),e(li,bh),e(Qt,yh),e(Qt,di),e(di,wh),e(Qt,$h),e(xe,Eh),e(xe,Ro),e(Ro,Mh),e(Ro,ci),e(ci,zh),e(Ro,qh),e(xe,Ph),e(xe,Wn),b(Vo,Wn,null),e(Wn,Ch),e(Wn,$l),e($l,xh),e(Wn,jh),e(Wn,Ho),e(Ho,pi),e(pi,Lh),e(pi,El),e(El,Oh),e(Ho,Dh),e(Ho,ui),e(ui,Ah),e(ui,Ml),e(Ml,Nh),e(xe,Sh),e(xe,Ut),b(Yo,Ut,null),e(Ut,Ih),e(Ut,Ko),e(Ko,Wh),e(Ko,zl),e(zl,Bh),e(Ko,Qh),e(xe,Uh),e(xe,bn),b(Go,bn,null),e(bn,Rh),e(bn,ql),e(ql,Vh),e(bn,Hh),b(Zo,bn,null),e(bn,Yh),e(bn,et),e(et,Kh),e(et,Pl),e(Pl,Gh),e(et,Zh),e(et,Cl),e(Cl,Xh),e(et,Jh),e(xe,em),e(xe,hi),b(Xo,hi,null),h(s,Ic,m),h(s,nt,m),e(nt,Rt),e(Rt,xl),b(Jo,xl,null),e(nt,nm),e(nt,jl),e(jl,tm),h(s,Wc,m),h(s,sn,m),b(es,sn,null),e(sn,om),e(sn,ns),e(ns,sm),e(ns,Ll),e(Ll,rm),e(ns,am),e(sn,im),e(sn,Vt),e(Vt,mi),e(mi,lm),e(Vt,dm),e(Vt,fi),e(fi,cm),e(Vt,pm),e(sn,um),e(sn,ts),e(ts,hm),e(ts,gi),e(gi,mm),e(ts,fm),e(sn,gm),e(sn,yn),b(os,yn,null),e(yn,_m),e(yn,Ol),e(Ol,Tm),e(yn,km),b(ss,yn,null),e(yn,Fm),e(yn,tt),e(tt,vm),e(tt,Dl),e(Dl,bm),e(tt,ym),e(tt,Al),e(Al,wm),e(tt,$m),h(s,Bc,m),h(s,ot,m),e(ot,Ht),e(Ht,Nl),b(rs,Nl,null),e(ot,Em),e(ot,Sl),e(Sl,Mm),h(s,Qc,m),h(s,st,m),b(as,st,null),e(st,zm),e(st,is),e(is,qm),e(is,_i),e(_i,Pm),e(is,Cm),h(s,Uc,m),h(s,rt,m),b(ls,rt,null),e(rt,xm),e(rt,ds),e(ds,jm),e(ds,Ti),e(Ti,Lm),e(ds,Om),h(s,Rc,m),h(s,at,m),e(at,Yt),e(Yt,Il),b(cs,Il,null),e(at,Dm),e(at,Wl),e(Wl,Am),h(s,Vc,m),h(s,Qe,m),b(ps,Qe,null),e(Qe,Nm),e(Qe,Bl),e(Bl,Sm),e(Qe,Im),e(Qe,us),e(us,Wm),e(us,hs),e(hs,Bm),e(us,Qm),e(Qe,Um),e(Qe,ms),e(ms,Rm),e(ms,ki),e(ki,Vm),e(ms,Hm),e(Qe,Ym),e(Qe,fs),e(fs,Km),e(fs,gs),e(gs,Gm),e(fs,Zm),e(Qe,Xm),e(Qe,rn),b(_s,rn,null),e(rn,Jm),e(rn,it),e(it,ef),e(it,Fi),e(Fi,nf),e(it,tf),e(it,Ql),e(Ql,of),e(it,sf),e(rn,rf),b(Kt,rn,null),e(rn,af),e(rn,Ul),e(Ul,lf),e(rn,df),b(Ts,rn,null),h(s,Hc,m),h(s,lt,m),e(lt,Gt),e(Gt,Rl),b(ks,Rl,null),e(lt,cf),e(lt,Vl),e(Vl,pf),h(s,Yc,m),h(s,Ue,m),b(Fs,Ue,null),e(Ue,uf),e(Ue,Hl),e(Hl,hf),e(Ue,mf),e(Ue,vs),e(vs,ff),e(vs,bs),e(bs,gf),e(vs,_f),e(Ue,Tf),e(Ue,ys),e(ys,kf),e(ys,vi),e(vi,Ff),e(ys,vf),e(Ue,bf),e(Ue,ws),e(ws,yf),e(ws,$s),e($s,wf),e(ws,$f),e(Ue,Ef),e(Ue,an),b(Es,an,null),e(an,Mf),e(an,dt),e(dt,zf),e(dt,bi),e(bi,qf),e(dt,Pf),e(dt,Yl),e(Yl,Cf),e(dt,xf),e(an,jf),b(Zt,an,null),e(an,Lf),e(an,Kl),e(Kl,Of),e(an,Df),b(Ms,an,null),h(s,Kc,m),h(s,ct,m),e(ct,Xt),e(Xt,Gl),b(zs,Gl,null),e(ct,Af),e(ct,Zl),e(Zl,Nf),h(s,Gc,m),h(s,pt,m),b(qs,pt,null),e(pt,Sf),e(pt,ln),b(Ps,ln,null),e(ln,If),e(ln,ut),e(ut,Wf),e(ut,yi),e(yi,Bf),e(ut,Qf),e(ut,Xl),e(Xl,Uf),e(ut,Rf),e(ln,Vf),b(Jt,ln,null),e(ln,Hf),e(ln,Jl),e(Jl,Yf),e(ln,Kf),b(Cs,ln,null),h(s,Zc,m),h(s,ht,m),e(ht,eo),e(eo,ed),b(xs,ed,null),e(ht,Gf),e(ht,nd),e(nd,Zf),h(s,Xc,m),h(s,Re,m),b(js,Re,null),e(Re,Xf),e(Re,Ls),e(Ls,Jf),e(Ls,td),e(td,eg),e(Ls,ng),e(Re,tg),e(Re,Os),e(Os,og),e(Os,Ds),e(Ds,sg),e(Os,rg),e(Re,ag),e(Re,As),e(As,ig),e(As,wi),e(wi,lg),e(As,dg),e(Re,cg),e(Re,Ns),e(Ns,pg),e(Ns,Ss),e(Ss,ug),e(Ns,hg),e(Re,mg),e(Re,Ge),b(Is,Ge,null),e(Ge,fg),e(Ge,mt),e(mt,gg),e(mt,$i),e($i,_g),e(mt,Tg),e(mt,od),e(od,kg),e(mt,Fg),e(Ge,vg),b(no,Ge,null),e(Ge,bg),e(Ge,sd),e(sd,yg),e(Ge,wg),b(Ws,Ge,null),e(Ge,$g),b(Bs,Ge,null),h(s,Jc,m),h(s,ft,m),e(ft,to),e(to,rd),b(Qs,rd,null),e(ft,Eg),e(ft,ad),e(ad,Mg),h(s,ep,m),h(s,Ve,m),b(Us,Ve,null),e(Ve,zg),e(Ve,id),e(id,qg),e(Ve,Pg),e(Ve,Rs),e(Rs,Cg),e(Rs,Vs),e(Vs,xg),e(Rs,jg),e(Ve,Lg),e(Ve,Hs),e(Hs,Og),e(Hs,Ei),e(Ei,Dg),e(Hs,Ag),e(Ve,Ng),e(Ve,Ys),e(Ys,Sg),e(Ys,Ks),e(Ks,Ig),e(Ys,Wg),e(Ve,Bg),e(Ve,Pe),b(Gs,Pe,null),e(Pe,Qg),e(Pe,gt),e(gt,Ug),e(gt,Mi),e(Mi,Rg),e(gt,Vg),e(gt,ld),e(ld,Hg),e(gt,Yg),e(Pe,Kg),b(oo,Pe,null),e(Pe,Gg),e(Pe,dd),e(dd,Zg),e(Pe,Xg),b(Zs,Pe,null),e(Pe,Jg),b(Xs,Pe,null),e(Pe,e_),e(Pe,cd),e(cd,n_),e(Pe,t_),b(Js,Pe,null),e(Pe,o_),b(er,Pe,null),h(s,np,m),h(s,_t,m),e(_t,so),e(so,pd),b(nr,pd,null),e(_t,s_),e(_t,ud),e(ud,r_),h(s,tp,m),h(s,He,m),b(tr,He,null),e(He,a_),e(He,hd),e(hd,i_),e(He,l_),e(He,or),e(or,d_),e(or,sr),e(sr,c_),e(or,p_),e(He,u_),e(He,rr),e(rr,h_),e(rr,zi),e(zi,m_),e(rr,f_),e(He,g_),e(He,ar),e(ar,__),e(ar,ir),e(ir,T_),e(ar,k_),e(He,F_),e(He,dn),b(lr,dn,null),e(dn,v_),e(dn,Tt),e(Tt,b_),e(Tt,qi),e(qi,y_),e(Tt,w_),e(Tt,md),e(md,$_),e(Tt,E_),e(dn,M_),b(ro,dn,null),e(dn,z_),e(dn,fd),e(fd,q_),e(dn,P_),b(dr,dn,null),h(s,op,m),h(s,kt,m),e(kt,ao),e(ao,gd),b(cr,gd,null),e(kt,C_),e(kt,_d),e(_d,x_),h(s,sp,m),h(s,Ye,m),b(pr,Ye,null),e(Ye,j_),e(Ye,Td),e(Td,L_),e(Ye,O_),e(Ye,ur),e(ur,D_),e(ur,hr),e(hr,A_),e(ur,N_),e(Ye,S_),e(Ye,mr),e(mr,I_),e(mr,Pi),e(Pi,W_),e(mr,B_),e(Ye,Q_),e(Ye,fr),e(fr,U_),e(fr,gr),e(gr,R_),e(fr,V_),e(Ye,H_),e(Ye,Ze),b(_r,Ze,null),e(Ze,Y_),e(Ze,Ft),e(Ft,K_),e(Ft,Ci),e(Ci,G_),e(Ft,Z_),e(Ft,kd),e(kd,X_),e(Ft,J_),e(Ze,eT),b(io,Ze,null),e(Ze,nT),e(Ze,Fd),e(Fd,tT),e(Ze,oT),b(Tr,Ze,null),e(Ze,sT),b(kr,Ze,null),h(s,rp,m),h(s,vt,m),e(vt,lo),e(lo,vd),b(Fr,vd,null),e(vt,rT),e(vt,bd),e(bd,aT),h(s,ap,m),h(s,Ke,m),b(vr,Ke,null),e(Ke,iT),e(Ke,bt),e(bt,lT),e(bt,yd),e(yd,dT),e(bt,cT),e(bt,wd),e(wd,pT),e(bt,uT),e(Ke,hT),e(Ke,br),e(br,mT),e(br,yr),e(yr,fT),e(br,gT),e(Ke,_T),e(Ke,wr),e(wr,TT),e(wr,xi),e(xi,kT),e(wr,FT),e(Ke,vT),e(Ke,$r),e($r,bT),e($r,Er),e(Er,yT),e($r,wT),e(Ke,$T),e(Ke,Xe),b(Mr,Xe,null),e(Xe,ET),e(Xe,yt),e(yt,MT),e(yt,ji),e(ji,zT),e(yt,qT),e(yt,$d),e($d,PT),e(yt,CT),e(Xe,xT),b(co,Xe,null),e(Xe,jT),e(Xe,Ed),e(Ed,LT),e(Xe,OT),b(zr,Xe,null),e(Xe,DT),b(qr,Xe,null),h(s,ip,m),h(s,wt,m),e(wt,po),e(po,Md),b(Pr,Md,null),e(wt,AT),e(wt,zd),e(zd,NT),h(s,lp,m),h(s,Le,m),b(Cr,Le,null),e(Le,ST),e(Le,qd),e(qd,IT),e(Le,WT),e(Le,xr),e(xr,BT),e(xr,jr),e(jr,QT),e(xr,UT),e(Le,RT),e(Le,Lr),e(Lr,VT),e(Lr,Li),e(Li,HT),e(Lr,YT),e(Le,KT),e(Le,Or),e(Or,GT),e(Or,Dr),e(Dr,ZT),e(Or,XT),e(Le,JT),b(uo,Le,null),e(Le,ek),e(Le,cn),b(Ar,cn,null),e(cn,nk),e(cn,$t),e($t,tk),e($t,Oi),e(Oi,ok),e($t,sk),e($t,Pd),e(Pd,rk),e($t,ak),e(cn,ik),b(ho,cn,null),e(cn,lk),e(cn,Cd),e(Cd,dk),e(cn,ck),b(Nr,cn,null),h(s,dp,m),h(s,Et,m),e(Et,mo),e(mo,xd),b(Sr,xd,null),e(Et,pk),e(Et,jd),e(jd,uk),h(s,cp,m),h(s,Oe,m),b(Ir,Oe,null),e(Oe,hk),e(Oe,Ld),e(Ld,mk),e(Oe,fk),e(Oe,Wr),e(Wr,gk),e(Wr,Br),e(Br,_k),e(Wr,Tk),e(Oe,kk),e(Oe,Qr),e(Qr,Fk),e(Qr,Di),e(Di,vk),e(Qr,bk),e(Oe,yk),e(Oe,Ur),e(Ur,wk),e(Ur,Rr),e(Rr,$k),e(Ur,Ek),e(Oe,Mk),b(fo,Oe,null),e(Oe,zk),e(Oe,pn),b(Vr,pn,null),e(pn,qk),e(pn,Mt),e(Mt,Pk),e(Mt,Ai),e(Ai,Ck),e(Mt,xk),e(Mt,Od),e(Od,jk),e(Mt,Lk),e(pn,Ok),b(go,pn,null),e(pn,Dk),e(pn,Dd),e(Dd,Ak),e(pn,Nk),b(Hr,pn,null),h(s,pp,m),h(s,zt,m),e(zt,_o),e(_o,Ad),b(Yr,Ad,null),e(zt,Sk),e(zt,Nd),e(Nd,Ik),h(s,up,m),h(s,De,m),b(Kr,De,null),e(De,Wk),e(De,Sd),e(Sd,Bk),e(De,Qk),e(De,Gr),e(Gr,Uk),e(Gr,Zr),e(Zr,Rk),e(Gr,Vk),e(De,Hk),e(De,Xr),e(Xr,Yk),e(Xr,Ni),e(Ni,Kk),e(Xr,Gk),e(De,Zk),e(De,Jr),e(Jr,Xk),e(Jr,ea),e(ea,Jk),e(Jr,eF),e(De,nF),b(To,De,null),e(De,tF),e(De,un),b(na,un,null),e(un,oF),e(un,qt),e(qt,sF),e(qt,Si),e(Si,rF),e(qt,aF),e(qt,Id),e(Id,iF),e(qt,lF),e(un,dF),b(ko,un,null),e(un,cF),e(un,Wd),e(Wd,pF),e(un,uF),b(ta,un,null),h(s,hp,m),h(s,Pt,m),e(Pt,Fo),e(Fo,Bd),b(oa,Bd,null),e(Pt,hF),e(Pt,Qd),e(Qd,mF),h(s,mp,m),h(s,Ae,m),b(sa,Ae,null),e(Ae,fF),e(Ae,ra),e(ra,gF),e(ra,Ud),e(Ud,_F),e(ra,TF),e(Ae,kF),e(Ae,aa),e(aa,FF),e(aa,ia),e(ia,vF),e(aa,bF),e(Ae,yF),e(Ae,la),e(la,wF),e(la,Ii),e(Ii,$F),e(la,EF),e(Ae,MF),e(Ae,da),e(da,zF),e(da,ca),e(ca,qF),e(da,PF),e(Ae,CF),b(vo,Ae,null),e(Ae,xF),e(Ae,Je),b(pa,Je,null),e(Je,jF),e(Je,Ct),e(Ct,LF),e(Ct,Wi),e(Wi,OF),e(Ct,DF),e(Ct,Rd),e(Rd,AF),e(Ct,NF),e(Je,SF),b(bo,Je,null),e(Je,IF),e(Je,Vd),e(Vd,WF),e(Je,BF),b(ua,Je,null),e(Je,QF),b(ha,Je,null),h(s,fp,m),h(s,xt,m),e(xt,yo),e(yo,Hd),b(ma,Hd,null),e(xt,UF),e(xt,Yd),e(Yd,RF),h(s,gp,m),h(s,Ne,m),b(fa,Ne,null),e(Ne,VF),e(Ne,Kd),e(Kd,HF),e(Ne,YF),e(Ne,ga),e(ga,KF),e(ga,_a),e(_a,GF),e(ga,ZF),e(Ne,XF),e(Ne,Ta),e(Ta,JF),e(Ta,Bi),e(Bi,ev),e(Ta,nv),e(Ne,tv),e(Ne,ka),e(ka,ov),e(ka,Fa),e(Fa,sv),e(ka,rv),e(Ne,av),b(wo,Ne,null),e(Ne,iv),e(Ne,en),b(va,en,null),e(en,lv),e(en,jt),e(jt,dv),e(jt,Qi),e(Qi,cv),e(jt,pv),e(jt,Gd),e(Gd,uv),e(jt,hv),e(en,mv),b($o,en,null),e(en,fv),e(en,Zd),e(Zd,gv),e(en,_v),b(ba,en,null),e(en,Tv),b(ya,en,null),h(s,_p,m),h(s,Lt,m),e(Lt,Eo),e(Eo,Xd),b(wa,Xd,null),e(Lt,kv),e(Lt,Jd),e(Jd,Fv),h(s,Tp,m),h(s,Se,m),b($a,Se,null),e(Se,vv),e(Se,ec),e(ec,bv),e(Se,yv),e(Se,Ea),e(Ea,wv),e(Ea,Ma),e(Ma,$v),e(Ea,Ev),e(Se,Mv),e(Se,za),e(za,zv),e(za,Ui),e(Ui,qv),e(za,Pv),e(Se,Cv),e(Se,qa),e(qa,xv),e(qa,Pa),e(Pa,jv),e(qa,Lv),e(Se,Ov),b(Mo,Se,null),e(Se,Dv),e(Se,hn),b(Ca,hn,null),e(hn,Av),e(hn,Ot),e(Ot,Nv),e(Ot,Ri),e(Ri,Sv),e(Ot,Iv),e(Ot,nc),e(nc,Wv),e(Ot,Bv),e(hn,Qv),b(zo,hn,null),e(hn,Uv),e(hn,tc),e(tc,Rv),e(hn,Vv),b(xa,hn,null),h(s,kp,m),h(s,Dt,m),e(Dt,qo),e(qo,oc),b(ja,oc,null),e(Dt,Hv),e(Dt,sc),e(sc,Yv),h(s,Fp,m),h(s,Ie,m),b(La,Ie,null),e(Ie,Kv),e(Ie,rc),e(rc,Gv),e(Ie,Zv),e(Ie,Oa),e(Oa,Xv),e(Oa,Da),e(Da,Jv),e(Oa,eb),e(Ie,nb),e(Ie,Aa),e(Aa,tb),e(Aa,Vi),e(Vi,ob),e(Aa,sb),e(Ie,rb),e(Ie,Na),e(Na,ab),e(Na,Sa),e(Sa,ib),e(Na,lb),e(Ie,db),b(Po,Ie,null),e(Ie,cb),e(Ie,nn),b(Ia,nn,null),e(nn,pb),e(nn,At),e(At,ub),e(At,Hi),e(Hi,hb),e(At,mb),e(At,ac),e(ac,fb),e(At,gb),e(nn,_b),b(Co,nn,null),e(nn,Tb),e(nn,ic),e(ic,kb),e(nn,Fb),b(Wa,nn,null),e(nn,vb),b(Ba,nn,null),h(s,vp,m),h(s,Nt,m),e(Nt,xo),e(xo,lc),b(Qa,lc,null),e(Nt,bb),e(Nt,dc),e(dc,yb),h(s,bp,m),h(s,We,m),b(Ua,We,null),e(We,wb),e(We,St),e(St,$b),e(St,cc),e(cc,Eb),e(St,Mb),e(St,pc),e(pc,zb),e(St,qb),e(We,Pb),e(We,Ra),e(Ra,Cb),e(Ra,Va),e(Va,xb),e(Ra,jb),e(We,Lb),e(We,Ha),e(Ha,Ob),e(Ha,Yi),e(Yi,Db),e(Ha,Ab),e(We,Nb),e(We,Ya),e(Ya,Sb),e(Ya,Ka),e(Ka,Ib),e(Ya,Wb),e(We,Bb),b(jo,We,null),e(We,Qb),e(We,tn),b(Ga,tn,null),e(tn,Ub),e(tn,It),e(It,Rb),e(It,Ki),e(Ki,Vb),e(It,Hb),e(It,uc),e(uc,Yb),e(It,Kb),e(tn,Gb),b(Lo,tn,null),e(tn,Zb),e(tn,hc),e(hc,Xb),e(tn,Jb),b(Za,tn,null),e(tn,ey),b(Xa,tn,null),yp=!0},p(s,[m]){const Ja={};m&2&&(Ja.$$scope={dirty:m,ctx:s}),Kt.$set(Ja);const mc={};m&2&&(mc.$$scope={dirty:m,ctx:s}),Zt.$set(mc);const fc={};m&2&&(fc.$$scope={dirty:m,ctx:s}),Jt.$set(fc);const gc={};m&2&&(gc.$$scope={dirty:m,ctx:s}),no.$set(gc);const ei={};m&2&&(ei.$$scope={dirty:m,ctx:s}),oo.$set(ei);const _c={};m&2&&(_c.$$scope={dirty:m,ctx:s}),ro.$set(_c);const Tc={};m&2&&(Tc.$$scope={dirty:m,ctx:s}),io.$set(Tc);const kc={};m&2&&(kc.$$scope={dirty:m,ctx:s}),co.$set(kc);const ni={};m&2&&(ni.$$scope={dirty:m,ctx:s}),uo.$set(ni);const Fc={};m&2&&(Fc.$$scope={dirty:m,ctx:s}),ho.$set(Fc);const vc={};m&2&&(vc.$$scope={dirty:m,ctx:s}),fo.$set(vc);const bc={};m&2&&(bc.$$scope={dirty:m,ctx:s}),go.$set(bc);const yc={};m&2&&(yc.$$scope={dirty:m,ctx:s}),To.$set(yc);const wc={};m&2&&(wc.$$scope={dirty:m,ctx:s}),ko.$set(wc);const ti={};m&2&&(ti.$$scope={dirty:m,ctx:s}),vo.$set(ti);const $c={};m&2&&($c.$$scope={dirty:m,ctx:s}),bo.$set($c);const je={};m&2&&(je.$$scope={dirty:m,ctx:s}),wo.$set(je);const Ec={};m&2&&(Ec.$$scope={dirty:m,ctx:s}),$o.$set(Ec);const Mc={};m&2&&(Mc.$$scope={dirty:m,ctx:s}),Mo.$set(Mc);const zc={};m&2&&(zc.$$scope={dirty:m,ctx:s}),zo.$set(zc);const qc={};m&2&&(qc.$$scope={dirty:m,ctx:s}),Po.$set(qc);const Pc={};m&2&&(Pc.$$scope={dirty:m,ctx:s}),Co.$set(Pc);const Cc={};m&2&&(Cc.$$scope={dirty:m,ctx:s}),jo.$set(Cc);const xc={};m&2&&(xc.$$scope={dirty:m,ctx:s}),Lo.$set(xc)},i(s){yp||(y(T.$$.fragment,s),y(ne.$$.fragment,s),y(Io.$$.fragment,s),y(Wo.$$.fragment,s),y(Qo.$$.fragment,s),y(Uo.$$.fragment,s),y(Vo.$$.fragment,s),y(Yo.$$.fragment,s),y(Go.$$.fragment,s),y(Zo.$$.fragment,s),y(Xo.$$.fragment,s),y(Jo.$$.fragment,s),y(es.$$.fragment,s),y(os.$$.fragment,s),y(ss.$$.fragment,s),y(rs.$$.fragment,s),y(as.$$.fragment,s),y(ls.$$.fragment,s),y(cs.$$.fragment,s),y(ps.$$.fragment,s),y(_s.$$.fragment,s),y(Kt.$$.fragment,s),y(Ts.$$.fragment,s),y(ks.$$.fragment,s),y(Fs.$$.fragment,s),y(Es.$$.fragment,s),y(Zt.$$.fragment,s),y(Ms.$$.fragment,s),y(zs.$$.fragment,s),y(qs.$$.fragment,s),y(Ps.$$.fragment,s),y(Jt.$$.fragment,s),y(Cs.$$.fragment,s),y(xs.$$.fragment,s),y(js.$$.fragment,s),y(Is.$$.fragment,s),y(no.$$.fragment,s),y(Ws.$$.fragment,s),y(Bs.$$.fragment,s),y(Qs.$$.fragment,s),y(Us.$$.fragment,s),y(Gs.$$.fragment,s),y(oo.$$.fragment,s),y(Zs.$$.fragment,s),y(Xs.$$.fragment,s),y(Js.$$.fragment,s),y(er.$$.fragment,s),y(nr.$$.fragment,s),y(tr.$$.fragment,s),y(lr.$$.fragment,s),y(ro.$$.fragment,s),y(dr.$$.fragment,s),y(cr.$$.fragment,s),y(pr.$$.fragment,s),y(_r.$$.fragment,s),y(io.$$.fragment,s),y(Tr.$$.fragment,s),y(kr.$$.fragment,s),y(Fr.$$.fragment,s),y(vr.$$.fragment,s),y(Mr.$$.fragment,s),y(co.$$.fragment,s),y(zr.$$.fragment,s),y(qr.$$.fragment,s),y(Pr.$$.fragment,s),y(Cr.$$.fragment,s),y(uo.$$.fragment,s),y(Ar.$$.fragment,s),y(ho.$$.fragment,s),y(Nr.$$.fragment,s),y(Sr.$$.fragment,s),y(Ir.$$.fragment,s),y(fo.$$.fragment,s),y(Vr.$$.fragment,s),y(go.$$.fragment,s),y(Hr.$$.fragment,s),y(Yr.$$.fragment,s),y(Kr.$$.fragment,s),y(To.$$.fragment,s),y(na.$$.fragment,s),y(ko.$$.fragment,s),y(ta.$$.fragment,s),y(oa.$$.fragment,s),y(sa.$$.fragment,s),y(vo.$$.fragment,s),y(pa.$$.fragment,s),y(bo.$$.fragment,s),y(ua.$$.fragment,s),y(ha.$$.fragment,s),y(ma.$$.fragment,s),y(fa.$$.fragment,s),y(wo.$$.fragment,s),y(va.$$.fragment,s),y($o.$$.fragment,s),y(ba.$$.fragment,s),y(ya.$$.fragment,s),y(wa.$$.fragment,s),y($a.$$.fragment,s),y(Mo.$$.fragment,s),y(Ca.$$.fragment,s),y(zo.$$.fragment,s),y(xa.$$.fragment,s),y(ja.$$.fragment,s),y(La.$$.fragment,s),y(Po.$$.fragment,s),y(Ia.$$.fragment,s),y(Co.$$.fragment,s),y(Wa.$$.fragment,s),y(Ba.$$.fragment,s),y(Qa.$$.fragment,s),y(Ua.$$.fragment,s),y(jo.$$.fragment,s),y(Ga.$$.fragment,s),y(Lo.$$.fragment,s),y(Za.$$.fragment,s),y(Xa.$$.fragment,s),yp=!0)},o(s){w(T.$$.fragment,s),w(ne.$$.fragment,s),w(Io.$$.fragment,s),w(Wo.$$.fragment,s),w(Qo.$$.fragment,s),w(Uo.$$.fragment,s),w(Vo.$$.fragment,s),w(Yo.$$.fragment,s),w(Go.$$.fragment,s),w(Zo.$$.fragment,s),w(Xo.$$.fragment,s),w(Jo.$$.fragment,s),w(es.$$.fragment,s),w(os.$$.fragment,s),w(ss.$$.fragment,s),w(rs.$$.fragment,s),w(as.$$.fragment,s),w(ls.$$.fragment,s),w(cs.$$.fragment,s),w(ps.$$.fragment,s),w(_s.$$.fragment,s),w(Kt.$$.fragment,s),w(Ts.$$.fragment,s),w(ks.$$.fragment,s),w(Fs.$$.fragment,s),w(Es.$$.fragment,s),w(Zt.$$.fragment,s),w(Ms.$$.fragment,s),w(zs.$$.fragment,s),w(qs.$$.fragment,s),w(Ps.$$.fragment,s),w(Jt.$$.fragment,s),w(Cs.$$.fragment,s),w(xs.$$.fragment,s),w(js.$$.fragment,s),w(Is.$$.fragment,s),w(no.$$.fragment,s),w(Ws.$$.fragment,s),w(Bs.$$.fragment,s),w(Qs.$$.fragment,s),w(Us.$$.fragment,s),w(Gs.$$.fragment,s),w(oo.$$.fragment,s),w(Zs.$$.fragment,s),w(Xs.$$.fragment,s),w(Js.$$.fragment,s),w(er.$$.fragment,s),w(nr.$$.fragment,s),w(tr.$$.fragment,s),w(lr.$$.fragment,s),w(ro.$$.fragment,s),w(dr.$$.fragment,s),w(cr.$$.fragment,s),w(pr.$$.fragment,s),w(_r.$$.fragment,s),w(io.$$.fragment,s),w(Tr.$$.fragment,s),w(kr.$$.fragment,s),w(Fr.$$.fragment,s),w(vr.$$.fragment,s),w(Mr.$$.fragment,s),w(co.$$.fragment,s),w(zr.$$.fragment,s),w(qr.$$.fragment,s),w(Pr.$$.fragment,s),w(Cr.$$.fragment,s),w(uo.$$.fragment,s),w(Ar.$$.fragment,s),w(ho.$$.fragment,s),w(Nr.$$.fragment,s),w(Sr.$$.fragment,s),w(Ir.$$.fragment,s),w(fo.$$.fragment,s),w(Vr.$$.fragment,s),w(go.$$.fragment,s),w(Hr.$$.fragment,s),w(Yr.$$.fragment,s),w(Kr.$$.fragment,s),w(To.$$.fragment,s),w(na.$$.fragment,s),w(ko.$$.fragment,s),w(ta.$$.fragment,s),w(oa.$$.fragment,s),w(sa.$$.fragment,s),w(vo.$$.fragment,s),w(pa.$$.fragment,s),w(bo.$$.fragment,s),w(ua.$$.fragment,s),w(ha.$$.fragment,s),w(ma.$$.fragment,s),w(fa.$$.fragment,s),w(wo.$$.fragment,s),w(va.$$.fragment,s),w($o.$$.fragment,s),w(ba.$$.fragment,s),w(ya.$$.fragment,s),w(wa.$$.fragment,s),w($a.$$.fragment,s),w(Mo.$$.fragment,s),w(Ca.$$.fragment,s),w(zo.$$.fragment,s),w(xa.$$.fragment,s),w(ja.$$.fragment,s),w(La.$$.fragment,s),w(Po.$$.fragment,s),w(Ia.$$.fragment,s),w(Co.$$.fragment,s),w(Wa.$$.fragment,s),w(Ba.$$.fragment,s),w(Qa.$$.fragment,s),w(Ua.$$.fragment,s),w(jo.$$.fragment,s),w(Ga.$$.fragment,s),w(Lo.$$.fragment,s),w(Za.$$.fragment,s),w(Xa.$$.fragment,s),yp=!1},d(s){n(u),s&&n(z),s&&n(g),$(T),s&&n(K),s&&n(q),$(ne),s&&n(ie),s&&n(Y),s&&n(x),s&&n(oe),s&&n(le),s&&n(se),s&&n(de),s&&n(C),s&&n(W),s&&n(ee),s&&n(Oc),s&&n(In),s&&n(Dc),s&&n(Zn),$(Io),s&&n(Ac),s&&n(Nn),$(Wo),s&&n(Nc),s&&n(Jn),$(Qo),s&&n(Sc),s&&n(xe),$(Uo),$(Vo),$(Yo),$(Go),$(Zo),$(Xo),s&&n(Ic),s&&n(nt),$(Jo),s&&n(Wc),s&&n(sn),$(es),$(os),$(ss),s&&n(Bc),s&&n(ot),$(rs),s&&n(Qc),s&&n(st),$(as),s&&n(Uc),s&&n(rt),$(ls),s&&n(Rc),s&&n(at),$(cs),s&&n(Vc),s&&n(Qe),$(ps),$(_s),$(Kt),$(Ts),s&&n(Hc),s&&n(lt),$(ks),s&&n(Yc),s&&n(Ue),$(Fs),$(Es),$(Zt),$(Ms),s&&n(Kc),s&&n(ct),$(zs),s&&n(Gc),s&&n(pt),$(qs),$(Ps),$(Jt),$(Cs),s&&n(Zc),s&&n(ht),$(xs),s&&n(Xc),s&&n(Re),$(js),$(Is),$(no),$(Ws),$(Bs),s&&n(Jc),s&&n(ft),$(Qs),s&&n(ep),s&&n(Ve),$(Us),$(Gs),$(oo),$(Zs),$(Xs),$(Js),$(er),s&&n(np),s&&n(_t),$(nr),s&&n(tp),s&&n(He),$(tr),$(lr),$(ro),$(dr),s&&n(op),s&&n(kt),$(cr),s&&n(sp),s&&n(Ye),$(pr),$(_r),$(io),$(Tr),$(kr),s&&n(rp),s&&n(vt),$(Fr),s&&n(ap),s&&n(Ke),$(vr),$(Mr),$(co),$(zr),$(qr),s&&n(ip),s&&n(wt),$(Pr),s&&n(lp),s&&n(Le),$(Cr),$(uo),$(Ar),$(ho),$(Nr),s&&n(dp),s&&n(Et),$(Sr),s&&n(cp),s&&n(Oe),$(Ir),$(fo),$(Vr),$(go),$(Hr),s&&n(pp),s&&n(zt),$(Yr),s&&n(up),s&&n(De),$(Kr),$(To),$(na),$(ko),$(ta),s&&n(hp),s&&n(Pt),$(oa),s&&n(mp),s&&n(Ae),$(sa),$(vo),$(pa),$(bo),$(ua),$(ha),s&&n(fp),s&&n(xt),$(ma),s&&n(gp),s&&n(Ne),$(fa),$(wo),$(va),$($o),$(ba),$(ya),s&&n(_p),s&&n(Lt),$(wa),s&&n(Tp),s&&n(Se),$($a),$(Mo),$(Ca),$(zo),$(xa),s&&n(kp),s&&n(Dt),$(ja),s&&n(Fp),s&&n(Ie),$(La),$(Po),$(Ia),$(Co),$(Wa),$(Ba),s&&n(vp),s&&n(Nt),$(Qa),s&&n(bp),s&&n(We),$(Ua),$(jo),$(Ga),$(Lo),$(Za),$(Xa)}}}const _$={local:"funnel-transformer",sections:[{local:"overview",title:"Overview"},{local:"transformers.FunnelConfig",title:"FunnelConfig"},{local:"transformers.FunnelTokenizer",title:"FunnelTokenizer"},{local:"transformers.FunnelTokenizerFast",title:"FunnelTokenizerFast"},{local:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput",title:"Funnel specific outputs"},{local:"transformers.FunnelBaseModel",title:"FunnelBaseModel"},{local:"transformers.FunnelModel",title:"FunnelModel"},{local:"transformers.FunnelForPreTraining",title:"FunnelModelForPreTraining"},{local:"transformers.FunnelForMaskedLM",title:"FunnelForMaskedLM"},{local:"transformers.FunnelForSequenceClassification",title:"FunnelForSequenceClassification"},{local:"transformers.FunnelForMultipleChoice",title:"FunnelForMultipleChoice"},{local:"transformers.FunnelForTokenClassification",title:"FunnelForTokenClassification"},{local:"transformers.FunnelForQuestionAnswering",title:"FunnelForQuestionAnswering"},{local:"transformers.TFFunnelBaseModel",title:"TFFunnelBaseModel"},{local:"transformers.TFFunnelModel",title:"TFFunnelModel"},{local:"transformers.TFFunnelForPreTraining",title:"TFFunnelModelForPreTraining"},{local:"transformers.TFFunnelForMaskedLM",title:"TFFunnelForMaskedLM"},{local:"transformers.TFFunnelForSequenceClassification",title:"TFFunnelForSequenceClassification"},{local:"transformers.TFFunnelForMultipleChoice",title:"TFFunnelForMultipleChoice"},{local:"transformers.TFFunnelForTokenClassification",title:"TFFunnelForTokenClassification"},{local:"transformers.TFFunnelForQuestionAnswering",title:"TFFunnelForQuestionAnswering"}],title:"Funnel Transformer"};function T$(H){return R2(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class w$ extends W2{constructor(u){super();B2(this,u,T$,g$,Q2,{})}}export{w$ as default,_$ as metadata};
