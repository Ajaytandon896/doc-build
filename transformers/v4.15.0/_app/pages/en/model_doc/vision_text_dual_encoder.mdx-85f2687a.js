import{S as vi,i as xi,s as Ti,e as a,k as d,w as v,t as n,L as Ei,c as s,d as t,m as c,a as i,x,h as r,b as l,J as e,g as u,y as T,q as E,o as b,B as $}from"../../../chunks/vendor-b1433968.js";import{T as on}from"../../../chunks/Tip-c3840994.js";import{D as R}from"../../../chunks/Docstring-ff504c58.js";import{C as ns}from"../../../chunks/CodeBlock-a320dbd7.js";import{I as Bt}from"../../../chunks/IconCopyLink-7029626d.js";import"../../../chunks/CopyButton-f65cb278.js";function bi(J){let m,w,f,g,k,h,_,P;return{c(){m=a("p"),w=n(`This class method is simply calling AutoFeatureExtractor\u2019s
`),f=a("code"),g=n("from_pretrained"),k=n(` and AutoTokenizer\u2019s
`),h=a("code"),_=n("from_pretrained"),P=n(`. Please refer to the
docstrings of the methods above for more information.`)},l(I){m=s(I,"P",{});var D=i(m);w=r(D,`This class method is simply calling AutoFeatureExtractor\u2019s
`),f=s(D,"CODE",{});var A=i(f);g=r(A,"from_pretrained"),A.forEach(t),k=r(D,` and AutoTokenizer\u2019s
`),h=s(D,"CODE",{});var L=i(h);_=r(L,"from_pretrained"),L.forEach(t),P=r(D,`. Please refer to the
docstrings of the methods above for more information.`),D.forEach(t)},m(I,D){u(I,m,D),e(m,w),e(m,f),e(f,g),e(m,k),e(m,h),e(h,_),e(m,P)},d(I){I&&t(m)}}}function $i(J){let m,w,f,g,k,h,_,P;return{c(){m=a("p"),w=n("This class method is simply calling "),f=a("code"),g=n("save_pretrained"),k=n(` and
`),h=a("code"),_=n("save_pretrained"),P=n(`. Please refer to the
docstrings of the methods above for more information.`)},l(I){m=s(I,"P",{});var D=i(m);w=r(D,"This class method is simply calling "),f=s(D,"CODE",{});var A=i(f);g=r(A,"save_pretrained"),A.forEach(t),k=r(D,` and
`),h=s(D,"CODE",{});var L=i(h);_=r(L,"save_pretrained"),L.forEach(t),P=r(D,`. Please refer to the
docstrings of the methods above for more information.`),D.forEach(t)},m(I,D){u(I,m,D),e(m,w),e(m,f),e(f,g),e(m,k),e(m,h),e(h,_),e(m,P)},d(I){I&&t(m)}}}function yi(J){let m,w,f,g,k;return{c(){m=a("p"),w=n("Although the recipe for forward pass needs to be defined within this function, one should call the "),f=a("code"),g=n("Module"),k=n(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(h){m=s(h,"P",{});var _=i(m);w=r(_,"Although the recipe for forward pass needs to be defined within this function, one should call the "),f=s(_,"CODE",{});var P=i(f);g=r(P,"Module"),P.forEach(t),k=r(_,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),_.forEach(t)},m(h,_){u(h,m,_),e(m,w),e(m,f),e(f,g),e(m,k)},d(h){h&&t(m)}}}function wi(J){let m,w,f,g,k;return{c(){m=a("p"),w=n("Although the recipe for forward pass needs to be defined within this function, one should call the "),f=a("code"),g=n("Module"),k=n(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(h){m=s(h,"P",{});var _=i(m);w=r(_,"Although the recipe for forward pass needs to be defined within this function, one should call the "),f=s(_,"CODE",{});var P=i(f);g=r(P,"Module"),P.forEach(t),k=r(_,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),_.forEach(t)},m(h,_){u(h,m,_),e(m,w),e(m,f),e(f,g),e(m,k)},d(h){h&&t(m)}}}function Di(J){let m,w,f,g,k,h,_,P,I,D,A,L,Wt,Ee,nn,Rt,rn,bo,V,an,mt,sn,ln,Jt,dn,cn,ft,mn,fn,pt,pn,hn,ht,un,gn,Ut,_n,vn,ut,xn,Tn,gt,En,bn,$o,ie,$n,be,yn,wn,yo,Y,le,Ht,$e,Dn,Zt,Vn,wo,j,ye,kn,Z,_t,Pn,jn,vt,zn,Mn,xt,Cn,Fn,In,ee,An,Tt,Ln,qn,Et,Sn,On,Nn,Gt,Bn,Wn,we,Rn,de,De,Jn,Ve,Un,bt,Hn,Zn,Gn,ce,ke,Xn,Pe,Kn,$t,Qn,Yn,Do,te,me,Xt,je,er,Kt,tr,Vo,z,ze,or,Qt,nr,rr,q,yt,ar,sr,wt,ir,lr,Dt,dr,cr,Yt,mr,fr,Vt,pr,hr,ur,fe,Me,gr,Ce,_r,kt,vr,xr,Tr,pe,Fe,Er,Ie,br,Pt,$r,yr,wr,G,Ae,Dr,Le,Vr,jt,kr,Pr,jr,he,zr,X,qe,Mr,oe,Cr,eo,Fr,Ir,zt,Ar,Lr,qr,ue,ko,ne,ge,to,Se,Sr,oo,Or,Po,M,Oe,Nr,Ne,Br,no,Wr,Rr,Jr,Be,Ur,We,Hr,Zr,Gr,ro,Xr,Kr,Re,Qr,Mt,Yr,ea,ta,Je,oa,Ue,na,ra,aa,S,He,sa,re,ia,Ct,la,da,ao,ca,ma,fa,_e,pa,so,ha,ua,Ze,jo,ae,ve,io,Ge,ga,lo,_a,zo,y,Xe,va,Ke,xa,co,Ta,Ea,ba,Qe,$a,Ye,ya,wa,Da,mo,Va,ka,et,Pa,Ft,ja,za,Ma,tt,Ca,ot,Fa,Ia,Aa,fo,La,qa,U,po,nt,Sa,Oa,ho,rt,Na,Ba,uo,at,Wa,Ra,go,st,Ja,Ua,O,it,Ha,se,Za,It,Ga,Xa,_o,Ka,Qa,Ya,xe,es,vo,ts,os,lt,Mo;return h=new Bt({}),Ee=new Bt({}),$e=new Bt({}),ye=new R({props:{name:"class transformers.VisionTextDualEncoderConfig",anchor:"transformers.VisionTextDualEncoderConfig",parameters:[{name:"projection_dim",val:" = 512"},{name:"logit_scale_init_value",val:" = 2.6592"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.15.0/src/transformers/models/vision_text_dual_encoder/configuration_vision_text_dual_encoder.py#L28",parametersDescription:[{anchor:"transformers.VisionTextDualEncoderConfig.text_config_dict",description:`<strong>text_config_dict</strong> (<code>dict</code>) &#x2014;
Dictionary of configuration options that defines text model config.`,name:"text_config_dict"},{anchor:"transformers.VisionTextDualEncoderConfig.vision_config_dict",description:`<strong>vision_config_dict</strong> (<code>dict</code>) &#x2014;
Dictionary of configuration options that defines vison model config.`,name:"vision_config_dict"},{anchor:"transformers.VisionTextDualEncoderConfig.projection_dim",description:`<strong>projection_dim</strong> (<code>int</code>, <em>optional</em>, defaults to 512) &#x2014;
Dimentionality of text and vision projection layers.`,name:"projection_dim"},{anchor:"transformers.VisionTextDualEncoderConfig.logit_scale_init_value",description:`<strong>logit_scale_init_value</strong> (<code>float</code>, <em>optional</em>, defaults to 2.6592) &#x2014;
The inital value of the <em>logit_scale</em> paramter. Default is used as per the original CLIP implementation.`,name:"logit_scale_init_value"},{anchor:"transformers.VisionTextDualEncoderConfig.kwargs",description:`<strong>kwargs</strong> (<em>optional</em>) &#x2014;
Dictionary of keyword arguments.`,name:"kwargs"}]}}),we=new ns({props:{code:`from transformers import ViTConfig, BertConfig, VisionTextDualEncoderConfig, VisionTextDualEncoderModel

# Initializing a BERT and ViT configuration
config_vision = ViTConfig()
config_text = BertConfig()

config = VisionTextDualEncoderConfig.from_vision_text_configs(config_vision, config_text, projection_dim=512)

# Initializing a BERT and ViT model
model = VisionTextDualEncoderModel(config=config)

# Accessing the model configuration
config_vision  = model.config.vision_config
config_text = model.config.text_config

# Saving the model, including its configuration
model.save_pretrained('my-model')

# loading model and config from pretrained folder
vision_text_config = VisionTextDualEncoderConfig.from_pretrained('vit-bert')
model = VisionTextDualEncoderModel.from_pretrained('vit-bert', config=vision_text_config),`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> ViTConfig, BertConfig, VisionTextDualEncoderConfig, VisionTextDualEncoderModel

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a BERT and ViT configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>config_vision = ViTConfig()
<span class="hljs-meta">&gt;&gt;&gt; </span>config_text = BertConfig()

<span class="hljs-meta">&gt;&gt;&gt; </span>config = VisionTextDualEncoderConfig.from_vision_text_configs(config_vision, config_text, projection_dim=<span class="hljs-number">512</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a BERT and ViT model</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = VisionTextDualEncoderModel(config=config)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Accessing the model configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>config_vision  = model.config.vision_config
<span class="hljs-meta">&gt;&gt;&gt; </span>config_text = model.config.text_config

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Saving the model, including its configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model.save_pretrained(<span class="hljs-string">&#x27;my-model&#x27;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># loading model and config from pretrained folder</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>vision_text_config = VisionTextDualEncoderConfig.from_pretrained(<span class="hljs-string">&#x27;vit-bert&#x27;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = VisionTextDualEncoderModel.from_pretrained(<span class="hljs-string">&#x27;vit-bert&#x27;</span>, config=vision_text_config)`}}),De=new R({props:{name:"from_vision_text_configs",anchor:"transformers.VisionTextDualEncoderConfig.from_vision_text_configs",parameters:[{name:"vision_config",val:": PretrainedConfig"},{name:"text_config",val:": PretrainedConfig"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.15.0/src/transformers/models/vision_text_dual_encoder/configuration_vision_text_dual_encoder.py#L106",returnDescription:`
<p>An instance of a configuration object</p>
`,returnType:`
<p><a
  href="/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderConfig"
>VisionTextDualEncoderConfig</a></p>
`}}),ke=new R({props:{name:"to_dict",anchor:"transformers.VisionTextDualEncoderConfig.to_dict",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.15.0/src/transformers/models/vision_text_dual_encoder/configuration_vision_text_dual_encoder.py#L118",returnDescription:`
<p>Dictionary of all the attributes that make up this configuration instance,</p>
`,returnType:`
<p><code>Dict[str, any]</code></p>
`}}),je=new Bt({}),ze=new R({props:{name:"class transformers.VisionTextDualEncoderProcessor",anchor:"transformers.VisionTextDualEncoderProcessor",parameters:[{name:"feature_extractor",val:": FeatureExtractionMixin"},{name:"tokenizer",val:": typing.Union[transformers.tokenization_utils.PreTrainedTokenizer, transformers.tokenization_utils_fast.PreTrainedTokenizerFast]"}],source:"https://github.com/huggingface/transformers/blob/v4.15.0/src/transformers/models/vision_text_dual_encoder/processing_vision_text_dual_encoder.py#L28",parametersDescription:[{anchor:"transformers.VisionTextDualEncoderProcessor.feature_extractor",description:`<strong>feature_extractor</strong> (<a href="/docs/transformers/v4.15.0/en/model_doc/auto#transformers.AutoFeatureExtractor">AutoFeatureExtractor</a>) &#x2014;
The feature extractor is a required input.`,name:"feature_extractor"},{anchor:"transformers.VisionTextDualEncoderProcessor.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/v4.15.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer is a required input.`,name:"tokenizer"}]}}),Me=new R({props:{name:"batch_decode",anchor:"transformers.VisionTextDualEncoderProcessor.batch_decode",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.15.0/src/transformers/models/vision_text_dual_encoder/processing_vision_text_dual_encoder.py#L175"}}),Fe=new R({props:{name:"decode",anchor:"transformers.VisionTextDualEncoderProcessor.decode",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.15.0/src/transformers/models/vision_text_dual_encoder/processing_vision_text_dual_encoder.py#L183"}}),Ae=new R({props:{name:"from_pretrained",anchor:"transformers.VisionTextDualEncoderProcessor.from_pretrained",parameters:[{name:"pretrained_model_name_or_path",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.15.0/src/transformers/models/vision_text_dual_encoder/processing_vision_text_dual_encoder.py#L84",parametersDescription:[{anchor:"transformers.VisionTextDualEncoderProcessor.from_pretrained.pretrained_model_name_or_path",description:`<strong>pretrained_model_name_or_path</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
This can be either:</p>
<ul>
<li>a string, the <em>model id</em> of a pretrained feature_extractor hosted inside a model repo on
huggingface.co. Valid model ids can be located at the root-level, like <code>bert-base-uncased</code>, or
namespaced under a user or organization name, like <code>dbmdz/bert-base-german-cased</code>.</li>
<li>a path to a <em>directory</em> containing a feature extractor file saved using the
<code>save_pretrained</code> method, e.g.,
<code>./my_model_directory/</code>.</li>
<li>a path or url to a saved feature extractor JSON <em>file</em>, e.g.,
<code>./my_model_directory/preprocessor_config.json</code>.</li>
</ul>`,name:"pretrained_model_name_or_path"}]}}),he=new on({props:{$$slots:{default:[bi]},$$scope:{ctx:J}}}),qe=new R({props:{name:"save_pretrained",anchor:"transformers.VisionTextDualEncoderProcessor.save_pretrained",parameters:[{name:"save_directory",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.15.0/src/transformers/models/vision_text_dual_encoder/processing_vision_text_dual_encoder.py#L61",parametersDescription:[{anchor:"transformers.VisionTextDualEncoderProcessor.save_pretrained.save_directory",description:`<strong>save_directory</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
Directory where the feature extractor JSON file and the tokenizer files will be saved (directory will
be created if it does not exist).`,name:"save_directory"}]}}),ue=new on({props:{$$slots:{default:[$i]},$$scope:{ctx:J}}}),Se=new Bt({}),Oe=new R({props:{name:"class transformers.VisionTextDualEncoderModel",anchor:"transformers.VisionTextDualEncoderModel",parameters:[{name:"config",val:": typing.Optional[transformers.models.vision_text_dual_encoder.configuration_vision_text_dual_encoder.VisionTextDualEncoderConfig] = None"},{name:"vision_model",val:": typing.Optional[transformers.modeling_utils.PreTrainedModel] = None"},{name:"text_model",val:": typing.Optional[transformers.modeling_utils.PreTrainedModel] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.15.0/src/transformers/models/vision_text_dual_encoder/modeling_vision_text_dual_encoder.py#L166",parametersDescription:[{anchor:"transformers.VisionTextDualEncoderModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/v4.15.0/en/model_doc/visionencoderdecoder#transformers.VisionEncoderDecoderConfig">VisionEncoderDecoderConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.15.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model
weights.`,name:"config"}]}}),He=new R({props:{name:"forward",anchor:"transformers.VisionTextDualEncoderModel.forward",parameters:[{name:"input_ids",val:" = None"},{name:"pixel_values",val:" = None"},{name:"attention_mask",val:" = None"},{name:"position_ids",val:" = None"},{name:"return_loss",val:" = None"},{name:"token_type_ids",val:" = None"},{name:"output_attentions",val:" = None"},{name:"output_hidden_states",val:" = None"},{name:"return_dict",val:" = None"}],source:"https://github.com/huggingface/transformers/blob/v4.15.0/src/transformers/models/vision_text_dual_encoder/modeling_vision_text_dual_encoder.py#L296",parametersDescription:[{anchor:"transformers.VisionTextDualEncoderModel.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide
it.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.15.0/en/model_doc/clip#transformers.CLIPTokenizer">CLIPTokenizer</a>. See
<a href="/docs/transformers/v4.15.0/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and <a href="/docs/transformers/v4.15.0/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for
details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.VisionTextDualEncoderModel.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.VisionTextDualEncoderModel.forward.position_ids",description:`<strong>position_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Indices of positions of each input sequence tokens in the position embeddings. Selected in the range <code>[0, config.max_position_embeddings - 1]</code>.</p>
<p><a href="../glossary#position-ids">What are position IDs?</a>`,name:"position_ids"},{anchor:"transformers.VisionTextDualEncoderModel.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Padding will be ignored by default should you provide it. Pixel values can be obtained using
a feature extractor (e.g. if you use ViT as the encoder, you should use
<a href="/docs/transformers/v4.15.0/en/model_doc/vit#transformers.ViTFeatureExtractor">ViTFeatureExtractor</a>). See <a href="/docs/transformers/v4.15.0/en/model_doc/vit#transformers.ViTFeatureExtractor.__call__">ViTFeatureExtractor.<strong>call</strong>()</a> for
details.`,name:"pixel_values"},{anchor:"transformers.VisionTextDualEncoderModel.forward.return_loss",description:`<strong>return_loss</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the contrastive loss.`,name:"return_loss"},{anchor:"transformers.VisionTextDualEncoderModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.VisionTextDualEncoderModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.VisionTextDualEncoderModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.15.0/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <code>transformers.models.clip.modeling_clip.CLIPOutput</code> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderConfig"
>VisionTextDualEncoderConfig</a>) and inputs.</p>
<ul>
<li><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>return_loss</code> is <code>True</code>) \u2014 Contrastive loss for image-text similarity.</li>
<li><strong>logits_per_image:(<code>torch.FloatTensor</code></strong> of shape <code>(image_batch_size, text_batch_size)</code>) \u2014 The scaled dot product scores between <code>image_embeds</code> and <code>text_embeds</code>. This represents the
image-text similarity scores.</li>
<li><strong>logits_per_text:(<code>torch.FloatTensor</code></strong> of shape <code>(text_batch_size, image_batch_size)</code>) \u2014 The scaled dot product scores between <code>text_embeds</code> and <code>image_embeds</code>. This represents the
text-image similarity scores.</li>
<li><strong>text_embeds(<code>torch.FloatTensor</code></strong> of shape <code>(batch_size, output_dim</code>) \u2014 The text embeddings obtained by applying the projection layer to the pooled output of
<a
  href="/docs/transformers/v4.15.0/en/model_doc/clip#transformers.CLIPTextModel"
>CLIPTextModel</a>.</li>
<li><strong>image_embeds(<code>torch.FloatTensor</code></strong> of shape <code>(batch_size, output_dim</code>) \u2014 The image embeddings obtained by applying the projection layer to the pooled output of
<a
  href="/docs/transformers/v4.15.0/en/model_doc/clip#transformers.CLIPVisionModel"
>CLIPVisionModel</a>.</li>
<li><strong>text_model_output(<code>BaseModelOutputWithPooling</code>):</strong>
The output of the <a
  href="/docs/transformers/v4.15.0/en/model_doc/clip#transformers.CLIPTextModel"
>CLIPTextModel</a>.</li>
<li><strong>vision_model_output(<code>BaseModelOutputWithPooling</code>):</strong>
The output of the <a
  href="/docs/transformers/v4.15.0/en/model_doc/clip#transformers.CLIPVisionModel"
>CLIPVisionModel</a>.</li>
</ul>
`,returnType:`
<p><code>transformers.models.clip.modeling_clip.CLIPOutput</code> or <code>tuple(torch.FloatTensor)</code></p>
`}}),_e=new on({props:{$$slots:{default:[yi]},$$scope:{ctx:J}}}),Ze=new ns({props:{code:`from PIL import Image
import requests
from transformers import VisionTextDualEncoderModel, VisionTextDualEncoderProcessor, ViTFeatureExtractor, BertTokenizer

tokenizer = BertTokenizer.from_pretrained("bert-base-uncased")
feature_extractor = ViTFeatureExtractor.from_pretrained("google/vit-base-patch16-224")
processor = VisionTextDualEncoderProcessor(feature_extractor, tokenizer)
model = VisionTextDualEncoderModel.from_vision_text_pretrained("google/vit-base-patch16-224", "bert-base-uncased")

# contrastive training
urls = ["http://images.cocodataset.org/val2017/000000039769.jpg", "https://farm3.staticflickr.com/2674/5850229113_4fe05d5265_z.jpg]
images = [Image.open(requests.get(url, stream=True).raw) for url in urls]
inputs = processor(text=["a photo of a cat", "a photo of a dog"], images=images, return_tensors="pt", padding=True)
outputs = model(input_ids=inputs.input_ids, attention_mask=inputs.attention_mask, pixel_values=inputs.pixel_values, return_loss=True)
loss, logits_per_image = outputs.loss, outputs.logits_per_imag # this is the image-text similarity score

# save and load from pretrained
model.save_pretrained("vit-bert")
model = VisionTextDualEncoderModel.from_pretrained("vit-bert")

# inference
outputs = model(**inputs)
logits_per_image = outputs.logits_per_image # this is the image-text similarity score
probs = logits_per_image.softmax(dim=1) # we can take the softmax to get the label probabilities,`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> VisionTextDualEncoderModel, VisionTextDualEncoderProcessor, ViTFeatureExtractor, BertTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = BertTokenizer.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = ViTFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;google/vit-base-patch16-224&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>processor = VisionTextDualEncoderProcessor(feature_extractor, tokenizer)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = VisionTextDualEncoderModel.from_vision_text_pretrained(<span class="hljs-string">&quot;google/vit-base-patch16-224&quot;</span>, <span class="hljs-string">&quot;bert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># contrastive training</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>urls = [<span class="hljs-string">&quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot;</span>, <span class="hljs-string">&quot;https://farm3.staticflickr.com/2674/5850229113_4fe05d5265_z.jpg]
&gt;&gt;&gt; images = [Image.open(requests.get(url, stream=True).raw) for url in urls]
&gt;&gt;&gt; inputs = processor(text=[&quot;</span>a photo of a cat<span class="hljs-string">&quot;, &quot;</span>a photo of a dog<span class="hljs-string">&quot;], images=images, return_tensors=&quot;</span>pt<span class="hljs-string">&quot;, padding=True)
&gt;&gt;&gt; outputs = model(input_ids=inputs.input_ids, attention_mask=inputs.attention_mask, pixel_values=inputs.pixel_values, return_loss=True)
&gt;&gt;&gt; loss, logits_per_image = outputs.loss, outputs.logits_per_imag # this is the image-text similarity score

&gt;&gt;&gt; # save and load from pretrained
&gt;&gt;&gt; model.save_pretrained(&quot;</span>vit-bert<span class="hljs-string">&quot;)
&gt;&gt;&gt; model = VisionTextDualEncoderModel.from_pretrained(&quot;</span>vit-bert<span class="hljs-string">&quot;)

&gt;&gt;&gt; # inference
&gt;&gt;&gt; outputs = model(**inputs)
&gt;&gt;&gt; logits_per_image = outputs.logits_per_image # this is the image-text similarity score
&gt;&gt;&gt; probs = logits_per_image.softmax(dim=1) # we can take the softmax to get the label probabilities</span>`}}),Ge=new Bt({}),Xe=new R({props:{name:"class transformers.FlaxVisionTextDualEncoderModel",anchor:"transformers.FlaxVisionTextDualEncoderModel",parameters:[{name:"config",val:": VisionTextDualEncoderConfig"},{name:"input_shape",val:": typing.Optional[typing.Tuple] = None"},{name:"seed",val:": int = 0"},{name:"dtype",val:": dtype = <class 'jax._src.numpy.lax_numpy.float32'>"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.15.0/src/transformers/models/vision_text_dual_encoder/modeling_flax_vision_text_dual_encoder.py#L220",parametersDescription:[{anchor:"transformers.FlaxVisionTextDualEncoderModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderConfig">VisionTextDualEncoderConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.15.0/en/main_classes/model#transformers.FlaxPreTrainedModel.from_pretrained">from_pretrained()</a> method to load the
model weights.`,name:"config"},{anchor:"transformers.FlaxVisionTextDualEncoderModel.dtype",description:`<strong>dtype</strong> (<code>jax.numpy.dtype</code>, <em>optional</em>, defaults to <code>jax.numpy.float32</code>) &#x2014;
The data type of the computation. Can be one of <code>jax.numpy.float32</code>, <code>jax.numpy.float16</code> (on
GPUs) and <code>jax.numpy.bfloat16</code> (on TPUs).</p>
<p>This can be used to enable mixed-precision training or half-precision inference on GPUs or TPUs. If
specified all the computation will be performed with the given <code>dtype</code>.</p>
<p><strong>Note that this only specifies the dtype of the computation and does not influence the dtype of model
parameters.</strong></p>
<p>If you wish to change the dtype of the model parameters, see
<a href="/docs/transformers/v4.15.0/en/main_classes/model#transformers.FlaxPreTrainedModel.to_fp16">to_fp16()</a> and <a href="/docs/transformers/v4.15.0/en/main_classes/model#transformers.FlaxPreTrainedModel.to_bf16">to_bf16()</a>.`,name:"dtype"}]}}),it=new R({props:{name:"__call__",anchor:"transformers.FlaxVisionTextDualEncoderModel.__call__",parameters:[{name:"input_ids",val:""},{name:"pixel_values",val:""},{name:"attention_mask",val:" = None"},{name:"position_ids",val:" = None"},{name:"token_type_ids",val:" = None"},{name:"params",val:": dict = None"},{name:"dropout_rng",val:": PRNGKey = None"},{name:"train",val:": bool = False"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.15.0/src/transformers/models/vision_text_dual_encoder/modeling_flax_vision_text_dual_encoder.py#L252",parametersDescription:[{anchor:"transformers.FlaxVisionTextDualEncoderModel.__call__.input_ids",description:`<strong>input_ids</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide
it.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.15.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>. See
<a href="/docs/transformers/v4.15.0/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and <a href="/docs/transformers/v4.15.0/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for
details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FlaxVisionTextDualEncoderModel.__call__.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FlaxVisionTextDualEncoderModel.__call__.position_ids",description:`<strong>position_ids</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Indices of positions of each input sequence tokens in the position embeddings. Selected in the range <code>[0, config.max_position_embeddings - 1]</code>.</p>
<p><a href="../glossary#position-ids">What are position IDs?</a>`,name:"position_ids"},{anchor:"transformers.FlaxVisionTextDualEncoderModel.__call__.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Padding will be ignored by default should you provide it. Pixel values can be obtained using
a feature extractor (e.g. if you use ViT as the encoder, you should use
<a href="/docs/transformers/v4.15.0/en/model_doc/vit#transformers.ViTFeatureExtractor">ViTFeatureExtractor</a>). See <a href="/docs/transformers/v4.15.0/en/model_doc/vit#transformers.ViTFeatureExtractor.__call__">ViTFeatureExtractor.<strong>call</strong>()</a> for
details.`,name:"pixel_values"},{anchor:"transformers.FlaxVisionTextDualEncoderModel.__call__.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FlaxVisionTextDualEncoderModel.__call__.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FlaxVisionTextDualEncoderModel.__call__.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.15.0/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <code>transformers.models.clip.modeling_flax_clip.FlaxCLIPOutput</code> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderConfig"
>VisionTextDualEncoderConfig</a>) and inputs.</p>
<ul>
<li><strong>logits_per_image:(<code>jnp.ndarray</code></strong> of shape <code>(image_batch_size, text_batch_size)</code>) \u2014 The scaled dot product scores between <code>image_embeds</code> and <code>text_embeds</code>. This represents the
image-text similarity scores.</li>
<li><strong>logits_per_text:(<code>jnp.ndarray</code></strong> of shape <code>(text_batch_size, image_batch_size)</code>) \u2014 The scaled dot product scores between <code>text_embeds</code> and <code>image_embeds</code>. This represents the
text-image similarity scores.</li>
<li><strong>text_embeds(<code>jnp.ndarray</code></strong> of shape <code>(batch_size, output_dim</code>) \u2014 The text embeddings obtained by applying the projection layer to the pooled output of
<a
  href="/docs/transformers/v4.15.0/en/model_doc/clip#transformers.FlaxCLIPTextModel"
>FlaxCLIPTextModel</a>.</li>
<li><strong>image_embeds(<code>jnp.ndarray</code></strong> of shape <code>(batch_size, output_dim</code>) \u2014 The image embeddings obtained by applying the projection layer to the pooled output of
<a
  href="/docs/transformers/v4.15.0/en/model_doc/clip#transformers.FlaxCLIPVisionModel"
>FlaxCLIPVisionModel</a>.</li>
<li><strong>text_model_output(<code>FlaxBaseModelOutputWithPooling</code>):</strong>
The output of the <a
  href="/docs/transformers/v4.15.0/en/model_doc/clip#transformers.FlaxCLIPTextModel"
>FlaxCLIPTextModel</a>.</li>
<li><strong>vision_model_output(<code>FlaxBaseModelOutputWithPooling</code>):</strong>
The output of the <a
  href="/docs/transformers/v4.15.0/en/model_doc/clip#transformers.FlaxCLIPVisionModel"
>FlaxCLIPVisionModel</a>.</li>
</ul>
`,returnType:`
<p><code>transformers.models.clip.modeling_flax_clip.FlaxCLIPOutput</code> or <code>tuple(torch.FloatTensor)</code></p>
`}}),xe=new on({props:{$$slots:{default:[wi]},$$scope:{ctx:J}}}),lt=new ns({props:{code:`from PIL import Image
import requests
import jax
from transformers import FlaxVisionTextDualEncoderModel, VisionTextDualEncoderProcessor, ViTFeatureExtractor, BertTokenizer

tokenizer = BertTokenizer.from_pretrained("bert-base-uncased")
feature_extractor = ViTFeatureExtractor.from_pretrained("google/vit-base-patch16-224")
processor = VisionTextDualEncoderProcessor(feature_extractor, tokenizer)
model = FlaxVisionTextDualEncoderModel.from_vision_text_pretrained("google/vit-base-patch16-224", "bert-base-uncased")

# contrastive training
urls = ["http://images.cocodataset.org/val2017/000000039769.jpg", "https://farm3.staticflickr.com/2674/5850229113_4fe05d5265_z.jpg]
images = [Image.open(requests.get(url, stream=True).raw) for url in urls]
inputs = processor(text=["a photo of a cat", "a photo of a dog"], images=images, return_tensors="np", padding=True)
outputs = model(input_ids=inputs.input_ids, attention_mask=inputs.attention_mask, pixel_values=inputs.pixel_values, return_loss=True)
loss, logits_per_image = outputs.loss, outputs.logits_per_imag # this is the image-text similarity score

# save and load from pretrained
model.save_pretrained("vit-bert")
model = FlaxVisionTextDualEncoderModel.from_pretrained("vit-bert")

# inference
outputs = model(**inputs)
logits_per_image = outputs.logits_per_image # this is the image-text similarity score
probs = jax.nn.softmax(logits_per_image, axis=1) # we can take the softmax to get the label probabilities,`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> jax
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FlaxVisionTextDualEncoderModel, VisionTextDualEncoderProcessor, ViTFeatureExtractor, BertTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = BertTokenizer.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = ViTFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;google/vit-base-patch16-224&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>processor = VisionTextDualEncoderProcessor(feature_extractor, tokenizer)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FlaxVisionTextDualEncoderModel.from_vision_text_pretrained(<span class="hljs-string">&quot;google/vit-base-patch16-224&quot;</span>, <span class="hljs-string">&quot;bert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># contrastive training</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>urls = [<span class="hljs-string">&quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot;</span>, <span class="hljs-string">&quot;https://farm3.staticflickr.com/2674/5850229113_4fe05d5265_z.jpg]
&gt;&gt;&gt; images = [Image.open(requests.get(url, stream=True).raw) for url in urls]
&gt;&gt;&gt; inputs = processor(text=[&quot;</span>a photo of a cat<span class="hljs-string">&quot;, &quot;</span>a photo of a dog<span class="hljs-string">&quot;], images=images, return_tensors=&quot;</span>np<span class="hljs-string">&quot;, padding=True)
&gt;&gt;&gt; outputs = model(input_ids=inputs.input_ids, attention_mask=inputs.attention_mask, pixel_values=inputs.pixel_values, return_loss=True)
&gt;&gt;&gt; loss, logits_per_image = outputs.loss, outputs.logits_per_imag # this is the image-text similarity score

&gt;&gt;&gt; # save and load from pretrained
&gt;&gt;&gt; model.save_pretrained(&quot;</span>vit-bert<span class="hljs-string">&quot;)
&gt;&gt;&gt; model = FlaxVisionTextDualEncoderModel.from_pretrained(&quot;</span>vit-bert<span class="hljs-string">&quot;)

&gt;&gt;&gt; # inference
&gt;&gt;&gt; outputs = model(**inputs)
&gt;&gt;&gt; logits_per_image = outputs.logits_per_image # this is the image-text similarity score
&gt;&gt;&gt; probs = jax.nn.softmax(logits_per_image, axis=1) # we can take the softmax to get the label probabilities</span>`}}),{c(){m=a("meta"),w=d(),f=a("h1"),g=a("a"),k=a("span"),v(h.$$.fragment),_=d(),P=a("span"),I=n("VisionTextDualEncoder"),D=d(),A=a("h2"),L=a("a"),Wt=a("span"),v(Ee.$$.fragment),nn=d(),Rt=a("span"),rn=n("Overview"),bo=d(),V=a("p"),an=n("The "),mt=a("a"),sn=n("VisionTextDualEncoderModel"),ln=n(` can be used to initialize a vision-text dual encoder model with
any pretrained vision autoencoding model as the vision encoder (`),Jt=a("em"),dn=n("e.g."),cn=d(),ft=a("a"),mn=n("ViT"),fn=n(", "),pt=a("a"),pn=n("BEiT"),hn=n(", "),ht=a("a"),un=n("DeiT"),gn=n(") and any pretrained text autoencoding model as the text encoder ("),Ut=a("em"),_n=n("e.g."),vn=d(),ut=a("a"),xn=n("RoBERTa"),Tn=n(", "),gt=a("a"),En=n("BERT"),bn=n(`). Two projection layers are added on top of both the vision and text encoder to project the output embeddings
to a shared latent space. The projection layers are randomly initialized so the model should be fine-tuned on a
downstream task. This model can be used to align the vision-text embeddings using CLIP like contrastive image-text
training and then can be used for zero-shot vision tasks such image-classification or retrieval.`),$o=d(),ie=a("p"),$n=n("In "),be=a("a"),yn=n("LiT: Zero-Shot Transfer with Locked-image Text Tuning"),wn=n(` it is shown how
leveraging pre-trained (locked/frozen) image and text model for contrastive learning yields significant improvment on
new zero-shot vision tasks such as image classification or retrieval.`),yo=d(),Y=a("h2"),le=a("a"),Ht=a("span"),v($e.$$.fragment),Dn=d(),Zt=a("span"),Vn=n("VisionTextDualEncoderConfig"),wo=d(),j=a("div"),v(ye.$$.fragment),kn=d(),Z=a("p"),_t=a("a"),Pn=n("VisionTextDualEncoderConfig"),jn=n(` is the configuration class to store the configuration of a
`),vt=a("a"),zn=n("VisionTextDualEncoderModel"),Mn=n(`. It is used to instantiate
`),xt=a("a"),Cn=n("VisionTextDualEncoderModel"),Fn=n(` model according to the specified arguments, defining the text
model and vision model configs.`),In=d(),ee=a("p"),An=n("Configuration objects inherit from "),Tt=a("a"),Ln=n("PretrainedConfig"),qn=n(` and can be used to control the model
outputs. Read the documentation from `),Et=a("a"),Sn=n("PretrainedConfig"),On=n(" for more information."),Nn=d(),Gt=a("p"),Bn=n("Examples:"),Wn=d(),v(we.$$.fragment),Rn=d(),de=a("div"),v(De.$$.fragment),Jn=d(),Ve=a("p"),Un=n("Instantiate a "),bt=a("a"),Hn=n("VisionTextDualEncoderConfig"),Zn=n(` (or a derived class) from text model configuration and
vision model configuration.`),Gn=d(),ce=a("div"),v(ke.$$.fragment),Xn=d(),Pe=a("p"),Kn=n(`Serializes this instance to a Python dictionary. Override the default
`),$t=a("a"),Qn=n("to_dict()"),Yn=n("."),Do=d(),te=a("h2"),me=a("a"),Xt=a("span"),v(je.$$.fragment),er=d(),Kt=a("span"),tr=n("VisionTextDualEncoderProcessor"),Vo=d(),z=a("div"),v(ze.$$.fragment),or=d(),Qt=a("p"),nr=n(`Constructs a VisionTextDualEncoder processor which wraps a vision feature extractor and a tokenizer into a single
processor.`),rr=d(),q=a("p"),yt=a("a"),ar=n("VisionTextDualEncoderProcessor"),sr=n(` offers all the functionalities of
`),wt=a("a"),ir=n("AutoFeatureExtractor"),lr=n(" and "),Dt=a("a"),dr=n("AutoTokenizer"),cr=n(`. See the
`),Yt=a("code"),mr=n("__call__()"),fr=n(` and
`),Vt=a("a"),pr=n("decode()"),hr=n(" for more information."),ur=d(),fe=a("div"),v(Me.$$.fragment),gr=d(),Ce=a("p"),_r=n(`This method forwards all its arguments to VisionTextDualEncoderTokenizer\u2019s
`),kt=a("a"),vr=n("batch_decode()"),xr=n(`. Please refer to the docstring of this method for more
information.`),Tr=d(),pe=a("div"),v(Fe.$$.fragment),Er=d(),Ie=a("p"),br=n(`This method forwards all its arguments to VisionTextDualEncoderTokenizer\u2019s
`),Pt=a("a"),$r=n("decode()"),yr=n(`. Please refer to the docstring of this method for more
information.`),wr=d(),G=a("div"),v(Ae.$$.fragment),Dr=d(),Le=a("p"),Vr=n("Instantiate a "),jt=a("a"),kr=n("VisionTextDualEncoderProcessor"),Pr=n(` from a pretrained VisionTextDualEncoder
processor.`),jr=d(),v(he.$$.fragment),zr=d(),X=a("div"),v(qe.$$.fragment),Mr=d(),oe=a("p"),Cr=n(`Save a VisionTextDualEncoder feature extractor object and VisionTextDualEncoder tokenizer object to the
directory `),eo=a("code"),Fr=n("save_directory"),Ir=n(`, so that it can be re-loaded using the
`),zt=a("a"),Ar=n("from_pretrained()"),Lr=n(" class method."),qr=d(),v(ue.$$.fragment),ko=d(),ne=a("h2"),ge=a("a"),to=a("span"),v(Se.$$.fragment),Sr=d(),oo=a("span"),Or=n("VisionTextDualEncoderModel"),Po=d(),M=a("div"),v(Oe.$$.fragment),Nr=d(),Ne=a("p"),Br=n(`This class can be used to initialize a vision-text dual encoder model with any pretrained vision autoencoding model
as the vision encoder and any pretrained text model as the text encoder. The vision and text encoders are loaded
via the `),no=a("code"),Wr=n("from_pretrained()"),Rr=n(` method. The projection layers are automatically added to
the model and should be fine-tuned on a downstream task, like contrastive image-text modeling.`),Jr=d(),Be=a("p"),Ur=n("In "),We=a("a"),Hr=n("LiT: Zero-Shot Transfer with Locked-image Text Tuning"),Zr=n(` it is shown how
leveraging pre-trained (locked/frozen) image and text model for contrastive learning yields significant improvment
on new zero-shot vision tasks such as image classification or retrieval.`),Gr=d(),ro=a("p"),Xr=n(`After such a Vision-Text-Dual-Encoder model has been trained/fine-tuned, it can be saved/loaded just like any other
models (see the examples for more information).`),Kr=d(),Re=a("p"),Qr=n("This model inherits from "),Mt=a("a"),Yr=n("PreTrainedModel"),ea=n(`. Check the superclass documentation for the generic
methods the library implements for all its model (such as downloading or saving, resizing the input embeddings,
pruning heads etc.)`),ta=d(),Je=a("p"),oa=n("This model is also a PyTorch "),Ue=a("a"),na=n("torch.nn.Module"),ra=n(`
subclass. Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to
general usage and behavior.`),aa=d(),S=a("div"),v(He.$$.fragment),sa=d(),re=a("p"),ia=n("The "),Ct=a("a"),la=n("VisionTextDualEncoderModel"),da=n(" forward method, overrides the "),ao=a("code"),ca=n("__call__"),ma=n(" special method."),fa=d(),v(_e.$$.fragment),pa=d(),so=a("p"),ha=n("Examples:"),ua=d(),v(Ze.$$.fragment),jo=d(),ae=a("h2"),ve=a("a"),io=a("span"),v(Ge.$$.fragment),ga=d(),lo=a("span"),_a=n("FlaxVisionTextDualEncoderModel"),zo=d(),y=a("div"),v(Xe.$$.fragment),va=d(),Ke=a("p"),xa=n(`This class can be used to initialize a vision-text dual encoder model with any pretrained vision autoencoding model
as the vision encoder and any pretrained text model as the text encoder. The vision and text encoders are loaded
via the `),co=a("code"),Ta=n("from_pretrained()"),Ea=n(` method. The projection layers are automatically added
to the model and should be fine-tuned on a downstream task, like contrastive image-text modeling.`),ba=d(),Qe=a("p"),$a=n("In "),Ye=a("a"),ya=n("LiT: Zero-Shot Transfer with Locked-image Text Tuning"),wa=n(` it is shown how
leveraging pre-trained (locked/frozen) image and text model for contrastive learning yields significant improvment
on new zero-shot vision tasks such as image classification or retrieval.`),Da=d(),mo=a("p"),Va=n(`After such a Vision-Text-Dual-Encoder model has been trained/fine-tuned, it can be saved/loaded just like any other
models (see the examples for more information).`),ka=d(),et=a("p"),Pa=n("This model inherits from "),Ft=a("a"),ja=n("PreTrainedModel"),za=n(`. Check the superclass documentation for the generic
methods the library implements for all its model (such as downloading or saving, resizing the input embeddings,
pruning heads etc.)`),Ma=d(),tt=a("p"),Ca=n("This model is also a Flax Linen "),ot=a("a"),Fa=n("flax.linen.Module"),Ia=n(` subclass. Use it as a regular Flax linen Module
and refer to the Flax documentation for all matter related to general usage and behavior.`),Aa=d(),fo=a("p"),La=n("Finally, this model supports inherent JAX features such as:"),qa=d(),U=a("ul"),po=a("li"),nt=a("a"),Sa=n("Just-In-Time (JIT) compilation"),Oa=d(),ho=a("li"),rt=a("a"),Na=n("Automatic Differentiation"),Ba=d(),uo=a("li"),at=a("a"),Wa=n("Vectorization"),Ra=d(),go=a("li"),st=a("a"),Ja=n("Parallelization"),Ua=d(),O=a("div"),v(it.$$.fragment),Ha=d(),se=a("p"),Za=n("The "),It=a("a"),Ga=n("FlaxVisionTextDualEncoderModel"),Xa=n(" forward method, overrides the "),_o=a("code"),Ka=n("__call__"),Qa=n(" special method."),Ya=d(),v(xe.$$.fragment),es=d(),vo=a("p"),ts=n("Examples:"),os=d(),v(lt.$$.fragment),this.h()},l(o){const p=Ei('[data-svelte="svelte-1phssyn"]',document.head);m=s(p,"META",{name:!0,content:!0}),p.forEach(t),w=c(o),f=s(o,"H1",{class:!0});var dt=i(f);g=s(dt,"A",{id:!0,class:!0,href:!0});var xo=i(g);k=s(xo,"SPAN",{});var To=i(k);x(h.$$.fragment,To),To.forEach(t),xo.forEach(t),_=c(dt),P=s(dt,"SPAN",{});var Eo=i(P);I=r(Eo,"VisionTextDualEncoder"),Eo.forEach(t),dt.forEach(t),D=c(o),A=s(o,"H2",{class:!0});var Co=i(A);L=s(Co,"A",{id:!0,class:!0,href:!0});var rs=i(L);Wt=s(rs,"SPAN",{});var as=i(Wt);x(Ee.$$.fragment,as),as.forEach(t),rs.forEach(t),nn=c(Co),Rt=s(Co,"SPAN",{});var ss=i(Rt);rn=r(ss,"Overview"),ss.forEach(t),Co.forEach(t),bo=c(o),V=s(o,"P",{});var C=i(V);an=r(C,"The "),mt=s(C,"A",{href:!0});var is=i(mt);sn=r(is,"VisionTextDualEncoderModel"),is.forEach(t),ln=r(C,` can be used to initialize a vision-text dual encoder model with
any pretrained vision autoencoding model as the vision encoder (`),Jt=s(C,"EM",{});var ls=i(Jt);dn=r(ls,"e.g."),ls.forEach(t),cn=c(C),ft=s(C,"A",{href:!0});var ds=i(ft);mn=r(ds,"ViT"),ds.forEach(t),fn=r(C,", "),pt=s(C,"A",{href:!0});var cs=i(pt);pn=r(cs,"BEiT"),cs.forEach(t),hn=r(C,", "),ht=s(C,"A",{href:!0});var ms=i(ht);un=r(ms,"DeiT"),ms.forEach(t),gn=r(C,") and any pretrained text autoencoding model as the text encoder ("),Ut=s(C,"EM",{});var fs=i(Ut);_n=r(fs,"e.g."),fs.forEach(t),vn=c(C),ut=s(C,"A",{href:!0});var ps=i(ut);xn=r(ps,"RoBERTa"),ps.forEach(t),Tn=r(C,", "),gt=s(C,"A",{href:!0});var hs=i(gt);En=r(hs,"BERT"),hs.forEach(t),bn=r(C,`). Two projection layers are added on top of both the vision and text encoder to project the output embeddings
to a shared latent space. The projection layers are randomly initialized so the model should be fine-tuned on a
downstream task. This model can be used to align the vision-text embeddings using CLIP like contrastive image-text
training and then can be used for zero-shot vision tasks such image-classification or retrieval.`),C.forEach(t),$o=c(o),ie=s(o,"P",{});var Fo=i(ie);$n=r(Fo,"In "),be=s(Fo,"A",{href:!0,rel:!0});var us=i(be);yn=r(us,"LiT: Zero-Shot Transfer with Locked-image Text Tuning"),us.forEach(t),wn=r(Fo,` it is shown how
leveraging pre-trained (locked/frozen) image and text model for contrastive learning yields significant improvment on
new zero-shot vision tasks such as image classification or retrieval.`),Fo.forEach(t),yo=c(o),Y=s(o,"H2",{class:!0});var Io=i(Y);le=s(Io,"A",{id:!0,class:!0,href:!0});var gs=i(le);Ht=s(gs,"SPAN",{});var _s=i(Ht);x($e.$$.fragment,_s),_s.forEach(t),gs.forEach(t),Dn=c(Io),Zt=s(Io,"SPAN",{});var vs=i(Zt);Vn=r(vs,"VisionTextDualEncoderConfig"),vs.forEach(t),Io.forEach(t),wo=c(o),j=s(o,"DIV",{class:!0});var N=i(j);x(ye.$$.fragment,N),kn=c(N),Z=s(N,"P",{});var ct=i(Z);_t=s(ct,"A",{href:!0});var xs=i(_t);Pn=r(xs,"VisionTextDualEncoderConfig"),xs.forEach(t),jn=r(ct,` is the configuration class to store the configuration of a
`),vt=s(ct,"A",{href:!0});var Ts=i(vt);zn=r(Ts,"VisionTextDualEncoderModel"),Ts.forEach(t),Mn=r(ct,`. It is used to instantiate
`),xt=s(ct,"A",{href:!0});var Es=i(xt);Cn=r(Es,"VisionTextDualEncoderModel"),Es.forEach(t),Fn=r(ct,` model according to the specified arguments, defining the text
model and vision model configs.`),ct.forEach(t),In=c(N),ee=s(N,"P",{});var At=i(ee);An=r(At,"Configuration objects inherit from "),Tt=s(At,"A",{href:!0});var bs=i(Tt);Ln=r(bs,"PretrainedConfig"),bs.forEach(t),qn=r(At,` and can be used to control the model
outputs. Read the documentation from `),Et=s(At,"A",{href:!0});var $s=i(Et);Sn=r($s,"PretrainedConfig"),$s.forEach(t),On=r(At," for more information."),At.forEach(t),Nn=c(N),Gt=s(N,"P",{});var ys=i(Gt);Bn=r(ys,"Examples:"),ys.forEach(t),Wn=c(N),x(we.$$.fragment,N),Rn=c(N),de=s(N,"DIV",{class:!0});var Ao=i(de);x(De.$$.fragment,Ao),Jn=c(Ao),Ve=s(Ao,"P",{});var Lo=i(Ve);Un=r(Lo,"Instantiate a "),bt=s(Lo,"A",{href:!0});var ws=i(bt);Hn=r(ws,"VisionTextDualEncoderConfig"),ws.forEach(t),Zn=r(Lo,` (or a derived class) from text model configuration and
vision model configuration.`),Lo.forEach(t),Ao.forEach(t),Gn=c(N),ce=s(N,"DIV",{class:!0});var qo=i(ce);x(ke.$$.fragment,qo),Xn=c(qo),Pe=s(qo,"P",{});var So=i(Pe);Kn=r(So,`Serializes this instance to a Python dictionary. Override the default
`),$t=s(So,"A",{href:!0});var Ds=i($t);Qn=r(Ds,"to_dict()"),Ds.forEach(t),Yn=r(So,"."),So.forEach(t),qo.forEach(t),N.forEach(t),Do=c(o),te=s(o,"H2",{class:!0});var Oo=i(te);me=s(Oo,"A",{id:!0,class:!0,href:!0});var Vs=i(me);Xt=s(Vs,"SPAN",{});var ks=i(Xt);x(je.$$.fragment,ks),ks.forEach(t),Vs.forEach(t),er=c(Oo),Kt=s(Oo,"SPAN",{});var Ps=i(Kt);tr=r(Ps,"VisionTextDualEncoderProcessor"),Ps.forEach(t),Oo.forEach(t),Vo=c(o),z=s(o,"DIV",{class:!0});var B=i(z);x(ze.$$.fragment,B),or=c(B),Qt=s(B,"P",{});var js=i(Qt);nr=r(js,`Constructs a VisionTextDualEncoder processor which wraps a vision feature extractor and a tokenizer into a single
processor.`),js.forEach(t),rr=c(B),q=s(B,"P",{});var H=i(q);yt=s(H,"A",{href:!0});var zs=i(yt);ar=r(zs,"VisionTextDualEncoderProcessor"),zs.forEach(t),sr=r(H,` offers all the functionalities of
`),wt=s(H,"A",{href:!0});var Ms=i(wt);ir=r(Ms,"AutoFeatureExtractor"),Ms.forEach(t),lr=r(H," and "),Dt=s(H,"A",{href:!0});var Cs=i(Dt);dr=r(Cs,"AutoTokenizer"),Cs.forEach(t),cr=r(H,`. See the
`),Yt=s(H,"CODE",{});var Fs=i(Yt);mr=r(Fs,"__call__()"),Fs.forEach(t),fr=r(H,` and
`),Vt=s(H,"A",{href:!0});var Is=i(Vt);pr=r(Is,"decode()"),Is.forEach(t),hr=r(H," for more information."),H.forEach(t),ur=c(B),fe=s(B,"DIV",{class:!0});var No=i(fe);x(Me.$$.fragment,No),gr=c(No),Ce=s(No,"P",{});var Bo=i(Ce);_r=r(Bo,`This method forwards all its arguments to VisionTextDualEncoderTokenizer\u2019s
`),kt=s(Bo,"A",{href:!0});var As=i(kt);vr=r(As,"batch_decode()"),As.forEach(t),xr=r(Bo,`. Please refer to the docstring of this method for more
information.`),Bo.forEach(t),No.forEach(t),Tr=c(B),pe=s(B,"DIV",{class:!0});var Wo=i(pe);x(Fe.$$.fragment,Wo),Er=c(Wo),Ie=s(Wo,"P",{});var Ro=i(Ie);br=r(Ro,`This method forwards all its arguments to VisionTextDualEncoderTokenizer\u2019s
`),Pt=s(Ro,"A",{href:!0});var Ls=i(Pt);$r=r(Ls,"decode()"),Ls.forEach(t),yr=r(Ro,`. Please refer to the docstring of this method for more
information.`),Ro.forEach(t),Wo.forEach(t),wr=c(B),G=s(B,"DIV",{class:!0});var Lt=i(G);x(Ae.$$.fragment,Lt),Dr=c(Lt),Le=s(Lt,"P",{});var Jo=i(Le);Vr=r(Jo,"Instantiate a "),jt=s(Jo,"A",{href:!0});var qs=i(jt);kr=r(qs,"VisionTextDualEncoderProcessor"),qs.forEach(t),Pr=r(Jo,` from a pretrained VisionTextDualEncoder
processor.`),Jo.forEach(t),jr=c(Lt),x(he.$$.fragment,Lt),Lt.forEach(t),zr=c(B),X=s(B,"DIV",{class:!0});var qt=i(X);x(qe.$$.fragment,qt),Mr=c(qt),oe=s(qt,"P",{});var St=i(oe);Cr=r(St,`Save a VisionTextDualEncoder feature extractor object and VisionTextDualEncoder tokenizer object to the
directory `),eo=s(St,"CODE",{});var Ss=i(eo);Fr=r(Ss,"save_directory"),Ss.forEach(t),Ir=r(St,`, so that it can be re-loaded using the
`),zt=s(St,"A",{href:!0});var Os=i(zt);Ar=r(Os,"from_pretrained()"),Os.forEach(t),Lr=r(St," class method."),St.forEach(t),qr=c(qt),x(ue.$$.fragment,qt),qt.forEach(t),B.forEach(t),ko=c(o),ne=s(o,"H2",{class:!0});var Uo=i(ne);ge=s(Uo,"A",{id:!0,class:!0,href:!0});var Ns=i(ge);to=s(Ns,"SPAN",{});var Bs=i(to);x(Se.$$.fragment,Bs),Bs.forEach(t),Ns.forEach(t),Sr=c(Uo),oo=s(Uo,"SPAN",{});var Ws=i(oo);Or=r(Ws,"VisionTextDualEncoderModel"),Ws.forEach(t),Uo.forEach(t),Po=c(o),M=s(o,"DIV",{class:!0});var W=i(M);x(Oe.$$.fragment,W),Nr=c(W),Ne=s(W,"P",{});var Ho=i(Ne);Br=r(Ho,`This class can be used to initialize a vision-text dual encoder model with any pretrained vision autoencoding model
as the vision encoder and any pretrained text model as the text encoder. The vision and text encoders are loaded
via the `),no=s(Ho,"CODE",{});var Rs=i(no);Wr=r(Rs,"from_pretrained()"),Rs.forEach(t),Rr=r(Ho,` method. The projection layers are automatically added to
the model and should be fine-tuned on a downstream task, like contrastive image-text modeling.`),Ho.forEach(t),Jr=c(W),Be=s(W,"P",{});var Zo=i(Be);Ur=r(Zo,"In "),We=s(Zo,"A",{href:!0,rel:!0});var Js=i(We);Hr=r(Js,"LiT: Zero-Shot Transfer with Locked-image Text Tuning"),Js.forEach(t),Zr=r(Zo,` it is shown how
leveraging pre-trained (locked/frozen) image and text model for contrastive learning yields significant improvment
on new zero-shot vision tasks such as image classification or retrieval.`),Zo.forEach(t),Gr=c(W),ro=s(W,"P",{});var Us=i(ro);Xr=r(Us,`After such a Vision-Text-Dual-Encoder model has been trained/fine-tuned, it can be saved/loaded just like any other
models (see the examples for more information).`),Us.forEach(t),Kr=c(W),Re=s(W,"P",{});var Go=i(Re);Qr=r(Go,"This model inherits from "),Mt=s(Go,"A",{href:!0});var Hs=i(Mt);Yr=r(Hs,"PreTrainedModel"),Hs.forEach(t),ea=r(Go,`. Check the superclass documentation for the generic
methods the library implements for all its model (such as downloading or saving, resizing the input embeddings,
pruning heads etc.)`),Go.forEach(t),ta=c(W),Je=s(W,"P",{});var Xo=i(Je);oa=r(Xo,"This model is also a PyTorch "),Ue=s(Xo,"A",{href:!0,rel:!0});var Zs=i(Ue);na=r(Zs,"torch.nn.Module"),Zs.forEach(t),ra=r(Xo,`
subclass. Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to
general usage and behavior.`),Xo.forEach(t),aa=c(W),S=s(W,"DIV",{class:!0});var K=i(S);x(He.$$.fragment,K),sa=c(K),re=s(K,"P",{});var Ot=i(re);ia=r(Ot,"The "),Ct=s(Ot,"A",{href:!0});var Gs=i(Ct);la=r(Gs,"VisionTextDualEncoderModel"),Gs.forEach(t),da=r(Ot," forward method, overrides the "),ao=s(Ot,"CODE",{});var Xs=i(ao);ca=r(Xs,"__call__"),Xs.forEach(t),ma=r(Ot," special method."),Ot.forEach(t),fa=c(K),x(_e.$$.fragment,K),pa=c(K),so=s(K,"P",{});var Ks=i(so);ha=r(Ks,"Examples:"),Ks.forEach(t),ua=c(K),x(Ze.$$.fragment,K),K.forEach(t),W.forEach(t),jo=c(o),ae=s(o,"H2",{class:!0});var Ko=i(ae);ve=s(Ko,"A",{id:!0,class:!0,href:!0});var Qs=i(ve);io=s(Qs,"SPAN",{});var Ys=i(io);x(Ge.$$.fragment,Ys),Ys.forEach(t),Qs.forEach(t),ga=c(Ko),lo=s(Ko,"SPAN",{});var ei=i(lo);_a=r(ei,"FlaxVisionTextDualEncoderModel"),ei.forEach(t),Ko.forEach(t),zo=c(o),y=s(o,"DIV",{class:!0});var F=i(y);x(Xe.$$.fragment,F),va=c(F),Ke=s(F,"P",{});var Qo=i(Ke);xa=r(Qo,`This class can be used to initialize a vision-text dual encoder model with any pretrained vision autoencoding model
as the vision encoder and any pretrained text model as the text encoder. The vision and text encoders are loaded
via the `),co=s(Qo,"CODE",{});var ti=i(co);Ta=r(ti,"from_pretrained()"),ti.forEach(t),Ea=r(Qo,` method. The projection layers are automatically added
to the model and should be fine-tuned on a downstream task, like contrastive image-text modeling.`),Qo.forEach(t),ba=c(F),Qe=s(F,"P",{});var Yo=i(Qe);$a=r(Yo,"In "),Ye=s(Yo,"A",{href:!0,rel:!0});var oi=i(Ye);ya=r(oi,"LiT: Zero-Shot Transfer with Locked-image Text Tuning"),oi.forEach(t),wa=r(Yo,` it is shown how
leveraging pre-trained (locked/frozen) image and text model for contrastive learning yields significant improvment
on new zero-shot vision tasks such as image classification or retrieval.`),Yo.forEach(t),Da=c(F),mo=s(F,"P",{});var ni=i(mo);Va=r(ni,`After such a Vision-Text-Dual-Encoder model has been trained/fine-tuned, it can be saved/loaded just like any other
models (see the examples for more information).`),ni.forEach(t),ka=c(F),et=s(F,"P",{});var en=i(et);Pa=r(en,"This model inherits from "),Ft=s(en,"A",{href:!0});var ri=i(Ft);ja=r(ri,"PreTrainedModel"),ri.forEach(t),za=r(en,`. Check the superclass documentation for the generic
methods the library implements for all its model (such as downloading or saving, resizing the input embeddings,
pruning heads etc.)`),en.forEach(t),Ma=c(F),tt=s(F,"P",{});var tn=i(tt);Ca=r(tn,"This model is also a Flax Linen "),ot=s(tn,"A",{href:!0,rel:!0});var ai=i(ot);Fa=r(ai,"flax.linen.Module"),ai.forEach(t),Ia=r(tn,` subclass. Use it as a regular Flax linen Module
and refer to the Flax documentation for all matter related to general usage and behavior.`),tn.forEach(t),Aa=c(F),fo=s(F,"P",{});var si=i(fo);La=r(si,"Finally, this model supports inherent JAX features such as:"),si.forEach(t),qa=c(F),U=s(F,"UL",{});var Te=i(U);po=s(Te,"LI",{});var ii=i(po);nt=s(ii,"A",{href:!0,rel:!0});var li=i(nt);Sa=r(li,"Just-In-Time (JIT) compilation"),li.forEach(t),ii.forEach(t),Oa=c(Te),ho=s(Te,"LI",{});var di=i(ho);rt=s(di,"A",{href:!0,rel:!0});var ci=i(rt);Na=r(ci,"Automatic Differentiation"),ci.forEach(t),di.forEach(t),Ba=c(Te),uo=s(Te,"LI",{});var mi=i(uo);at=s(mi,"A",{href:!0,rel:!0});var fi=i(at);Wa=r(fi,"Vectorization"),fi.forEach(t),mi.forEach(t),Ra=c(Te),go=s(Te,"LI",{});var pi=i(go);st=s(pi,"A",{href:!0,rel:!0});var hi=i(st);Ja=r(hi,"Parallelization"),hi.forEach(t),pi.forEach(t),Te.forEach(t),Ua=c(F),O=s(F,"DIV",{class:!0});var Q=i(O);x(it.$$.fragment,Q),Ha=c(Q),se=s(Q,"P",{});var Nt=i(se);Za=r(Nt,"The "),It=s(Nt,"A",{href:!0});var ui=i(It);Ga=r(ui,"FlaxVisionTextDualEncoderModel"),ui.forEach(t),Xa=r(Nt," forward method, overrides the "),_o=s(Nt,"CODE",{});var gi=i(_o);Ka=r(gi,"__call__"),gi.forEach(t),Qa=r(Nt," special method."),Nt.forEach(t),Ya=c(Q),x(xe.$$.fragment,Q),es=c(Q),vo=s(Q,"P",{});var _i=i(vo);ts=r(_i,"Examples:"),_i.forEach(t),os=c(Q),x(lt.$$.fragment,Q),Q.forEach(t),F.forEach(t),this.h()},h(){l(m,"name","hf:doc:metadata"),l(m,"content",JSON.stringify(Vi)),l(g,"id","visiontextdualencoder"),l(g,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(g,"href","#visiontextdualencoder"),l(f,"class","relative group"),l(L,"id","overview"),l(L,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(L,"href","#overview"),l(A,"class","relative group"),l(mt,"href","/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderModel"),l(ft,"href","/docs/transformers/v4.15.0/en/vit"),l(pt,"href","/docs/transformers/v4.15.0/en/beit"),l(ht,"href","/docs/transformers/v4.15.0/en/deit"),l(ut,"href","/docs/transformers/v4.15.0/en/roberta"),l(gt,"href","/docs/transformers/v4.15.0/en/bert"),l(be,"href","https://arxiv.org/abs/2111.07991"),l(be,"rel","nofollow"),l(le,"id","transformers.VisionTextDualEncoderConfig"),l(le,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(le,"href","#transformers.VisionTextDualEncoderConfig"),l(Y,"class","relative group"),l(_t,"href","/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderConfig"),l(vt,"href","/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderModel"),l(xt,"href","/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderModel"),l(Tt,"href","/docs/transformers/v4.15.0/en/main_classes/configuration#transformers.PretrainedConfig"),l(Et,"href","/docs/transformers/v4.15.0/en/main_classes/configuration#transformers.PretrainedConfig"),l(bt,"href","/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderConfig"),l(de,"class","docstring"),l($t,"href","/docs/transformers/v4.15.0/en/main_classes/configuration#transformers.PretrainedConfig.to_dict"),l(ce,"class","docstring"),l(j,"class","docstring"),l(me,"id","transformers.VisionTextDualEncoderProcessor"),l(me,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(me,"href","#transformers.VisionTextDualEncoderProcessor"),l(te,"class","relative group"),l(yt,"href","/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderProcessor"),l(wt,"href","/docs/transformers/v4.15.0/en/model_doc/auto#transformers.AutoFeatureExtractor"),l(Dt,"href","/docs/transformers/v4.15.0/en/model_doc/auto#transformers.AutoTokenizer"),l(Vt,"href","/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderProcessor.decode"),l(kt,"href","/docs/transformers/v4.15.0/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.batch_decode"),l(fe,"class","docstring"),l(Pt,"href","/docs/transformers/v4.15.0/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.decode"),l(pe,"class","docstring"),l(jt,"href","/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderProcessor"),l(G,"class","docstring"),l(zt,"href","/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderProcessor.from_pretrained"),l(X,"class","docstring"),l(z,"class","docstring"),l(ge,"id","transformers.VisionTextDualEncoderModel"),l(ge,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(ge,"href","#transformers.VisionTextDualEncoderModel"),l(ne,"class","relative group"),l(We,"href","https://arxiv.org/abs/2111.07991"),l(We,"rel","nofollow"),l(Mt,"href","/docs/transformers/v4.15.0/en/main_classes/model#transformers.PreTrainedModel"),l(Ue,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),l(Ue,"rel","nofollow"),l(Ct,"href","/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.VisionTextDualEncoderModel"),l(S,"class","docstring"),l(M,"class","docstring"),l(ve,"id","transformers.FlaxVisionTextDualEncoderModel"),l(ve,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(ve,"href","#transformers.FlaxVisionTextDualEncoderModel"),l(ae,"class","relative group"),l(Ye,"href","https://arxiv.org/abs/2111.07991"),l(Ye,"rel","nofollow"),l(Ft,"href","/docs/transformers/v4.15.0/en/main_classes/model#transformers.PreTrainedModel"),l(ot,"href","https://flax.readthedocs.io/en/latest/flax.linen.html#module"),l(ot,"rel","nofollow"),l(nt,"href","https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit"),l(nt,"rel","nofollow"),l(rt,"href","https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation"),l(rt,"rel","nofollow"),l(at,"href","https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap"),l(at,"rel","nofollow"),l(st,"href","https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap"),l(st,"rel","nofollow"),l(It,"href","/docs/transformers/v4.15.0/en/model_doc/vision_text_dual_encoder#transformers.FlaxVisionTextDualEncoderModel"),l(O,"class","docstring"),l(y,"class","docstring")},m(o,p){e(document.head,m),u(o,w,p),u(o,f,p),e(f,g),e(g,k),T(h,k,null),e(f,_),e(f,P),e(P,I),u(o,D,p),u(o,A,p),e(A,L),e(L,Wt),T(Ee,Wt,null),e(A,nn),e(A,Rt),e(Rt,rn),u(o,bo,p),u(o,V,p),e(V,an),e(V,mt),e(mt,sn),e(V,ln),e(V,Jt),e(Jt,dn),e(V,cn),e(V,ft),e(ft,mn),e(V,fn),e(V,pt),e(pt,pn),e(V,hn),e(V,ht),e(ht,un),e(V,gn),e(V,Ut),e(Ut,_n),e(V,vn),e(V,ut),e(ut,xn),e(V,Tn),e(V,gt),e(gt,En),e(V,bn),u(o,$o,p),u(o,ie,p),e(ie,$n),e(ie,be),e(be,yn),e(ie,wn),u(o,yo,p),u(o,Y,p),e(Y,le),e(le,Ht),T($e,Ht,null),e(Y,Dn),e(Y,Zt),e(Zt,Vn),u(o,wo,p),u(o,j,p),T(ye,j,null),e(j,kn),e(j,Z),e(Z,_t),e(_t,Pn),e(Z,jn),e(Z,vt),e(vt,zn),e(Z,Mn),e(Z,xt),e(xt,Cn),e(Z,Fn),e(j,In),e(j,ee),e(ee,An),e(ee,Tt),e(Tt,Ln),e(ee,qn),e(ee,Et),e(Et,Sn),e(ee,On),e(j,Nn),e(j,Gt),e(Gt,Bn),e(j,Wn),T(we,j,null),e(j,Rn),e(j,de),T(De,de,null),e(de,Jn),e(de,Ve),e(Ve,Un),e(Ve,bt),e(bt,Hn),e(Ve,Zn),e(j,Gn),e(j,ce),T(ke,ce,null),e(ce,Xn),e(ce,Pe),e(Pe,Kn),e(Pe,$t),e($t,Qn),e(Pe,Yn),u(o,Do,p),u(o,te,p),e(te,me),e(me,Xt),T(je,Xt,null),e(te,er),e(te,Kt),e(Kt,tr),u(o,Vo,p),u(o,z,p),T(ze,z,null),e(z,or),e(z,Qt),e(Qt,nr),e(z,rr),e(z,q),e(q,yt),e(yt,ar),e(q,sr),e(q,wt),e(wt,ir),e(q,lr),e(q,Dt),e(Dt,dr),e(q,cr),e(q,Yt),e(Yt,mr),e(q,fr),e(q,Vt),e(Vt,pr),e(q,hr),e(z,ur),e(z,fe),T(Me,fe,null),e(fe,gr),e(fe,Ce),e(Ce,_r),e(Ce,kt),e(kt,vr),e(Ce,xr),e(z,Tr),e(z,pe),T(Fe,pe,null),e(pe,Er),e(pe,Ie),e(Ie,br),e(Ie,Pt),e(Pt,$r),e(Ie,yr),e(z,wr),e(z,G),T(Ae,G,null),e(G,Dr),e(G,Le),e(Le,Vr),e(Le,jt),e(jt,kr),e(Le,Pr),e(G,jr),T(he,G,null),e(z,zr),e(z,X),T(qe,X,null),e(X,Mr),e(X,oe),e(oe,Cr),e(oe,eo),e(eo,Fr),e(oe,Ir),e(oe,zt),e(zt,Ar),e(oe,Lr),e(X,qr),T(ue,X,null),u(o,ko,p),u(o,ne,p),e(ne,ge),e(ge,to),T(Se,to,null),e(ne,Sr),e(ne,oo),e(oo,Or),u(o,Po,p),u(o,M,p),T(Oe,M,null),e(M,Nr),e(M,Ne),e(Ne,Br),e(Ne,no),e(no,Wr),e(Ne,Rr),e(M,Jr),e(M,Be),e(Be,Ur),e(Be,We),e(We,Hr),e(Be,Zr),e(M,Gr),e(M,ro),e(ro,Xr),e(M,Kr),e(M,Re),e(Re,Qr),e(Re,Mt),e(Mt,Yr),e(Re,ea),e(M,ta),e(M,Je),e(Je,oa),e(Je,Ue),e(Ue,na),e(Je,ra),e(M,aa),e(M,S),T(He,S,null),e(S,sa),e(S,re),e(re,ia),e(re,Ct),e(Ct,la),e(re,da),e(re,ao),e(ao,ca),e(re,ma),e(S,fa),T(_e,S,null),e(S,pa),e(S,so),e(so,ha),e(S,ua),T(Ze,S,null),u(o,jo,p),u(o,ae,p),e(ae,ve),e(ve,io),T(Ge,io,null),e(ae,ga),e(ae,lo),e(lo,_a),u(o,zo,p),u(o,y,p),T(Xe,y,null),e(y,va),e(y,Ke),e(Ke,xa),e(Ke,co),e(co,Ta),e(Ke,Ea),e(y,ba),e(y,Qe),e(Qe,$a),e(Qe,Ye),e(Ye,ya),e(Qe,wa),e(y,Da),e(y,mo),e(mo,Va),e(y,ka),e(y,et),e(et,Pa),e(et,Ft),e(Ft,ja),e(et,za),e(y,Ma),e(y,tt),e(tt,Ca),e(tt,ot),e(ot,Fa),e(tt,Ia),e(y,Aa),e(y,fo),e(fo,La),e(y,qa),e(y,U),e(U,po),e(po,nt),e(nt,Sa),e(U,Oa),e(U,ho),e(ho,rt),e(rt,Na),e(U,Ba),e(U,uo),e(uo,at),e(at,Wa),e(U,Ra),e(U,go),e(go,st),e(st,Ja),e(y,Ua),e(y,O),T(it,O,null),e(O,Ha),e(O,se),e(se,Za),e(se,It),e(It,Ga),e(se,Xa),e(se,_o),e(_o,Ka),e(se,Qa),e(O,Ya),T(xe,O,null),e(O,es),e(O,vo),e(vo,ts),e(O,os),T(lt,O,null),Mo=!0},p(o,[p]){const dt={};p&2&&(dt.$$scope={dirty:p,ctx:o}),he.$set(dt);const xo={};p&2&&(xo.$$scope={dirty:p,ctx:o}),ue.$set(xo);const To={};p&2&&(To.$$scope={dirty:p,ctx:o}),_e.$set(To);const Eo={};p&2&&(Eo.$$scope={dirty:p,ctx:o}),xe.$set(Eo)},i(o){Mo||(E(h.$$.fragment,o),E(Ee.$$.fragment,o),E($e.$$.fragment,o),E(ye.$$.fragment,o),E(we.$$.fragment,o),E(De.$$.fragment,o),E(ke.$$.fragment,o),E(je.$$.fragment,o),E(ze.$$.fragment,o),E(Me.$$.fragment,o),E(Fe.$$.fragment,o),E(Ae.$$.fragment,o),E(he.$$.fragment,o),E(qe.$$.fragment,o),E(ue.$$.fragment,o),E(Se.$$.fragment,o),E(Oe.$$.fragment,o),E(He.$$.fragment,o),E(_e.$$.fragment,o),E(Ze.$$.fragment,o),E(Ge.$$.fragment,o),E(Xe.$$.fragment,o),E(it.$$.fragment,o),E(xe.$$.fragment,o),E(lt.$$.fragment,o),Mo=!0)},o(o){b(h.$$.fragment,o),b(Ee.$$.fragment,o),b($e.$$.fragment,o),b(ye.$$.fragment,o),b(we.$$.fragment,o),b(De.$$.fragment,o),b(ke.$$.fragment,o),b(je.$$.fragment,o),b(ze.$$.fragment,o),b(Me.$$.fragment,o),b(Fe.$$.fragment,o),b(Ae.$$.fragment,o),b(he.$$.fragment,o),b(qe.$$.fragment,o),b(ue.$$.fragment,o),b(Se.$$.fragment,o),b(Oe.$$.fragment,o),b(He.$$.fragment,o),b(_e.$$.fragment,o),b(Ze.$$.fragment,o),b(Ge.$$.fragment,o),b(Xe.$$.fragment,o),b(it.$$.fragment,o),b(xe.$$.fragment,o),b(lt.$$.fragment,o),Mo=!1},d(o){t(m),o&&t(w),o&&t(f),$(h),o&&t(D),o&&t(A),$(Ee),o&&t(bo),o&&t(V),o&&t($o),o&&t(ie),o&&t(yo),o&&t(Y),$($e),o&&t(wo),o&&t(j),$(ye),$(we),$(De),$(ke),o&&t(Do),o&&t(te),$(je),o&&t(Vo),o&&t(z),$(ze),$(Me),$(Fe),$(Ae),$(he),$(qe),$(ue),o&&t(ko),o&&t(ne),$(Se),o&&t(Po),o&&t(M),$(Oe),$(He),$(_e),$(Ze),o&&t(jo),o&&t(ae),$(Ge),o&&t(zo),o&&t(y),$(Xe),$(it),$(xe),$(lt)}}}const Vi={local:"visiontextdualencoder",sections:[{local:"overview",title:"Overview"},{local:"transformers.VisionTextDualEncoderConfig",title:"VisionTextDualEncoderConfig"},{local:"transformers.VisionTextDualEncoderProcessor",title:"VisionTextDualEncoderProcessor"},{local:"transformers.VisionTextDualEncoderModel",title:"VisionTextDualEncoderModel"},{local:"transformers.FlaxVisionTextDualEncoderModel",title:"FlaxVisionTextDualEncoderModel"}],title:"VisionTextDualEncoder"};function ki(J,m,w){let{fw:f}=m;return J.$$set=g=>{"fw"in g&&w(0,f=g.fw)},[f]}class Ii extends vi{constructor(m){super();xi(this,m,ki,Di,Ti,{fw:0})}}export{Ii as default,Vi as metadata};
