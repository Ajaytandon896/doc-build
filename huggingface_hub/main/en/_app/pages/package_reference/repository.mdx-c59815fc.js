import{S as eg,i as tg,s as og,e as n,k as c,w as u,t as s,M as ng,c as r,d as o,m as l,a,x as d,h as i,b as p,F as e,g as $,y as f,L as rg,q as m,o as _,B as b,v as ag}from"../../chunks/vendor-7b1da053.js";import{D as y}from"../../chunks/Docstring-f1352b16.js";import{C as sg}from"../../chunks/CodeBlock-5f39b59e.js";import{I as Er}from"../../chunks/IconCopyLink-d24e9a6f.js";function ig(_c){let V,$n,A,oe,Ut,He,kr,Mt,Dr,wn,E,Rr,Wt,xr,Tr,Bt,Pr,Ir,Gt,Or,Lr,En,ne,Cr,zt,Fr,Nr,kn,S,re,Jt,Ve,jr,Kt,Hr,Dn,g,Ae,Vr,Qt,Ar,Sr,Xt,qr,Ur,k,Se,Mr,Yt,Wr,Br,q,Gr,Zt,zr,Jr,eo,Kr,Qr,Xr,D,to,Yr,Zr,oo,ea,ta,no,oa,na,ro,ra,aa,sa,ae,qe,ia,ao,ca,la,R,Ue,ga,so,ha,pa,io,ua,da,co,fa,ma,se,Me,_a,lo,ba,va,ie,We,ya,U,$a,go,wa,Ea,ho,ka,Da,Ra,C,Be,xa,po,Ta,Pa,uo,Ia,Oa,x,Ge,La,M,Ca,fo,Fa,Na,mo,ja,Ha,Va,_o,Aa,Sa,ze,qa,ce,Je,Ua,bo,Ma,Wa,F,Ke,Ba,vo,Ga,za,I,Ja,yo,Ka,Qa,$o,Xa,Ya,wo,Za,es,ts,N,Qe,os,Eo,ns,rs,W,as,ko,ss,is,Do,cs,ls,gs,le,Xe,hs,Ro,ps,us,ge,Ye,ds,xo,fs,ms,he,Ze,_s,Pt,bs,To,vs,ys,pe,et,$s,Po,ws,Es,ue,tt,ks,Io,Ds,Rs,de,ot,xs,Oo,Ts,Ps,j,nt,Is,Lo,Os,Ls,B,Cs,Co,Fs,Ns,Fo,js,Hs,Vs,fe,rt,As,No,Ss,qs,me,at,Us,jo,Ms,Ws,_e,st,Bs,Ho,Gs,zs,be,it,Js,Vo,Ks,Qs,H,ct,Xs,Ao,Ys,Zs,O,ei,So,ti,oi,qo,ni,ri,Uo,ai,si,ii,ve,lt,ci,Mo,li,gi,ye,gt,hi,Wo,pi,ui,$e,ht,di,Bo,fi,mi,we,pt,_i,Go,bi,vi,Ee,ut,yi,zo,$i,Rn,G,ke,Jo,dt,wi,Ko,Ei,xn,z,ft,ki,Qo,Di,Tn,J,mt,Ri,Xo,xi,Pn,K,_t,Ti,Yo,Pi,In,Q,bt,Ii,Zo,Oi,On,X,vt,Li,en,Ci,Ln,Y,yt,Fi,tn,Ni,Cn,L,$t,ji,on,Hi,Vi,nn,Ai,Fn,Z,De,rn,wt,Si,an,qi,Nn,Re,Ui,sn,Mi,Wi,jn,T,cn,ln,Bi,Gi,gn,hn,zi,Ji,pn,un,Ki,Qi,Et,Xi,dn,Yi,Zi,Hn,It,ec,Vn,w,kt,tc,fn,oc,nc,mn,rc,ac,xe,Dt,sc,_n,ic,cc,Te,Rt,lc,bn,gc,hc,Pe,xt,pc,vn,uc,An,ee,Tt,dc,yn,fc,Sn;return He=new Er({}),Ve=new Er({}),Ae=new y({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L423"}}),Se=new y({props:{name:"__init__",anchor:"huggingface_hub.Repository.__init__",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L434",parametersDescription:[{anchor:"huggingface_hub.Repository.__init__.local_dir",description:`<strong>local_dir</strong> (<code>str</code>) &#x2014;
path (e.g. <code>&apos;my_trained_model/&apos;</code>) to the local directory, where
the <code>Repository</code> will be initalized.`,name:"local_dir"},{anchor:"huggingface_hub.Repository.__init__.clone_from",description:`<strong>clone_from</strong> (<code>str</code>, <em>optional</em>) &#x2014;
repository url (e.g.
<code>&apos;https://huggingface.co/philschmid/playground-tests&apos;</code>).`,name:"clone_from"},{anchor:"huggingface_hub.Repository.__init__.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
To set when creating a repo: et to &#x201C;dataset&#x201D; or &#x201C;space&#x201D; if
creating a dataset or space, default is model.`,name:"repo_type"},{anchor:"huggingface_hub.Repository.__init__.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code> or <code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
huggingface_token can be extract from <code>HfApi().login(username, password)</code> and is used to authenticate against the hub (useful
from Google Colab for instance).`,name:"use_auth_token"},{anchor:"huggingface_hub.Repository.__init__.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.name</code> for committing and
pushing files to the hub.`,name:"git_user"},{anchor:"huggingface_hub.Repository.__init__.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.email</code> for committing and
pushing files to the hub.`,name:"git_email"},{anchor:"huggingface_hub.Repository.__init__.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Revision to checkout after initializing the repository. If the
revision doesn&#x2019;t exist, a branch will be created with that
revision name from the default branch&#x2019;s current HEAD.`,name:"revision"},{anchor:"huggingface_hub.Repository.__init__.private",description:`<strong>private</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether the repository is private or not.`,name:"private"},{anchor:"huggingface_hub.Repository.__init__.skip_lfs_files",description:`<strong>skip_lfs_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether to skip git-LFS files or not.`,name:"skip_lfs_files"},{anchor:"huggingface_hub.Repository.__init__.client",description:`<strong>client</strong> (<code>HfApi</code>, <em>optional</em>) &#x2014;
Instance of HfApi to use when calling the HF Hub API.
A new instance will be created if this is left to <code>None</code>.`,name:"client"}]}}),qe=new y({props:{name:"current_branch",anchor:"huggingface_hub.Repository.current_branch",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L543",returnDescription:`
<p>Current checked out branch.</p>
`,returnType:`
<p><code>str</code></p>
`}}),Ue=new y({props:{name:"add_tag",anchor:"huggingface_hub.Repository.add_tag",parameters:[{name:"tag_name",val:": str"},{name:"message",val:": str = None"},{name:"remote",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1377",parametersDescription:[{anchor:"huggingface_hub.Repository.add_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to be added.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.add_tag.message",description:`<strong>message</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The message that accompanies the tag. The tag will turn into an
annotated tag if a message is passed.`,name:"message"},{anchor:"huggingface_hub.Repository.add_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to add the tag.`,name:"remote"}]}}),Me=new y({props:{name:"auto_track_large_files",anchor:"huggingface_hub.Repository.auto_track_large_files",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L984",parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_large_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are above 10MBs.`,name:"pattern"}],returnDescription:`
<p>List of filenames that are now tracked due to their
size.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),We=new y({props:{name:"check_git_versions",anchor:"huggingface_hub.Repository.check_git_versions",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L566"}}),Be=new y({props:{name:"clone_from",anchor:"huggingface_hub.Repository.clone_from",parameters:[{name:"repo_url",val:": str"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L602",parametersDescription:[{anchor:"huggingface_hub.Repository.clone_from.repo_url",description:`<strong>repo_url</strong> (<code>str</code>) &#x2014;
The URL from which to clone the repository`,name:"repo_url"},{anchor:"huggingface_hub.Repository.clone_from.use_auth_token",description:`<strong>use_auth_token</strong> (<code>Union[str, bool]</code>, <em>optional</em>) &#x2014;
Whether to use the authentication token. It can be:<ul>
<li>a string which is the token itself</li>
<li><code>False</code>, which would not use the authentication token</li>
<li><code>True</code>, which would fetch the authentication token from the
local folder and use it (you should be logged in for this to
work).</li>
<li><code>None</code>, which would retrieve the value of
<code>self.huggingface_token</code>.</li>
</ul>`,name:"use_auth_token"}]}}),Ge=new y({props:{name:"commit",anchor:"huggingface_hub.Repository.commit",parameters:[{name:"commit_message",val:": str"},{name:"branch",val:": typing.Optional[str] = None"},{name:"track_large_files",val:": typing.Optional[bool] = True"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1481",parametersDescription:[{anchor:"huggingface_hub.Repository.commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.commit.branch",description:`<strong>branch</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The branch on which the commit will appear. This branch will be
checked-out before any operation.`,name:"branch"},{anchor:"huggingface_hub.Repository.commit.track_large_files",description:`<strong>track_large_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to automatically track large files or not. Will do so by
default.`,name:"track_large_files"},{anchor:"huggingface_hub.Repository.commit.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.commit.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}]}}),ze=new sg({props:{code:`with Repository(
    "text-files",
    clone_from="<user>/text-files",
    use_auth_token=True,
).commit("My first file :)"):
    with open("file.txt", "w+") as f:
        f.write(json.dumps({"hey": 8}))

import torch

model = torch.nn.Transformer()
with Repository(
    "torch-model",
    clone_from="<user>/torch-model",
    use_auth_token=True,
).commit("My cool model :)"):
    torch.save(model.state_dict(), "model.pt")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;text-files&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/text-files&quot;</span>,
<span class="hljs-meta">... </span>    use_auth_token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My first file :)&quot;</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>) <span class="hljs-keyword">as</span> f:
<span class="hljs-meta">... </span>        f.write(json.dumps({<span class="hljs-string">&quot;hey&quot;</span>: <span class="hljs-number">8</span>}))

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>model = torch.nn.Transformer()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;torch-model&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/torch-model&quot;</span>,
<span class="hljs-meta">... </span>    use_auth_token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My cool model :)&quot;</span>):
<span class="hljs-meta">... </span>    torch.save(model.state_dict(), <span class="hljs-string">&quot;model.pt&quot;</span>)`}}),Je=new y({props:{name:"delete_tag",anchor:"huggingface_hub.Repository.delete_tag",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1326",parametersDescription:[{anchor:"huggingface_hub.Repository.delete_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The tag name to delete.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.delete_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to delete the tag.`,name:"remote"}],returnDescription:`
<p><code>True</code> if deleted, <code>False</code> if the tag didn\u2019t exist.
If remote is not passed, will just be updated locally</p>
`,returnType:`
<p><code>bool</code></p>
`}}),Ke=new y({props:{name:"git_add",anchor:"huggingface_hub.Repository.git_add",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"},{name:"auto_lfs_track",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1080",parametersDescription:[{anchor:"huggingface_hub.Repository.git_add.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to add files to staging.`,name:"pattern"},{anchor:"huggingface_hub.Repository.git_add.auto_lfs_track",description:`<strong>auto_lfs_track</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically track large files with git-lfs. Any
file over 10MB in size will be automatically tracked.`,name:"auto_lfs_track"}]}}),Qe=new y({props:{name:"git_checkout",anchor:"huggingface_hub.Repository.git_checkout",parameters:[{name:"revision",val:": str"},{name:"create_branch_ok",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1234",parametersDescription:[{anchor:"huggingface_hub.Repository.git_checkout.revision",description:`<strong>revision</strong> (<code>str</code>) &#x2014;
The revision to checkout.`,name:"revision"},{anchor:"huggingface_hub.Repository.git_checkout.create_branch_ok",description:`<strong>create_branch_ok</strong> (<code>str</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether creating a branch named with the <code>revision</code> passed at
the current checked-out reference if <code>revision</code> isn&#x2019;t an
existing revision is allowed.`,name:"create_branch_ok"}]}}),Xe=new y({props:{name:"git_commit",anchor:"huggingface_hub.Repository.git_commit",parameters:[{name:"commit_message",val:": str = 'commit files to HF hub'"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1116",parametersDescription:[{anchor:"huggingface_hub.Repository.git_commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201C;commit files to HF hub&#x201D;) &#x2014;
The message attributed to the commit.`,name:"commit_message"}]}}),Ye=new y({props:{name:"git_config_username_and_email",anchor:"huggingface_hub.Repository.git_config_username_and_email",parameters:[{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L753",parametersDescription:[{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The username to register through <code>git</code>.`,name:"git_user"},{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The email to register through <code>git</code>.`,name:"git_email"}]}}),Ze=new y({props:{name:"git_credential_helper_store",anchor:"huggingface_hub.Repository.git_credential_helper_store",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L787"}}),et=new y({props:{name:"git_head_commit_url",anchor:"huggingface_hub.Repository.git_head_commit_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L845",returnDescription:`
<p>The URL to the current checked-out commit.</p>
`,returnType:`
<p><code>str</code></p>
`}}),tt=new y({props:{name:"git_head_hash",anchor:"huggingface_hub.Repository.git_head_hash",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L803",returnDescription:`
<p>The current checked out commit SHA.</p>
`,returnType:`
<p><code>str</code></p>
`}}),ot=new y({props:{name:"git_pull",anchor:"huggingface_hub.Repository.git_pull",parameters:[{name:"rebase",val:": typing.Optional[bool] = False"},{name:"lfs",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1049",parametersDescription:[{anchor:"huggingface_hub.Repository.git_pull.rebase",description:`<strong>rebase</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to rebase the current branch on top of the upstream
branch after fetching.`,name:"rebase"},{anchor:"huggingface_hub.Repository.git_pull.lfs",description:`<strong>lfs</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to fetch the LFS files too. This option only changes the
behavior when a repository was cloned without fetching the LFS
files; calling <code>repo.git_pull(lfs=True)</code> will then fetch the LFS
file from the remote repository.`,name:"lfs"}]}}),nt=new y({props:{name:"git_push",anchor:"huggingface_hub.Repository.git_push",parameters:[{name:"upstream",val:": typing.Optional[str] = None"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1140",parametersDescription:[{anchor:"huggingface_hub.Repository.git_push.upstream",description:`<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Upstream to which this should push. If not specified, will push
to the lastly defined upstream or to the default one (<code>origin main</code>).`,name:"upstream"},{anchor:"huggingface_hub.Repository.git_push.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the push has
finished. Setting this to <code>False</code> will return an
<code>CommandInProgress</code> object which has an <code>is_done</code> property. This
property will be set to <code>True</code> when the push is finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.git_push.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}]}}),rt=new y({props:{name:"git_remote_url",anchor:"huggingface_hub.Repository.git_remote_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L823",returnDescription:`
<p>The URL of the <code>origin</code> remote.</p>
`,returnType:`
<p><code>str</code></p>
`}}),at=new y({props:{name:"is_repo_clean",anchor:"huggingface_hub.Repository.is_repo_clean",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1424",returnDescription:`
<p><code>True</code> if the git status is clean, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),st=new y({props:{name:"lfs_enable_largefiles",anchor:"huggingface_hub.Repository.lfs_enable_largefiles",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L960"}}),it=new y({props:{name:"lfs_prune",anchor:"huggingface_hub.Repository.lfs_prune",parameters:[{name:"recent",val:" = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1021",parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_prune.recent",description:`<strong>recent</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to prune files even if they were referenced by recent
commits. See the following
<a href="https://github.com/git-lfs/git-lfs/blob/f3d43f0428a84fc4f1e5405b76b5a73ec2437e65/docs/man/git-lfs-prune.1.ronn#recent-files" rel="nofollow">link</a>
for more information.`,name:"recent"}]}}),ct=new y({props:{name:"lfs_track",anchor:"huggingface_hub.Repository.lfs_track",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"},{name:"filename",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L905",parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_track.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to track with git-lfs.`,name:"patterns"},{anchor:"huggingface_hub.Repository.lfs_track.filename",description:`<strong>filename</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to use the patterns as literal filenames.`,name:"filename"}]}}),lt=new y({props:{name:"lfs_untrack",anchor:"huggingface_hub.Repository.lfs_untrack",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L937",parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_untrack.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to untrack with git-lfs.`,name:"patterns"}]}}),gt=new y({props:{name:"list_deleted_files",anchor:"huggingface_hub.Repository.list_deleted_files",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L859",returnDescription:`
<p>A list of files that have been deleted in the working
directory or index.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),ht=new y({props:{name:"push_to_hub",anchor:"huggingface_hub.Repository.push_to_hub",parameters:[{name:"commit_message",val:": typing.Optional[str] = 'commit files to HF hub'"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"clean_ok",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1445",parametersDescription:[{anchor:"huggingface_hub.Repository.push_to_hub.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.push_to_hub.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.push_to_hub.clean_ok",description:`<strong>clean_ok</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
If True, this function will return None if the repo is
untouched. Default behavior is to fail because the git command
fails.`,name:"clean_ok"},{anchor:"huggingface_hub.Repository.push_to_hub.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}]}}),pt=new y({props:{name:"tag_exists",anchor:"huggingface_hub.Repository.tag_exists",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1282",parametersDescription:[{anchor:"huggingface_hub.Repository.tag_exists.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to check.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.tag_exists.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Whether to check if the tag exists on a remote. This parameter
should be the identifier of the remote.`,name:"remote"}],returnDescription:`
<p>Whether the tag exists.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),ut=new y({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1613"}}),dt=new Er({}),ft=new y({props:{name:"huggingface_hub.repository.is_git_repo",anchor:"huggingface_hub.repository.is_git_repo",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L103",parametersDescription:[{anchor:"huggingface_hub.repository.is_git_repo.folder",description:`<strong>folder</strong> (<code>str</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],returnDescription:`
<p><code>True</code> if the repository is part of a repository, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),mt=new y({props:{name:"huggingface_hub.repository.is_local_clone",anchor:"huggingface_hub.repository.is_local_clone",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"remote_url",val:": str"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L122",parametersDescription:[{anchor:"huggingface_hub.repository.is_local_clone.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.is_local_clone.remote_url",description:`<strong>remote_url</strong> (<code>str</code>) &#x2014;
The url of a git repository.`,name:"remote_url"}],returnDescription:`
<p><code>True</code> if the repository is a local clone of the remote
repository specified, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),_t=new y({props:{name:"huggingface_hub.repository.is_tracked_with_lfs",anchor:"huggingface_hub.repository.is_tracked_with_lfs",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L154",parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_with_lfs.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],returnDescription:`
<p><code>True</code> if the file passed is tracked with git-lfs, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),bt=new y({props:{name:"huggingface_hub.repository.is_git_ignored",anchor:"huggingface_hub.repository.is_git_ignored",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L198",parametersDescription:[{anchor:"huggingface_hub.repository.is_git_ignored.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],returnDescription:`
<p><code>True</code> if the file passed is ignored by <code>git</code>, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),vt=new y({props:{name:"huggingface_hub.repository.files_to_be_staged",anchor:"huggingface_hub.repository.files_to_be_staged",parameters:[{name:"pattern",val:": str"},{name:"folder",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L229",parametersDescription:[{anchor:"huggingface_hub.repository.files_to_be_staged.pattern",description:`<strong>pattern</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The pattern of filenames to check. Put <code>.</code> to get all files.`,name:"pattern"},{anchor:"huggingface_hub.repository.files_to_be_staged.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],returnDescription:`
<p>List of files that are to be staged.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),yt=new y({props:{name:"huggingface_hub.repository.is_tracked_upstream",anchor:"huggingface_hub.repository.is_tracked_upstream",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L261",parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_upstream.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],returnDescription:`
<p><code>True</code> if the current checked-out branch is tracked upstream,
<code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),$t=new y({props:{name:"huggingface_hub.repository.commits_to_push",anchor:"huggingface_hub.repository.commits_to_push",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"upstream",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L291",parametersDescription:[{anchor:"huggingface_hub.repository.commits_to_push.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.commits_to_push.upstream",description:"<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;",name:"upstream"}],returnDescription:`
<p>Number of commits that would be pushed upstream were a <code>git push</code> to proceed.</p>
`,returnType:`
<p><code>int</code></p>
`}}),wt=new Er({}),kt=new y({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L423"}}),Dt=new y({props:{name:"commands_failed",anchor:"huggingface_hub.Repository.commands_failed",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1599"}}),Rt=new y({props:{name:"commands_in_progress",anchor:"huggingface_hub.Repository.commands_in_progress",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1606"}}),xt=new y({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1613"}}),Tt=new y({props:{name:"class huggingface_hub.repository.CommandInProgress",anchor:"huggingface_hub.repository.CommandInProgress",parameters:[{name:"title",val:": str"},{name:"is_done_method",val:": typing.Callable"},{name:"status_method",val:": typing.Callable"},{name:"process",val:": Popen"},{name:"post_method",val:": typing.Optional[typing.Callable] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L26"}}),{c(){V=n("meta"),$n=c(),A=n("h1"),oe=n("a"),Ut=n("span"),u(He.$$.fragment),kr=c(),Mt=n("span"),Dr=s("Managing local and online repositories"),wn=c(),E=n("p"),Rr=s("The "),Wt=n("code"),xr=s("Repository"),Tr=s(" class is a helper class that wraps "),Bt=n("code"),Pr=s("git"),Ir=s(" and "),Gt=n("code"),Or=s("git-lfs"),Lr=s(` commands. It provides tooling adapted
for managing repositories which can be very large.`),En=c(),ne=n("p"),Cr=s("It is the recommended tool as soon as any "),zt=n("code"),Fr=s("git"),Nr=s(` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),kn=c(),S=n("h2"),re=n("a"),Jt=n("span"),u(Ve.$$.fragment),jr=c(),Kt=n("span"),Hr=s("The Repository class"),Dn=c(),g=n("div"),u(Ae.$$.fragment),Vr=c(),Qt=n("p"),Ar=s("Helper class to wrap the git and git-lfs commands."),Sr=c(),Xt=n("p"),qr=s(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),Ur=c(),k=n("div"),u(Se.$$.fragment),Mr=c(),Yt=n("p"),Wr=s("Instantiate a local clone of a git repo."),Br=c(),q=n("p"),Gr=s("If specifying a "),Zt=n("code"),zr=s("clone_from"),Jr=s(`, it will clone an existing remote
repository, for instance one that was previously created using
`),eo=n("code"),Kr=s("HfApi().create_repo(repo_id=repo_name)"),Qr=s("."),Xr=c(),D=n("p"),to=n("code"),Yr=s("Repository"),Zr=s(` uses the local git credentials by default, but if required,
the `),oo=n("code"),ea=s("huggingface_token"),ta=s(" as well as the git "),no=n("code"),oa=s("user"),na=s(" and the "),ro=n("code"),ra=s("email"),aa=s(` can be
explicitly specified.`),sa=c(),ae=n("div"),u(qe.$$.fragment),ia=c(),ao=n("p"),ca=s("Returns the current checked out branch."),la=c(),R=n("div"),u(Ue.$$.fragment),ga=c(),so=n("p"),ha=s("Add a tag at the current head and push it"),pa=c(),io=n("p"),ua=s("If remote is None, will just be updated locally"),da=c(),co=n("p"),fa=s(`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),ma=c(),se=n("div"),u(Me.$$.fragment),_a=c(),lo=n("p"),ba=s(`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),va=c(),ie=n("div"),u(We.$$.fragment),ya=c(),U=n("p"),$a=s("Checks that "),go=n("code"),wa=s("git"),Ea=s(" and "),ho=n("code"),ka=s("git-lfs"),Da=s(" can be run."),Ra=c(),C=n("div"),u(Be.$$.fragment),xa=c(),po=n("p"),Ta=s(`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),Pa=c(),uo=n("p"),Ia=s(`If this folder is a git repository with linked history, will try to
update the repository.`),Oa=c(),x=n("div"),u(Ge.$$.fragment),La=c(),M=n("p"),Ca=s(`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),fo=n("code"),Fa=s("track_large_files"),Na=s(" argument to "),mo=n("code"),ja=s("False"),Ha=s(` if you wish to ignore that
behavior.`),Va=c(),_o=n("p"),Aa=s("Examples:"),Sa=c(),u(ze.$$.fragment),qa=c(),ce=n("div"),u(Je.$$.fragment),Ua=c(),bo=n("p"),Ma=s("Delete a tag, both local and remote, if it exists"),Wa=c(),F=n("div"),u(Ke.$$.fragment),Ba=c(),vo=n("p"),Ga=s("git add"),za=c(),I=n("p"),Ja=s("Setting the "),yo=n("code"),Ka=s("auto_lfs_track"),Qa=s(" parameter to "),$o=n("code"),Xa=s("True"),Ya=s(` will automatically
track files that are larger than 10MB with `),wo=n("code"),Za=s("git-lfs"),es=s("."),ts=c(),N=n("div"),u(Qe.$$.fragment),os=c(),Eo=n("p"),ns=s("git checkout a given revision"),rs=c(),W=n("p"),as=s("Specifying "),ko=n("code"),ss=s("create_branch_ok"),is=s(" to "),Do=n("code"),cs=s("True"),ls=s(` will create the branch to the
given revision if that revision doesn\u2019t exist.`),gs=c(),le=n("div"),u(Xe.$$.fragment),hs=c(),Ro=n("p"),ps=s("git commit"),us=c(),ge=n("div"),u(Ye.$$.fragment),ds=c(),xo=n("p"),fs=s("Sets git username and email (only in the current repo)."),ms=c(),he=n("div"),u(Ze.$$.fragment),_s=c(),Pt=n("p"),bs=s("Sets the git credential helper to "),To=n("code"),vs=s("store"),ys=c(),pe=n("div"),u(et.$$.fragment),$s=c(),Po=n("p"),ws=s(`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),Es=c(),ue=n("div"),u(tt.$$.fragment),ks=c(),Io=n("p"),Ds=s("Get commit sha on top of HEAD."),Rs=c(),de=n("div"),u(ot.$$.fragment),xs=c(),Oo=n("p"),Ts=s("git pull"),Ps=c(),j=n("div"),u(nt.$$.fragment),Is=c(),Lo=n("p"),Os=s("git push"),Ls=c(),B=n("p"),Cs=s("If used without setting "),Co=n("code"),Fs=s("blocking"),Ns=s(`, will return url to commit on remote
repo. If used with `),Fo=n("code"),js=s("blocking=True"),Hs=s(`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),Vs=c(),fe=n("div"),u(rt.$$.fragment),As=c(),No=n("p"),Ss=s("Get URL to origin remote."),qs=c(),me=n("div"),u(at.$$.fragment),Us=c(),jo=n("p"),Ms=s("Return whether or not the git status is clean or not"),Ws=c(),_e=n("div"),u(st.$$.fragment),Bs=c(),Ho=n("p"),Gs=s("HF-specific. This enables upload support of files >5GB."),zs=c(),be=n("div"),u(it.$$.fragment),Js=c(),Vo=n("p"),Ks=s("git lfs prune"),Qs=c(),H=n("div"),u(ct.$$.fragment),Xs=c(),Ao=n("p"),Ys=s("Tell git-lfs to track files according to a pattern."),Zs=c(),O=n("p"),ei=s("Setting the "),So=n("code"),ti=s("filename"),oi=s(" argument to "),qo=n("code"),ni=s("True"),ri=s(` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),Uo=n("code"),ai=s(".gitattributes"),si=s(" file."),ii=c(),ve=n("div"),u(lt.$$.fragment),ci=c(),Mo=n("p"),li=s("Tell git-lfs to untrack those files."),gi=c(),ye=n("div"),u(gt.$$.fragment),hi=c(),Wo=n("p"),pi=s(`Returns a list of the files that are deleted in the working directory or
index.`),ui=c(),$e=n("div"),u(ht.$$.fragment),di=c(),Bo=n("p"),fi=s(`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),mi=c(),we=n("div"),u(pt.$$.fragment),_i=c(),Go=n("p"),bi=s("Check if a tag exists or not."),vi=c(),Ee=n("div"),u(ut.$$.fragment),yi=c(),zo=n("p"),$i=s(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Rn=c(),G=n("h2"),ke=n("a"),Jo=n("span"),u(dt.$$.fragment),wi=c(),Ko=n("span"),Ei=s("Helper methods"),xn=c(),z=n("div"),u(ft.$$.fragment),ki=c(),Qo=n("p"),Di=s("Check if the folder is the root or part of a git repository"),Tn=c(),J=n("div"),u(mt.$$.fragment),Ri=c(),Xo=n("p"),xi=s("Check if the folder is a local clone of the remote_url"),Pn=c(),K=n("div"),u(_t.$$.fragment),Ti=c(),Yo=n("p"),Pi=s("Check if the file passed is tracked with git-lfs."),In=c(),Q=n("div"),u(bt.$$.fragment),Ii=c(),Zo=n("p"),Oi=s("Check if file is git-ignored. Supports nested .gitignore files."),On=c(),X=n("div"),u(vt.$$.fragment),Li=c(),en=n("p"),Ci=s("Returns a list of filenames that are to be staged."),Ln=c(),Y=n("div"),u(yt.$$.fragment),Fi=c(),tn=n("p"),Ni=s("Check if the current checked-out branch is tracked upstream."),Cn=c(),L=n("div"),u($t.$$.fragment),ji=c(),on=n("p"),Hi=s("Check the number of commits that would be pushed upstream"),Vi=c(),nn=n("p"),Ai=s(`The name of the upstream repository with which the comparison should be
made.`),Fn=c(),Z=n("h2"),De=n("a"),rn=n("span"),u(wt.$$.fragment),Si=c(),an=n("span"),qi=s("Following asynchronous commands"),Nn=c(),Re=n("p"),Ui=s("The "),sn=n("code"),Mi=s("Repository"),Wi=s(" utility offers several methods which can be launched asynchronously:"),jn=c(),T=n("ul"),cn=n("li"),ln=n("code"),Bi=s("git_push"),Gi=c(),gn=n("li"),hn=n("code"),zi=s("git_pull"),Ji=c(),pn=n("li"),un=n("code"),Ki=s("push_to_hub"),Qi=c(),Et=n("li"),Xi=s("The "),dn=n("code"),Yi=s("commit"),Zi=s(" context manager"),Hn=c(),It=n("p"),ec=s("See below for utilities to manage such asynchronous methods."),Vn=c(),w=n("div"),u(kt.$$.fragment),tc=c(),fn=n("p"),oc=s("Helper class to wrap the git and git-lfs commands."),nc=c(),mn=n("p"),rc=s(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),ac=c(),xe=n("div"),u(Dt.$$.fragment),sc=c(),_n=n("p"),ic=s("Returns the asynchronous commands that failed."),cc=c(),Te=n("div"),u(Rt.$$.fragment),lc=c(),bn=n("p"),gc=s("Returns the asynchronous commands that are currently in progress."),hc=c(),Pe=n("div"),u(xt.$$.fragment),pc=c(),vn=n("p"),uc=s(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),An=c(),ee=n("div"),u(Tt.$$.fragment),dc=c(),yn=n("p"),fc=s("Utility to follow commands launched asynchronously."),this.h()},l(t){const v=ng('[data-svelte="svelte-1phssyn"]',document.head);V=r(v,"META",{name:!0,content:!0}),v.forEach(o),$n=l(t),A=r(t,"H1",{class:!0});var qn=a(A);oe=r(qn,"A",{id:!0,class:!0,href:!0});var bc=a(oe);Ut=r(bc,"SPAN",{});var vc=a(Ut);d(He.$$.fragment,vc),vc.forEach(o),bc.forEach(o),kr=l(qn),Mt=r(qn,"SPAN",{});var yc=a(Mt);Dr=i(yc,"Managing local and online repositories"),yc.forEach(o),qn.forEach(o),wn=l(t),E=r(t,"P",{});var Ie=a(E);Rr=i(Ie,"The "),Wt=r(Ie,"CODE",{});var $c=a(Wt);xr=i($c,"Repository"),$c.forEach(o),Tr=i(Ie," class is a helper class that wraps "),Bt=r(Ie,"CODE",{});var wc=a(Bt);Pr=i(wc,"git"),wc.forEach(o),Ir=i(Ie," and "),Gt=r(Ie,"CODE",{});var Ec=a(Gt);Or=i(Ec,"git-lfs"),Ec.forEach(o),Lr=i(Ie,` commands. It provides tooling adapted
for managing repositories which can be very large.`),Ie.forEach(o),En=l(t),ne=r(t,"P",{});var Un=a(ne);Cr=i(Un,"It is the recommended tool as soon as any "),zt=r(Un,"CODE",{});var kc=a(zt);Fr=i(kc,"git"),kc.forEach(o),Nr=i(Un,` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),Un.forEach(o),kn=l(t),S=r(t,"H2",{class:!0});var Mn=a(S);re=r(Mn,"A",{id:!0,class:!0,href:!0});var Dc=a(re);Jt=r(Dc,"SPAN",{});var Rc=a(Jt);d(Ve.$$.fragment,Rc),Rc.forEach(o),Dc.forEach(o),jr=l(Mn),Kt=r(Mn,"SPAN",{});var xc=a(Kt);Hr=i(xc,"The Repository class"),xc.forEach(o),Mn.forEach(o),Dn=l(t),g=r(t,"DIV",{class:!0});var h=a(g);d(Ae.$$.fragment,h),Vr=l(h),Qt=r(h,"P",{});var Tc=a(Qt);Ar=i(Tc,"Helper class to wrap the git and git-lfs commands."),Tc.forEach(o),Sr=l(h),Xt=r(h,"P",{});var Pc=a(Xt);qr=i(Pc,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),Pc.forEach(o),Ur=l(h),k=r(h,"DIV",{class:!0});var Oe=a(k);d(Se.$$.fragment,Oe),Mr=l(Oe),Yt=r(Oe,"P",{});var Ic=a(Yt);Wr=i(Ic,"Instantiate a local clone of a git repo."),Ic.forEach(o),Br=l(Oe),q=r(Oe,"P",{});var Ot=a(q);Gr=i(Ot,"If specifying a "),Zt=r(Ot,"CODE",{});var Oc=a(Zt);zr=i(Oc,"clone_from"),Oc.forEach(o),Jr=i(Ot,`, it will clone an existing remote
repository, for instance one that was previously created using
`),eo=r(Ot,"CODE",{});var Lc=a(eo);Kr=i(Lc,"HfApi().create_repo(repo_id=repo_name)"),Lc.forEach(o),Qr=i(Ot,"."),Ot.forEach(o),Xr=l(Oe),D=r(Oe,"P",{});var te=a(D);to=r(te,"CODE",{});var Cc=a(to);Yr=i(Cc,"Repository"),Cc.forEach(o),Zr=i(te,` uses the local git credentials by default, but if required,
the `),oo=r(te,"CODE",{});var Fc=a(oo);ea=i(Fc,"huggingface_token"),Fc.forEach(o),ta=i(te," as well as the git "),no=r(te,"CODE",{});var Nc=a(no);oa=i(Nc,"user"),Nc.forEach(o),na=i(te," and the "),ro=r(te,"CODE",{});var jc=a(ro);ra=i(jc,"email"),jc.forEach(o),aa=i(te,` can be
explicitly specified.`),te.forEach(o),Oe.forEach(o),sa=l(h),ae=r(h,"DIV",{class:!0});var Wn=a(ae);d(qe.$$.fragment,Wn),ia=l(Wn),ao=r(Wn,"P",{});var Hc=a(ao);ca=i(Hc,"Returns the current checked out branch."),Hc.forEach(o),Wn.forEach(o),la=l(h),R=r(h,"DIV",{class:!0});var Le=a(R);d(Ue.$$.fragment,Le),ga=l(Le),so=r(Le,"P",{});var Vc=a(so);ha=i(Vc,"Add a tag at the current head and push it"),Vc.forEach(o),pa=l(Le),io=r(Le,"P",{});var Ac=a(io);ua=i(Ac,"If remote is None, will just be updated locally"),Ac.forEach(o),da=l(Le),co=r(Le,"P",{});var Sc=a(co);fa=i(Sc,`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),Sc.forEach(o),Le.forEach(o),ma=l(h),se=r(h,"DIV",{class:!0});var Bn=a(se);d(Me.$$.fragment,Bn),_a=l(Bn),lo=r(Bn,"P",{});var qc=a(lo);ba=i(qc,`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),qc.forEach(o),Bn.forEach(o),va=l(h),ie=r(h,"DIV",{class:!0});var Gn=a(ie);d(We.$$.fragment,Gn),ya=l(Gn),U=r(Gn,"P",{});var Lt=a(U);$a=i(Lt,"Checks that "),go=r(Lt,"CODE",{});var Uc=a(go);wa=i(Uc,"git"),Uc.forEach(o),Ea=i(Lt," and "),ho=r(Lt,"CODE",{});var Mc=a(ho);ka=i(Mc,"git-lfs"),Mc.forEach(o),Da=i(Lt," can be run."),Lt.forEach(o),Gn.forEach(o),Ra=l(h),C=r(h,"DIV",{class:!0});var Ct=a(C);d(Be.$$.fragment,Ct),xa=l(Ct),po=r(Ct,"P",{});var Wc=a(po);Ta=i(Wc,`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),Wc.forEach(o),Pa=l(Ct),uo=r(Ct,"P",{});var Bc=a(uo);Ia=i(Bc,`If this folder is a git repository with linked history, will try to
update the repository.`),Bc.forEach(o),Ct.forEach(o),Oa=l(h),x=r(h,"DIV",{class:!0});var Ce=a(x);d(Ge.$$.fragment,Ce),La=l(Ce),M=r(Ce,"P",{});var Ft=a(M);Ca=i(Ft,`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),fo=r(Ft,"CODE",{});var Gc=a(fo);Fa=i(Gc,"track_large_files"),Gc.forEach(o),Na=i(Ft," argument to "),mo=r(Ft,"CODE",{});var zc=a(mo);ja=i(zc,"False"),zc.forEach(o),Ha=i(Ft,` if you wish to ignore that
behavior.`),Ft.forEach(o),Va=l(Ce),_o=r(Ce,"P",{});var Jc=a(_o);Aa=i(Jc,"Examples:"),Jc.forEach(o),Sa=l(Ce),d(ze.$$.fragment,Ce),Ce.forEach(o),qa=l(h),ce=r(h,"DIV",{class:!0});var zn=a(ce);d(Je.$$.fragment,zn),Ua=l(zn),bo=r(zn,"P",{});var Kc=a(bo);Ma=i(Kc,"Delete a tag, both local and remote, if it exists"),Kc.forEach(o),zn.forEach(o),Wa=l(h),F=r(h,"DIV",{class:!0});var Nt=a(F);d(Ke.$$.fragment,Nt),Ba=l(Nt),vo=r(Nt,"P",{});var Qc=a(vo);Ga=i(Qc,"git add"),Qc.forEach(o),za=l(Nt),I=r(Nt,"P",{});var Fe=a(I);Ja=i(Fe,"Setting the "),yo=r(Fe,"CODE",{});var Xc=a(yo);Ka=i(Xc,"auto_lfs_track"),Xc.forEach(o),Qa=i(Fe," parameter to "),$o=r(Fe,"CODE",{});var Yc=a($o);Xa=i(Yc,"True"),Yc.forEach(o),Ya=i(Fe,` will automatically
track files that are larger than 10MB with `),wo=r(Fe,"CODE",{});var Zc=a(wo);Za=i(Zc,"git-lfs"),Zc.forEach(o),es=i(Fe,"."),Fe.forEach(o),Nt.forEach(o),ts=l(h),N=r(h,"DIV",{class:!0});var jt=a(N);d(Qe.$$.fragment,jt),os=l(jt),Eo=r(jt,"P",{});var el=a(Eo);ns=i(el,"git checkout a given revision"),el.forEach(o),rs=l(jt),W=r(jt,"P",{});var Ht=a(W);as=i(Ht,"Specifying "),ko=r(Ht,"CODE",{});var tl=a(ko);ss=i(tl,"create_branch_ok"),tl.forEach(o),is=i(Ht," to "),Do=r(Ht,"CODE",{});var ol=a(Do);cs=i(ol,"True"),ol.forEach(o),ls=i(Ht,` will create the branch to the
given revision if that revision doesn\u2019t exist.`),Ht.forEach(o),jt.forEach(o),gs=l(h),le=r(h,"DIV",{class:!0});var Jn=a(le);d(Xe.$$.fragment,Jn),hs=l(Jn),Ro=r(Jn,"P",{});var nl=a(Ro);ps=i(nl,"git commit"),nl.forEach(o),Jn.forEach(o),us=l(h),ge=r(h,"DIV",{class:!0});var Kn=a(ge);d(Ye.$$.fragment,Kn),ds=l(Kn),xo=r(Kn,"P",{});var rl=a(xo);fs=i(rl,"Sets git username and email (only in the current repo)."),rl.forEach(o),Kn.forEach(o),ms=l(h),he=r(h,"DIV",{class:!0});var Qn=a(he);d(Ze.$$.fragment,Qn),_s=l(Qn),Pt=r(Qn,"P",{});var mc=a(Pt);bs=i(mc,"Sets the git credential helper to "),To=r(mc,"CODE",{});var al=a(To);vs=i(al,"store"),al.forEach(o),mc.forEach(o),Qn.forEach(o),ys=l(h),pe=r(h,"DIV",{class:!0});var Xn=a(pe);d(et.$$.fragment,Xn),$s=l(Xn),Po=r(Xn,"P",{});var sl=a(Po);ws=i(sl,`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),sl.forEach(o),Xn.forEach(o),Es=l(h),ue=r(h,"DIV",{class:!0});var Yn=a(ue);d(tt.$$.fragment,Yn),ks=l(Yn),Io=r(Yn,"P",{});var il=a(Io);Ds=i(il,"Get commit sha on top of HEAD."),il.forEach(o),Yn.forEach(o),Rs=l(h),de=r(h,"DIV",{class:!0});var Zn=a(de);d(ot.$$.fragment,Zn),xs=l(Zn),Oo=r(Zn,"P",{});var cl=a(Oo);Ts=i(cl,"git pull"),cl.forEach(o),Zn.forEach(o),Ps=l(h),j=r(h,"DIV",{class:!0});var Vt=a(j);d(nt.$$.fragment,Vt),Is=l(Vt),Lo=r(Vt,"P",{});var ll=a(Lo);Os=i(ll,"git push"),ll.forEach(o),Ls=l(Vt),B=r(Vt,"P",{});var At=a(B);Cs=i(At,"If used without setting "),Co=r(At,"CODE",{});var gl=a(Co);Fs=i(gl,"blocking"),gl.forEach(o),Ns=i(At,`, will return url to commit on remote
repo. If used with `),Fo=r(At,"CODE",{});var hl=a(Fo);js=i(hl,"blocking=True"),hl.forEach(o),Hs=i(At,`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),At.forEach(o),Vt.forEach(o),Vs=l(h),fe=r(h,"DIV",{class:!0});var er=a(fe);d(rt.$$.fragment,er),As=l(er),No=r(er,"P",{});var pl=a(No);Ss=i(pl,"Get URL to origin remote."),pl.forEach(o),er.forEach(o),qs=l(h),me=r(h,"DIV",{class:!0});var tr=a(me);d(at.$$.fragment,tr),Us=l(tr),jo=r(tr,"P",{});var ul=a(jo);Ms=i(ul,"Return whether or not the git status is clean or not"),ul.forEach(o),tr.forEach(o),Ws=l(h),_e=r(h,"DIV",{class:!0});var or=a(_e);d(st.$$.fragment,or),Bs=l(or),Ho=r(or,"P",{});var dl=a(Ho);Gs=i(dl,"HF-specific. This enables upload support of files >5GB."),dl.forEach(o),or.forEach(o),zs=l(h),be=r(h,"DIV",{class:!0});var nr=a(be);d(it.$$.fragment,nr),Js=l(nr),Vo=r(nr,"P",{});var fl=a(Vo);Ks=i(fl,"git lfs prune"),fl.forEach(o),nr.forEach(o),Qs=l(h),H=r(h,"DIV",{class:!0});var St=a(H);d(ct.$$.fragment,St),Xs=l(St),Ao=r(St,"P",{});var ml=a(Ao);Ys=i(ml,"Tell git-lfs to track files according to a pattern."),ml.forEach(o),Zs=l(St),O=r(St,"P",{});var Ne=a(O);ei=i(Ne,"Setting the "),So=r(Ne,"CODE",{});var _l=a(So);ti=i(_l,"filename"),_l.forEach(o),oi=i(Ne," argument to "),qo=r(Ne,"CODE",{});var bl=a(qo);ni=i(bl,"True"),bl.forEach(o),ri=i(Ne,` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),Uo=r(Ne,"CODE",{});var vl=a(Uo);ai=i(vl,".gitattributes"),vl.forEach(o),si=i(Ne," file."),Ne.forEach(o),St.forEach(o),ii=l(h),ve=r(h,"DIV",{class:!0});var rr=a(ve);d(lt.$$.fragment,rr),ci=l(rr),Mo=r(rr,"P",{});var yl=a(Mo);li=i(yl,"Tell git-lfs to untrack those files."),yl.forEach(o),rr.forEach(o),gi=l(h),ye=r(h,"DIV",{class:!0});var ar=a(ye);d(gt.$$.fragment,ar),hi=l(ar),Wo=r(ar,"P",{});var $l=a(Wo);pi=i($l,`Returns a list of the files that are deleted in the working directory or
index.`),$l.forEach(o),ar.forEach(o),ui=l(h),$e=r(h,"DIV",{class:!0});var sr=a($e);d(ht.$$.fragment,sr),di=l(sr),Bo=r(sr,"P",{});var wl=a(Bo);fi=i(wl,`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),wl.forEach(o),sr.forEach(o),mi=l(h),we=r(h,"DIV",{class:!0});var ir=a(we);d(pt.$$.fragment,ir),_i=l(ir),Go=r(ir,"P",{});var El=a(Go);bi=i(El,"Check if a tag exists or not."),El.forEach(o),ir.forEach(o),vi=l(h),Ee=r(h,"DIV",{class:!0});var cr=a(Ee);d(ut.$$.fragment,cr),yi=l(cr),zo=r(cr,"P",{});var kl=a(zo);$i=i(kl,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),kl.forEach(o),cr.forEach(o),h.forEach(o),Rn=l(t),G=r(t,"H2",{class:!0});var lr=a(G);ke=r(lr,"A",{id:!0,class:!0,href:!0});var Dl=a(ke);Jo=r(Dl,"SPAN",{});var Rl=a(Jo);d(dt.$$.fragment,Rl),Rl.forEach(o),Dl.forEach(o),wi=l(lr),Ko=r(lr,"SPAN",{});var xl=a(Ko);Ei=i(xl,"Helper methods"),xl.forEach(o),lr.forEach(o),xn=l(t),z=r(t,"DIV",{class:!0});var gr=a(z);d(ft.$$.fragment,gr),ki=l(gr),Qo=r(gr,"P",{});var Tl=a(Qo);Di=i(Tl,"Check if the folder is the root or part of a git repository"),Tl.forEach(o),gr.forEach(o),Tn=l(t),J=r(t,"DIV",{class:!0});var hr=a(J);d(mt.$$.fragment,hr),Ri=l(hr),Xo=r(hr,"P",{});var Pl=a(Xo);xi=i(Pl,"Check if the folder is a local clone of the remote_url"),Pl.forEach(o),hr.forEach(o),Pn=l(t),K=r(t,"DIV",{class:!0});var pr=a(K);d(_t.$$.fragment,pr),Ti=l(pr),Yo=r(pr,"P",{});var Il=a(Yo);Pi=i(Il,"Check if the file passed is tracked with git-lfs."),Il.forEach(o),pr.forEach(o),In=l(t),Q=r(t,"DIV",{class:!0});var ur=a(Q);d(bt.$$.fragment,ur),Ii=l(ur),Zo=r(ur,"P",{});var Ol=a(Zo);Oi=i(Ol,"Check if file is git-ignored. Supports nested .gitignore files."),Ol.forEach(o),ur.forEach(o),On=l(t),X=r(t,"DIV",{class:!0});var dr=a(X);d(vt.$$.fragment,dr),Li=l(dr),en=r(dr,"P",{});var Ll=a(en);Ci=i(Ll,"Returns a list of filenames that are to be staged."),Ll.forEach(o),dr.forEach(o),Ln=l(t),Y=r(t,"DIV",{class:!0});var fr=a(Y);d(yt.$$.fragment,fr),Fi=l(fr),tn=r(fr,"P",{});var Cl=a(tn);Ni=i(Cl,"Check if the current checked-out branch is tracked upstream."),Cl.forEach(o),fr.forEach(o),Cn=l(t),L=r(t,"DIV",{class:!0});var qt=a(L);d($t.$$.fragment,qt),ji=l(qt),on=r(qt,"P",{});var Fl=a(on);Hi=i(Fl,"Check the number of commits that would be pushed upstream"),Fl.forEach(o),Vi=l(qt),nn=r(qt,"P",{});var Nl=a(nn);Ai=i(Nl,`The name of the upstream repository with which the comparison should be
made.`),Nl.forEach(o),qt.forEach(o),Fn=l(t),Z=r(t,"H2",{class:!0});var mr=a(Z);De=r(mr,"A",{id:!0,class:!0,href:!0});var jl=a(De);rn=r(jl,"SPAN",{});var Hl=a(rn);d(wt.$$.fragment,Hl),Hl.forEach(o),jl.forEach(o),Si=l(mr),an=r(mr,"SPAN",{});var Vl=a(an);qi=i(Vl,"Following asynchronous commands"),Vl.forEach(o),mr.forEach(o),Nn=l(t),Re=r(t,"P",{});var _r=a(Re);Ui=i(_r,"The "),sn=r(_r,"CODE",{});var Al=a(sn);Mi=i(Al,"Repository"),Al.forEach(o),Wi=i(_r," utility offers several methods which can be launched asynchronously:"),_r.forEach(o),jn=l(t),T=r(t,"UL",{});var je=a(T);cn=r(je,"LI",{});var Sl=a(cn);ln=r(Sl,"CODE",{});var ql=a(ln);Bi=i(ql,"git_push"),ql.forEach(o),Sl.forEach(o),Gi=l(je),gn=r(je,"LI",{});var Ul=a(gn);hn=r(Ul,"CODE",{});var Ml=a(hn);zi=i(Ml,"git_pull"),Ml.forEach(o),Ul.forEach(o),Ji=l(je),pn=r(je,"LI",{});var Wl=a(pn);un=r(Wl,"CODE",{});var Bl=a(un);Ki=i(Bl,"push_to_hub"),Bl.forEach(o),Wl.forEach(o),Qi=l(je),Et=r(je,"LI",{});var br=a(Et);Xi=i(br,"The "),dn=r(br,"CODE",{});var Gl=a(dn);Yi=i(Gl,"commit"),Gl.forEach(o),Zi=i(br," context manager"),br.forEach(o),je.forEach(o),Hn=l(t),It=r(t,"P",{});var zl=a(It);ec=i(zl,"See below for utilities to manage such asynchronous methods."),zl.forEach(o),Vn=l(t),w=r(t,"DIV",{class:!0});var P=a(w);d(kt.$$.fragment,P),tc=l(P),fn=r(P,"P",{});var Jl=a(fn);oc=i(Jl,"Helper class to wrap the git and git-lfs commands."),Jl.forEach(o),nc=l(P),mn=r(P,"P",{});var Kl=a(mn);rc=i(Kl,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),Kl.forEach(o),ac=l(P),xe=r(P,"DIV",{class:!0});var vr=a(xe);d(Dt.$$.fragment,vr),sc=l(vr),_n=r(vr,"P",{});var Ql=a(_n);ic=i(Ql,"Returns the asynchronous commands that failed."),Ql.forEach(o),vr.forEach(o),cc=l(P),Te=r(P,"DIV",{class:!0});var yr=a(Te);d(Rt.$$.fragment,yr),lc=l(yr),bn=r(yr,"P",{});var Xl=a(bn);gc=i(Xl,"Returns the asynchronous commands that are currently in progress."),Xl.forEach(o),yr.forEach(o),hc=l(P),Pe=r(P,"DIV",{class:!0});var $r=a(Pe);d(xt.$$.fragment,$r),pc=l($r),vn=r($r,"P",{});var Yl=a(vn);uc=i(Yl,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Yl.forEach(o),$r.forEach(o),P.forEach(o),An=l(t),ee=r(t,"DIV",{class:!0});var wr=a(ee);d(Tt.$$.fragment,wr),dc=l(wr),yn=r(wr,"P",{});var Zl=a(yn);fc=i(Zl,"Utility to follow commands launched asynchronously."),Zl.forEach(o),wr.forEach(o),this.h()},h(){p(V,"name","hf:doc:metadata"),p(V,"content",JSON.stringify(cg)),p(oe,"id","managing-local-and-online-repositories"),p(oe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(oe,"href","#managing-local-and-online-repositories"),p(A,"class","relative group"),p(re,"id","huggingface_hub.Repository"),p(re,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(re,"href","#huggingface_hub.Repository"),p(S,"class","relative group"),p(k,"class","docstring"),p(ae,"class","docstring"),p(R,"class","docstring"),p(se,"class","docstring"),p(ie,"class","docstring"),p(C,"class","docstring"),p(x,"class","docstring"),p(ce,"class","docstring"),p(F,"class","docstring"),p(N,"class","docstring"),p(le,"class","docstring"),p(ge,"class","docstring"),p(he,"class","docstring"),p(pe,"class","docstring"),p(ue,"class","docstring"),p(de,"class","docstring"),p(j,"class","docstring"),p(fe,"class","docstring"),p(me,"class","docstring"),p(_e,"class","docstring"),p(be,"class","docstring"),p(H,"class","docstring"),p(ve,"class","docstring"),p(ye,"class","docstring"),p($e,"class","docstring"),p(we,"class","docstring"),p(Ee,"class","docstring"),p(g,"class","docstring"),p(ke,"id","huggingface_hub.repository.is_git_repo"),p(ke,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(ke,"href","#huggingface_hub.repository.is_git_repo"),p(G,"class","relative group"),p(z,"class","docstring"),p(J,"class","docstring"),p(K,"class","docstring"),p(Q,"class","docstring"),p(X,"class","docstring"),p(Y,"class","docstring"),p(L,"class","docstring"),p(De,"id","huggingface_hub.Repository"),p(De,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(De,"href","#huggingface_hub.Repository"),p(Z,"class","relative group"),p(xe,"class","docstring"),p(Te,"class","docstring"),p(Pe,"class","docstring"),p(w,"class","docstring"),p(ee,"class","docstring")},m(t,v){e(document.head,V),$(t,$n,v),$(t,A,v),e(A,oe),e(oe,Ut),f(He,Ut,null),e(A,kr),e(A,Mt),e(Mt,Dr),$(t,wn,v),$(t,E,v),e(E,Rr),e(E,Wt),e(Wt,xr),e(E,Tr),e(E,Bt),e(Bt,Pr),e(E,Ir),e(E,Gt),e(Gt,Or),e(E,Lr),$(t,En,v),$(t,ne,v),e(ne,Cr),e(ne,zt),e(zt,Fr),e(ne,Nr),$(t,kn,v),$(t,S,v),e(S,re),e(re,Jt),f(Ve,Jt,null),e(S,jr),e(S,Kt),e(Kt,Hr),$(t,Dn,v),$(t,g,v),f(Ae,g,null),e(g,Vr),e(g,Qt),e(Qt,Ar),e(g,Sr),e(g,Xt),e(Xt,qr),e(g,Ur),e(g,k),f(Se,k,null),e(k,Mr),e(k,Yt),e(Yt,Wr),e(k,Br),e(k,q),e(q,Gr),e(q,Zt),e(Zt,zr),e(q,Jr),e(q,eo),e(eo,Kr),e(q,Qr),e(k,Xr),e(k,D),e(D,to),e(to,Yr),e(D,Zr),e(D,oo),e(oo,ea),e(D,ta),e(D,no),e(no,oa),e(D,na),e(D,ro),e(ro,ra),e(D,aa),e(g,sa),e(g,ae),f(qe,ae,null),e(ae,ia),e(ae,ao),e(ao,ca),e(g,la),e(g,R),f(Ue,R,null),e(R,ga),e(R,so),e(so,ha),e(R,pa),e(R,io),e(io,ua),e(R,da),e(R,co),e(co,fa),e(g,ma),e(g,se),f(Me,se,null),e(se,_a),e(se,lo),e(lo,ba),e(g,va),e(g,ie),f(We,ie,null),e(ie,ya),e(ie,U),e(U,$a),e(U,go),e(go,wa),e(U,Ea),e(U,ho),e(ho,ka),e(U,Da),e(g,Ra),e(g,C),f(Be,C,null),e(C,xa),e(C,po),e(po,Ta),e(C,Pa),e(C,uo),e(uo,Ia),e(g,Oa),e(g,x),f(Ge,x,null),e(x,La),e(x,M),e(M,Ca),e(M,fo),e(fo,Fa),e(M,Na),e(M,mo),e(mo,ja),e(M,Ha),e(x,Va),e(x,_o),e(_o,Aa),e(x,Sa),f(ze,x,null),e(g,qa),e(g,ce),f(Je,ce,null),e(ce,Ua),e(ce,bo),e(bo,Ma),e(g,Wa),e(g,F),f(Ke,F,null),e(F,Ba),e(F,vo),e(vo,Ga),e(F,za),e(F,I),e(I,Ja),e(I,yo),e(yo,Ka),e(I,Qa),e(I,$o),e($o,Xa),e(I,Ya),e(I,wo),e(wo,Za),e(I,es),e(g,ts),e(g,N),f(Qe,N,null),e(N,os),e(N,Eo),e(Eo,ns),e(N,rs),e(N,W),e(W,as),e(W,ko),e(ko,ss),e(W,is),e(W,Do),e(Do,cs),e(W,ls),e(g,gs),e(g,le),f(Xe,le,null),e(le,hs),e(le,Ro),e(Ro,ps),e(g,us),e(g,ge),f(Ye,ge,null),e(ge,ds),e(ge,xo),e(xo,fs),e(g,ms),e(g,he),f(Ze,he,null),e(he,_s),e(he,Pt),e(Pt,bs),e(Pt,To),e(To,vs),e(g,ys),e(g,pe),f(et,pe,null),e(pe,$s),e(pe,Po),e(Po,ws),e(g,Es),e(g,ue),f(tt,ue,null),e(ue,ks),e(ue,Io),e(Io,Ds),e(g,Rs),e(g,de),f(ot,de,null),e(de,xs),e(de,Oo),e(Oo,Ts),e(g,Ps),e(g,j),f(nt,j,null),e(j,Is),e(j,Lo),e(Lo,Os),e(j,Ls),e(j,B),e(B,Cs),e(B,Co),e(Co,Fs),e(B,Ns),e(B,Fo),e(Fo,js),e(B,Hs),e(g,Vs),e(g,fe),f(rt,fe,null),e(fe,As),e(fe,No),e(No,Ss),e(g,qs),e(g,me),f(at,me,null),e(me,Us),e(me,jo),e(jo,Ms),e(g,Ws),e(g,_e),f(st,_e,null),e(_e,Bs),e(_e,Ho),e(Ho,Gs),e(g,zs),e(g,be),f(it,be,null),e(be,Js),e(be,Vo),e(Vo,Ks),e(g,Qs),e(g,H),f(ct,H,null),e(H,Xs),e(H,Ao),e(Ao,Ys),e(H,Zs),e(H,O),e(O,ei),e(O,So),e(So,ti),e(O,oi),e(O,qo),e(qo,ni),e(O,ri),e(O,Uo),e(Uo,ai),e(O,si),e(g,ii),e(g,ve),f(lt,ve,null),e(ve,ci),e(ve,Mo),e(Mo,li),e(g,gi),e(g,ye),f(gt,ye,null),e(ye,hi),e(ye,Wo),e(Wo,pi),e(g,ui),e(g,$e),f(ht,$e,null),e($e,di),e($e,Bo),e(Bo,fi),e(g,mi),e(g,we),f(pt,we,null),e(we,_i),e(we,Go),e(Go,bi),e(g,vi),e(g,Ee),f(ut,Ee,null),e(Ee,yi),e(Ee,zo),e(zo,$i),$(t,Rn,v),$(t,G,v),e(G,ke),e(ke,Jo),f(dt,Jo,null),e(G,wi),e(G,Ko),e(Ko,Ei),$(t,xn,v),$(t,z,v),f(ft,z,null),e(z,ki),e(z,Qo),e(Qo,Di),$(t,Tn,v),$(t,J,v),f(mt,J,null),e(J,Ri),e(J,Xo),e(Xo,xi),$(t,Pn,v),$(t,K,v),f(_t,K,null),e(K,Ti),e(K,Yo),e(Yo,Pi),$(t,In,v),$(t,Q,v),f(bt,Q,null),e(Q,Ii),e(Q,Zo),e(Zo,Oi),$(t,On,v),$(t,X,v),f(vt,X,null),e(X,Li),e(X,en),e(en,Ci),$(t,Ln,v),$(t,Y,v),f(yt,Y,null),e(Y,Fi),e(Y,tn),e(tn,Ni),$(t,Cn,v),$(t,L,v),f($t,L,null),e(L,ji),e(L,on),e(on,Hi),e(L,Vi),e(L,nn),e(nn,Ai),$(t,Fn,v),$(t,Z,v),e(Z,De),e(De,rn),f(wt,rn,null),e(Z,Si),e(Z,an),e(an,qi),$(t,Nn,v),$(t,Re,v),e(Re,Ui),e(Re,sn),e(sn,Mi),e(Re,Wi),$(t,jn,v),$(t,T,v),e(T,cn),e(cn,ln),e(ln,Bi),e(T,Gi),e(T,gn),e(gn,hn),e(hn,zi),e(T,Ji),e(T,pn),e(pn,un),e(un,Ki),e(T,Qi),e(T,Et),e(Et,Xi),e(Et,dn),e(dn,Yi),e(Et,Zi),$(t,Hn,v),$(t,It,v),e(It,ec),$(t,Vn,v),$(t,w,v),f(kt,w,null),e(w,tc),e(w,fn),e(fn,oc),e(w,nc),e(w,mn),e(mn,rc),e(w,ac),e(w,xe),f(Dt,xe,null),e(xe,sc),e(xe,_n),e(_n,ic),e(w,cc),e(w,Te),f(Rt,Te,null),e(Te,lc),e(Te,bn),e(bn,gc),e(w,hc),e(w,Pe),f(xt,Pe,null),e(Pe,pc),e(Pe,vn),e(vn,uc),$(t,An,v),$(t,ee,v),f(Tt,ee,null),e(ee,dc),e(ee,yn),e(yn,fc),Sn=!0},p:rg,i(t){Sn||(m(He.$$.fragment,t),m(Ve.$$.fragment,t),m(Ae.$$.fragment,t),m(Se.$$.fragment,t),m(qe.$$.fragment,t),m(Ue.$$.fragment,t),m(Me.$$.fragment,t),m(We.$$.fragment,t),m(Be.$$.fragment,t),m(Ge.$$.fragment,t),m(ze.$$.fragment,t),m(Je.$$.fragment,t),m(Ke.$$.fragment,t),m(Qe.$$.fragment,t),m(Xe.$$.fragment,t),m(Ye.$$.fragment,t),m(Ze.$$.fragment,t),m(et.$$.fragment,t),m(tt.$$.fragment,t),m(ot.$$.fragment,t),m(nt.$$.fragment,t),m(rt.$$.fragment,t),m(at.$$.fragment,t),m(st.$$.fragment,t),m(it.$$.fragment,t),m(ct.$$.fragment,t),m(lt.$$.fragment,t),m(gt.$$.fragment,t),m(ht.$$.fragment,t),m(pt.$$.fragment,t),m(ut.$$.fragment,t),m(dt.$$.fragment,t),m(ft.$$.fragment,t),m(mt.$$.fragment,t),m(_t.$$.fragment,t),m(bt.$$.fragment,t),m(vt.$$.fragment,t),m(yt.$$.fragment,t),m($t.$$.fragment,t),m(wt.$$.fragment,t),m(kt.$$.fragment,t),m(Dt.$$.fragment,t),m(Rt.$$.fragment,t),m(xt.$$.fragment,t),m(Tt.$$.fragment,t),Sn=!0)},o(t){_(He.$$.fragment,t),_(Ve.$$.fragment,t),_(Ae.$$.fragment,t),_(Se.$$.fragment,t),_(qe.$$.fragment,t),_(Ue.$$.fragment,t),_(Me.$$.fragment,t),_(We.$$.fragment,t),_(Be.$$.fragment,t),_(Ge.$$.fragment,t),_(ze.$$.fragment,t),_(Je.$$.fragment,t),_(Ke.$$.fragment,t),_(Qe.$$.fragment,t),_(Xe.$$.fragment,t),_(Ye.$$.fragment,t),_(Ze.$$.fragment,t),_(et.$$.fragment,t),_(tt.$$.fragment,t),_(ot.$$.fragment,t),_(nt.$$.fragment,t),_(rt.$$.fragment,t),_(at.$$.fragment,t),_(st.$$.fragment,t),_(it.$$.fragment,t),_(ct.$$.fragment,t),_(lt.$$.fragment,t),_(gt.$$.fragment,t),_(ht.$$.fragment,t),_(pt.$$.fragment,t),_(ut.$$.fragment,t),_(dt.$$.fragment,t),_(ft.$$.fragment,t),_(mt.$$.fragment,t),_(_t.$$.fragment,t),_(bt.$$.fragment,t),_(vt.$$.fragment,t),_(yt.$$.fragment,t),_($t.$$.fragment,t),_(wt.$$.fragment,t),_(kt.$$.fragment,t),_(Dt.$$.fragment,t),_(Rt.$$.fragment,t),_(xt.$$.fragment,t),_(Tt.$$.fragment,t),Sn=!1},d(t){o(V),t&&o($n),t&&o(A),b(He),t&&o(wn),t&&o(E),t&&o(En),t&&o(ne),t&&o(kn),t&&o(S),b(Ve),t&&o(Dn),t&&o(g),b(Ae),b(Se),b(qe),b(Ue),b(Me),b(We),b(Be),b(Ge),b(ze),b(Je),b(Ke),b(Qe),b(Xe),b(Ye),b(Ze),b(et),b(tt),b(ot),b(nt),b(rt),b(at),b(st),b(it),b(ct),b(lt),b(gt),b(ht),b(pt),b(ut),t&&o(Rn),t&&o(G),b(dt),t&&o(xn),t&&o(z),b(ft),t&&o(Tn),t&&o(J),b(mt),t&&o(Pn),t&&o(K),b(_t),t&&o(In),t&&o(Q),b(bt),t&&o(On),t&&o(X),b(vt),t&&o(Ln),t&&o(Y),b(yt),t&&o(Cn),t&&o(L),b($t),t&&o(Fn),t&&o(Z),b(wt),t&&o(Nn),t&&o(Re),t&&o(jn),t&&o(T),t&&o(Hn),t&&o(It),t&&o(Vn),t&&o(w),b(kt),b(Dt),b(Rt),b(xt),t&&o(An),t&&o(ee),b(Tt)}}}const cg={local:"managing-local-and-online-repositories",sections:[{local:"huggingface_hub.Repository",title:"The Repository class"},{local:"huggingface_hub.repository.is_git_repo",title:"Helper methods"},{local:"huggingface_hub.Repository",title:"Following asynchronous commands"}],title:"Managing local and online repositories"};function lg(_c){return ag(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class dg extends eg{constructor(V){super();tg(this,V,lg,ig,og,{})}}export{dg as default,cg as metadata};
