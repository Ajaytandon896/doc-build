import{S as Mo,i as Bo,s as Vo,e as t,k as h,w as ge,t as i,M as zo,c as n,d as o,m as f,a,x as me,h as s,b as g,G as e,g as v,y as _e,q as be,o as ve,B as ye,v as Wo,L as Go}from"../../chunks/vendor-hf-doc-builder.js";import{T as vo}from"../../chunks/Tip-hf-doc-builder.js";import{D as yo}from"../../chunks/Docstring-hf-doc-builder.js";import{C as Ko}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as Ho}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as Jo}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function Qo(se){let u,L,m,l,p,d,_,P,C,E,b,N,U,T,c,y,F,M,R,x,D,S,oe,B,O,$,A,G,le,V,de,te,J,K,z,Q,ce,De,j,ne,q,ae,Le,X,he,Ie,we;return{c(){u=t("p"),L=i("Raises the following errors:"),m=h(),l=t("ul"),p=t("li"),d=t("a"),_=t("code"),P=i("EnvironmentError"),C=i(`
if `),E=t("code"),b=i("use_auth_token=True"),N=i(" and the token cannot be found."),U=h(),T=t("li"),c=t("a"),y=t("code"),F=i("OSError"),M=i(`
if ETag cannot be determined.`),R=h(),x=t("li"),D=t("a"),S=t("code"),oe=i("ValueError"),B=i(`
if some parameter value is invalid`),O=h(),$=t("li"),A=t("a"),G=i("RepositoryNotFoundError"),le=i(`
If the repository to download from cannot be found. This may be because it doesn\u2019t exist,
or because it is set to `),V=t("code"),de=i("private"),te=i(" and you do not have access."),J=h(),K=t("li"),z=t("a"),Q=i("RevisionNotFoundError"),ce=i(`
If the revision to download from cannot be found.`),De=h(),j=t("li"),ne=t("a"),q=i("EntryNotFoundError"),ae=i(`
If the file to download cannot be found.`),Le=h(),X=t("li"),he=t("a"),Ie=i("LocalEntryNotFoundError"),we=i(`
If network is disabled or unavailable and file is not found in cache.`),this.h()},l(H){u=n(H,"P",{});var fe=a(u);L=s(fe,"Raises the following errors:"),fe.forEach(o),m=f(H),l=n(H,"UL",{});var I=a(l);p=n(I,"LI",{});var Ee=a(p);d=n(Ee,"A",{href:!0,rel:!0});var Ce=a(d);_=n(Ce,"CODE",{});var re=a(_);P=s(re,"EnvironmentError"),re.forEach(o),Ce.forEach(o),C=s(Ee,`
if `),E=n(Ee,"CODE",{});var Oe=a(E);b=s(Oe,"use_auth_token=True"),Oe.forEach(o),N=s(Ee," and the token cannot be found."),Ee.forEach(o),U=f(I),T=n(I,"LI",{});var k=a(T);c=n(k,"A",{href:!0,rel:!0});var ue=a(c);y=n(ue,"CODE",{});var Fe=a(y);F=s(Fe,"OSError"),Fe.forEach(o),ue.forEach(o),M=s(k,`
if ETag cannot be determined.`),k.forEach(o),R=f(I),x=n(I,"LI",{});var $e=a(x);D=n($e,"A",{href:!0,rel:!0});var Re=a(D);S=n(Re,"CODE",{});var Ue=a(S);oe=s(Ue,"ValueError"),Ue.forEach(o),Re.forEach(o),B=s($e,`
if some parameter value is invalid`),$e.forEach(o),O=f(I),$=n(I,"LI",{});var ie=a($);A=n(ie,"A",{href:!0});var Se=a(A);G=s(Se,"RepositoryNotFoundError"),Se.forEach(o),le=s(ie,`
If the repository to download from cannot be found. This may be because it doesn\u2019t exist,
or because it is set to `),V=n(ie,"CODE",{});var je=a(V);de=s(je,"private"),je.forEach(o),te=s(ie," and you do not have access."),ie.forEach(o),J=f(I),K=n(I,"LI",{});var Y=a(K);z=n(Y,"A",{href:!0});var He=a(z);Q=s(He,"RevisionNotFoundError"),He.forEach(o),ce=s(Y,`
If the revision to download from cannot be found.`),Y.forEach(o),De=f(I),j=n(I,"LI",{});var Z=a(j);ne=n(Z,"A",{href:!0});var Me=a(ne);q=s(Me,"EntryNotFoundError"),Me.forEach(o),ae=s(Z,`
If the file to download cannot be found.`),Z.forEach(o),Le=f(I),X=n(I,"LI",{});var xe=a(X);he=n(xe,"A",{href:!0});var Be=a(he);Ie=s(Be,"LocalEntryNotFoundError"),Be.forEach(o),we=s(xe,`
If network is disabled or unavailable and file is not found in cache.`),xe.forEach(o),I.forEach(o),this.h()},h(){g(d,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),g(d,"rel","nofollow"),g(c,"href","https://docs.python.org/3/library/exceptions.html#OSError"),g(c,"rel","nofollow"),g(D,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),g(D,"rel","nofollow"),g(A,"href","/docs/huggingface_hub/main/en/package_reference/utilities#huggingface_hub.utils.RepositoryNotFoundError"),g(z,"href","/docs/huggingface_hub/main/en/package_reference/utilities#huggingface_hub.utils.RevisionNotFoundError"),g(ne,"href","/docs/huggingface_hub/main/en/package_reference/utilities#huggingface_hub.utils.EntryNotFoundError"),g(he,"href","/docs/huggingface_hub/main/en/package_reference/utilities#huggingface_hub.utils.LocalEntryNotFoundError")},m(H,fe){v(H,u,fe),e(u,L),v(H,m,fe),v(H,l,fe),e(l,p),e(p,d),e(d,_),e(_,P),e(p,C),e(p,E),e(E,b),e(p,N),e(l,U),e(l,T),e(T,c),e(c,y),e(y,F),e(T,M),e(l,R),e(l,x),e(x,D),e(D,S),e(S,oe),e(x,B),e(l,O),e(l,$),e($,A),e(A,G),e($,le),e($,V),e(V,de),e($,te),e(l,J),e(l,K),e(K,z),e(z,Q),e(K,ce),e(l,De),e(l,j),e(j,ne),e(ne,q),e(j,ae),e(l,Le),e(l,X),e(X,he),e(he,Ie),e(X,we)},d(H){H&&o(u),H&&o(m),H&&o(l)}}}function Xo(se){let u,L,m,l,p,d,_,P,C,E,b,N,U,T,c,y,F,M,R,x,D,S,oe,B;return{c(){u=t("p"),L=i("Raises the following errors:"),m=h(),l=t("ul"),p=t("li"),d=t("a"),_=t("code"),P=i("EnvironmentError"),C=i(`
if `),E=t("code"),b=i("use_auth_token=True"),N=i(" and the token cannot be found."),U=h(),T=t("li"),c=t("a"),y=t("code"),F=i("OSError"),M=i(` if
ETag cannot be determined.`),R=h(),x=t("li"),D=t("a"),S=t("code"),oe=i("ValueError"),B=i(`
if some parameter value is invalid`),this.h()},l(O){u=n(O,"P",{});var $=a(u);L=s($,"Raises the following errors:"),$.forEach(o),m=f(O),l=n(O,"UL",{});var A=a(l);p=n(A,"LI",{});var G=a(p);d=n(G,"A",{href:!0,rel:!0});var le=a(d);_=n(le,"CODE",{});var V=a(_);P=s(V,"EnvironmentError"),V.forEach(o),le.forEach(o),C=s(G,`
if `),E=n(G,"CODE",{});var de=a(E);b=s(de,"use_auth_token=True"),de.forEach(o),N=s(G," and the token cannot be found."),G.forEach(o),U=f(A),T=n(A,"LI",{});var te=a(T);c=n(te,"A",{href:!0,rel:!0});var J=a(c);y=n(J,"CODE",{});var K=a(y);F=s(K,"OSError"),K.forEach(o),J.forEach(o),M=s(te,` if
ETag cannot be determined.`),te.forEach(o),R=f(A),x=n(A,"LI",{});var z=a(x);D=n(z,"A",{href:!0,rel:!0});var Q=a(D);S=n(Q,"CODE",{});var ce=a(S);oe=s(ce,"ValueError"),ce.forEach(o),Q.forEach(o),B=s(z,`
if some parameter value is invalid`),z.forEach(o),A.forEach(o),this.h()},h(){g(d,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),g(d,"rel","nofollow"),g(c,"href","https://docs.python.org/3/library/exceptions.html#OSError"),g(c,"rel","nofollow"),g(D,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),g(D,"rel","nofollow")},m(O,$){v(O,u,$),e(u,L),v(O,m,$),v(O,l,$),e(l,p),e(p,d),e(d,_),e(_,P),e(p,C),e(p,E),e(E,b),e(p,N),e(l,U),e(l,T),e(T,c),e(c,y),e(y,F),e(T,M),e(l,R),e(l,x),e(x,D),e(D,S),e(S,oe),e(x,B)},d(O){O&&o(u),O&&o(m),O&&o(l)}}}function Yo(se){let u,L,m,l,p;return l=new Ko({props:{code:`from huggingface_hub import hf_hub_url

hf_hub_url(
    repo_id="julien-c/EsperBERTo-small", filename="pytorch_model.bin"
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> hf_hub_url

<span class="hljs-meta">&gt;&gt;&gt; </span>hf_hub_url(
<span class="hljs-meta">... </span>    repo_id=<span class="hljs-string">&quot;julien-c/EsperBERTo-small&quot;</span>, filename=<span class="hljs-string">&quot;pytorch_model.bin&quot;</span>
<span class="hljs-meta">... </span>)
<span class="hljs-string">&#x27;https://huggingface.co/julien-c/EsperBERTo-small/resolve/main/pytorch_model.bin&#x27;</span>`}}),{c(){u=t("p"),L=i("Example:"),m=h(),ge(l.$$.fragment)},l(d){u=n(d,"P",{});var _=a(u);L=s(_,"Example:"),_.forEach(o),m=f(d),me(l.$$.fragment,d)},m(d,_){v(d,u,_),e(u,L),v(d,m,_),_e(l,d,_),p=!0},p:Go,i(d){p||(be(l.$$.fragment,d),p=!0)},o(d){ve(l.$$.fragment,d),p=!1},d(d){d&&o(u),d&&o(m),ye(l,d)}}}function Zo(se){let u,L,m,l,p,d,_,P,C,E,b,N,U,T;return{c(){u=t("p"),L=i("Notes:"),m=h(),l=t("p"),p=i(`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),d=h(),_=t("p"),P=i(`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we store
the files on S3/Cloudfront in a content-addressable way (i.e., the file
name is its hash). Using content-addressable filenames means cache can\u2019t
ever be stale.`),C=h(),E=t("p"),b=i(`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),N=t("code"),U=i("ETag"),T=i(`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`)},l(c){u=n(c,"P",{});var y=a(u);L=s(y,"Notes:"),y.forEach(o),m=f(c),l=n(c,"P",{});var F=a(l);p=s(F,`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),F.forEach(o),d=f(c),_=n(c,"P",{});var M=a(_);P=s(M,`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we store
the files on S3/Cloudfront in a content-addressable way (i.e., the file
name is its hash). Using content-addressable filenames means cache can\u2019t
ever be stale.`),M.forEach(o),C=f(c),E=n(c,"P",{});var R=a(E);b=s(R,`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),N=n(R,"CODE",{});var x=a(N);U=s(x,"ETag"),x.forEach(o),T=s(R,`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`),R.forEach(o)},m(c,y){v(c,u,y),e(u,L),v(c,m,y),v(c,l,y),e(l,p),v(c,d,y),v(c,_,y),e(_,P),v(c,C,y),v(c,E,y),e(E,b),e(E,N),e(N,U),e(E,T)},d(c){c&&o(u),c&&o(m),c&&o(l),c&&o(d),c&&o(_),c&&o(C),c&&o(E)}}}function et(se){let u,L,m,l,p,d,_,P,C,E,b,N,U,T,c,y,F,M,R,x,D,S,oe,B,O,$,A,G,le,V,de,te,J,K,z,Q,ce,De,j,ne,q,ae,Le,X,he,Ie,we,H,fe,I,Ee,Ce,re,Oe,k,ue,Fe,$e,Re,Ue,ie,Se,je,Y,He,Z,Me,xe,Be,so,Ke,Ve,lo,Ae,co,eo,Te,ke,Je,qe,ho,Qe,fo,oo,ze,uo,to,Ne,po,We,go,mo,no;return d=new Ho({}),N=new yo({props:{name:"huggingface_hub.hf_hub_download",anchor:"huggingface_hub.hf_hub_download",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"force_download",val:": typing.Optional[bool] = False"},{name:"force_filename",val:": typing.Optional[str] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"},{name:"legacy_cache_layout",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.hf_hub_download.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A user or an organization name and a repo name separated by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_download.filename",description:`<strong>filename</strong> (<code>str</code>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_download.subfolder",description:`<strong>subfolder</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the model repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_download.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset or space,
<code>None</code> or <code>&quot;model&quot;</code> if uploading to a model. Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_download.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.hf_hub_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.hf_hub_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.hf_hub_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.hf_hub_download.user_agent",description:`<strong>user_agent</strong> (<code>dict</code>, <code>str</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.hf_hub_download.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the file should be downloaded even if it already exists in
the local cache.`,name:"force_download"},{anchor:"huggingface_hub.hf_hub_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.hf_hub_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.hf_hub_download.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, resume a previously interrupted download.`,name:"resume_download"},{anchor:"huggingface_hub.hf_hub_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <code>bool</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.hf_hub_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"},{anchor:"huggingface_hub.hf_hub_download.legacy_cache_layout",description:`<strong>legacy_cache_layout</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, uses the legacy file cache layout i.e. just call <a href="/docs/huggingface_hub/main/en/package_reference/file_download#huggingface_hub.hf_hub_url">hf_hub_url()</a>
then <code>cached_download</code>. This is deprecated as the new cache layout is
more powerful.`,name:"legacy_cache_layout"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/file_download.py#L908",returnDescription:`
<p>Local path (string) of file or if networking is off, last version of
file cached on disk.</p>
`}}),j=new vo({props:{$$slots:{default:[Qo]},$$scope:{ctx:se}}}),ae=new yo({props:{name:"huggingface_hub.snapshot_download",anchor:"huggingface_hub.snapshot_download",parameters:[{name:"repo_id",val:": str"},{name:"revision",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"},{name:"allow_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"},{name:"ignore_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"},{name:"allow_patterns",val:": typing.Union[typing.List[str], str, NoneType] = None"},{name:"ignore_patterns",val:": typing.Union[typing.List[str], str, NoneType] = None"}],parametersDescription:[{anchor:"huggingface_hub.snapshot_download.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A user or an organization name and a repo name separated by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.snapshot_download.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.snapshot_download.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset or space,
<code>None</code> or <code>&quot;model&quot;</code> if uploading to a model. Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.snapshot_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.snapshot_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.snapshot_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.snapshot_download.user_agent",description:`<strong>user_agent</strong> (<code>str</code>, <code>dict</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.snapshot_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.snapshot_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.snapshot_download.resume_download",description:"<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False) -- If </code>True`, resume a previously interrupted download.",name:"resume_download"},{anchor:"huggingface_hub.snapshot_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <code>bool</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.snapshot_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"},{anchor:"huggingface_hub.snapshot_download.allow_patterns",description:`<strong>allow_patterns</strong> (<code>List[str]</code> or <code>str</code>, <em>optional</em>) &#x2014;
If provided, only files matching at least one pattern are downloaded.`,name:"allow_patterns"},{anchor:"huggingface_hub.snapshot_download.ignore_patterns",description:`<strong>ignore_patterns</strong> (<code>List[str]</code> or <code>str</code>, <em>optional</em>) &#x2014;
If provided, files matching any of the patterns are not downloaded.`,name:"ignore_patterns"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/_snapshot_download.py#L15",returnDescription:`
<p>Local folder path (string) of repo snapshot</p>
`}}),re=new vo({props:{$$slots:{default:[Xo]},$$scope:{ctx:se}}}),ue=new yo({props:{name:"huggingface_hub.hf_hub_url",anchor:"huggingface_hub.hf_hub_url",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.hf_hub_url.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A namespace (user or an organization) name and a repo name separated
by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_url.filename",description:`<strong>filename</strong> (<code>str</code>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_url.subfolder",description:`<strong>subfolder</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_url.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset or space,
<code>None</code> or <code>&quot;model&quot;</code> if uploading to a model. Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_url.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/file_download.py#L178"}}),Y=new Jo({props:{anchor:"huggingface_hub.hf_hub_url.example",$$slots:{default:[Yo]},$$scope:{ctx:se}}}),Z=new vo({props:{$$slots:{default:[Zo]},$$scope:{ctx:se}}}),qe=new Ho({}),{c(){u=t("meta"),L=h(),m=t("h1"),l=t("a"),p=t("span"),ge(d.$$.fragment),_=h(),P=t("span"),C=i("Downloading files"),E=h(),b=t("div"),ge(N.$$.fragment),U=h(),T=t("p"),c=i("Download a given file if it\u2019s not already present in the local cache."),y=h(),F=t("p"),M=i("The new cache file layout looks like this:"),R=h(),x=t("ul"),D=t("li"),S=i("The cache directory contains one subfolder per repo_id (namespaced by repo type)"),oe=h(),B=t("li"),O=i("inside each repo folder:"),$=t("ul"),A=t("li"),G=i("refs is a list of the latest known revision => commit_hash pairs"),le=h(),V=t("li"),de=i(`blobs contains the actual file blobs (identified by their git-sha or sha256, depending on
whether they\u2019re LFS files or not)`),te=h(),J=t("li"),K=i(`snapshots contains one subfolder per commit, each \u201Ccommit\u201D contains the subset of the files
that have been resolved at that particular commit. Each filename is a symlink to the blob
at that particular commit.`),z=h(),Q=t("p"),ce=i(`[  96]  .
\u2514\u2500\u2500 [ 160]  models\u2014julien-c\u2014EsperBERTo-small
\u251C\u2500\u2500 [ 160]  blobs
\u2502   \u251C\u2500\u2500 [321M]  403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd
\u2502   \u251C\u2500\u2500 [ 398]  7cb18dc9bafbfcf74629a4b760af1b160957a83e
\u2502   \u2514\u2500\u2500 [1.4K]  d7edf6bd2a681fb0175f7735299831ee1b22b812
\u251C\u2500\u2500 [  96]  refs
\u2502   \u2514\u2500\u2500 [  40]  main
\u2514\u2500\u2500 [ 128]  snapshots
\u251C\u2500\u2500 [ 128]  2439f60ef33a0d46d85da5001d52aeda5b00ce9f
\u2502   \u251C\u2500\u2500 [  52]  README.md -> ../../blobs/d7edf6bd2a681fb0175f7735299831ee1b22b812
\u2502   \u2514\u2500\u2500 [  76]  pytorch_model.bin -> ../../blobs/403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd
\u2514\u2500\u2500 [ 128]  bbc77c8132af1cc5cf678da3f1ddf2de43606d48
\u251C\u2500\u2500 [  52]  README.md -> ../../blobs/7cb18dc9bafbfcf74629a4b760af1b160957a83e
\u2514\u2500\u2500 [  76]  pytorch_model.bin -> ../../blobs/403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd`),De=h(),ge(j.$$.fragment),ne=h(),q=t("div"),ge(ae.$$.fragment),Le=h(),X=t("p"),he=i("Download all files of a repo."),Ie=h(),we=t("p"),H=i(`Downloads a whole snapshot of a repo\u2019s files at the specified revision. This
is useful when you want all files from a repo, because you don\u2019t know which
ones you will need a priori. All files are nested inside a folder in order
to keep their actual filename relative to that folder.`),fe=h(),I=t("p"),Ee=i(`An alternative would be to just clone a repo but this would require that the
user always has git and git-lfs installed, and properly configured.`),Ce=h(),ge(re.$$.fragment),Oe=h(),k=t("div"),ge(ue.$$.fragment),Fe=h(),$e=t("p"),Re=i("Construct the URL of a file from the given information."),Ue=h(),ie=t("p"),Se=i(`The resolved address can either be a huggingface.co-hosted url, or a link to
Cloudfront (a Content Delivery Network, or CDN) for large files which are
more than a few MBs.`),je=h(),ge(Y.$$.fragment),He=h(),ge(Z.$$.fragment),Me=h(),xe=t("p"),Be=i("References:"),so=h(),Ke=t("ul"),Ve=t("li"),lo=i("[1] "),Ae=t("a"),co=i("https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),eo=h(),Te=t("h2"),ke=t("a"),Je=t("span"),ge(qe.$$.fragment),ho=h(),Qe=t("span"),fo=i("Caching"),oo=h(),ze=t("p"),uo=i(`The methods displayed above are designed to work with a caching system that prevents
re-downloading files. The caching system was updated in v0.8.0 to become the central
cache-system shared across libraries that depend on the Hub.`),to=h(),Ne=t("p"),po=i("Read the "),We=t("a"),go=i("cache-system guide"),mo=i(` for a detailed presentation of caching at
at HF.`),this.h()},l(r){const w=zo('[data-svelte="svelte-1phssyn"]',document.head);u=n(w,"META",{name:!0,content:!0}),w.forEach(o),L=f(r),m=n(r,"H1",{class:!0});var Pe=a(m);l=n(Pe,"A",{id:!0,class:!0,href:!0});var Xe=a(l);p=n(Xe,"SPAN",{});var Ye=a(p);me(d.$$.fragment,Ye),Ye.forEach(o),Xe.forEach(o),_=f(Pe),P=n(Pe,"SPAN",{});var Ze=a(P);C=s(Ze,"Downloading files"),Ze.forEach(o),Pe.forEach(o),E=f(r),b=n(r,"DIV",{class:!0});var ee=a(b);me(N.$$.fragment,ee),U=f(ee),T=n(ee,"P",{});var wo=a(T);c=s(wo,"Download a given file if it\u2019s not already present in the local cache."),wo.forEach(o),y=f(ee),F=n(ee,"P",{});var Eo=a(F);M=s(Eo,"The new cache file layout looks like this:"),Eo.forEach(o),R=f(ee),x=n(ee,"UL",{});var ao=a(x);D=n(ao,"LI",{});var $o=a(D);S=s($o,"The cache directory contains one subfolder per repo_id (namespaced by repo type)"),$o.forEach(o),oe=f(ao),B=n(ao,"LI",{});var _o=a(B);O=s(_o,"inside each repo folder:"),$=n(_o,"UL",{});var Ge=a($);A=n(Ge,"LI",{});var xo=a(A);G=s(xo,"refs is a list of the latest known revision => commit_hash pairs"),xo.forEach(o),le=f(Ge),V=n(Ge,"LI",{});var To=a(V);de=s(To,`blobs contains the actual file blobs (identified by their git-sha or sha256, depending on
whether they\u2019re LFS files or not)`),To.forEach(o),te=f(Ge),J=n(Ge,"LI",{});var ko=a(J);K=s(ko,`snapshots contains one subfolder per commit, each \u201Ccommit\u201D contains the subset of the files
that have been resolved at that particular commit. Each filename is a symlink to the blob
at that particular commit.`),ko.forEach(o),Ge.forEach(o),_o.forEach(o),ao.forEach(o),z=f(ee),Q=n(ee,"P",{});var No=a(Q);ce=s(No,`[  96]  .
\u2514\u2500\u2500 [ 160]  models\u2014julien-c\u2014EsperBERTo-small
\u251C\u2500\u2500 [ 160]  blobs
\u2502   \u251C\u2500\u2500 [321M]  403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd
\u2502   \u251C\u2500\u2500 [ 398]  7cb18dc9bafbfcf74629a4b760af1b160957a83e
\u2502   \u2514\u2500\u2500 [1.4K]  d7edf6bd2a681fb0175f7735299831ee1b22b812
\u251C\u2500\u2500 [  96]  refs
\u2502   \u2514\u2500\u2500 [  40]  main
\u2514\u2500\u2500 [ 128]  snapshots
\u251C\u2500\u2500 [ 128]  2439f60ef33a0d46d85da5001d52aeda5b00ce9f
\u2502   \u251C\u2500\u2500 [  52]  README.md -> ../../blobs/d7edf6bd2a681fb0175f7735299831ee1b22b812
\u2502   \u2514\u2500\u2500 [  76]  pytorch_model.bin -> ../../blobs/403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd
\u2514\u2500\u2500 [ 128]  bbc77c8132af1cc5cf678da3f1ddf2de43606d48
\u251C\u2500\u2500 [  52]  README.md -> ../../blobs/7cb18dc9bafbfcf74629a4b760af1b160957a83e
\u2514\u2500\u2500 [  76]  pytorch_model.bin -> ../../blobs/403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd`),No.forEach(o),De=f(ee),me(j.$$.fragment,ee),ee.forEach(o),ne=f(r),q=n(r,"DIV",{class:!0});var pe=a(q);me(ae.$$.fragment,pe),Le=f(pe),X=n(pe,"P",{});var Do=a(X);he=s(Do,"Download all files of a repo."),Do.forEach(o),Ie=f(pe),we=n(pe,"P",{});var Lo=a(we);H=s(Lo,`Downloads a whole snapshot of a repo\u2019s files at the specified revision. This
is useful when you want all files from a repo, because you don\u2019t know which
ones you will need a priori. All files are nested inside a folder in order
to keep their actual filename relative to that folder.`),Lo.forEach(o),fe=f(pe),I=n(pe,"P",{});var Io=a(I);Ee=s(Io,`An alternative would be to just clone a repo but this would require that the
user always has git and git-lfs installed, and properly configured.`),Io.forEach(o),Ce=f(pe),me(re.$$.fragment,pe),pe.forEach(o),Oe=f(r),k=n(r,"DIV",{class:!0});var W=a(k);me(ue.$$.fragment,W),Fe=f(W),$e=n(W,"P",{});var Oo=a($e);Re=s(Oo,"Construct the URL of a file from the given information."),Oo.forEach(o),Ue=f(W),ie=n(W,"P",{});var Ao=a(ie);Se=s(Ao,`The resolved address can either be a huggingface.co-hosted url, or a link to
Cloudfront (a Content Delivery Network, or CDN) for large files which are
more than a few MBs.`),Ao.forEach(o),je=f(W),me(Y.$$.fragment,W),He=f(W),me(Z.$$.fragment,W),Me=f(W),xe=n(W,"P",{});var qo=a(xe);Be=s(qo,"References:"),qo.forEach(o),so=f(W),Ke=n(W,"UL",{});var Po=a(Ke);Ve=n(Po,"LI",{});var bo=a(Ve);lo=s(bo,"[1] "),Ae=n(bo,"A",{href:!0,rel:!0});var Co=a(Ae);co=s(Co,"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),Co.forEach(o),bo.forEach(o),Po.forEach(o),W.forEach(o),eo=f(r),Te=n(r,"H2",{class:!0});var ro=a(Te);ke=n(ro,"A",{id:!0,class:!0,href:!0});var Fo=a(ke);Je=n(Fo,"SPAN",{});var Ro=a(Je);me(qe.$$.fragment,Ro),Ro.forEach(o),Fo.forEach(o),ho=f(ro),Qe=n(ro,"SPAN",{});var Uo=a(Qe);fo=s(Uo,"Caching"),Uo.forEach(o),ro.forEach(o),oo=f(r),ze=n(r,"P",{});var So=a(ze);uo=s(So,`The methods displayed above are designed to work with a caching system that prevents
re-downloading files. The caching system was updated in v0.8.0 to become the central
cache-system shared across libraries that depend on the Hub.`),So.forEach(o),to=f(r),Ne=n(r,"P",{});var io=a(Ne);po=s(io,"Read the "),We=n(io,"A",{href:!0});var jo=a(We);go=s(jo,"cache-system guide"),jo.forEach(o),mo=s(io,` for a detailed presentation of caching at
at HF.`),io.forEach(o),this.h()},h(){g(u,"name","hf:doc:metadata"),g(u,"content",JSON.stringify(ot)),g(l,"id","huggingface_hub.hf_hub_download"),g(l,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),g(l,"href","#huggingface_hub.hf_hub_download"),g(m,"class","relative group"),g(b,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),g(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),g(Ae,"href","https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),g(Ae,"rel","nofollow"),g(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),g(ke,"id","caching"),g(ke,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),g(ke,"href","#caching"),g(Te,"class","relative group"),g(We,"href","../how-to-cache")},m(r,w){e(document.head,u),v(r,L,w),v(r,m,w),e(m,l),e(l,p),_e(d,p,null),e(m,_),e(m,P),e(P,C),v(r,E,w),v(r,b,w),_e(N,b,null),e(b,U),e(b,T),e(T,c),e(b,y),e(b,F),e(F,M),e(b,R),e(b,x),e(x,D),e(D,S),e(x,oe),e(x,B),e(B,O),e(B,$),e($,A),e(A,G),e($,le),e($,V),e(V,de),e($,te),e($,J),e(J,K),e(b,z),e(b,Q),e(Q,ce),e(b,De),_e(j,b,null),v(r,ne,w),v(r,q,w),_e(ae,q,null),e(q,Le),e(q,X),e(X,he),e(q,Ie),e(q,we),e(we,H),e(q,fe),e(q,I),e(I,Ee),e(q,Ce),_e(re,q,null),v(r,Oe,w),v(r,k,w),_e(ue,k,null),e(k,Fe),e(k,$e),e($e,Re),e(k,Ue),e(k,ie),e(ie,Se),e(k,je),_e(Y,k,null),e(k,He),_e(Z,k,null),e(k,Me),e(k,xe),e(xe,Be),e(k,so),e(k,Ke),e(Ke,Ve),e(Ve,lo),e(Ve,Ae),e(Ae,co),v(r,eo,w),v(r,Te,w),e(Te,ke),e(ke,Je),_e(qe,Je,null),e(Te,ho),e(Te,Qe),e(Qe,fo),v(r,oo,w),v(r,ze,w),e(ze,uo),v(r,to,w),v(r,Ne,w),e(Ne,po),e(Ne,We),e(We,go),e(Ne,mo),no=!0},p(r,[w]){const Pe={};w&2&&(Pe.$$scope={dirty:w,ctx:r}),j.$set(Pe);const Xe={};w&2&&(Xe.$$scope={dirty:w,ctx:r}),re.$set(Xe);const Ye={};w&2&&(Ye.$$scope={dirty:w,ctx:r}),Y.$set(Ye);const Ze={};w&2&&(Ze.$$scope={dirty:w,ctx:r}),Z.$set(Ze)},i(r){no||(be(d.$$.fragment,r),be(N.$$.fragment,r),be(j.$$.fragment,r),be(ae.$$.fragment,r),be(re.$$.fragment,r),be(ue.$$.fragment,r),be(Y.$$.fragment,r),be(Z.$$.fragment,r),be(qe.$$.fragment,r),no=!0)},o(r){ve(d.$$.fragment,r),ve(N.$$.fragment,r),ve(j.$$.fragment,r),ve(ae.$$.fragment,r),ve(re.$$.fragment,r),ve(ue.$$.fragment,r),ve(Y.$$.fragment,r),ve(Z.$$.fragment,r),ve(qe.$$.fragment,r),no=!1},d(r){o(u),r&&o(L),r&&o(m),ye(d),r&&o(E),r&&o(b),ye(N),ye(j),r&&o(ne),r&&o(q),ye(ae),ye(re),r&&o(Oe),r&&o(k),ye(ue),ye(Y),ye(Z),r&&o(eo),r&&o(Te),ye(qe),r&&o(oo),r&&o(ze),r&&o(to),r&&o(Ne)}}}const ot={local:"huggingface_hub.hf_hub_download",sections:[{local:"caching",title:"Caching"}],title:"Downloading files"};function tt(se){return Wo(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class dt extends Mo{constructor(u){super();Bo(this,u,tt,et,Vo,{})}}export{dt as default,ot as metadata};
