import{S as Es,i as xs,s as Ns,e as n,k as h,w as f,t as r,M as Ps,c as o,d as t,m as c,a as i,x as u,h as p,b as m,G as s,g as l,y as d,L as Ts,q as g,o as b,B as w,v as Ss}from"../../chunks/vendor-hf-doc-builder.js";import{I as je}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as ie}from"../../chunks/CodeBlock-hf-doc-builder.js";function As(Ot){let _,ye,v,x,re,z,it,pe,rt,ke,$,me,pt,mt,he,ht,ct,Ee,Z,ft,xe,N,ut,R,dt,gt,Ne,P,bt,U,wt,_t,Pe,T,vt,G,$t,jt,Te,j,S,ce,M,yt,fe,kt,Se,ee,Et,Ae,Y,Ce,te,xt,qe,D,Ie,se,Nt,He,F,Be,ae,Pt,Le,V,ze,A,Tt,ue,St,At,Re,C,Ct,ne,qt,It,Ue,y,q,de,J,Ht,ge,Bt,Ge,oe,Lt,Me,O,Ye,I,zt,Q,Rt,Ut,De,k,H,be,X,Gt,we,Mt,Fe,B,Yt,le,Dt,Ft,Ve,E,L,_e,K,Vt,ve,Jt,Je,W,Oe;return z=new je({}),M=new je({}),Y=new ie({props:{code:`import timm
model = timm.create_model('tf_efficientnet_cc_b0_4e', pretrained=True)
model.eval()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> timm
<span class="hljs-meta">&gt;&gt;&gt; </span>model = timm.create_model(<span class="hljs-string">&#x27;tf_efficientnet_cc_b0_4e&#x27;</span>, pretrained=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model.<span class="hljs-built_in">eval</span>()`}}),D=new ie({props:{code:`import urllib
from PIL import Image
from timm.data import resolve_data_config
from timm.data.transforms_factory import create_transform

config = resolve_data_config({}, model=model)
transform = create_transform(**config)

url, filename = ("https://github.com/pytorch/hub/raw/master/images/dog.jpg", "dog.jpg")
urllib.request.urlretrieve(url, filename)
img = Image.open(filename).convert('RGB')
tensor = transform(img).unsqueeze(0) # transform and add batch dimension`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> urllib
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> timm.data <span class="hljs-keyword">import</span> resolve_data_config
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> timm.data.transforms_factory <span class="hljs-keyword">import</span> create_transform

<span class="hljs-meta">&gt;&gt;&gt; </span>config = resolve_data_config({}, model=model)
<span class="hljs-meta">&gt;&gt;&gt; </span>transform = create_transform(**config)

<span class="hljs-meta">&gt;&gt;&gt; </span>url, filename = (<span class="hljs-string">&quot;https://github.com/pytorch/hub/raw/master/images/dog.jpg&quot;</span>, <span class="hljs-string">&quot;dog.jpg&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>urllib.request.urlretrieve(url, filename)
<span class="hljs-meta">&gt;&gt;&gt; </span>img = Image.<span class="hljs-built_in">open</span>(filename).convert(<span class="hljs-string">&#x27;RGB&#x27;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tensor = transform(img).unsqueeze(<span class="hljs-number">0</span>) <span class="hljs-comment"># transform and add batch dimension</span>`}}),F=new ie({props:{code:`import torch
with torch.no_grad():
    out = model(tensor)
probabilities = torch.nn.functional.softmax(out[0], dim=0)
print(probabilities.shape)
# prints: torch.Size([1000])`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    out = model(tensor)
<span class="hljs-meta">&gt;&gt;&gt; </span>probabilities = torch.nn.functional.softmax(out[<span class="hljs-number">0</span>], dim=<span class="hljs-number">0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(probabilities.shape)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># prints: torch.Size([1000])</span>`}}),V=new ie({props:{code:`# Get imagenet class mappings
url, filename = ("https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt", "imagenet_classes.txt")
urllib.request.urlretrieve(url, filename) 
with open("imagenet_classes.txt", "r") as f:
    categories = [s.strip() for s in f.readlines()]

# Print top categories per image
top5_prob, top5_catid = torch.topk(probabilities, 5)
for i in range(top5_prob.size(0)):
    print(categories[top5_catid[i]], top5_prob[i].item())
# prints class names and probabilities like:
# [('Samoyed', 0.6425196528434753), ('Pomeranian', 0.04062102362513542), ('keeshond', 0.03186424449086189), ('white wolf', 0.01739676296710968), ('Eskimo dog', 0.011717947199940681)]`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Get imagenet class mappings</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>url, filename = (<span class="hljs-string">&quot;https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt&quot;</span>, <span class="hljs-string">&quot;imagenet_classes.txt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>urllib.request.urlretrieve(url, filename) 
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;imagenet_classes.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:
<span class="hljs-meta">... </span>    categories = [s.strip() <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> f.readlines()]

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Print top categories per image</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>top5_prob, top5_catid = torch.topk(probabilities, <span class="hljs-number">5</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(top5_prob.size(<span class="hljs-number">0</span>)):
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(categories[top5_catid[i]], top5_prob[i].item())
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># prints class names and probabilities like:</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># [(&#x27;Samoyed&#x27;, 0.6425196528434753), (&#x27;Pomeranian&#x27;, 0.04062102362513542), (&#x27;keeshond&#x27;, 0.03186424449086189), (&#x27;white wolf&#x27;, 0.01739676296710968), (&#x27;Eskimo dog&#x27;, 0.011717947199940681)]</span>`}}),J=new je({}),O=new ie({props:{code:"model = timm.create_model('tf_efficientnet_cc_b0_4e', pretrained=True, num_classes=NUM_FINETUNE_CLASSES)",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>model = timm.create_model(<span class="hljs-string">&#x27;tf_efficientnet_cc_b0_4e&#x27;</span>, pretrained=<span class="hljs-literal">True</span>, num_classes=NUM_FINETUNE_CLASSES)'}}),X=new je({}),K=new je({}),W=new ie({props:{code:`@article{DBLP:journals/corr/abs-1904-04971,
  author    = {Brandon Yang and
               Gabriel Bender and
               Quoc V. Le and
               Jiquan Ngiam},
  title     = {Soft Conditional Computation},
  journal   = {CoRR},
  volume    = {abs/1904.04971},
  year      = {2019},
  url       = {http://arxiv.org/abs/1904.04971},
  archivePrefix = {arXiv},
  eprint    = {1904.04971},
  timestamp = {Thu, 25 Apr 2019 13:55:01 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1904-04971.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}`,highlighted:`@article{DBLP:journals<span class="hljs-regexp">/corr/</span>abs-<span class="hljs-number">1904</span>-<span class="hljs-number">04971</span>,
  author    = {Brandon Yang and
               Gabriel Bender and
               Quoc V. Le and
               Jiquan Ngiam},
  title     = {Soft Conditional Computation},
  journal   = {CoRR},
  volume    = {abs/<span class="hljs-number">1904.04971</span>},
  year      = {<span class="hljs-number">2019</span>},
  url       = {http:<span class="hljs-regexp">//</span>arxiv.org<span class="hljs-regexp">/abs/</span><span class="hljs-number">1904.04971</span>},
  archivePrefix = {arXiv},
  eprint    = {<span class="hljs-number">1904.04971</span>},
  timestamp = {Thu, <span class="hljs-number">25</span> Apr <span class="hljs-number">2019</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">01</span> +<span class="hljs-number">0200</span>},
  biburl    = {https:<span class="hljs-regexp">//</span>dblp.org<span class="hljs-regexp">/rec/</span>journals<span class="hljs-regexp">/corr/</span>abs-<span class="hljs-number">1904</span>-<span class="hljs-number">04971</span>.bib},
  bibsource = {dblp computer science bibliography, https:<span class="hljs-regexp">//</span>dblp.org}
}`}}),{c(){_=n("meta"),ye=h(),v=n("h1"),x=n("a"),re=n("span"),f(z.$$.fragment),it=h(),pe=n("span"),rt=r("(Tensorflow) EfficientNet CondConv"),ke=h(),$=n("p"),me=n("strong"),pt=r("EfficientNet"),mt=r(" is a convolutional neural network architecture and scaling method that uniformly scales all dimensions of depth/width/resolution using a "),he=n("em"),ht=r("compound coefficient"),ct=r(". Unlike conventional practice that arbitrary scales  these factors, the EfficientNet scaling method uniformly scales network width, depth, and resolution with a set of fixed scaling coefficients. For example, if we want to use $2^N$ times more computational resources, then we can simply increase the network depth by $\\alpha ^ N$,  width by $\\beta ^ N$, and image size by $\\gamma ^ N$, where $\\alpha, \\beta, \\gamma$ are constant coefficients determined by a small grid search on the original small model. EfficientNet uses a compound coefficient $\\phi$ to uniformly scales network width, depth, and resolution in a  principled way."),Ee=h(),Z=n("p"),ft=r("The compound scaling method is justified by the intuition that if the input image is bigger, then the network needs more layers to increase the receptive field and more channels to capture more fine-grained patterns on the bigger image."),xe=h(),N=n("p"),ut=r("The base EfficientNet-B0 network is based on the inverted bottleneck residual blocks of "),R=n("a"),dt=r("MobileNetV2"),gt=r(", in addition to squeeze-and-excitation blocks."),Ne=h(),P=n("p"),bt=r("This collection of models amends EfficientNet by adding "),U=n("a"),wt=r("CondConv"),_t=r(" convolutions."),Pe=h(),T=n("p"),vt=r("The weights from this model were ported from "),G=n("a"),$t=r("Tensorflow/TPU"),jt=r("."),Te=h(),j=n("h2"),S=n("a"),ce=n("span"),f(M.$$.fragment),yt=h(),fe=n("span"),kt=r("How do I use this model on an image?"),Se=h(),ee=n("p"),Et=r("To load a pretrained model:"),Ae=h(),f(Y.$$.fragment),Ce=h(),te=n("p"),xt=r("To load and preprocess the image:"),qe=h(),f(D.$$.fragment),Ie=h(),se=n("p"),Nt=r("To get the model predictions:"),He=h(),f(F.$$.fragment),Be=h(),ae=n("p"),Pt=r("To get the top-5 predictions class names:"),Le=h(),f(V.$$.fragment),ze=h(),A=n("p"),Tt=r("Replace the model name with the variant you want to use, e.g. "),ue=n("code"),St=r("tf_efficientnet_cc_b0_4e"),At=r(". You can find the IDs in the model summaries at the top of this page."),Re=h(),C=n("p"),Ct=r("To extract image features with this model, follow the "),ne=n("a"),qt=r("timm feature extraction examples"),It=r(", just change the name of the model you want to use."),Ue=h(),y=n("h2"),q=n("a"),de=n("span"),f(J.$$.fragment),Ht=h(),ge=n("span"),Bt=r("How do I finetune this model?"),Ge=h(),oe=n("p"),Lt=r("You can finetune any of the pre-trained models just by changing the classifier (the last layer)."),Me=h(),f(O.$$.fragment),Ye=h(),I=n("p"),zt=r("To finetune on your own dataset, you have to write a training loop or adapt "),Q=n("a"),Rt=r(`timm\u2019s training
script`),Ut=r(" to use your dataset."),De=h(),k=n("h2"),H=n("a"),be=n("span"),f(X.$$.fragment),Gt=h(),we=n("span"),Mt=r("How do I train this model?"),Fe=h(),B=n("p"),Yt=r("You can follow the "),le=n("a"),Dt=r("timm recipe scripts"),Ft=r(" for training a new model afresh."),Ve=h(),E=n("h2"),L=n("a"),_e=n("span"),f(K.$$.fragment),Vt=h(),ve=n("span"),Jt=r("Citation"),Je=h(),f(W.$$.fragment),this.h()},l(e){const a=Ps('[data-svelte="svelte-1phssyn"]',document.head);_=o(a,"META",{name:!0,content:!0}),a.forEach(t),ye=c(e),v=o(e,"H1",{class:!0});var Qe=i(v);x=o(Qe,"A",{id:!0,class:!0,href:!0});var Qt=i(x);re=o(Qt,"SPAN",{});var Xt=i(re);u(z.$$.fragment,Xt),Xt.forEach(t),Qt.forEach(t),it=c(Qe),pe=o(Qe,"SPAN",{});var Kt=i(pe);rt=p(Kt,"(Tensorflow) EfficientNet CondConv"),Kt.forEach(t),Qe.forEach(t),ke=c(e),$=o(e,"P",{});var $e=i($);me=o($e,"STRONG",{});var Wt=i(me);pt=p(Wt,"EfficientNet"),Wt.forEach(t),mt=p($e," is a convolutional neural network architecture and scaling method that uniformly scales all dimensions of depth/width/resolution using a "),he=o($e,"EM",{});var Zt=i(he);ht=p(Zt,"compound coefficient"),Zt.forEach(t),ct=p($e,". Unlike conventional practice that arbitrary scales  these factors, the EfficientNet scaling method uniformly scales network width, depth, and resolution with a set of fixed scaling coefficients. For example, if we want to use $2^N$ times more computational resources, then we can simply increase the network depth by $\\alpha ^ N$,  width by $\\beta ^ N$, and image size by $\\gamma ^ N$, where $\\alpha, \\beta, \\gamma$ are constant coefficients determined by a small grid search on the original small model. EfficientNet uses a compound coefficient $\\phi$ to uniformly scales network width, depth, and resolution in a  principled way."),$e.forEach(t),Ee=c(e),Z=o(e,"P",{});var es=i(Z);ft=p(es,"The compound scaling method is justified by the intuition that if the input image is bigger, then the network needs more layers to increase the receptive field and more channels to capture more fine-grained patterns on the bigger image."),es.forEach(t),xe=c(e),N=o(e,"P",{});var Xe=i(N);ut=p(Xe,"The base EfficientNet-B0 network is based on the inverted bottleneck residual blocks of "),R=o(Xe,"A",{href:!0,rel:!0});var ts=i(R);dt=p(ts,"MobileNetV2"),ts.forEach(t),gt=p(Xe,", in addition to squeeze-and-excitation blocks."),Xe.forEach(t),Ne=c(e),P=o(e,"P",{});var Ke=i(P);bt=p(Ke,"This collection of models amends EfficientNet by adding "),U=o(Ke,"A",{href:!0,rel:!0});var ss=i(U);wt=p(ss,"CondConv"),ss.forEach(t),_t=p(Ke," convolutions."),Ke.forEach(t),Pe=c(e),T=o(e,"P",{});var We=i(T);vt=p(We,"The weights from this model were ported from "),G=o(We,"A",{href:!0,rel:!0});var as=i(G);$t=p(as,"Tensorflow/TPU"),as.forEach(t),jt=p(We,"."),We.forEach(t),Te=c(e),j=o(e,"H2",{class:!0});var Ze=i(j);S=o(Ze,"A",{id:!0,class:!0,href:!0});var ns=i(S);ce=o(ns,"SPAN",{});var os=i(ce);u(M.$$.fragment,os),os.forEach(t),ns.forEach(t),yt=c(Ze),fe=o(Ze,"SPAN",{});var ls=i(fe);kt=p(ls,"How do I use this model on an image?"),ls.forEach(t),Ze.forEach(t),Se=c(e),ee=o(e,"P",{});var is=i(ee);Et=p(is,"To load a pretrained model:"),is.forEach(t),Ae=c(e),u(Y.$$.fragment,e),Ce=c(e),te=o(e,"P",{});var rs=i(te);xt=p(rs,"To load and preprocess the image:"),rs.forEach(t),qe=c(e),u(D.$$.fragment,e),Ie=c(e),se=o(e,"P",{});var ps=i(se);Nt=p(ps,"To get the model predictions:"),ps.forEach(t),He=c(e),u(F.$$.fragment,e),Be=c(e),ae=o(e,"P",{});var ms=i(ae);Pt=p(ms,"To get the top-5 predictions class names:"),ms.forEach(t),Le=c(e),u(V.$$.fragment,e),ze=c(e),A=o(e,"P",{});var et=i(A);Tt=p(et,"Replace the model name with the variant you want to use, e.g. "),ue=o(et,"CODE",{});var hs=i(ue);St=p(hs,"tf_efficientnet_cc_b0_4e"),hs.forEach(t),At=p(et,". You can find the IDs in the model summaries at the top of this page."),et.forEach(t),Re=c(e),C=o(e,"P",{});var tt=i(C);Ct=p(tt,"To extract image features with this model, follow the "),ne=o(tt,"A",{href:!0});var cs=i(ne);qt=p(cs,"timm feature extraction examples"),cs.forEach(t),It=p(tt,", just change the name of the model you want to use."),tt.forEach(t),Ue=c(e),y=o(e,"H2",{class:!0});var st=i(y);q=o(st,"A",{id:!0,class:!0,href:!0});var fs=i(q);de=o(fs,"SPAN",{});var us=i(de);u(J.$$.fragment,us),us.forEach(t),fs.forEach(t),Ht=c(st),ge=o(st,"SPAN",{});var ds=i(ge);Bt=p(ds,"How do I finetune this model?"),ds.forEach(t),st.forEach(t),Ge=c(e),oe=o(e,"P",{});var gs=i(oe);Lt=p(gs,"You can finetune any of the pre-trained models just by changing the classifier (the last layer)."),gs.forEach(t),Me=c(e),u(O.$$.fragment,e),Ye=c(e),I=o(e,"P",{});var at=i(I);zt=p(at,"To finetune on your own dataset, you have to write a training loop or adapt "),Q=o(at,"A",{href:!0,rel:!0});var bs=i(Q);Rt=p(bs,`timm\u2019s training
script`),bs.forEach(t),Ut=p(at," to use your dataset."),at.forEach(t),De=c(e),k=o(e,"H2",{class:!0});var nt=i(k);H=o(nt,"A",{id:!0,class:!0,href:!0});var ws=i(H);be=o(ws,"SPAN",{});var _s=i(be);u(X.$$.fragment,_s),_s.forEach(t),ws.forEach(t),Gt=c(nt),we=o(nt,"SPAN",{});var vs=i(we);Mt=p(vs,"How do I train this model?"),vs.forEach(t),nt.forEach(t),Fe=c(e),B=o(e,"P",{});var ot=i(B);Yt=p(ot,"You can follow the "),le=o(ot,"A",{href:!0});var $s=i(le);Dt=p($s,"timm recipe scripts"),$s.forEach(t),Ft=p(ot," for training a new model afresh."),ot.forEach(t),Ve=c(e),E=o(e,"H2",{class:!0});var lt=i(E);L=o(lt,"A",{id:!0,class:!0,href:!0});var js=i(L);_e=o(js,"SPAN",{});var ys=i(_e);u(K.$$.fragment,ys),ys.forEach(t),js.forEach(t),Vt=c(lt),ve=o(lt,"SPAN",{});var ks=i(ve);Jt=p(ks,"Citation"),ks.forEach(t),lt.forEach(t),Je=c(e),u(W.$$.fragment,e),this.h()},h(){m(_,"name","hf:doc:metadata"),m(_,"content",JSON.stringify(Cs)),m(x,"id","tensorflow-efficientnet-condconv"),m(x,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(x,"href","#tensorflow-efficientnet-condconv"),m(v,"class","relative group"),m(R,"href","https://paperswithcode.com/method/mobilenetv2"),m(R,"rel","nofollow"),m(U,"href","https://paperswithcode.com/method/condconv"),m(U,"rel","nofollow"),m(G,"href","https://github.com/tensorflow/tpu"),m(G,"rel","nofollow"),m(S,"id","how-do-i-use-this-model-on-an-image"),m(S,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(S,"href","#how-do-i-use-this-model-on-an-image"),m(j,"class","relative group"),m(ne,"href","../feature_extraction"),m(q,"id","how-do-i-finetune-this-model"),m(q,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(q,"href","#how-do-i-finetune-this-model"),m(y,"class","relative group"),m(Q,"href","https://github.com/rwightman/pytorch-image-models/blob/master/train.py"),m(Q,"rel","nofollow"),m(H,"id","how-do-i-train-this-model"),m(H,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(H,"href","#how-do-i-train-this-model"),m(k,"class","relative group"),m(le,"href","../scripts"),m(L,"id","citation"),m(L,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(L,"href","#citation"),m(E,"class","relative group")},m(e,a){s(document.head,_),l(e,ye,a),l(e,v,a),s(v,x),s(x,re),d(z,re,null),s(v,it),s(v,pe),s(pe,rt),l(e,ke,a),l(e,$,a),s($,me),s(me,pt),s($,mt),s($,he),s(he,ht),s($,ct),l(e,Ee,a),l(e,Z,a),s(Z,ft),l(e,xe,a),l(e,N,a),s(N,ut),s(N,R),s(R,dt),s(N,gt),l(e,Ne,a),l(e,P,a),s(P,bt),s(P,U),s(U,wt),s(P,_t),l(e,Pe,a),l(e,T,a),s(T,vt),s(T,G),s(G,$t),s(T,jt),l(e,Te,a),l(e,j,a),s(j,S),s(S,ce),d(M,ce,null),s(j,yt),s(j,fe),s(fe,kt),l(e,Se,a),l(e,ee,a),s(ee,Et),l(e,Ae,a),d(Y,e,a),l(e,Ce,a),l(e,te,a),s(te,xt),l(e,qe,a),d(D,e,a),l(e,Ie,a),l(e,se,a),s(se,Nt),l(e,He,a),d(F,e,a),l(e,Be,a),l(e,ae,a),s(ae,Pt),l(e,Le,a),d(V,e,a),l(e,ze,a),l(e,A,a),s(A,Tt),s(A,ue),s(ue,St),s(A,At),l(e,Re,a),l(e,C,a),s(C,Ct),s(C,ne),s(ne,qt),s(C,It),l(e,Ue,a),l(e,y,a),s(y,q),s(q,de),d(J,de,null),s(y,Ht),s(y,ge),s(ge,Bt),l(e,Ge,a),l(e,oe,a),s(oe,Lt),l(e,Me,a),d(O,e,a),l(e,Ye,a),l(e,I,a),s(I,zt),s(I,Q),s(Q,Rt),s(I,Ut),l(e,De,a),l(e,k,a),s(k,H),s(H,be),d(X,be,null),s(k,Gt),s(k,we),s(we,Mt),l(e,Fe,a),l(e,B,a),s(B,Yt),s(B,le),s(le,Dt),s(B,Ft),l(e,Ve,a),l(e,E,a),s(E,L),s(L,_e),d(K,_e,null),s(E,Vt),s(E,ve),s(ve,Jt),l(e,Je,a),d(W,e,a),Oe=!0},p:Ts,i(e){Oe||(g(z.$$.fragment,e),g(M.$$.fragment,e),g(Y.$$.fragment,e),g(D.$$.fragment,e),g(F.$$.fragment,e),g(V.$$.fragment,e),g(J.$$.fragment,e),g(O.$$.fragment,e),g(X.$$.fragment,e),g(K.$$.fragment,e),g(W.$$.fragment,e),Oe=!0)},o(e){b(z.$$.fragment,e),b(M.$$.fragment,e),b(Y.$$.fragment,e),b(D.$$.fragment,e),b(F.$$.fragment,e),b(V.$$.fragment,e),b(J.$$.fragment,e),b(O.$$.fragment,e),b(X.$$.fragment,e),b(K.$$.fragment,e),b(W.$$.fragment,e),Oe=!1},d(e){t(_),e&&t(ye),e&&t(v),w(z),e&&t(ke),e&&t($),e&&t(Ee),e&&t(Z),e&&t(xe),e&&t(N),e&&t(Ne),e&&t(P),e&&t(Pe),e&&t(T),e&&t(Te),e&&t(j),w(M),e&&t(Se),e&&t(ee),e&&t(Ae),w(Y,e),e&&t(Ce),e&&t(te),e&&t(qe),w(D,e),e&&t(Ie),e&&t(se),e&&t(He),w(F,e),e&&t(Be),e&&t(ae),e&&t(Le),w(V,e),e&&t(ze),e&&t(A),e&&t(Re),e&&t(C),e&&t(Ue),e&&t(y),w(J),e&&t(Ge),e&&t(oe),e&&t(Me),w(O,e),e&&t(Ye),e&&t(I),e&&t(De),e&&t(k),w(X),e&&t(Fe),e&&t(B),e&&t(Ve),e&&t(E),w(K),e&&t(Je),w(W,e)}}}const Cs={local:"tensorflow-efficientnet-condconv",sections:[{local:"how-do-i-use-this-model-on-an-image",title:"How do I use this model on an image?"},{local:"how-do-i-finetune-this-model",title:"How do I finetune this model?"},{local:"how-do-i-train-this-model",title:"How do I train this model?"},{local:"citation",title:"Citation"}],title:"(Tensorflow) EfficientNet CondConv"};function qs(Ot){return Ss(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Ls extends Es{constructor(_){super();xs(this,_,qs,As,Ns,{})}}export{Ls as default,Cs as metadata};
