import{S as Es,i as Ms,s as As,e as a,k as m,w as u,t as d,M as Ds,c as s,d as e,m as l,a as r,x as g,h as c,b as i,G as o,g as f,y as v,q as _,o as $,B as b,v as Is,L as Ia}from"../../chunks/vendor-hf-doc-builder.js";import{D as M}from"../../chunks/Docstring-hf-doc-builder.js";import{C as Pt}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as nt}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as Da}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function Ps(V){let y,z,x,h,j;return h=new Pt({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import ChangeTrueDivToMulByInverse, MergeLinears, compose

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
composition = compose(ChangeTrueDivToMulByInverse(), MergeLinears())
transformed_model = composition(traced)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ChangeTrueDivToMulByInverse, MergeLinears, compose

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>composition = compose(ChangeTrueDivToMulByInverse(), MergeLinears())
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = composition(traced)`}}),{c(){y=a("p"),z=d("Example:"),x=m(),u(h.$$.fragment)},l(p){y=s(p,"P",{});var w=r(y);z=c(w,"Example:"),w.forEach(e),x=l(p),g(h.$$.fragment,p)},m(p,w){f(p,y,w),o(y,z),f(p,x,w),v(h,p,w),j=!0},p:Ia,i(p){j||(_(h.$$.fragment,p),j=!0)},o(p){$(h.$$.fragment,p),j=!1},d(p){p&&e(y),p&&e(x),b(h,p)}}}function qs(V){let y,z,x,h,j;return h=new Pt({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import MergeLinears

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
transformation = MergeLinears()
transformed_model = transformation(traced)
restored_model = transformation(transformed_model, reverse=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> MergeLinears

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = MergeLinears()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)
<span class="hljs-meta">&gt;&gt;&gt; </span>restored_model = transformation(transformed_model, reverse=<span class="hljs-literal">True</span>)`}}),{c(){y=a("p"),z=d("Example:"),x=m(),u(h.$$.fragment)},l(p){y=s(p,"P",{});var w=r(y);z=c(w,"Example:"),w.forEach(e),x=l(p),g(h.$$.fragment,p)},m(p,w){f(p,y,w),o(y,z),f(p,x,w),v(h,p,w),j=!0},p:Ia,i(p){j||(_(h.$$.fragment,p),j=!0)},o(p){$(h.$$.fragment,p),j=!1},d(p){p&&e(y),p&&e(x),b(h,p)}}}function Ls(V){let y,z,x,h,j;return h=new Pt({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import ChangeTrueDivToMulByInverse

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
transformation = ChangeTrueDivToMulByInverse()
transformed_model = transformation(traced)
restored_model = transformation(transformed_model, reverse=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ChangeTrueDivToMulByInverse

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = ChangeTrueDivToMulByInverse()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)
<span class="hljs-meta">&gt;&gt;&gt; </span>restored_model = transformation(transformed_model, reverse=<span class="hljs-literal">True</span>)`}}),{c(){y=a("p"),z=d("Example:"),x=m(),u(h.$$.fragment)},l(p){y=s(p,"P",{});var w=r(y);z=c(w,"Example:"),w.forEach(e),x=l(p),g(h.$$.fragment,p)},m(p,w){f(p,y,w),o(y,z),f(p,x,w),v(h,p,w),j=!0},p:Ia,i(p){j||(_(h.$$.fragment,p),j=!0)},o(p){$(h.$$.fragment,p),j=!1},d(p){p&&e(y),p&&e(x),b(h,p)}}}function Bs(V){let y,z,x,h,j,p,w,se,co,Me,W,ho,re,uo,go,Ae,B,H,ne,it,vo,ie,_o,De,qt,$o,Ie,C,J,me,mt,bo,le,yo,Pe,L,xo,Lt,wo,To,Bt,jo,ko,qe,Ct,zo,Le,lt,Be,Nt,Eo,Ce,pt,Ne,N,U,pe,ft,Mo,fe,Ao,Re,A,Do,Rt,Io,Po,St,qo,Lo,Gt,Bo,Co,Se,Ft,No,Ge,dt,Fe,R,K,de,ct,Ro,ce,So,Oe,Q,Go,Ot,Fo,Oo,Ve,ht,We,S,X,he,ut,Vo,ue,Wo,He,G,Y,ge,gt,Ho,ve,Jo,Je,T,vt,Uo,_e,Ko,Qo,_t,Xo,Vt,Yo,Zo,ta,Wt,$t,ea,Ht,bt,oa,Z,yt,aa,$e,sa,ra,Jt,xt,na,Ut,wt,Ue,k,Tt,ia,be,ma,la,F,pa,Kt,fa,da,Qt,ca,ha,ua,Xt,jt,ga,tt,kt,va,ye,_a,$a,Yt,zt,Ke,I,Et,ba,xe,ya,xa,et,Qe,O,ot,we,Mt,wa,Te,Ta,Xe,P,At,ja,je,ka,za,at,Ye,q,Dt,Ea,ke,Ma,Aa,st,Ze;return p=new nt({}),it=new nt({}),mt=new nt({}),lt=new Pt({props:{code:`from optimum.fx.optimization import Transformation

class ChangeMulToAdd(Transformation):
    def transform(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                node.target = operator.add
        return graph_module`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> Transformation

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeMulToAdd</span>(<span class="hljs-title class_ inherited__">Transformation</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.target = operator.add
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module`}}),pt=new Pt({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)

transformation = ChangeMulToAdd()
transformed_model = transformation(traced)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = ChangeMulToAdd()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)`}}),ft=new nt({}),dt=new Pt({props:{code:`from optimum.fx.optimization import ReversibleTransformation

class MulToMulTimesTwo(ReversibleTransformation):
    def transform(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                x, y = node.args
                node.args = (2 * x, y)
        return graph_module

    def reverse(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                x, y = node.args
                node.args = (x / 2, y)
        return graph_module`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ReversibleTransformation

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulToMulTimesTwo</span>(<span class="hljs-title class_ inherited__">ReversibleTransformation</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                x, y = node.args
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.args = (<span class="hljs-number">2</span> * x, y)
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module

<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                x, y = node.args
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.args = (x / <span class="hljs-number">2</span>, y)
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module`}}),ct=new nt({}),ht=new Pt({props:{code:`from optimum.fx.optimization import compose
composition = compose(MulToMulTimesTwo(), ChangeMulToAdd())`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> compose
<span class="hljs-meta">&gt;&gt;&gt; </span>composition = compose(MulToMulTimesTwo(), ChangeMulToAdd())`}}),ut=new nt({}),gt=new nt({}),vt=new M({props:{name:"class optimum.fx.optimization.Transformation",anchor:"optimum.fx.optimization.Transformation",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/v1.3.0/src/optimum/fx/optimization/transformations.py#L87"}}),$t=new M({props:{name:"__call__",anchor:"optimum.fx.optimization.Transformation.__call__",parameters:[{name:"graph_module",val:": GraphModule"},{name:"lint_and_recompile",val:": bool = True"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.__call__.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"},{anchor:"optimum.fx.optimization.Transformation.__call__.lint_and_recompile",description:`<strong>lint_and_recompile</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the transformed module should be linted and recompiled.
This can be set to <code>False</code> when chaining transformations together to perform this operation only once.`,name:"lint_and_recompile"}],source:"https://github.com/huggingface/optimum/blob/v1.3.0/src/optimum/fx/optimization/transformations.py#L110",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),bt=new M({props:{name:"get_transformed_nodes",anchor:"optimum.fx.optimization.Transformation.get_transformed_nodes",parameters:[{name:"graph_module",val:": GraphModule"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.get_transformed_nodes.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The graph_module to get the nodes from.`,name:"graph_module"}],source:"https://github.com/huggingface/optimum/blob/v1.3.0/src/optimum/fx/optimization/transformations.py#L163",returnDescription:`
<p>Gives the list of nodes that were transformed by the transformation.</p>
`,returnType:`
<p><code>List[torch.fx.Node]</code></p>
`}}),yt=new M({props:{name:"mark_as_transformed",anchor:"optimum.fx.optimization.Transformation.mark_as_transformed",parameters:[{name:"node",val:": Node"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.mark_as_transformed.node",description:`<strong>node</strong> (<code>torch.fx.Node</code>) &#x2014;
The node to mark as transformed.`,name:"node"}],source:"https://github.com/huggingface/optimum/blob/v1.3.0/src/optimum/fx/optimization/transformations.py#L139"}}),xt=new M({props:{name:"transform",anchor:"optimum.fx.optimization.Transformation.transform",parameters:[{name:"graph_module",val:": GraphModule"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.transform.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"}],source:"https://github.com/huggingface/optimum/blob/v1.3.0/src/optimum/fx/optimization/transformations.py#L97",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),wt=new M({props:{name:"transformed",anchor:"optimum.fx.optimization.Transformation.transformed",parameters:[{name:"node",val:": Node"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.transformed.node",description:`<strong>node</strong> (<code>torch.fx.Node</code>) &#x2014;
The node to check.`,name:"node"}],source:"https://github.com/huggingface/optimum/blob/v1.3.0/src/optimum/fx/optimization/transformations.py#L151",returnDescription:`
<p>Specifies whether the node was transformed by this transformation or not.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),Tt=new M({props:{name:"class optimum.fx.optimization.ReversibleTransformation",anchor:"optimum.fx.optimization.ReversibleTransformation",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/v1.3.0/src/optimum/fx/optimization/transformations.py#L178"}}),jt=new M({props:{name:"__call__",anchor:"optimum.fx.optimization.ReversibleTransformation.__call__",parameters:[{name:"graph_module",val:": GraphModule"},{name:"lint_and_recompile",val:": bool = True"},{name:"reverse",val:": bool = False"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"},{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.lint_and_recompile",description:`<strong>lint_and_recompile</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the transformed module should be linted and recompiled.
This can be set to <code>False</code> when chaining transformations together to perform this operation only once.`,name:"lint_and_recompile"},{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.reverse",description:`<strong>reverse</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, the reverse transformation is performed.`,name:"reverse"}],source:"https://github.com/huggingface/optimum/blob/v1.3.0/src/optimum/fx/optimization/transformations.py#L199",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),kt=new M({props:{name:"mark_as_restored",anchor:"optimum.fx.optimization.ReversibleTransformation.mark_as_restored",parameters:[{name:"node",val:": Node"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.mark_as_restored.node",description:`<strong>node</strong> (<code>torch.fx.Node</code>) &#x2014;
The node to mark as restored.`,name:"node"}],source:"https://github.com/huggingface/optimum/blob/v1.3.0/src/optimum/fx/optimization/transformations.py#L224"}}),zt=new M({props:{name:"reverse",anchor:"optimum.fx.optimization.ReversibleTransformation.reverse",parameters:[{name:"graph_module",val:": GraphModule"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.reverse.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"}],source:"https://github.com/huggingface/optimum/blob/v1.3.0/src/optimum/fx/optimization/transformations.py#L186",returnDescription:`
<p>The reverse transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),Et=new M({props:{name:"optimum.fx.optimization.compose",anchor:"optimum.fx.optimization.compose",parameters:[{name:"*args",val:": Transformation"},{name:"inplace",val:": bool = True"}],parametersDescription:[{anchor:"optimum.fx.optimization.compose.args",description:`<strong>args</strong> (<a href="/docs/optimum/v1.3.0/en/fx/optimization#optimum.fx.optimization.Transformation">Transformation</a>) &#x2014;
The transformations to compose together.`,name:"args"},{anchor:"optimum.fx.optimization.compose.inplace",description:`<strong>inplace</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the resulting transformation should be inplace, or create a new graph module.`,name:"inplace"}],source:"https://github.com/huggingface/optimum/blob/v1.3.0/src/optimum/fx/optimization/transformations.py#L435",returnDescription:`
<p>The composition transformation object.</p>
`}}),et=new Da({props:{anchor:"optimum.fx.optimization.compose.example",$$slots:{default:[Ps]},$$scope:{ctx:V}}}),Mt=new nt({}),At=new M({props:{name:"class optimum.fx.optimization.MergeLinears",anchor:"optimum.fx.optimization.MergeLinears",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.MergeLinears.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/v1.3.0/src/optimum/fx/optimization/transformations.py#L239"}}),at=new Da({props:{anchor:"optimum.fx.optimization.MergeLinears.example",$$slots:{default:[qs]},$$scope:{ctx:V}}}),Dt=new M({props:{name:"class optimum.fx.optimization.ChangeTrueDivToMulByInverse",anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/v1.3.0/src/optimum/fx/optimization/transformations.py#L366"}}),st=new Da({props:{anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse.example",$$slots:{default:[Ls]},$$scope:{ctx:V}}}),{c(){y=a("meta"),z=m(),x=a("h1"),h=a("a"),j=a("span"),u(p.$$.fragment),w=m(),se=a("span"),co=d("Optimization"),Me=m(),W=a("p"),ho=d("The "),re=a("code"),uo=d("optimum.fx.optimization"),go=d(" module provides a set of torch.fx graph transformations, along with classes and functions to write your own transformations and compose them."),Ae=m(),B=a("h2"),H=a("a"),ne=a("span"),u(it.$$.fragment),vo=m(),ie=a("span"),_o=d("The transformation guide"),De=m(),qt=a("p"),$o=d("In \u{1F917} Optimum, there are two kinds of transformations: reversible and non-reversible transformations."),Ie=m(),C=a("h3"),J=a("a"),me=a("span"),u(mt.$$.fragment),bo=m(),le=a("span"),yo=d("Write a non-reversible transformation"),Pe=m(),L=a("p"),xo=d("The most basic case of transformations is non-reversible transformations. Those transformations cannot be reversed, meaning that after applying them to a graph module, there is no way to get the original model back. To implement such transformations in \u{1F917} Optimum, it is very easy: you just need to subclass "),Lt=a("a"),wo=d("Transformation"),To=d(" and implement the "),Bt=a("a"),jo=d("transform()"),ko=d(" method."),qe=m(),Ct=a("p"),zo=d("For instance, the following transformation changes all the multiplications to additions:"),Le=m(),u(lt.$$.fragment),Be=m(),Nt=a("p"),Eo=d("After implementing it, your transformation can be used as a regular function:"),Ce=m(),u(pt.$$.fragment),Ne=m(),N=a("h3"),U=a("a"),pe=a("span"),u(ft.$$.fragment),Mo=m(),fe=a("span"),Ao=d("Write a reversible transformation"),Re=m(),A=a("p"),Do=d("A reversible transformation implements both the transformation and its reverse, allowing to retrieve the original model from the transformed one. To implement such transformation, you need to subclass "),Rt=a("a"),Io=d("ReversibleTransformation"),Po=d(" and implement the "),St=a("a"),qo=d("transform()"),Lo=d(" and "),Gt=a("a"),Bo=d("reverse()"),Co=d(" methods."),Se=m(),Ft=a("p"),No=d("For instance, the following transformation is reversible:"),Ge=m(),u(dt.$$.fragment),Fe=m(),R=a("h3"),K=a("a"),de=a("span"),u(ct.$$.fragment),Ro=m(),ce=a("span"),So=d("Composing transformations together"),Oe=m(),Q=a("p"),Go=d("As applying mutilple transformations in chain is needed more often that not, "),Ot=a("a"),Fo=d("compose()"),Oo=d(" is provided. It is an utility function that allows you to create a transformation by chaining multiple other transformations."),Ve=m(),u(ht.$$.fragment),We=m(),S=a("h2"),X=a("a"),he=a("span"),u(ut.$$.fragment),Vo=m(),ue=a("span"),Wo=d("The Optimization API"),He=m(),G=a("h3"),Y=a("a"),ge=a("span"),u(gt.$$.fragment),Ho=m(),ve=a("span"),Jo=d("Main classes and functions"),Je=m(),T=a("div"),u(vt.$$.fragment),Uo=m(),_e=a("p"),Ko=d("A torch.fx graph transformation."),Qo=m(),_t=a("p"),Xo=d("It  must implemement the "),Vt=a("a"),Yo=d("transform()"),Zo=d(` method, and be used as a
callable.`),ta=m(),Wt=a("div"),u($t.$$.fragment),ea=m(),Ht=a("div"),u(bt.$$.fragment),oa=m(),Z=a("div"),u(yt.$$.fragment),aa=m(),$e=a("p"),sa=d("Marks a node as transformed by this transformation."),ra=m(),Jt=a("div"),u(xt.$$.fragment),na=m(),Ut=a("div"),u(wt.$$.fragment),Ue=m(),k=a("div"),u(Tt.$$.fragment),ia=m(),be=a("p"),ma=d("A torch.fx graph transformation that is reversible."),la=m(),F=a("p"),pa=d("It must implemement the "),Kt=a("a"),fa=d("transform()"),da=d(` and
`),Qt=a("a"),ca=d("reverse()"),ha=d(" methods, and be used as a callable."),ua=m(),Xt=a("div"),u(jt.$$.fragment),ga=m(),tt=a("div"),u(kt.$$.fragment),va=m(),ye=a("p"),_a=d("Marks a node as restored back to its original state."),$a=m(),Yt=a("div"),u(zt.$$.fragment),Ke=m(),I=a("div"),u(Et.$$.fragment),ba=m(),xe=a("p"),ya=d("Composes a list of transformations together."),xa=m(),u(et.$$.fragment),Qe=m(),O=a("h3"),ot=a("a"),we=a("span"),u(Mt.$$.fragment),wa=m(),Te=a("span"),Ta=d("Transformations"),Xe=m(),P=a("div"),u(At.$$.fragment),ja=m(),je=a("p"),ka=d("Transformation that merges linear layers that take the same input into one big linear layer."),za=m(),u(at.$$.fragment),Ye=m(),q=a("div"),u(Dt.$$.fragment),Ea=m(),ke=a("p"),Ma=d(`Transformation that changes truediv nodes to multiplication by the inverse nodes when the denominator is static.
For example, that is sometimes the case for the scaling factor in attention layers.`),Aa=m(),u(st.$$.fragment),this.h()},l(t){const n=Ds('[data-svelte="svelte-1phssyn"]',document.head);y=s(n,"META",{name:!0,content:!0}),n.forEach(e),z=l(t),x=s(t,"H1",{class:!0});var It=r(x);h=s(It,"A",{id:!0,class:!0,href:!0});var ze=r(h);j=s(ze,"SPAN",{});var Ee=r(j);g(p.$$.fragment,Ee),Ee.forEach(e),ze.forEach(e),w=l(It),se=s(It,"SPAN",{});var Pa=r(se);co=c(Pa,"Optimization"),Pa.forEach(e),It.forEach(e),Me=l(t),W=s(t,"P",{});var to=r(W);ho=c(to,"The "),re=s(to,"CODE",{});var qa=r(re);uo=c(qa,"optimum.fx.optimization"),qa.forEach(e),go=c(to," module provides a set of torch.fx graph transformations, along with classes and functions to write your own transformations and compose them."),to.forEach(e),Ae=l(t),B=s(t,"H2",{class:!0});var eo=r(B);H=s(eo,"A",{id:!0,class:!0,href:!0});var La=r(H);ne=s(La,"SPAN",{});var Ba=r(ne);g(it.$$.fragment,Ba),Ba.forEach(e),La.forEach(e),vo=l(eo),ie=s(eo,"SPAN",{});var Ca=r(ie);_o=c(Ca,"The transformation guide"),Ca.forEach(e),eo.forEach(e),De=l(t),qt=s(t,"P",{});var Na=r(qt);$o=c(Na,"In \u{1F917} Optimum, there are two kinds of transformations: reversible and non-reversible transformations."),Na.forEach(e),Ie=l(t),C=s(t,"H3",{class:!0});var oo=r(C);J=s(oo,"A",{id:!0,class:!0,href:!0});var Ra=r(J);me=s(Ra,"SPAN",{});var Sa=r(me);g(mt.$$.fragment,Sa),Sa.forEach(e),Ra.forEach(e),bo=l(oo),le=s(oo,"SPAN",{});var Ga=r(le);yo=c(Ga,"Write a non-reversible transformation"),Ga.forEach(e),oo.forEach(e),Pe=l(t),L=s(t,"P",{});var Zt=r(L);xo=c(Zt,"The most basic case of transformations is non-reversible transformations. Those transformations cannot be reversed, meaning that after applying them to a graph module, there is no way to get the original model back. To implement such transformations in \u{1F917} Optimum, it is very easy: you just need to subclass "),Lt=s(Zt,"A",{href:!0});var Fa=r(Lt);wo=c(Fa,"Transformation"),Fa.forEach(e),To=c(Zt," and implement the "),Bt=s(Zt,"A",{href:!0});var Oa=r(Bt);jo=c(Oa,"transform()"),Oa.forEach(e),ko=c(Zt," method."),Zt.forEach(e),qe=l(t),Ct=s(t,"P",{});var Va=r(Ct);zo=c(Va,"For instance, the following transformation changes all the multiplications to additions:"),Va.forEach(e),Le=l(t),g(lt.$$.fragment,t),Be=l(t),Nt=s(t,"P",{});var Wa=r(Nt);Eo=c(Wa,"After implementing it, your transformation can be used as a regular function:"),Wa.forEach(e),Ce=l(t),g(pt.$$.fragment,t),Ne=l(t),N=s(t,"H3",{class:!0});var ao=r(N);U=s(ao,"A",{id:!0,class:!0,href:!0});var Ha=r(U);pe=s(Ha,"SPAN",{});var Ja=r(pe);g(ft.$$.fragment,Ja),Ja.forEach(e),Ha.forEach(e),Mo=l(ao),fe=s(ao,"SPAN",{});var Ua=r(fe);Ao=c(Ua,"Write a reversible transformation"),Ua.forEach(e),ao.forEach(e),Re=l(t),A=s(t,"P",{});var rt=r(A);Do=c(rt,"A reversible transformation implements both the transformation and its reverse, allowing to retrieve the original model from the transformed one. To implement such transformation, you need to subclass "),Rt=s(rt,"A",{href:!0});var Ka=r(Rt);Io=c(Ka,"ReversibleTransformation"),Ka.forEach(e),Po=c(rt," and implement the "),St=s(rt,"A",{href:!0});var Qa=r(St);qo=c(Qa,"transform()"),Qa.forEach(e),Lo=c(rt," and "),Gt=s(rt,"A",{href:!0});var Xa=r(Gt);Bo=c(Xa,"reverse()"),Xa.forEach(e),Co=c(rt," methods."),rt.forEach(e),Se=l(t),Ft=s(t,"P",{});var Ya=r(Ft);No=c(Ya,"For instance, the following transformation is reversible:"),Ya.forEach(e),Ge=l(t),g(dt.$$.fragment,t),Fe=l(t),R=s(t,"H3",{class:!0});var so=r(R);K=s(so,"A",{id:!0,class:!0,href:!0});var Za=r(K);de=s(Za,"SPAN",{});var ts=r(de);g(ct.$$.fragment,ts),ts.forEach(e),Za.forEach(e),Ro=l(so),ce=s(so,"SPAN",{});var es=r(ce);So=c(es,"Composing transformations together"),es.forEach(e),so.forEach(e),Oe=l(t),Q=s(t,"P",{});var ro=r(Q);Go=c(ro,"As applying mutilple transformations in chain is needed more often that not, "),Ot=s(ro,"A",{href:!0});var os=r(Ot);Fo=c(os,"compose()"),os.forEach(e),Oo=c(ro," is provided. It is an utility function that allows you to create a transformation by chaining multiple other transformations."),ro.forEach(e),Ve=l(t),g(ht.$$.fragment,t),We=l(t),S=s(t,"H2",{class:!0});var no=r(S);X=s(no,"A",{id:!0,class:!0,href:!0});var as=r(X);he=s(as,"SPAN",{});var ss=r(he);g(ut.$$.fragment,ss),ss.forEach(e),as.forEach(e),Vo=l(no),ue=s(no,"SPAN",{});var rs=r(ue);Wo=c(rs,"The Optimization API"),rs.forEach(e),no.forEach(e),He=l(t),G=s(t,"H3",{class:!0});var io=r(G);Y=s(io,"A",{id:!0,class:!0,href:!0});var ns=r(Y);ge=s(ns,"SPAN",{});var is=r(ge);g(gt.$$.fragment,is),is.forEach(e),ns.forEach(e),Ho=l(io),ve=s(io,"SPAN",{});var ms=r(ve);Jo=c(ms,"Main classes and functions"),ms.forEach(e),io.forEach(e),Je=l(t),T=s(t,"DIV",{class:!0});var E=r(T);g(vt.$$.fragment,E),Uo=l(E),_e=s(E,"P",{});var ls=r(_e);Ko=c(ls,"A torch.fx graph transformation."),ls.forEach(e),Qo=l(E),_t=s(E,"P",{});var mo=r(_t);Xo=c(mo,"It  must implemement the "),Vt=s(mo,"A",{href:!0});var ps=r(Vt);Yo=c(ps,"transform()"),ps.forEach(e),Zo=c(mo,` method, and be used as a
callable.`),mo.forEach(e),ta=l(E),Wt=s(E,"DIV",{class:!0});var fs=r(Wt);g($t.$$.fragment,fs),fs.forEach(e),ea=l(E),Ht=s(E,"DIV",{class:!0});var ds=r(Ht);g(bt.$$.fragment,ds),ds.forEach(e),oa=l(E),Z=s(E,"DIV",{class:!0});var lo=r(Z);g(yt.$$.fragment,lo),aa=l(lo),$e=s(lo,"P",{});var cs=r($e);sa=c(cs,"Marks a node as transformed by this transformation."),cs.forEach(e),lo.forEach(e),ra=l(E),Jt=s(E,"DIV",{class:!0});var hs=r(Jt);g(xt.$$.fragment,hs),hs.forEach(e),na=l(E),Ut=s(E,"DIV",{class:!0});var us=r(Ut);g(wt.$$.fragment,us),us.forEach(e),E.forEach(e),Ue=l(t),k=s(t,"DIV",{class:!0});var D=r(k);g(Tt.$$.fragment,D),ia=l(D),be=s(D,"P",{});var gs=r(be);ma=c(gs,"A torch.fx graph transformation that is reversible."),gs.forEach(e),la=l(D),F=s(D,"P",{});var te=r(F);pa=c(te,"It must implemement the "),Kt=s(te,"A",{href:!0});var vs=r(Kt);fa=c(vs,"transform()"),vs.forEach(e),da=c(te,` and
`),Qt=s(te,"A",{href:!0});var _s=r(Qt);ca=c(_s,"reverse()"),_s.forEach(e),ha=c(te," methods, and be used as a callable."),te.forEach(e),ua=l(D),Xt=s(D,"DIV",{class:!0});var $s=r(Xt);g(jt.$$.fragment,$s),$s.forEach(e),ga=l(D),tt=s(D,"DIV",{class:!0});var po=r(tt);g(kt.$$.fragment,po),va=l(po),ye=s(po,"P",{});var bs=r(ye);_a=c(bs,"Marks a node as restored back to its original state."),bs.forEach(e),po.forEach(e),$a=l(D),Yt=s(D,"DIV",{class:!0});var ys=r(Yt);g(zt.$$.fragment,ys),ys.forEach(e),D.forEach(e),Ke=l(t),I=s(t,"DIV",{class:!0});var ee=r(I);g(Et.$$.fragment,ee),ba=l(ee),xe=s(ee,"P",{});var xs=r(xe);ya=c(xs,"Composes a list of transformations together."),xs.forEach(e),xa=l(ee),g(et.$$.fragment,ee),ee.forEach(e),Qe=l(t),O=s(t,"H3",{class:!0});var fo=r(O);ot=s(fo,"A",{id:!0,class:!0,href:!0});var ws=r(ot);we=s(ws,"SPAN",{});var Ts=r(we);g(Mt.$$.fragment,Ts),Ts.forEach(e),ws.forEach(e),wa=l(fo),Te=s(fo,"SPAN",{});var js=r(Te);Ta=c(js,"Transformations"),js.forEach(e),fo.forEach(e),Xe=l(t),P=s(t,"DIV",{class:!0});var oe=r(P);g(At.$$.fragment,oe),ja=l(oe),je=s(oe,"P",{});var ks=r(je);ka=c(ks,"Transformation that merges linear layers that take the same input into one big linear layer."),ks.forEach(e),za=l(oe),g(at.$$.fragment,oe),oe.forEach(e),Ye=l(t),q=s(t,"DIV",{class:!0});var ae=r(q);g(Dt.$$.fragment,ae),Ea=l(ae),ke=s(ae,"P",{});var zs=r(ke);Ma=c(zs,`Transformation that changes truediv nodes to multiplication by the inverse nodes when the denominator is static.
For example, that is sometimes the case for the scaling factor in attention layers.`),zs.forEach(e),Aa=l(ae),g(st.$$.fragment,ae),ae.forEach(e),this.h()},h(){i(y,"name","hf:doc:metadata"),i(y,"content",JSON.stringify(Cs)),i(h,"id","optimization"),i(h,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(h,"href","#optimization"),i(x,"class","relative group"),i(H,"id","the-transformation-guide"),i(H,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(H,"href","#the-transformation-guide"),i(B,"class","relative group"),i(J,"id","write-a-nonreversible-transformation"),i(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(J,"href","#write-a-nonreversible-transformation"),i(C,"class","relative group"),i(Lt,"href","/docs/optimum/v1.3.0/en/fx/optimization#optimum.fx.optimization.Transformation"),i(Bt,"href","/docs/optimum/v1.3.0/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),i(U,"id","write-a-reversible-transformation"),i(U,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(U,"href","#write-a-reversible-transformation"),i(N,"class","relative group"),i(Rt,"href","/docs/optimum/v1.3.0/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation"),i(St,"href","/docs/optimum/v1.3.0/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),i(Gt,"href","/docs/optimum/v1.3.0/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation.reverse"),i(K,"id","composing-transformations-together"),i(K,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(K,"href","#composing-transformations-together"),i(R,"class","relative group"),i(Ot,"href","/docs/optimum/v1.3.0/en/fx/optimization#optimum.fx.optimization.compose"),i(X,"id","the-optimization-api"),i(X,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(X,"href","#the-optimization-api"),i(S,"class","relative group"),i(Y,"id","optimum.fx.optimization.Transformation"),i(Y,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(Y,"href","#optimum.fx.optimization.Transformation"),i(G,"class","relative group"),i(Vt,"href","/docs/optimum/v1.3.0/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),i(Wt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ht,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Jt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ut,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(T,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Kt,"href","/docs/optimum/v1.3.0/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),i(Qt,"href","/docs/optimum/v1.3.0/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation.reverse"),i(Xt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(tt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Yt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ot,"id","optimum.fx.optimization.MergeLinears"),i(ot,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(ot,"href","#optimum.fx.optimization.MergeLinears"),i(O,"class","relative group"),i(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,n){o(document.head,y),f(t,z,n),f(t,x,n),o(x,h),o(h,j),v(p,j,null),o(x,w),o(x,se),o(se,co),f(t,Me,n),f(t,W,n),o(W,ho),o(W,re),o(re,uo),o(W,go),f(t,Ae,n),f(t,B,n),o(B,H),o(H,ne),v(it,ne,null),o(B,vo),o(B,ie),o(ie,_o),f(t,De,n),f(t,qt,n),o(qt,$o),f(t,Ie,n),f(t,C,n),o(C,J),o(J,me),v(mt,me,null),o(C,bo),o(C,le),o(le,yo),f(t,Pe,n),f(t,L,n),o(L,xo),o(L,Lt),o(Lt,wo),o(L,To),o(L,Bt),o(Bt,jo),o(L,ko),f(t,qe,n),f(t,Ct,n),o(Ct,zo),f(t,Le,n),v(lt,t,n),f(t,Be,n),f(t,Nt,n),o(Nt,Eo),f(t,Ce,n),v(pt,t,n),f(t,Ne,n),f(t,N,n),o(N,U),o(U,pe),v(ft,pe,null),o(N,Mo),o(N,fe),o(fe,Ao),f(t,Re,n),f(t,A,n),o(A,Do),o(A,Rt),o(Rt,Io),o(A,Po),o(A,St),o(St,qo),o(A,Lo),o(A,Gt),o(Gt,Bo),o(A,Co),f(t,Se,n),f(t,Ft,n),o(Ft,No),f(t,Ge,n),v(dt,t,n),f(t,Fe,n),f(t,R,n),o(R,K),o(K,de),v(ct,de,null),o(R,Ro),o(R,ce),o(ce,So),f(t,Oe,n),f(t,Q,n),o(Q,Go),o(Q,Ot),o(Ot,Fo),o(Q,Oo),f(t,Ve,n),v(ht,t,n),f(t,We,n),f(t,S,n),o(S,X),o(X,he),v(ut,he,null),o(S,Vo),o(S,ue),o(ue,Wo),f(t,He,n),f(t,G,n),o(G,Y),o(Y,ge),v(gt,ge,null),o(G,Ho),o(G,ve),o(ve,Jo),f(t,Je,n),f(t,T,n),v(vt,T,null),o(T,Uo),o(T,_e),o(_e,Ko),o(T,Qo),o(T,_t),o(_t,Xo),o(_t,Vt),o(Vt,Yo),o(_t,Zo),o(T,ta),o(T,Wt),v($t,Wt,null),o(T,ea),o(T,Ht),v(bt,Ht,null),o(T,oa),o(T,Z),v(yt,Z,null),o(Z,aa),o(Z,$e),o($e,sa),o(T,ra),o(T,Jt),v(xt,Jt,null),o(T,na),o(T,Ut),v(wt,Ut,null),f(t,Ue,n),f(t,k,n),v(Tt,k,null),o(k,ia),o(k,be),o(be,ma),o(k,la),o(k,F),o(F,pa),o(F,Kt),o(Kt,fa),o(F,da),o(F,Qt),o(Qt,ca),o(F,ha),o(k,ua),o(k,Xt),v(jt,Xt,null),o(k,ga),o(k,tt),v(kt,tt,null),o(tt,va),o(tt,ye),o(ye,_a),o(k,$a),o(k,Yt),v(zt,Yt,null),f(t,Ke,n),f(t,I,n),v(Et,I,null),o(I,ba),o(I,xe),o(xe,ya),o(I,xa),v(et,I,null),f(t,Qe,n),f(t,O,n),o(O,ot),o(ot,we),v(Mt,we,null),o(O,wa),o(O,Te),o(Te,Ta),f(t,Xe,n),f(t,P,n),v(At,P,null),o(P,ja),o(P,je),o(je,ka),o(P,za),v(at,P,null),f(t,Ye,n),f(t,q,n),v(Dt,q,null),o(q,Ea),o(q,ke),o(ke,Ma),o(q,Aa),v(st,q,null),Ze=!0},p(t,[n]){const It={};n&2&&(It.$$scope={dirty:n,ctx:t}),et.$set(It);const ze={};n&2&&(ze.$$scope={dirty:n,ctx:t}),at.$set(ze);const Ee={};n&2&&(Ee.$$scope={dirty:n,ctx:t}),st.$set(Ee)},i(t){Ze||(_(p.$$.fragment,t),_(it.$$.fragment,t),_(mt.$$.fragment,t),_(lt.$$.fragment,t),_(pt.$$.fragment,t),_(ft.$$.fragment,t),_(dt.$$.fragment,t),_(ct.$$.fragment,t),_(ht.$$.fragment,t),_(ut.$$.fragment,t),_(gt.$$.fragment,t),_(vt.$$.fragment,t),_($t.$$.fragment,t),_(bt.$$.fragment,t),_(yt.$$.fragment,t),_(xt.$$.fragment,t),_(wt.$$.fragment,t),_(Tt.$$.fragment,t),_(jt.$$.fragment,t),_(kt.$$.fragment,t),_(zt.$$.fragment,t),_(Et.$$.fragment,t),_(et.$$.fragment,t),_(Mt.$$.fragment,t),_(At.$$.fragment,t),_(at.$$.fragment,t),_(Dt.$$.fragment,t),_(st.$$.fragment,t),Ze=!0)},o(t){$(p.$$.fragment,t),$(it.$$.fragment,t),$(mt.$$.fragment,t),$(lt.$$.fragment,t),$(pt.$$.fragment,t),$(ft.$$.fragment,t),$(dt.$$.fragment,t),$(ct.$$.fragment,t),$(ht.$$.fragment,t),$(ut.$$.fragment,t),$(gt.$$.fragment,t),$(vt.$$.fragment,t),$($t.$$.fragment,t),$(bt.$$.fragment,t),$(yt.$$.fragment,t),$(xt.$$.fragment,t),$(wt.$$.fragment,t),$(Tt.$$.fragment,t),$(jt.$$.fragment,t),$(kt.$$.fragment,t),$(zt.$$.fragment,t),$(Et.$$.fragment,t),$(et.$$.fragment,t),$(Mt.$$.fragment,t),$(At.$$.fragment,t),$(at.$$.fragment,t),$(Dt.$$.fragment,t),$(st.$$.fragment,t),Ze=!1},d(t){e(y),t&&e(z),t&&e(x),b(p),t&&e(Me),t&&e(W),t&&e(Ae),t&&e(B),b(it),t&&e(De),t&&e(qt),t&&e(Ie),t&&e(C),b(mt),t&&e(Pe),t&&e(L),t&&e(qe),t&&e(Ct),t&&e(Le),b(lt,t),t&&e(Be),t&&e(Nt),t&&e(Ce),b(pt,t),t&&e(Ne),t&&e(N),b(ft),t&&e(Re),t&&e(A),t&&e(Se),t&&e(Ft),t&&e(Ge),b(dt,t),t&&e(Fe),t&&e(R),b(ct),t&&e(Oe),t&&e(Q),t&&e(Ve),b(ht,t),t&&e(We),t&&e(S),b(ut),t&&e(He),t&&e(G),b(gt),t&&e(Je),t&&e(T),b(vt),b($t),b(bt),b(yt),b(xt),b(wt),t&&e(Ue),t&&e(k),b(Tt),b(jt),b(kt),b(zt),t&&e(Ke),t&&e(I),b(Et),b(et),t&&e(Qe),t&&e(O),b(Mt),t&&e(Xe),t&&e(P),b(At),b(at),t&&e(Ye),t&&e(q),b(Dt),b(st)}}}const Cs={local:"optimization",sections:[{local:"the-transformation-guide",sections:[{local:"write-a-nonreversible-transformation",title:"Write a non-reversible transformation"},{local:"write-a-reversible-transformation",title:"Write a reversible transformation"},{local:"composing-transformations-together",title:"Composing transformations together"}],title:"The transformation guide"},{local:"the-optimization-api",sections:[{local:"optimum.fx.optimization.Transformation",title:"Main classes and functions"},{local:"optimum.fx.optimization.MergeLinears",title:"Transformations"}],title:"The Optimization API"}],title:"Optimization"};function Ns(V){return Is(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Vs extends Es{constructor(y){super();Ms(this,y,Ns,Bs,As,{})}}export{Vs as default,Cs as metadata};
