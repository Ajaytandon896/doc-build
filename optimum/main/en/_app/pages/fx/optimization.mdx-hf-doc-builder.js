import{S as Es,i as Ms,s as As,e as o,k as m,w as u,t as d,M as Ds,c as s,d as e,m as l,a as r,x as g,h as c,b as i,G as a,g as f,y as _,q as v,o as $,B as b,v as Is,L as Io}from"../../chunks/vendor-hf-doc-builder.js";import{D as M}from"../../chunks/Docstring-hf-doc-builder.js";import{C as Pt}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as nt}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as Do}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function Ps(V){let y,z,x,h,j;return h=new Pt({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import ChangeTrueDivToMulByInverse, MergeLinears, compose

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
composition = compose(ChangeTrueDivToMulByInverse(), MergeLinears())
transformed_model = composition(traced)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ChangeTrueDivToMulByInverse, MergeLinears, compose

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>composition = compose(ChangeTrueDivToMulByInverse(), MergeLinears())
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = composition(traced)`}}),{c(){y=o("p"),z=d("Example:"),x=m(),u(h.$$.fragment)},l(p){y=s(p,"P",{});var w=r(y);z=c(w,"Example:"),w.forEach(e),x=l(p),g(h.$$.fragment,p)},m(p,w){f(p,y,w),a(y,z),f(p,x,w),_(h,p,w),j=!0},p:Io,i(p){j||(v(h.$$.fragment,p),j=!0)},o(p){$(h.$$.fragment,p),j=!1},d(p){p&&e(y),p&&e(x),b(h,p)}}}function qs(V){let y,z,x,h,j;return h=new Pt({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import MergeLinears

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
transformation = MergeLinears()
transformed_model = transformation(traced)
restored_model = transformation(transformed_model, reverse=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> MergeLinears

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = MergeLinears()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)
<span class="hljs-meta">&gt;&gt;&gt; </span>restored_model = transformation(transformed_model, reverse=<span class="hljs-literal">True</span>)`}}),{c(){y=o("p"),z=d("Example:"),x=m(),u(h.$$.fragment)},l(p){y=s(p,"P",{});var w=r(y);z=c(w,"Example:"),w.forEach(e),x=l(p),g(h.$$.fragment,p)},m(p,w){f(p,y,w),a(y,z),f(p,x,w),_(h,p,w),j=!0},p:Io,i(p){j||(v(h.$$.fragment,p),j=!0)},o(p){$(h.$$.fragment,p),j=!1},d(p){p&&e(y),p&&e(x),b(h,p)}}}function Ls(V){let y,z,x,h,j;return h=new Pt({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import ChangeTrueDivToMulByInverse

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
transformation = ChangeTrueDivToMulByInverse()
transformed_model = transformation(traced)
restored_model = transformation(transformed_model, reverse=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ChangeTrueDivToMulByInverse

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = ChangeTrueDivToMulByInverse()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)
<span class="hljs-meta">&gt;&gt;&gt; </span>restored_model = transformation(transformed_model, reverse=<span class="hljs-literal">True</span>)`}}),{c(){y=o("p"),z=d("Example:"),x=m(),u(h.$$.fragment)},l(p){y=s(p,"P",{});var w=r(y);z=c(w,"Example:"),w.forEach(e),x=l(p),g(h.$$.fragment,p)},m(p,w){f(p,y,w),a(y,z),f(p,x,w),_(h,p,w),j=!0},p:Io,i(p){j||(v(h.$$.fragment,p),j=!0)},o(p){$(h.$$.fragment,p),j=!1},d(p){p&&e(y),p&&e(x),b(h,p)}}}function Bs(V){let y,z,x,h,j,p,w,se,da,Me,W,ca,re,ha,ua,Ae,B,H,ne,it,ga,ie,_a,De,qt,va,Ie,C,J,me,mt,$a,le,ba,Pe,L,ya,Lt,xa,wa,Bt,Ta,ja,qe,Ct,ka,Le,lt,Be,Nt,za,Ce,pt,Ne,N,U,pe,ft,Ea,fe,Ma,Re,A,Aa,Rt,Da,Ia,St,Pa,qa,Gt,La,Ba,Se,Ft,Ca,Ge,dt,Fe,R,K,de,ct,Na,ce,Ra,Oe,Q,Sa,Ot,Ga,Fa,Ve,ht,We,S,X,he,ut,Oa,ue,Va,He,G,Y,ge,gt,Wa,_e,Ha,Je,T,_t,Ja,ve,Ua,Ka,vt,Qa,Vt,Xa,Ya,Za,Wt,$t,to,Ht,bt,eo,Z,yt,ao,$e,oo,so,Jt,xt,ro,Ut,wt,Ue,k,Tt,no,be,io,mo,F,lo,Kt,po,fo,Qt,co,ho,uo,Xt,jt,go,tt,kt,_o,ye,vo,$o,Yt,zt,Ke,I,Et,bo,xe,yo,xo,et,Qe,O,at,we,Mt,wo,Te,To,Xe,P,At,jo,je,ko,zo,ot,Ye,q,Dt,Eo,ke,Mo,Ao,st,Ze;return p=new nt({}),it=new nt({}),mt=new nt({}),lt=new Pt({props:{code:`from optimum.fx.optimization import Transformation

class ChangeMulToAdd(Transformation):
    def transform(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                node.target = operator.add
        return graph_module`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> Transformation

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeMulToAdd</span>(<span class="hljs-title class_ inherited__">Transformation</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.target = operator.add
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module`}}),pt=new Pt({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)

transformation = ChangeMulToAdd()
transformed_model = transformation(traced)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = ChangeMulToAdd()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)`}}),ft=new nt({}),dt=new Pt({props:{code:`from optimum.fx.optimization import ReversibleTransformation

class MulToMulTimesTwo(ReversibleTransformation):
    def transform(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                x, y = node.args
                node.args = (2 * x, y)
        return graph_module

    def reverse(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                x, y = node.args
                node.args = (x / 2, y)
        return graph_module`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ReversibleTransformation

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulToMulTimesTwo</span>(<span class="hljs-title class_ inherited__">ReversibleTransformation</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                x, y = node.args
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.args = (<span class="hljs-number">2</span> * x, y)
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module

<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                x, y = node.args
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.args = (x / <span class="hljs-number">2</span>, y)
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module`}}),ct=new nt({}),ht=new Pt({props:{code:`from optimum.fx.optimization import compose
composition = compose(MulToMulTimesTwo(), ChangeMulToAdd())`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> compose
<span class="hljs-meta">&gt;&gt;&gt; </span>composition = compose(MulToMulTimesTwo(), ChangeMulToAdd())`}}),ut=new nt({}),gt=new nt({}),_t=new M({props:{name:"class optimum.fx.optimization.Transformation",anchor:"optimum.fx.optimization.Transformation",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/fx/optimization/transformations.py#L87"}}),$t=new M({props:{name:"__call__",anchor:"optimum.fx.optimization.Transformation.__call__",parameters:[{name:"graph_module",val:": GraphModule"},{name:"lint_and_recompile",val:": bool = True"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.__call__.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"},{anchor:"optimum.fx.optimization.Transformation.__call__.lint_and_recompile",description:`<strong>lint_and_recompile</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the transformed module should be linted and recompiled.
This can be set to <code>False</code> when chaining transformations together to perform this operation only once.`,name:"lint_and_recompile"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/fx/optimization/transformations.py#L110",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),bt=new M({props:{name:"get_transformed_nodes",anchor:"optimum.fx.optimization.Transformation.get_transformed_nodes",parameters:[{name:"graph_module",val:": GraphModule"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.get_transformed_nodes.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The graph_module to get the nodes from.`,name:"graph_module"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/fx/optimization/transformations.py#L163",returnDescription:`
<p>Gives the list of nodes that were transformed by the transformation.</p>
`,returnType:`
<p><code>List[torch.fx.Node]</code></p>
`}}),yt=new M({props:{name:"mark_as_transformed",anchor:"optimum.fx.optimization.Transformation.mark_as_transformed",parameters:[{name:"node",val:": Node"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.mark_as_transformed.node",description:`<strong>node</strong> (<code>torch.fx.Node</code>) &#x2014;
The node to mark as transformed.`,name:"node"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/fx/optimization/transformations.py#L139"}}),xt=new M({props:{name:"transform",anchor:"optimum.fx.optimization.Transformation.transform",parameters:[{name:"graph_module",val:": GraphModule"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.transform.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/fx/optimization/transformations.py#L97",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),wt=new M({props:{name:"transformed",anchor:"optimum.fx.optimization.Transformation.transformed",parameters:[{name:"node",val:": Node"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.transformed.node",description:`<strong>node</strong> (<code>torch.fx.Node</code>) &#x2014;
The node to check.`,name:"node"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/fx/optimization/transformations.py#L151",returnDescription:`
<p>Specifies whether the node was transformed by this transformation or not.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),Tt=new M({props:{name:"class optimum.fx.optimization.ReversibleTransformation",anchor:"optimum.fx.optimization.ReversibleTransformation",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/fx/optimization/transformations.py#L178"}}),jt=new M({props:{name:"__call__",anchor:"optimum.fx.optimization.ReversibleTransformation.__call__",parameters:[{name:"graph_module",val:": GraphModule"},{name:"lint_and_recompile",val:": bool = True"},{name:"reverse",val:": bool = False"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"},{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.lint_and_recompile",description:`<strong>lint_and_recompile</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the transformed module should be linted and recompiled.
This can be set to <code>False</code> when chaining transformations together to perform this operation only once.`,name:"lint_and_recompile"},{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.reverse",description:`<strong>reverse</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, the reverse transformation is performed.`,name:"reverse"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/fx/optimization/transformations.py#L199",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),kt=new M({props:{name:"mark_as_restored",anchor:"optimum.fx.optimization.ReversibleTransformation.mark_as_restored",parameters:[{name:"node",val:": Node"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.mark_as_restored.node",description:`<strong>node</strong> (<code>torch.fx.Node</code>) &#x2014;
The node to mark as restored.`,name:"node"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/fx/optimization/transformations.py#L224"}}),zt=new M({props:{name:"reverse",anchor:"optimum.fx.optimization.ReversibleTransformation.reverse",parameters:[{name:"graph_module",val:": GraphModule"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.reverse.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/fx/optimization/transformations.py#L186",returnDescription:`
<p>The reverse transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),Et=new M({props:{name:"optimum.fx.optimization.compose",anchor:"optimum.fx.optimization.compose",parameters:[{name:"*args",val:": Transformation"},{name:"inplace",val:": bool = True"}],parametersDescription:[{anchor:"optimum.fx.optimization.compose.args",description:`<strong>args</strong> (<a href="/docs/optimum/main/en/fx/optimization#optimum.fx.optimization.Transformation">Transformation</a>) &#x2014;
The transformations to compose together.`,name:"args"},{anchor:"optimum.fx.optimization.compose.inplace",description:`<strong>inplace</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the resulting transformation should be inplace, or create a new graph module.`,name:"inplace"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/fx/optimization/transformations.py#L435",returnDescription:`
<p>The composition transformation object.</p>
`}}),et=new Do({props:{anchor:"optimum.fx.optimization.compose.example",$$slots:{default:[Ps]},$$scope:{ctx:V}}}),Mt=new nt({}),At=new M({props:{name:"class optimum.fx.optimization.MergeLinears",anchor:"optimum.fx.optimization.MergeLinears",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.MergeLinears.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/fx/optimization/transformations.py#L239"}}),ot=new Do({props:{anchor:"optimum.fx.optimization.MergeLinears.example",$$slots:{default:[qs]},$$scope:{ctx:V}}}),Dt=new M({props:{name:"class optimum.fx.optimization.ChangeTrueDivToMulByInverse",anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/fx/optimization/transformations.py#L366"}}),st=new Do({props:{anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse.example",$$slots:{default:[Ls]},$$scope:{ctx:V}}}),{c(){y=o("meta"),z=m(),x=o("h1"),h=o("a"),j=o("span"),u(p.$$.fragment),w=m(),se=o("span"),da=d("Optimization"),Me=m(),W=o("p"),ca=d("The "),re=o("code"),ha=d("optimum.fx.optimization"),ua=d(" module provides a set of torch.fx graph transformations, along with classes and functions to write your own transformations and compose them."),Ae=m(),B=o("h2"),H=o("a"),ne=o("span"),u(it.$$.fragment),ga=m(),ie=o("span"),_a=d("The transformation guide"),De=m(),qt=o("p"),va=d("In \u{1F917} Optimum, there are two kinds of transformations: reversible and non-reversible transformations."),Ie=m(),C=o("h3"),J=o("a"),me=o("span"),u(mt.$$.fragment),$a=m(),le=o("span"),ba=d("Write a non-reversible transformation"),Pe=m(),L=o("p"),ya=d("The most basic case of transformations is non-reversible transformations. Those transformations cannot be reversed, meaning that after applying them to a graph module, there is no way to get the original model back. To implement such transformations in \u{1F917} Optimum, it is very easy: you just need to subclass "),Lt=o("a"),xa=d("Transformation"),wa=d(" and implement the "),Bt=o("a"),Ta=d("transform()"),ja=d(" method."),qe=m(),Ct=o("p"),ka=d("For instance, the following transformation changes all the multiplications to additions:"),Le=m(),u(lt.$$.fragment),Be=m(),Nt=o("p"),za=d("After implementing it, your transformation can be used as a regular function:"),Ce=m(),u(pt.$$.fragment),Ne=m(),N=o("h3"),U=o("a"),pe=o("span"),u(ft.$$.fragment),Ea=m(),fe=o("span"),Ma=d("Write a reversible transformation"),Re=m(),A=o("p"),Aa=d("A reversible transformation implements both the transformation and its reverse, allowing to retrieve the original model from the transformed one. To implement such transformation, you need to subclass "),Rt=o("a"),Da=d("ReversibleTransformation"),Ia=d(" and implement the "),St=o("a"),Pa=d("transform()"),qa=d(" and "),Gt=o("a"),La=d("reverse()"),Ba=d(" methods."),Se=m(),Ft=o("p"),Ca=d("For instance, the following transformation is reversible:"),Ge=m(),u(dt.$$.fragment),Fe=m(),R=o("h3"),K=o("a"),de=o("span"),u(ct.$$.fragment),Na=m(),ce=o("span"),Ra=d("Composing transformations together"),Oe=m(),Q=o("p"),Sa=d("As applying mutilple transformations in chain is needed more often that not, "),Ot=o("a"),Ga=d("compose()"),Fa=d(" is provided. It is an utility function that allows you to create a transformation by chaining multiple other transformations."),Ve=m(),u(ht.$$.fragment),We=m(),S=o("h2"),X=o("a"),he=o("span"),u(ut.$$.fragment),Oa=m(),ue=o("span"),Va=d("The Optimization API"),He=m(),G=o("h3"),Y=o("a"),ge=o("span"),u(gt.$$.fragment),Wa=m(),_e=o("span"),Ha=d("Main classes and functions"),Je=m(),T=o("div"),u(_t.$$.fragment),Ja=m(),ve=o("p"),Ua=d("A torch.fx graph transformation."),Ka=m(),vt=o("p"),Qa=d("It  must implemement the "),Vt=o("a"),Xa=d("transform()"),Ya=d(` method, and be used as a
callable.`),Za=m(),Wt=o("div"),u($t.$$.fragment),to=m(),Ht=o("div"),u(bt.$$.fragment),eo=m(),Z=o("div"),u(yt.$$.fragment),ao=m(),$e=o("p"),oo=d("Marks a node as transformed by this transformation."),so=m(),Jt=o("div"),u(xt.$$.fragment),ro=m(),Ut=o("div"),u(wt.$$.fragment),Ue=m(),k=o("div"),u(Tt.$$.fragment),no=m(),be=o("p"),io=d("A torch.fx graph transformation that is reversible."),mo=m(),F=o("p"),lo=d("It must implemement the "),Kt=o("a"),po=d("transform()"),fo=d(` and
`),Qt=o("a"),co=d("reverse()"),ho=d(" methods, and be used as a callable."),uo=m(),Xt=o("div"),u(jt.$$.fragment),go=m(),tt=o("div"),u(kt.$$.fragment),_o=m(),ye=o("p"),vo=d("Marks a node as restored back to its original state."),$o=m(),Yt=o("div"),u(zt.$$.fragment),Ke=m(),I=o("div"),u(Et.$$.fragment),bo=m(),xe=o("p"),yo=d("Composes a list of transformations together."),xo=m(),u(et.$$.fragment),Qe=m(),O=o("h3"),at=o("a"),we=o("span"),u(Mt.$$.fragment),wo=m(),Te=o("span"),To=d("Transformations"),Xe=m(),P=o("div"),u(At.$$.fragment),jo=m(),je=o("p"),ko=d("Transformation that merges linear layers that take the same input into one big linear layer."),zo=m(),u(ot.$$.fragment),Ye=m(),q=o("div"),u(Dt.$$.fragment),Eo=m(),ke=o("p"),Mo=d(`Transformation that changes truediv nodes to multiplication by the inverse nodes when the denominator is static.
For example, that is sometimes the case for the scaling factor in attention layers.`),Ao=m(),u(st.$$.fragment),this.h()},l(t){const n=Ds('[data-svelte="svelte-1phssyn"]',document.head);y=s(n,"META",{name:!0,content:!0}),n.forEach(e),z=l(t),x=s(t,"H1",{class:!0});var It=r(x);h=s(It,"A",{id:!0,class:!0,href:!0});var ze=r(h);j=s(ze,"SPAN",{});var Ee=r(j);g(p.$$.fragment,Ee),Ee.forEach(e),ze.forEach(e),w=l(It),se=s(It,"SPAN",{});var Po=r(se);da=c(Po,"Optimization"),Po.forEach(e),It.forEach(e),Me=l(t),W=s(t,"P",{});var ta=r(W);ca=c(ta,"The "),re=s(ta,"CODE",{});var qo=r(re);ha=c(qo,"optimum.fx.optimization"),qo.forEach(e),ua=c(ta," module provides a set of torch.fx graph transformations, along with classes and functions to write your own transformations and compose them."),ta.forEach(e),Ae=l(t),B=s(t,"H2",{class:!0});var ea=r(B);H=s(ea,"A",{id:!0,class:!0,href:!0});var Lo=r(H);ne=s(Lo,"SPAN",{});var Bo=r(ne);g(it.$$.fragment,Bo),Bo.forEach(e),Lo.forEach(e),ga=l(ea),ie=s(ea,"SPAN",{});var Co=r(ie);_a=c(Co,"The transformation guide"),Co.forEach(e),ea.forEach(e),De=l(t),qt=s(t,"P",{});var No=r(qt);va=c(No,"In \u{1F917} Optimum, there are two kinds of transformations: reversible and non-reversible transformations."),No.forEach(e),Ie=l(t),C=s(t,"H3",{class:!0});var aa=r(C);J=s(aa,"A",{id:!0,class:!0,href:!0});var Ro=r(J);me=s(Ro,"SPAN",{});var So=r(me);g(mt.$$.fragment,So),So.forEach(e),Ro.forEach(e),$a=l(aa),le=s(aa,"SPAN",{});var Go=r(le);ba=c(Go,"Write a non-reversible transformation"),Go.forEach(e),aa.forEach(e),Pe=l(t),L=s(t,"P",{});var Zt=r(L);ya=c(Zt,"The most basic case of transformations is non-reversible transformations. Those transformations cannot be reversed, meaning that after applying them to a graph module, there is no way to get the original model back. To implement such transformations in \u{1F917} Optimum, it is very easy: you just need to subclass "),Lt=s(Zt,"A",{href:!0});var Fo=r(Lt);xa=c(Fo,"Transformation"),Fo.forEach(e),wa=c(Zt," and implement the "),Bt=s(Zt,"A",{href:!0});var Oo=r(Bt);Ta=c(Oo,"transform()"),Oo.forEach(e),ja=c(Zt," method."),Zt.forEach(e),qe=l(t),Ct=s(t,"P",{});var Vo=r(Ct);ka=c(Vo,"For instance, the following transformation changes all the multiplications to additions:"),Vo.forEach(e),Le=l(t),g(lt.$$.fragment,t),Be=l(t),Nt=s(t,"P",{});var Wo=r(Nt);za=c(Wo,"After implementing it, your transformation can be used as a regular function:"),Wo.forEach(e),Ce=l(t),g(pt.$$.fragment,t),Ne=l(t),N=s(t,"H3",{class:!0});var oa=r(N);U=s(oa,"A",{id:!0,class:!0,href:!0});var Ho=r(U);pe=s(Ho,"SPAN",{});var Jo=r(pe);g(ft.$$.fragment,Jo),Jo.forEach(e),Ho.forEach(e),Ea=l(oa),fe=s(oa,"SPAN",{});var Uo=r(fe);Ma=c(Uo,"Write a reversible transformation"),Uo.forEach(e),oa.forEach(e),Re=l(t),A=s(t,"P",{});var rt=r(A);Aa=c(rt,"A reversible transformation implements both the transformation and its reverse, allowing to retrieve the original model from the transformed one. To implement such transformation, you need to subclass "),Rt=s(rt,"A",{href:!0});var Ko=r(Rt);Da=c(Ko,"ReversibleTransformation"),Ko.forEach(e),Ia=c(rt," and implement the "),St=s(rt,"A",{href:!0});var Qo=r(St);Pa=c(Qo,"transform()"),Qo.forEach(e),qa=c(rt," and "),Gt=s(rt,"A",{href:!0});var Xo=r(Gt);La=c(Xo,"reverse()"),Xo.forEach(e),Ba=c(rt," methods."),rt.forEach(e),Se=l(t),Ft=s(t,"P",{});var Yo=r(Ft);Ca=c(Yo,"For instance, the following transformation is reversible:"),Yo.forEach(e),Ge=l(t),g(dt.$$.fragment,t),Fe=l(t),R=s(t,"H3",{class:!0});var sa=r(R);K=s(sa,"A",{id:!0,class:!0,href:!0});var Zo=r(K);de=s(Zo,"SPAN",{});var ts=r(de);g(ct.$$.fragment,ts),ts.forEach(e),Zo.forEach(e),Na=l(sa),ce=s(sa,"SPAN",{});var es=r(ce);Ra=c(es,"Composing transformations together"),es.forEach(e),sa.forEach(e),Oe=l(t),Q=s(t,"P",{});var ra=r(Q);Sa=c(ra,"As applying mutilple transformations in chain is needed more often that not, "),Ot=s(ra,"A",{href:!0});var as=r(Ot);Ga=c(as,"compose()"),as.forEach(e),Fa=c(ra," is provided. It is an utility function that allows you to create a transformation by chaining multiple other transformations."),ra.forEach(e),Ve=l(t),g(ht.$$.fragment,t),We=l(t),S=s(t,"H2",{class:!0});var na=r(S);X=s(na,"A",{id:!0,class:!0,href:!0});var os=r(X);he=s(os,"SPAN",{});var ss=r(he);g(ut.$$.fragment,ss),ss.forEach(e),os.forEach(e),Oa=l(na),ue=s(na,"SPAN",{});var rs=r(ue);Va=c(rs,"The Optimization API"),rs.forEach(e),na.forEach(e),He=l(t),G=s(t,"H3",{class:!0});var ia=r(G);Y=s(ia,"A",{id:!0,class:!0,href:!0});var ns=r(Y);ge=s(ns,"SPAN",{});var is=r(ge);g(gt.$$.fragment,is),is.forEach(e),ns.forEach(e),Wa=l(ia),_e=s(ia,"SPAN",{});var ms=r(_e);Ha=c(ms,"Main classes and functions"),ms.forEach(e),ia.forEach(e),Je=l(t),T=s(t,"DIV",{class:!0});var E=r(T);g(_t.$$.fragment,E),Ja=l(E),ve=s(E,"P",{});var ls=r(ve);Ua=c(ls,"A torch.fx graph transformation."),ls.forEach(e),Ka=l(E),vt=s(E,"P",{});var ma=r(vt);Qa=c(ma,"It  must implemement the "),Vt=s(ma,"A",{href:!0});var ps=r(Vt);Xa=c(ps,"transform()"),ps.forEach(e),Ya=c(ma,` method, and be used as a
callable.`),ma.forEach(e),Za=l(E),Wt=s(E,"DIV",{class:!0});var fs=r(Wt);g($t.$$.fragment,fs),fs.forEach(e),to=l(E),Ht=s(E,"DIV",{class:!0});var ds=r(Ht);g(bt.$$.fragment,ds),ds.forEach(e),eo=l(E),Z=s(E,"DIV",{class:!0});var la=r(Z);g(yt.$$.fragment,la),ao=l(la),$e=s(la,"P",{});var cs=r($e);oo=c(cs,"Marks a node as transformed by this transformation."),cs.forEach(e),la.forEach(e),so=l(E),Jt=s(E,"DIV",{class:!0});var hs=r(Jt);g(xt.$$.fragment,hs),hs.forEach(e),ro=l(E),Ut=s(E,"DIV",{class:!0});var us=r(Ut);g(wt.$$.fragment,us),us.forEach(e),E.forEach(e),Ue=l(t),k=s(t,"DIV",{class:!0});var D=r(k);g(Tt.$$.fragment,D),no=l(D),be=s(D,"P",{});var gs=r(be);io=c(gs,"A torch.fx graph transformation that is reversible."),gs.forEach(e),mo=l(D),F=s(D,"P",{});var te=r(F);lo=c(te,"It must implemement the "),Kt=s(te,"A",{href:!0});var _s=r(Kt);po=c(_s,"transform()"),_s.forEach(e),fo=c(te,` and
`),Qt=s(te,"A",{href:!0});var vs=r(Qt);co=c(vs,"reverse()"),vs.forEach(e),ho=c(te," methods, and be used as a callable."),te.forEach(e),uo=l(D),Xt=s(D,"DIV",{class:!0});var $s=r(Xt);g(jt.$$.fragment,$s),$s.forEach(e),go=l(D),tt=s(D,"DIV",{class:!0});var pa=r(tt);g(kt.$$.fragment,pa),_o=l(pa),ye=s(pa,"P",{});var bs=r(ye);vo=c(bs,"Marks a node as restored back to its original state."),bs.forEach(e),pa.forEach(e),$o=l(D),Yt=s(D,"DIV",{class:!0});var ys=r(Yt);g(zt.$$.fragment,ys),ys.forEach(e),D.forEach(e),Ke=l(t),I=s(t,"DIV",{class:!0});var ee=r(I);g(Et.$$.fragment,ee),bo=l(ee),xe=s(ee,"P",{});var xs=r(xe);yo=c(xs,"Composes a list of transformations together."),xs.forEach(e),xo=l(ee),g(et.$$.fragment,ee),ee.forEach(e),Qe=l(t),O=s(t,"H3",{class:!0});var fa=r(O);at=s(fa,"A",{id:!0,class:!0,href:!0});var ws=r(at);we=s(ws,"SPAN",{});var Ts=r(we);g(Mt.$$.fragment,Ts),Ts.forEach(e),ws.forEach(e),wo=l(fa),Te=s(fa,"SPAN",{});var js=r(Te);To=c(js,"Transformations"),js.forEach(e),fa.forEach(e),Xe=l(t),P=s(t,"DIV",{class:!0});var ae=r(P);g(At.$$.fragment,ae),jo=l(ae),je=s(ae,"P",{});var ks=r(je);ko=c(ks,"Transformation that merges linear layers that take the same input into one big linear layer."),ks.forEach(e),zo=l(ae),g(ot.$$.fragment,ae),ae.forEach(e),Ye=l(t),q=s(t,"DIV",{class:!0});var oe=r(q);g(Dt.$$.fragment,oe),Eo=l(oe),ke=s(oe,"P",{});var zs=r(ke);Mo=c(zs,`Transformation that changes truediv nodes to multiplication by the inverse nodes when the denominator is static.
For example, that is sometimes the case for the scaling factor in attention layers.`),zs.forEach(e),Ao=l(oe),g(st.$$.fragment,oe),oe.forEach(e),this.h()},h(){i(y,"name","hf:doc:metadata"),i(y,"content",JSON.stringify(Cs)),i(h,"id","optimization"),i(h,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(h,"href","#optimization"),i(x,"class","relative group"),i(H,"id","the-transformation-guide"),i(H,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(H,"href","#the-transformation-guide"),i(B,"class","relative group"),i(J,"id","write-a-nonreversible-transformation"),i(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(J,"href","#write-a-nonreversible-transformation"),i(C,"class","relative group"),i(Lt,"href","/docs/optimum/main/en/fx/optimization#optimum.fx.optimization.Transformation"),i(Bt,"href","/docs/optimum/main/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),i(U,"id","write-a-reversible-transformation"),i(U,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(U,"href","#write-a-reversible-transformation"),i(N,"class","relative group"),i(Rt,"href","/docs/optimum/main/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation"),i(St,"href","/docs/optimum/main/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),i(Gt,"href","/docs/optimum/main/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation.reverse"),i(K,"id","composing-transformations-together"),i(K,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(K,"href","#composing-transformations-together"),i(R,"class","relative group"),i(Ot,"href","/docs/optimum/main/en/fx/optimization#optimum.fx.optimization.compose"),i(X,"id","the-optimization-api"),i(X,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(X,"href","#the-optimization-api"),i(S,"class","relative group"),i(Y,"id","optimum.fx.optimization.Transformation"),i(Y,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(Y,"href","#optimum.fx.optimization.Transformation"),i(G,"class","relative group"),i(Vt,"href","/docs/optimum/main/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),i(Wt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ht,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Jt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ut,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(T,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Kt,"href","/docs/optimum/main/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),i(Qt,"href","/docs/optimum/main/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation.reverse"),i(Xt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(tt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Yt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(at,"id","optimum.fx.optimization.MergeLinears"),i(at,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(at,"href","#optimum.fx.optimization.MergeLinears"),i(O,"class","relative group"),i(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,n){a(document.head,y),f(t,z,n),f(t,x,n),a(x,h),a(h,j),_(p,j,null),a(x,w),a(x,se),a(se,da),f(t,Me,n),f(t,W,n),a(W,ca),a(W,re),a(re,ha),a(W,ua),f(t,Ae,n),f(t,B,n),a(B,H),a(H,ne),_(it,ne,null),a(B,ga),a(B,ie),a(ie,_a),f(t,De,n),f(t,qt,n),a(qt,va),f(t,Ie,n),f(t,C,n),a(C,J),a(J,me),_(mt,me,null),a(C,$a),a(C,le),a(le,ba),f(t,Pe,n),f(t,L,n),a(L,ya),a(L,Lt),a(Lt,xa),a(L,wa),a(L,Bt),a(Bt,Ta),a(L,ja),f(t,qe,n),f(t,Ct,n),a(Ct,ka),f(t,Le,n),_(lt,t,n),f(t,Be,n),f(t,Nt,n),a(Nt,za),f(t,Ce,n),_(pt,t,n),f(t,Ne,n),f(t,N,n),a(N,U),a(U,pe),_(ft,pe,null),a(N,Ea),a(N,fe),a(fe,Ma),f(t,Re,n),f(t,A,n),a(A,Aa),a(A,Rt),a(Rt,Da),a(A,Ia),a(A,St),a(St,Pa),a(A,qa),a(A,Gt),a(Gt,La),a(A,Ba),f(t,Se,n),f(t,Ft,n),a(Ft,Ca),f(t,Ge,n),_(dt,t,n),f(t,Fe,n),f(t,R,n),a(R,K),a(K,de),_(ct,de,null),a(R,Na),a(R,ce),a(ce,Ra),f(t,Oe,n),f(t,Q,n),a(Q,Sa),a(Q,Ot),a(Ot,Ga),a(Q,Fa),f(t,Ve,n),_(ht,t,n),f(t,We,n),f(t,S,n),a(S,X),a(X,he),_(ut,he,null),a(S,Oa),a(S,ue),a(ue,Va),f(t,He,n),f(t,G,n),a(G,Y),a(Y,ge),_(gt,ge,null),a(G,Wa),a(G,_e),a(_e,Ha),f(t,Je,n),f(t,T,n),_(_t,T,null),a(T,Ja),a(T,ve),a(ve,Ua),a(T,Ka),a(T,vt),a(vt,Qa),a(vt,Vt),a(Vt,Xa),a(vt,Ya),a(T,Za),a(T,Wt),_($t,Wt,null),a(T,to),a(T,Ht),_(bt,Ht,null),a(T,eo),a(T,Z),_(yt,Z,null),a(Z,ao),a(Z,$e),a($e,oo),a(T,so),a(T,Jt),_(xt,Jt,null),a(T,ro),a(T,Ut),_(wt,Ut,null),f(t,Ue,n),f(t,k,n),_(Tt,k,null),a(k,no),a(k,be),a(be,io),a(k,mo),a(k,F),a(F,lo),a(F,Kt),a(Kt,po),a(F,fo),a(F,Qt),a(Qt,co),a(F,ho),a(k,uo),a(k,Xt),_(jt,Xt,null),a(k,go),a(k,tt),_(kt,tt,null),a(tt,_o),a(tt,ye),a(ye,vo),a(k,$o),a(k,Yt),_(zt,Yt,null),f(t,Ke,n),f(t,I,n),_(Et,I,null),a(I,bo),a(I,xe),a(xe,yo),a(I,xo),_(et,I,null),f(t,Qe,n),f(t,O,n),a(O,at),a(at,we),_(Mt,we,null),a(O,wo),a(O,Te),a(Te,To),f(t,Xe,n),f(t,P,n),_(At,P,null),a(P,jo),a(P,je),a(je,ko),a(P,zo),_(ot,P,null),f(t,Ye,n),f(t,q,n),_(Dt,q,null),a(q,Eo),a(q,ke),a(ke,Mo),a(q,Ao),_(st,q,null),Ze=!0},p(t,[n]){const It={};n&2&&(It.$$scope={dirty:n,ctx:t}),et.$set(It);const ze={};n&2&&(ze.$$scope={dirty:n,ctx:t}),ot.$set(ze);const Ee={};n&2&&(Ee.$$scope={dirty:n,ctx:t}),st.$set(Ee)},i(t){Ze||(v(p.$$.fragment,t),v(it.$$.fragment,t),v(mt.$$.fragment,t),v(lt.$$.fragment,t),v(pt.$$.fragment,t),v(ft.$$.fragment,t),v(dt.$$.fragment,t),v(ct.$$.fragment,t),v(ht.$$.fragment,t),v(ut.$$.fragment,t),v(gt.$$.fragment,t),v(_t.$$.fragment,t),v($t.$$.fragment,t),v(bt.$$.fragment,t),v(yt.$$.fragment,t),v(xt.$$.fragment,t),v(wt.$$.fragment,t),v(Tt.$$.fragment,t),v(jt.$$.fragment,t),v(kt.$$.fragment,t),v(zt.$$.fragment,t),v(Et.$$.fragment,t),v(et.$$.fragment,t),v(Mt.$$.fragment,t),v(At.$$.fragment,t),v(ot.$$.fragment,t),v(Dt.$$.fragment,t),v(st.$$.fragment,t),Ze=!0)},o(t){$(p.$$.fragment,t),$(it.$$.fragment,t),$(mt.$$.fragment,t),$(lt.$$.fragment,t),$(pt.$$.fragment,t),$(ft.$$.fragment,t),$(dt.$$.fragment,t),$(ct.$$.fragment,t),$(ht.$$.fragment,t),$(ut.$$.fragment,t),$(gt.$$.fragment,t),$(_t.$$.fragment,t),$($t.$$.fragment,t),$(bt.$$.fragment,t),$(yt.$$.fragment,t),$(xt.$$.fragment,t),$(wt.$$.fragment,t),$(Tt.$$.fragment,t),$(jt.$$.fragment,t),$(kt.$$.fragment,t),$(zt.$$.fragment,t),$(Et.$$.fragment,t),$(et.$$.fragment,t),$(Mt.$$.fragment,t),$(At.$$.fragment,t),$(ot.$$.fragment,t),$(Dt.$$.fragment,t),$(st.$$.fragment,t),Ze=!1},d(t){e(y),t&&e(z),t&&e(x),b(p),t&&e(Me),t&&e(W),t&&e(Ae),t&&e(B),b(it),t&&e(De),t&&e(qt),t&&e(Ie),t&&e(C),b(mt),t&&e(Pe),t&&e(L),t&&e(qe),t&&e(Ct),t&&e(Le),b(lt,t),t&&e(Be),t&&e(Nt),t&&e(Ce),b(pt,t),t&&e(Ne),t&&e(N),b(ft),t&&e(Re),t&&e(A),t&&e(Se),t&&e(Ft),t&&e(Ge),b(dt,t),t&&e(Fe),t&&e(R),b(ct),t&&e(Oe),t&&e(Q),t&&e(Ve),b(ht,t),t&&e(We),t&&e(S),b(ut),t&&e(He),t&&e(G),b(gt),t&&e(Je),t&&e(T),b(_t),b($t),b(bt),b(yt),b(xt),b(wt),t&&e(Ue),t&&e(k),b(Tt),b(jt),b(kt),b(zt),t&&e(Ke),t&&e(I),b(Et),b(et),t&&e(Qe),t&&e(O),b(Mt),t&&e(Xe),t&&e(P),b(At),b(ot),t&&e(Ye),t&&e(q),b(Dt),b(st)}}}const Cs={local:"optimization",sections:[{local:"the-transformation-guide",sections:[{local:"write-a-nonreversible-transformation",title:"Write a non-reversible transformation"},{local:"write-a-reversible-transformation",title:"Write a reversible transformation"},{local:"composing-transformations-together",title:"Composing transformations together"}],title:"The transformation guide"},{local:"the-optimization-api",sections:[{local:"optimum.fx.optimization.Transformation",title:"Main classes and functions"},{local:"optimum.fx.optimization.MergeLinears",title:"Transformations"}],title:"The Optimization API"}],title:"Optimization"};function Ns(V){return Is(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Vs extends Es{constructor(y){super();Ms(this,y,Ns,Bs,As,{})}}export{Vs as default,Cs as metadata};
