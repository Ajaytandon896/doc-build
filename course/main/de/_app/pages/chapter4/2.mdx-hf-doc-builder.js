import{S as cs,i as ms,s as us,e as p,k as _,w as O,t as l,M as ps,c as d,d as s,m as w,x as N,a as b,h as o,b as v,N as as,G as r,g as u,y as W,o as M,p as is,q as j,B as H,v as ds,n as ls}from"../../chunks/vendor-hf-doc-builder.js";import{T as fs}from"../../chunks/Tip-hf-doc-builder.js";import{I as hs}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as ie}from"../../chunks/CodeBlock-hf-doc-builder.js";import{D as os}from"../../chunks/DocNotebookDropdown-hf-doc-builder.js";import{F as bs}from"../../chunks/FrameworkSwitchCourse-hf-doc-builder.js";function ks(E){let a,c;return a=new os({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter4/section2_tf.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter4/section2_tf.ipynb"}]}}),{c(){O(a.$$.fragment)},l(t){N(a.$$.fragment,t)},m(t,$){W(a,t,$),c=!0},i(t){c||(j(a.$$.fragment,t),c=!0)},o(t){M(a.$$.fragment,t),c=!1},d(t){H(a,t)}}}function gs(E){let a,c;return a=new os({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter4/section2_pt.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter4/section2_pt.ipynb"}]}}),{c(){O(a.$$.fragment)},l(t){N(a.$$.fragment,t)},m(t,$){W(a,t,$),c=!0},i(t){c||(j(a.$$.fragment,t),c=!0)},o(t){M(a.$$.fragment,t),c=!1},d(t){H(a,t)}}}function _s(E){let a,c,t,$,f,g,T,C,D,x,P,q,k,h,z;return a=new ie({props:{code:`from transformers import CamembertTokenizer, TFCamembertForMaskedLM

tokenizer = CamembertTokenizer.from_pretrained("camembert-base")
model = TFCamembertForMaskedLM.from_pretrained("camembert-base")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> CamembertTokenizer, TFCamembertForMaskedLM

tokenizer = CamembertTokenizer.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)
model = TFCamembertForMaskedLM.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)`}}),h=new ie({props:{code:`from transformers import AutoTokenizer, TFAutoModelForMaskedLM

tokenizer = AutoTokenizer.from_pretrained("camembert-base")
model = TFAutoModelForMaskedLM.from_pretrained("camembert-base")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, TFAutoModelForMaskedLM

tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)
model = TFAutoModelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)`}}),{c(){O(a.$$.fragment),c=_(),t=p("p"),$=l("Hier empfehlen wir auch, dass man stattdessen die "),f=p("a"),g=p("code"),T=l("TFAuto*"),C=l(" classes"),D=l(" benutzt, da diese architekturunabh\xE4ngig sind. Das vorherige Code-Beispiel gilt nur f\xFCr Checkpoints, die in die CamemBERT Architektur zu laden sind, aber mit den "),x=p("code"),P=l("TFAuto*"),q=l(" Klassen kann man Checkpoints einfach tauschen:"),k=_(),O(h.$$.fragment),this.h()},l(n){N(a.$$.fragment,n),c=w(n),t=d(n,"P",{});var m=b(t);$=o(m,"Hier empfehlen wir auch, dass man stattdessen die "),f=d(m,"A",{href:!0,rel:!0});var F=b(f);g=d(F,"CODE",{});var L=b(g);T=o(L,"TFAuto*"),L.forEach(s),C=o(F," classes"),F.forEach(s),D=o(m," benutzt, da diese architekturunabh\xE4ngig sind. Das vorherige Code-Beispiel gilt nur f\xFCr Checkpoints, die in die CamemBERT Architektur zu laden sind, aber mit den "),x=d(m,"CODE",{});var K=b(x);P=o(K,"TFAuto*"),K.forEach(s),q=o(m," Klassen kann man Checkpoints einfach tauschen:"),m.forEach(s),k=w(n),N(h.$$.fragment,n),this.h()},h(){v(f,"href","https://huggingface.co/transformers/model_doc/auto.html?highlight=auto#auto-classes"),v(f,"rel","nofollow")},m(n,m){W(a,n,m),u(n,c,m),u(n,t,m),r(t,$),r(t,f),r(f,g),r(g,T),r(f,C),r(t,D),r(t,x),r(x,P),r(t,q),u(n,k,m),W(h,n,m),z=!0},i(n){z||(j(a.$$.fragment,n),j(h.$$.fragment,n),z=!0)},o(n){M(a.$$.fragment,n),M(h.$$.fragment,n),z=!1},d(n){H(a,n),n&&s(c),n&&s(t),n&&s(k),H(h,n)}}}function ws(E){let a,c,t,$,f,g,T,C,D,x,P,q,k,h,z;return a=new ie({props:{code:`from transformers import CamembertTokenizer, CamembertForMaskedLM

tokenizer = CamembertTokenizer.from_pretrained("camembert-base")
model = CamembertForMaskedLM.from_pretrained("camembert-base")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> CamembertTokenizer, CamembertForMaskedLM

tokenizer = CamembertTokenizer.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)
model = CamembertForMaskedLM.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)`}}),h=new ie({props:{code:`from transformers import AutoTokenizer, AutoModelForMaskedLM

tokenizer = AutoTokenizer.from_pretrained("camembert-base")
model = AutoModelForMaskedLM.from_pretrained("camembert-base")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForMaskedLM

tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)
model = AutoModelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)`}}),{c(){O(a.$$.fragment),c=_(),t=p("p"),$=l("Dennoch empfehlen wir, dass man die "),f=p("a"),g=p("code"),T=l("Auto*"),C=l(" classes"),D=l(" stattdessen benutzt, da diese architekturunabh\xE4ngig sind. Das vorherige Code-Beispiel gilt nur f\xFCr Checkpoints, die in die CamemBERT Architektur zu laden sind, aber mit den "),x=p("code"),P=l("Auto*"),q=l(" Klassen kann man Checkpoints ziemlich einfach tauschen:"),k=_(),O(h.$$.fragment),this.h()},l(n){N(a.$$.fragment,n),c=w(n),t=d(n,"P",{});var m=b(t);$=o(m,"Dennoch empfehlen wir, dass man die "),f=d(m,"A",{href:!0,rel:!0});var F=b(f);g=d(F,"CODE",{});var L=b(g);T=o(L,"Auto*"),L.forEach(s),C=o(F," classes"),F.forEach(s),D=o(m," stattdessen benutzt, da diese architekturunabh\xE4ngig sind. Das vorherige Code-Beispiel gilt nur f\xFCr Checkpoints, die in die CamemBERT Architektur zu laden sind, aber mit den "),x=d(m,"CODE",{});var K=b(x);P=o(K,"Auto*"),K.forEach(s),q=o(m," Klassen kann man Checkpoints ziemlich einfach tauschen:"),m.forEach(s),k=w(n),N(h.$$.fragment,n),this.h()},h(){v(f,"href","https://huggingface.co/transformers/model_doc/auto.html?highlight=auto#auto-classes"),v(f,"rel","nofollow")},m(n,m){W(a,n,m),u(n,c,m),u(n,t,m),r(t,$),r(t,f),r(f,g),r(g,T),r(f,C),r(t,D),r(t,x),r(x,P),r(t,q),u(n,k,m),W(h,n,m),z=!0},i(n){z||(j(a.$$.fragment,n),j(h.$$.fragment,n),z=!0)},o(n){M(a.$$.fragment,n),M(h.$$.fragment,n),z=!1},d(n){H(a,n),n&&s(c),n&&s(t),n&&s(k),H(h,n)}}}function $s(E){let a;return{c(){a=l("Wenn du ein vortrainiertes Modell verwendest, pr\xFCf erstmal, wie genau das traininert wurde, mit welchen Datens\xE4tzen, sowie seine Einschr\xE4nkungen und Biases. All diese Informationen sollten auf der Modellbeschreibungskarte stehen.")},l(c){a=o(c,"Wenn du ein vortrainiertes Modell verwendest, pr\xFCf erstmal, wie genau das traininert wurde, mit welchen Datens\xE4tzen, sowie seine Einschr\xE4nkungen und Biases. All diese Informationen sollten auf der Modellbeschreibungskarte stehen.")},m(c,t){u(c,a,t)},d(c){c&&s(a)}}}function vs(E){let a,c,t,$,f,g,T,C,D,x,P,q,k,h,z,n,m,F,L,K,he,V,Z,We,be,y,ze,le,Ce,Me,oe,je,Ae,ce,Ee,Te,ke,J,ge,U,_e,A,qe,me,Fe,Le,ue,ye,De,pe,Pe,Se,de,Be,Oe,we,Q,X,He,$e,te,Ne,ve,S,B,ne,G,xe;t=new bs({props:{fw:E[0]}}),C=new hs({});const Ie=[gs,ks],Y=[];function Ke(e,i){return e[0]==="pt"?0:1}k=Ke(E),h=Y[k]=Ie[k](E),J=new ie({props:{code:`from transformers import pipeline

camembert_fill_mask = pipeline("fill-mask", model="camembert-base")
results = camembert_fill_mask("Le camembert est <mask> :)")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

camembert_fill_mask = pipeline(<span class="hljs-string">&quot;fill-mask&quot;</span>, model=<span class="hljs-string">&quot;camembert-base&quot;</span>)
results = camembert_fill_mask(<span class="hljs-string">&quot;Le camembert est &lt;mask&gt; :)&quot;</span>)`}}),U=new ie({props:{code:`[
  {'sequence': 'Le camembert est d\xE9licieux :)', 'score': 0.49091005325317383, 'token': 7200, 'token_str': 'd\xE9licieux'}, 
  {'sequence': 'Le camembert est excellent :)', 'score': 0.1055697426199913, 'token': 2183, 'token_str': 'excellent'}, 
  {'sequence': 'Le camembert est succulent :)', 'score': 0.03453313186764717, 'token': 26202, 'token_str': 'succulent'}, 
  {'sequence': 'Le camembert est meilleur :)', 'score': 0.0330314114689827, 'token': 528, 'token_str': 'meilleur'}, 
  {'sequence': 'Le camembert est parfait :)', 'score': 0.03007650189101696, 'token': 1654, 'token_str': 'parfait'}
]`,highlighted:`[
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est d\xE9licieux :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.49091005325317383</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">7200</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;d\xE9licieux&#x27;</span>}, 
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est excellent :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.1055697426199913</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">2183</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;excellent&#x27;</span>}, 
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est succulent :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.03453313186764717</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">26202</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;succulent&#x27;</span>}, 
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est meilleur :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.0330314114689827</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">528</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;meilleur&#x27;</span>}, 
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est parfait :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.03007650189101696</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">1654</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;parfait&#x27;</span>}
]`}});const Ge=[ws,_s],ee=[];function Re(e,i){return e[0]==="pt"?0:1}return S=Re(E),B=ee[S]=Ge[S](E),G=new fs({props:{$$slots:{default:[$s]},$$scope:{ctx:E}}}),{c(){a=p("meta"),c=_(),O(t.$$.fragment),$=_(),f=p("h1"),g=p("a"),T=p("span"),O(C.$$.fragment),D=_(),x=p("span"),P=l("Verwendung vortrainierter Modelle"),q=_(),h.c(),z=_(),n=p("p"),m=l("Der Model Hub erleichtert das Ausw\xE4hlen des passenden Modells, sodass es von downstream Libraries mit wenigen Codezeilen benutzt werden kann. Lass uns anschauen, wie genau man solche Modelle verwendet und wie man der Communinity zur\xFCck beitragen kann."),F=_(),L=p("p"),K=l("Nehmen wir an, wir suchen nach einem franz\xF6sichbasierten Modell, das die \u201Cmask filling\u201D Aufgabe kann."),he=_(),V=p("div"),Z=p("img"),be=_(),y=p("p"),ze=l("Wir w\xE4hlen den "),le=p("code"),Ce=l("camembert-base"),Me=l(" Checkpoint aus, um es zu auszuprobieren. Das Kennzeichen "),oe=p("code"),je=l("camembert-base"),Ae=l(" ist alles, was wir brauchen, um loszulegen! Wie in fr\xFCheren Kapiteln gezeigt wurde, k\xF6nnen wir das Modell mit der "),ce=p("code"),Ee=l("pipeline()"),Te=l(" Funktion instanziieren:"),ke=_(),O(J.$$.fragment),ge=_(),O(U.$$.fragment),_e=_(),A=p("p"),qe=l("So einfach kann man mit einer Pipeline ein Modell laden. Dabei muss man nur darauf achten, den passenden Checkpoint f\xFCr die gew\xFCnschte Aufgabe zu selektieren. Zum Beispiel: Wir laden hier den "),me=p("code"),Fe=l("camembert-base"),Le=l(" Checkpoint in die "),ue=p("code"),ye=l("fill-mask"),De=l(" Pipeline, was schon korrekt ist. Aber w\xFCrden wir diesen Checkpoint in die "),pe=p("code"),Pe=l("text-classification"),Se=l(" Pipeline laden, w\xE4ren die Ergebnisse v\xF6llig sinnlos, weil der \u201Chead\u201D von "),de=p("code"),Be=l("camembert-base"),Oe=l(" f\xFCr diese Aufgabe einfach nicht passt! Wir empfehlen, den \u201CTask Selector\u201D auf der Hugging Face Hub Seite zu benutzen, um die richtigen Checkpoints auszuw\xE4hlen:"),we=_(),Q=p("div"),X=p("img"),$e=_(),te=p("p"),Ne=l("Du kannst auch den Checkpoint mit der Modell-Architektur direkt instanziieren:"),ve=_(),B.c(),ne=_(),O(G.$$.fragment),this.h()},l(e){const i=ps('[data-svelte="svelte-1phssyn"]',document.head);a=d(i,"META",{name:!0,content:!0}),i.forEach(s),c=w(e),N(t.$$.fragment,e),$=w(e),f=d(e,"H1",{class:!0});var se=b(f);g=d(se,"A",{id:!0,class:!0,href:!0});var re=b(g);T=d(re,"SPAN",{});var ae=b(T);N(C.$$.fragment,ae),ae.forEach(s),re.forEach(s),D=w(se),x=d(se,"SPAN",{});var fe=b(x);P=o(fe,"Verwendung vortrainierter Modelle"),fe.forEach(s),se.forEach(s),q=w(e),h.l(e),z=w(e),n=d(e,"P",{});var Ve=b(n);m=o(Ve,"Der Model Hub erleichtert das Ausw\xE4hlen des passenden Modells, sodass es von downstream Libraries mit wenigen Codezeilen benutzt werden kann. Lass uns anschauen, wie genau man solche Modelle verwendet und wie man der Communinity zur\xFCck beitragen kann."),Ve.forEach(s),F=w(e),L=d(e,"P",{});var Ze=b(L);K=o(Ze,"Nehmen wir an, wir suchen nach einem franz\xF6sichbasierten Modell, das die \u201Cmask filling\u201D Aufgabe kann."),Ze.forEach(s),he=w(e),V=d(e,"DIV",{class:!0});var Je=b(V);Z=d(Je,"IMG",{src:!0,alt:!0,width:!0}),Je.forEach(s),be=w(e),y=d(e,"P",{});var R=b(y);ze=o(R,"Wir w\xE4hlen den "),le=d(R,"CODE",{});var Ue=b(le);Ce=o(Ue,"camembert-base"),Ue.forEach(s),Me=o(R," Checkpoint aus, um es zu auszuprobieren. Das Kennzeichen "),oe=d(R,"CODE",{});var Qe=b(oe);je=o(Qe,"camembert-base"),Qe.forEach(s),Ae=o(R," ist alles, was wir brauchen, um loszulegen! Wie in fr\xFCheren Kapiteln gezeigt wurde, k\xF6nnen wir das Modell mit der "),ce=d(R,"CODE",{});var Xe=b(ce);Ee=o(Xe,"pipeline()"),Xe.forEach(s),Te=o(R," Funktion instanziieren:"),R.forEach(s),ke=w(e),N(J.$$.fragment,e),ge=w(e),N(U.$$.fragment,e),_e=w(e),A=d(e,"P",{});var I=b(A);qe=o(I,"So einfach kann man mit einer Pipeline ein Modell laden. Dabei muss man nur darauf achten, den passenden Checkpoint f\xFCr die gew\xFCnschte Aufgabe zu selektieren. Zum Beispiel: Wir laden hier den "),me=d(I,"CODE",{});var Ye=b(me);Fe=o(Ye,"camembert-base"),Ye.forEach(s),Le=o(I," Checkpoint in die "),ue=d(I,"CODE",{});var es=b(ue);ye=o(es,"fill-mask"),es.forEach(s),De=o(I," Pipeline, was schon korrekt ist. Aber w\xFCrden wir diesen Checkpoint in die "),pe=d(I,"CODE",{});var ss=b(pe);Pe=o(ss,"text-classification"),ss.forEach(s),Se=o(I," Pipeline laden, w\xE4ren die Ergebnisse v\xF6llig sinnlos, weil der \u201Chead\u201D von "),de=d(I,"CODE",{});var ts=b(de);Be=o(ts,"camembert-base"),ts.forEach(s),Oe=o(I," f\xFCr diese Aufgabe einfach nicht passt! Wir empfehlen, den \u201CTask Selector\u201D auf der Hugging Face Hub Seite zu benutzen, um die richtigen Checkpoints auszuw\xE4hlen:"),I.forEach(s),we=w(e),Q=d(e,"DIV",{class:!0});var ns=b(Q);X=d(ns,"IMG",{src:!0,alt:!0,width:!0}),ns.forEach(s),$e=w(e),te=d(e,"P",{});var rs=b(te);Ne=o(rs,"Du kannst auch den Checkpoint mit der Modell-Architektur direkt instanziieren:"),rs.forEach(s),ve=w(e),B.l(e),ne=w(e),N(G.$$.fragment,e),this.h()},h(){v(a,"name","hf:doc:metadata"),v(a,"content",JSON.stringify(xs)),v(g,"id","verwendung-vortrainierter-modelle"),v(g,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(g,"href","#verwendung-vortrainierter-modelle"),v(f,"class","relative group"),as(Z.src,We="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/camembert.gif")||v(Z,"src",We),v(Z,"alt","Selecting the Camembert model."),v(Z,"width","80%"),v(V,"class","flex justify-center"),as(X.src,He="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/tasks.png")||v(X,"src",He),v(X,"alt","The task selector on the web interface."),v(X,"width","80%"),v(Q,"class","flex justify-center")},m(e,i){r(document.head,a),u(e,c,i),W(t,e,i),u(e,$,i),u(e,f,i),r(f,g),r(g,T),W(C,T,null),r(f,D),r(f,x),r(x,P),u(e,q,i),Y[k].m(e,i),u(e,z,i),u(e,n,i),r(n,m),u(e,F,i),u(e,L,i),r(L,K),u(e,he,i),u(e,V,i),r(V,Z),u(e,be,i),u(e,y,i),r(y,ze),r(y,le),r(le,Ce),r(y,Me),r(y,oe),r(oe,je),r(y,Ae),r(y,ce),r(ce,Ee),r(y,Te),u(e,ke,i),W(J,e,i),u(e,ge,i),W(U,e,i),u(e,_e,i),u(e,A,i),r(A,qe),r(A,me),r(me,Fe),r(A,Le),r(A,ue),r(ue,ye),r(A,De),r(A,pe),r(pe,Pe),r(A,Se),r(A,de),r(de,Be),r(A,Oe),u(e,we,i),u(e,Q,i),r(Q,X),u(e,$e,i),u(e,te,i),r(te,Ne),u(e,ve,i),ee[S].m(e,i),u(e,ne,i),W(G,e,i),xe=!0},p(e,[i]){const se={};i&1&&(se.fw=e[0]),t.$set(se);let re=k;k=Ke(e),k!==re&&(ls(),M(Y[re],1,1,()=>{Y[re]=null}),is(),h=Y[k],h||(h=Y[k]=Ie[k](e),h.c()),j(h,1),h.m(z.parentNode,z));let ae=S;S=Re(e),S!==ae&&(ls(),M(ee[ae],1,1,()=>{ee[ae]=null}),is(),B=ee[S],B||(B=ee[S]=Ge[S](e),B.c()),j(B,1),B.m(ne.parentNode,ne));const fe={};i&2&&(fe.$$scope={dirty:i,ctx:e}),G.$set(fe)},i(e){xe||(j(t.$$.fragment,e),j(C.$$.fragment,e),j(h),j(J.$$.fragment,e),j(U.$$.fragment,e),j(B),j(G.$$.fragment,e),xe=!0)},o(e){M(t.$$.fragment,e),M(C.$$.fragment,e),M(h),M(J.$$.fragment,e),M(U.$$.fragment,e),M(B),M(G.$$.fragment,e),xe=!1},d(e){s(a),e&&s(c),H(t,e),e&&s($),e&&s(f),H(C),e&&s(q),Y[k].d(e),e&&s(z),e&&s(n),e&&s(F),e&&s(L),e&&s(he),e&&s(V),e&&s(be),e&&s(y),e&&s(ke),H(J,e),e&&s(ge),H(U,e),e&&s(_e),e&&s(A),e&&s(we),e&&s(Q),e&&s($e),e&&s(te),e&&s(ve),ee[S].d(e),e&&s(ne),H(G,e)}}}const xs={local:"verwendung-vortrainierter-modelle",title:"Verwendung vortrainierter Modelle"};function zs(E,a,c){let t="pt";return ds(()=>{const $=new URLSearchParams(window.location.search);c(0,t=$.get("fw")||"pt")}),[t]}class qs extends cs{constructor(a){super();ms(this,a,zs,vs,us,{})}}export{qs as default,xs as metadata};
